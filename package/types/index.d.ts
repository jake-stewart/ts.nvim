/** @noSelfInFile **/


/** @noSelf **/
declare module lua {
    type LuaType =
        | "nil"
        | "number"
        | "string"
        | "boolean"
        | "table"
        | "function"
        | "thread"
        | "userdata"

    function require(name: string): any;
    function assert<T>(v?: T, message?: any, ...args: any): T;
    function type(v: any): LuaType;
    function pcall<T extends (...args: any) => any>(f: T, ...args: Parameters<T>): LuaMultiReturn<[success: true, ReturnType<T>] | [success: false, undefined]>;
}

declare namespace console {
    function log(...args: any[]): void;
    function debug(...args: any[]): void;
    function warn(...args: any[]): void;
    function error(...args: any[]): void;
}

declare module lua.string {
    /**
     * Returns the internal numeric codes of the characters `s[i], s[i+1], ..., s[j]`.
     */
    function byte(s: string, i?: number, j?: number): LuaMultiReturn<number[]>;

    /**
     * Returns a string with length equal to the number of arguments, in which each character has the internal numeric code equal to its corresponding argument.
     */
    function char(byte: number, ...args: number[]): string;

    /**
     * Returns a string containing a binary representation (a *binary chunk*) of the given function.
     */
    function dump(f: any, strip?: boolean): string;

    /**
     * Looks for the first match of `pattern` (see [§6.4.1](http://www.lua.org/manual/5.1/manual.html#6.4.1)) in the string.
     */
    function find(s: string | number, pattern: string | number, init?: number, plain?: boolean): LuaMultiReturn<[start: number | undefined, end: number | undefined, ...captured: (any | undefined)[]]>;

    /**
     * Returns a formatted version of its variable number of arguments following the description given in its first argument.
     */
    function format(s: string | number, ...args: any[]): string;

    /**
     * Returns an iterator function that, each time it is called, returns the next captures from `pattern` (see [§6.4.1](http://www.lua.org/manual/5.1/manual.html#6.4.1)) over the string s.
     */
    function gmatch(s: string | number, pattern: string | number): LuaIterable<string>;

     /**
     * Returns a copy of s in which all (or the first `n`, if given) occurrences of the `pattern` (see [§6.4.1](http://www.lua.org/manual/5.1/manual.html#6.4.1)) have been replaced by a replacement string specified by `repl`.
     */
    function gsub(s: string | number, pattern: string | number, repl: string | number | {[key: string]: string} | ((s: string) => (string | false | undefined | null)), n?: number): LuaMultiReturn<[string, number]>;

    /**
     * Returns its length.
     */
    function len(s: string | number): number;

    /**
     * Returns a copy of this string with all uppercase letters changed to lowercase.
     */
    function lower(s: string | number): string;

    /**
     * Looks for the first match of `pattern` (see [§6.4.1](http://www.lua.org/manual/5.1/manual.html#6.4.1)) in the string.
     */
    function match(s: string | number, pattern: string | number, init?: number): LuaMultiReturn<any[]>;

    /**
     * Returns a binary string containing the values `v1`, `v2`, etc. packed (that is, serialized in binary form) according to the format string `fmt` (see [§6.4.2](http://www.lua.org/manual/5.1/manual.html#6.4.2)) .
     */
    function pack(fmt: string, v1: string | number, ...vargs: (string | number)[]): string;

    /**
     * Returns the size of a string resulting from `string.pack` with the given format string `fmt` (see [§6.4.2](http://www.lua.org/manual/5.1/manual.html#6.4.2)) .
     */
    function packsize(fmt: string): number;

    /**
     * Returns a string that is the concatenation of `n` copies of the string `s` separated by the string `sep`.
     */
    function rep(s: string | number, n: number, sep?: string | number): string;

    /**
     * Returns a string that is the string `s` reversed.
     */
    function reverse(s: string | number): string;

    /**
     * Returns the substring of the string that starts at `i` and continues until `j`.
     */
    function sub(s: string | number, i: number, j?: number): string;

    /**
     * Returns the values packed in string according to the format string `fmt` (see [§6.4.2](http://www.lua.org/manual/5.1/manual.html#6.4.2)) .
     */
    function unpack(fmt: string, s: string, pos?: number): LuaMultiReturn<[...args: any[], number]>;

    /**
     * Returns a copy of this string with all lowercase letters changed to uppercase.
     */
    function upper(s: string | number): string;
}

declare module lua.table {
    /*
     * Given a list where all elements are strings or numbers, returns the string `list[i]..sep..list[i+1] ··· sep..list[j]`.
     */
    function concat(list: object, sep?: string, i?: number, j?: number): string;

    /*
     * Inserts element `value` at position `pos` in `list`.
     */
    function insert(list: object, pos: number, value: any): void;
    function insert(list: object, value: any): void;

    /*
     * Returns the largest positive numerical index of the given table, or zero if the table has no positive numerical indices.
     */
    function maxn(table: object): number;

    /*
     * Moves elements from table `a1` to table `a2`.
     */
    function move(a1: object, f: number, e: number, t: number, a2?: object): object;

    /*
     * Returns a new table with all arguments stored into keys `1`, `2`, etc. and with a field `"n"` with the total number of arguments.
     */
    function pack(...args: any[]): object;

    /*
     * Removes from `list` the element at position `pos`, returning the value of the removed element.
     */
    function remove(list: object, pos?: number): any;

    /*
     * Sorts list elements in a given order, *in-place*, from `list[1]` to `list[#list]`.
     */
    function sort<T>(list: T[], comp?: (a: T, b: T) => boolean): void;

    /*
     * Returns the elements from the given list.
     */
    function unpack<T>(list: T[], i?: number, j?: number): LuaMultiReturn<T[]>;

    /*
     * Executes the given f over all elements of table. For each element, f is called with the index and respective value as arguments. If f returns a non-nil value, then the loop is broken, and this value is returned as the final value of foreach.
     * @deprecated
     */
    function foreach<T>(list: object, callback: (key: string, value: any) => (T | undefined)): T | undefined;

    /*
     * Executes the given f over the numerical indices of table. For each index, f is called with the index and respective value as arguments. Indices are visited in sequential order, from 1 to n, where n is the size of the table. If f returns a non-nil value, then the loop is broken and this value is returned as the result of foreachi.
     * @deprecated
     */
    function foreachi<T>(list: object, callback: (key: string, value: any) => (T | undefined)): T | undefined;

    /*
     * Returns the number of elements in the table. This function is equivalent to `#list`.
     * @deprecated
     */
    function getn<T>(list: T[]): number;
}

declare module lua.math {
    /**
     * A value larger than any other numeric value.
     */
    export const huge: number;

    /**
     * The value of *π*.
     */
    export const pi: number;

    /**
     * Returns the absolute value of `x`.
     */
    function abs(x: number): number;

    /**
     * Returns the arc cosine of `x` (in radians).
     */
    function acos(x: number): number;

    /**
     * Returns the arc sine of `x` (in radians).
     */
    function asin(x: number): number;

    /**
     * Returns the arc tangent of `x` (in radians).
     */
    function atan(y: number): number;

    /**
     * Returns the arc tangent of `y/x` (in radians).
     */
    function atan2(y: number, x: number): number;

    /**
     * Returns the smallest integral value larger than or equal to `x`.
     */
    function ceil(x: number): number;

    /**
     * Returns the cosine of `x` (assumed to be in radians).
     */
    function cos(x: number): number;

    /**
     * Returns the hyperbolic cosine of `x` (assumed to be in radians).
     */
    function cosh(x: number): number;

    /**
     * Converts the angle `x` from radians to degrees.
     */
    function deg(x: number): number;

    /**
     * Returns the value `e^x` (where `e` is the base of natural logarithms).
     */
    function exp(x: number): number;

    /**
     * Returns the largest integral value smaller than or equal to `x`.
     */
    function floor(x: number): number;

    /**
     * Returns the remainder of the division of `x` by `y` that rounds the quotient towards zero.
     */
    function fmod(x: number, y: number): number;

    /**
     * Decompose `x` into tails and exponents. Returns `m` and `e` such that `x = m * (2 ^ e)`, `e` is an integer and the absolute value of `m` is in the range [0.5, 1) (or zero when `x` is zero).
     */
    function frexp(x: number): LuaMultiReturn<[number, number]>;

    /**
     * Returns `m * (2 ^ e)` .
     */
    function ldexp(m: number, e: number): number;

    /**
     * Returns the logarithm of `x` in the given base.
     */
    function log(x: number, base?: number): number;

    /**
     * Returns the base-10 logarithm of x.
     */
    function log10(x: number): number;

    /**
     * Returns the argument with the maximum value, according to the Lua operator `<`.
     */
    function max(x: number, ...args: number[]): number;

    /**
     * Returns the argument with the minimum value, according to the Lua operator `<`.
     */
    function min(x: number, ...args: number[]): number;

    /**
     * Returns the integral part of `x` and the fractional part of `x`.
     */
    function modf(x: number): number;

    /**
     * Returns `x ^ y` .
     */
    function pow(x: number, y: number): number;

    /**
     * Converts the angle `x` from degrees to radians.
     */
    function rad(x: number): number;

    /**
     * `math.random()`: Returns a float in the range [0,1).
     * `math.random(n)`: Returns a integer in the range [1, n].
     * `math.random(m, n)`: Returns a integer in the range [m, n].
     */
    function random(): number;
    function random(n: number): number;
    function random(m: number, n: number): number;

    /**
     * Sets `x` as the "seed" for the pseudo-random generator.
     */
    function randomseed(x: number): void;

    /**
     * Returns the sine of `x` (assumed to be in radians).
     */
    function sin(x: number): number;

    /**
     * Returns the hyperbolic sine of `x` (assumed to be in radians).
     */
    function sinh(x: number): number;

    /**
     * Returns the square root of `x`.
     */
    function sqrt(x: number): number;

    /**
     * Returns the tangent of `x` (assumed to be in radians).
     */
    function tan(x: number): number;

    /**
     * Returns the hyperbolic tangent of `x` (assumed to be in radians).
     */
    function tanh(x: number): number;

    /**
     * If the value `x` is convertible to an integer, returns that integer.
     */
    function tointeger(x: any): number | undefined;

    /**
     * Returns `"integer"` if `x` is an integer, `"float"` if it is a float, or `nil` if `x` is not a number.
     */
    function type(x: any): "integer" | "float" | "nil";

    /**
     * Returns `true` if and only if `m` is below `n` when they are compared as unsigned integers.
     */
    function ult(m: number, n: number): boolean;
}

declare namespace lua.io {

    type exitcode = "exit" | "signal"

    type readmode =
        | number
        | string
        | "*n" // Reads a numeral and returns it as number.
        | "*a" // Reads the whole file.
        | "*l" // Reads the next line skipping the end of line.
        | "*L" // Reads the next line keeping the end of line.

    type seekwhence =
        | "set" // Base is beginning of the file.
        | "cur" // Base is current position.
        | "end" // Base is: void; of file.

    type vbuf =
        | "no"   // Output operation appears immediately.
        | "full" // Performed only when the buffer is full.
        | "line" // Buffered until a newline is output.


    interface file {
        /**
         * Close `file`.
         */
        close(): LuaMultiReturn<[suc?: boolean, exitcode?: exitcode, code?: number]>;

        /**
         * Saves any written data to `file`.
         */
        flush(): void;

        // ```lua
        // for c in file:lines(...) do
        //     body
        //: void;
        // ```
        // 
        // 
        // [View documents](http://www.lua.org/manual/5.1/manual.html#pdf-file:lines)
        // 
        // @param ... readmode
        // @return fun():any, ...
        lines(...args: readmode[]): LuaIterable<any>;

        // Reads the `file`, according to the given formats, which specify what to read.
        // 
        // @param ... readmode
        // @return any
        // @return any ...
        // @nodiscard
        read(...args: readmode[]): LuaMultiReturn<any[]>;

        /**
         * Sets and gets the file position, measured from the beginning of the file.
         */
        seek(whence?: seekwhence, offset?: number): LuaMultiReturn<[offset: number, errmsg?: string]>;

        /**
         * Sets the buffering mode for an output file.
         */
        setvbuf(mode: vbuf, size?: number): void;

        /**
         * Writes the value of each of its arguments to `file`.
         */
        write(...args: (string | number)[]): LuaMultiReturn<[file, errmsg?: string]>;
    }

    export const stdin: file;
    export const stdout: file;
    export const stderr: file;

    type openmode =
        | "r"   // Read mode.
        | "w"   // Write mode.
        | "a"   // Append mode.
        | "r+"  // Update mode, all previous data is preserved.
        | "w+"  // Update mode, all previous data is erased.
        | "a+"  // Append update mode, previous data is preserved, writing is only allowed at the end of file.
        | "rb"  // Read mode. (in binary mode.)
        | "wb"  // Write mode. (in binary mode.)
        | "ab"  // Append mode. (in binary mode.)
        | "r+b" // Update mode, all previous data is preserved. (in binary mode.)
        | "w+b" // Update mode, all previous data is erased. (in binary mode.)
        | "a+b" // Append update mode, previous data is preserved, writing is only allowed at the end of file. (in binary mode.)

    /**
     * Close `file` or default output file.
     */
    function close(file?: file): LuaMultiReturn<[suc?: boolean, exitcode?: exitcode, code?: number]>;

    /**
     * Saves any written data to default output file.
     */
    function flush(): void;

    /**
     * Sets `file` as the default input file.
     */
    function input(): file;
    function input(file: string | file): void;

    // [View documents](http://www.lua.org/manual/5.1/manual.html#pdf-io.lines)
    // 
    // @param filename string?
    // @param ... readmode
    // @return fun():any, ...
    function lines(filename?: string, ...args: readmode[]): LuaIterable<any>;

    /**
     * Opens a file, in the mode specified in the string `mode`.
     */
    function open(filename: string, mode?: openmode): LuaMultiReturn<[file | undefined, errmsg?: string]>;

    /**
     * Sets `file` as the default output file.
     */
    function output(): file;
    function output(file: string | file): void;

    type popenmode =
        | "r" // Read data from this program by `file`.
        | "w" // Write data to this program by `file`.

    /**
     * Starts program prog in a separated process.
     */
    function popen(prog?: string, mode?: popenmode): LuaMultiReturn<[file | undefined, errmsg?: string]>;

    // 
    // [View documents](http://www.lua.org/manual/5.1/manual.html#pdf-io.read)
    // 
    // @param ... readmode
    // @return any
    // @return any ...
    // @nodiscard
    /**
     * Reads the `file`, according to the given formats, which specify what to read.
     */
    function read(...args: readmode[]): LuaMultiReturn<any[]>;

    /**
     * In case of success, returns a handle for a temporary file.
     */
    function tmpfile(): file;

    type filetype =
        | "file"        // Is an open file handle.
        | "closed file" // Is a closed file handle.
        | undefined     // Is not a file handle.

    /**
     * Checks whether `obj` is a valid file handle.
     */
    function type(file: file): filetype;

    /**
     * Writes the value of each of its arguments to default output file.
     */
    function write(...args: any[]): LuaMultiReturn<[file, errmsg?: string]>;
}

declare module lua.os {
    /**
     * Returns an approximation of the amount in seconds of CPU time used by the program.
     */
    function clock(): number;

    interface osdate {
        /**
         * four digits
         */
        year: number | string;
        /**
         * 1-12
         */
        month: number | string;
        /**
         * 1-31
         */
        day: number | string;
        /**
         * 0-23
         */
        hour: number | string;
        /**
         * 0-59
         */
        min: number | string;
        /**
         * 0-61
         */
        sec: number | string;
        /**
         * weekday, 1–7, Sunday is 1
         */
        wday: number | string;
        /**
         * day of the year, 1–366
         */
        yday: number | string;
        /**
         * daylight saving flag, a boolean
         */
        isdst: boolean;
    }

    /*
     * Returns a string or a table containing date and time, formatted according to the given string `format`.
     */
    function date(format?: string, time?: number): string | osdate;

    /*
     * Returns the difference, in seconds, from time `t1` to time `t2`.
     */
    function difftime(t2: number, t1: number): number;

    /*
     * Passes `command` to be executed by an operating system shell.
     */
    function execute(command?: string): LuaMultiReturn<[success?: boolean, exitcode?: any, code?: number]>;

    /*
     * Calls the ISO C function `exit` to terminate the host program.
     */
    function exit(code?: boolean | number, close?: boolean): void;

    /*
     * Returns the value of the process environment variable `varname`.
     */
    function getenv(varname: string): string | undefined;

    /*
     * Deletes the file with the given name.
     */
    function remove(filename: string): LuaMultiReturn<[suc?: boolean, errmsg?: string]>;

    /*
     * Renames the file or directory named `oldname` to `newname`.
     */
    function rename(oldname: string, newname: string): LuaMultiReturn<[suc: boolean, errmsg?: string]>;

    type localecategory =
        | "all"
        | "collate"
        | "ctype"
        | "monetary"
        | "numeric"
        | "time"

    /*
     * Sets the current locale of the program.
     */
    function setlocale(locale?: string, category?: localecategory): string;

    /*
     * Returns the current time when called without arguments, or a time representing the local date and time specified by the given table.
     */
    function time(date?: osdate): number;

    /*
     * Returns a string with a file name that can be used for a temporary file.
     */
    function tmpname(): string;
}

interface AutocommandEventData {
    /**
     * Whether the event triggered during
     * an aborting condition (e.g. |c_Esc| or
     * |c_CTRL-C| for |CmdlineLeave|).
     */
    abort: any,

    /**
     * |channel-id|
     */
    chan: any,

    /**
     * Level of cmdline.
     */
    cmdlevel: any,

    /**
     * Type of cmdline, |cmdline-char|.
     */
    cmdtype: any,

    /**
     * Current working directory.
     */
    cwd: any,

    /**
     * Motion is |inclusive|, else exclusive.
     */
    inclusive: any,

    /**
     * Event-specific scope name.
     */
    scope: any,

    /**
     * Current |operator|.  Also set for Ex
     * commands (unlike |v:operator|). For
     * example if |TextYankPost| is triggered
     * by the |:yank| Ex command then
     * `v:event.operator` is "y".
     */
    operator: any,

    /**
     * Text stored in the register as a
     * |readfile()|-style list of lines.
     */
    regcontents: any,

    /**
     * Requested register (e.g "x" for "xyy)
     * or the empty string for an unnamed
     * operation.
     */
    regname: any,

    /**
     * Type of register as returned by
     * |getregtype()|.
     */
    regtype: any,

    /**
     * Selection is visual (as opposed to,
     * e.g., via motion).
     */
    visual: any,

    /**
     * Current selected complete item on
     * |CompleteChanged|, Is `{}` when no complete
     * item selected.
     */
    completed_item: any,

    /**
     * Height of popup menu on |CompleteChanged|
     */
    height: any,

    /**
     * width of popup menu on |CompleteChanged|
     */
    width: any,

    /**
     * Row count of popup menu on |CompleteChanged|,
     * relative to screen.
     */
    row: any,

    /**
     * Col count of popup menu on |CompleteChanged|,
     * relative to screen.
     */
    col: any,

    /**
     * Total number of completion items on
     * |CompleteChanged|.
     */
    size: any,

    /**
     * Is |v:true| if popup menu have scrollbar, or
     * |v:false| if not.
     */
    scrollbar: any,

    /**
     * Is |v:true| if the event fired while
     * changing window (or tab) on |DirChanged|.
     */
    changed_window: any,

    /**
     * Job status or exit code, -1 means "unknown". |TermClose|
     */
    status: any,
}

interface VimV {
    /**
     * The command line arguments Vim was invoked with.  This is a
     * list of strings.  The first item is the Vim command.
     * See |v:progpath| for the command with full path.
     */
    argv: string[];

    /**
     * Argument for evaluating 'formatexpr' and used for the typed
     * character when using <expr> in an abbreviation |:map-<expr>|.
     * It is also used by the |InsertCharPre| and |InsertEnter| events.
     */
    char: string;

    /**
     * The name of the character encoding of a file to be converted.
     * Only valid while evaluating the 'charconvert' option.
     */
    charconvert_from: string;

    /**
     * The name of the character encoding of a file after conversion.
     * Only valid while evaluating the 'charconvert' option.
     */
    charconvert_to: string;

    /**
     * The extra arguments ("++p", "++enc=", "++ff=") given to a file
     * read/write command.  This is set before an autocommand event
     * for a file read/write command is triggered.  There is a
     * leading space to make it possible to append this variable
     * directly after the read/write command. Note: "+cmd" isn't
     * included here, because it will be executed anyway.
     */
    cmdarg: string;

    /**
     * The current locale setting for collation order of the runtime
     * environment.  This allows Vim scripts to be aware of the
     * current locale encoding.  Technical: it's the value of
     * LC_COLLATE.  When not using a locale the value is "C".
     * This variable can not be set directly, use the |:language|
     * command.
     * See |multi-lang|.
     */
    collate: string;

    /**
     * Set like v:cmdarg for a file read/write command.  When a "!"
     * was used the value is 1, otherwise it is 0.  Note that this
     * can only be used in autocommands.  For user commands |<bang>|
     * can be used.
     */
    cmdbang: number;


    /**
     * Dictionary containing the most recent |complete-items| after
     * |CompleteDone|.  Empty if the completion failed, or after
     * leaving and re-entering insert mode.
     * Note: Plugins can modify the value to emulate the builtin
     * |CompleteDone| event behavior.
     */
    completed_item: {[key: string]: any};

    /**
     * The count given for the last Normal mode command.  Can be used
     * to get the count before a mapping.  Read-only.  Example:  
     *     :map _x :<C-U>echo "the count is " .. v:count<CR>
     * Note: The <C-U> is required to remove the line range that you
     * get when typing ':' after a count.
     * When there are two counts, as in "3d2w", they are multiplied,
     * just like what happens in the command, "d6w" for the example.
     * Also used for evaluating the 'formatexpr' option.
     */
    count: number;

    /**
     * Just like "v:count", but defaults to one when no count is
     * used.
     */
    count1: number;

    /**
     * The current locale setting for characters of the runtime
     * environment.  This allows Vim scripts to be aware of the
     * current locale encoding.  Technical: it's the value of
     * LC_CTYPE.  When not using a locale the value is "C".
     * This variable can not be set directly, use the |:language|
     * command.
     * See |multi-lang|.
     */
    ctype: string;

    /**
     * Normally zero.  When a deadly signal is caught it's set to
     * one.  When multiple signals are caught the number increases.
     * Can be used in an autocommand to check if Vim didn't
     * terminate normally. {only works on Unix}
     * Example:  
     *     :au VimLeave * if v:dying | echo "\nAAAAaaaarrrggghhhh!!!\n" | endif
     * Note: if another deadly signal is caught when v:dying is one,
     * VimLeave autocommands will not be executed.
     */
    dying: number;

    /**
     * Exit code, or |v:null| before invoking the |VimLeavePre|
     * and |VimLeave| autocmds.  See |:q|, |:x| and |:cquit|.
     * Example:  
     *     :au VimLeave * echo "Exit value is " .. v:exiting
     */
    exiting: any;

    /**
     * Number of screen cells that can be used for an `:echo` message
     * in the last screen line before causing the |hit-enter-prompt|.
     * Depends on 'showcmd', 'ruler' and 'columns'.  You need to
     * check 'cmdheight' for whether there are full-width lines
     * available above the last line.
     */
    echospace: number;

    /**
     * Last given error message.
     * Modifiable (can be set).
     * Example:  
     *     :let v:errmsg = ""
     *     :silent! next
     *     :if v:errmsg != ""
     *     :  ... handle error
     */
    errmsg: string;

    /**
     * Errors found by assert functions, such as |assert_true()|.
     * This is a list of strings.
     * The assert functions append an item when an assert fails.
     * The return value indicates this: a one is returned if an item
     * was added to v:errors, otherwise zero is returned.
     * To remove old results make it empty:  
     *     :let v:errors = []
     * If v:errors is set to anything but a list it is made an empty
     * list by the assert function.
     */
    errors: string[];

    /**
     * Dictionary of event data for the current |autocommand|.  Valid
     * only during the event lifetime; storing or passing v:event is
     * invalid!  Copy it instead:  
     *     au TextYankPost * let g:foo = deepcopy(v:event)
     * Keys vary by event; see the documentation for the specific
     * event, e.g. |DirChanged| or |TextYankPost|.
     */
    event: AutocommandEventData;

    /**
     * The value of the exception most recently caught and not
     * finished.  See also |v:throwpoint| and |throw-variables|.
     * Example:  
     *     :try
     *     :  throw "oops"
     *     :catch /.* /
     *     :  echo "caught " .. v:exception
     *     :endtry
     * Output: "caught oops".
     */
    exception: string;

    /**
     * Special value used to put "false" in JSON and msgpack.  See
     * |json_encode()|.  This value is converted to "v:false" when used
     * as a String (e.g. in |expr5| with string concatenation
     * operator) and to zero when used as a Number (e.g. in |expr5|
     * or |expr7| when used with numeric operators). Read-only.
     */
    false: false;

    /**
     * The reason why the |FileChangedShell| event was triggered.
     * Can be used in an autocommand to decide what to do and/or what
     * to set v:fcs_choice to.  Possible values:
     *     deleted     file no longer exists
     *     conflict    file contents, mode or timestamp was
     *                 changed and buffer is modified
     *     changed     file contents has changed
     *     mode        mode of file changed
     *     time        only file timestamp changed
     */
    fcs_reason: "deleted" | "conflict" | "changed" | "mode" | "time";

    /**
     * What should happen after a |FileChangedShell| event was
     * triggered.  Can be used in an autocommand to tell Vim what to
     * do with the affected buffer:
     *     reload    Reload the buffer (does not work if
     *               the file was deleted).
     *     edit      Reload the buffer and detect the
     *               values for options such as
     *               'fileformat', 'fileencoding', 'binary'
     *               (does not work if the file was
     *               deleted).
     *     ask       Ask the user what to do, as if there
     *               was no autocommand.  Except that when
     *               only the timestamp changed nothing
     *               will happen.
     *     <empty>   Nothing, the autocommand should do
     *               everything that needs to be done.
     * The default is empty.  If another (invalid) value is used then
     * Vim behaves like it is empty, there is no warning message.
     */
    fcs_choice: "reload" | "edit" | "ask" | "";

    /**
     * When evaluating 'includeexpr': the file name that was
     * detected.  Empty otherwise.
     */
    fname: string;

    /**
     * The name of the input file.  Valid while evaluating:
     *     option         used for  
     *     'charconvert'  file to be converted
     *     'diffexpr'     original file
     *     'patchexpr'    original file
     * And set to the swap file name for |SwapExists|.
     */
    fname_in: string;

    /**
     * The name of the output file.  Only valid while
     * evaluating:
     *     option          used for  
     *     'charconvert'   resulting converted file [1]
     *     'diffexpr'      output of diff
     *     'patchexpr'     resulting patched file
     * [1] When doing conversion for a write command (e.g., ":w
     * file") it will be equal to v:fname_in.  When doing conversion
     * for a read command (e.g., ":e file") it will be a temporary
     * file and different from v:fname_in.
     */
    fname_out: string;

    /**
     * The name of the new version of the file.  Only valid while
     * evaluating 'diffexpr'.
     */
    fname_new: string;

    /**
     * The name of the diff (patch) file.  Only valid while
     * evaluating 'patchexpr'.
     */
    fname_diff: string;

    /**
     * Used for 'foldtext': dashes representing foldlevel of a closed
     * fold.
     * Read-only in the |sandbox|. |fold-foldtext|
     */
    folddashes: string;

    /**
     * Used for 'foldtext': foldlevel of closed fold.
     * Read-only in the |sandbox|. |fold-foldtext|
     */
    foldlevel: number;

    /**
     * Used for 'foldtext': last line of closed fold.
     * Read-only in the |sandbox|. |fold-foldtext|
     */
    foldend: number;

    /**
     * Used for 'foldtext': first line of closed fold.
     * Read-only in the |sandbox|. |fold-foldtext|
     */
    foldstart: number;

    /**
     * Variable that indicates whether search highlighting is on.
     * Setting it makes sense only if 'hlsearch' is enabled. Setting
     * this variable to zero acts like the |:nohlsearch| command,
     * setting it to one acts like  
     * let &hlsearch = &hlsearch
     * Note that the value is restored when returning from a
     * function. |function-search-undo|.
     */
    hlsearch: number;

    /**
     * Used for the |InsertEnter| and |InsertChange| autocommand
     * events.  Values:
     *    i    Insert mode
     *    r    Replace mode
     *    v    Virtual Replace mode
     */
    insertmode: string;

    /**
     * Key of the current item of a |Dictionary|.  Only valid while
     * evaluating the expression used with |map()| and |filter()|.
     * Read-only.
     */
    key?: string;

    /**
     * The current locale setting for messages of the runtime
     * environment.  This allows Vim scripts to be aware of the
     * current language.  Technical: it's the value of LC_MESSAGES.
     * The value is system dependent.
     * This variable can not be set directly, use the |:language|
     * command.
     * It can be different from |v:ctype| when messages are desired
     * in a different language than what is used for character
     * encoding.  See |multi-lang|.
     */
    lang: string;

    /**
     * The current locale setting for time messages of the runtime
     * environment.  This allows Vim scripts to be aware of the
     * current language.  Technical: it's the value of LC_TIME.
     * This variable can not be set directly, use the |:language|
     * command.  See |multi-lang|.
     */
    lc_time: string;

    /**
     * Line number for the 'foldexpr' |fold-expr|, 'formatexpr',
     * 'indentexpr' and 'statuscolumn' expressions, tab page number
     * for 'guitablabel' and 'guitabtooltip'.  Only valid while one of
     * these expressions is being evaluated.  Read-only when in the
     * |sandbox|.
     */
    lnum: number;

    /**
     * Prefix for calling Lua functions from expressions.
     * See |v:lua-call| for more information.
     */
    lua: any;

    /**
     * Maximum line length.  Depending on where it is used it can be
     * screen columns, characters or bytes.  The value currently is
     * 2147483647 on all systems.
     */
    maxcol: number;

    /**
     * Window number for a mouse click obtained with |getchar()|.
     * First window has number 1, like with |winnr()|.  The value is
     * zero when there was no mouse button click.
     */
    mouse_win: number;

    /**
     * |window-ID| for a mouse click obtained with |getchar()|.
     * The value is zero when there was no mouse button click.
     */
    mouse_winid: number;

    /**
     * Line number for a mouse click obtained with |getchar()|.
     * This is the text line number, not the screen line number.  The
     * value is zero when there was no mouse button click.
     */
    mouse_lnum: number;

    /**
     * Column number for a mouse click obtained with |getchar()|.
     * This is the screen column number, like with |virtcol()|.  The
     * value is zero when there was no mouse button click.
     */
    mouse_col: number;

    /**
     * Dictionary containing msgpack types used by |msgpackparse()|
     * and |msgpackdump()|. All types inside dictionary are fixed
     * (not editable) empty lists. To check whether some list is one
     * of msgpack types, use |is| operator.
     */
    msgpack_types: {[key: string]: any};

    /**
     * Special value used to put "null" in JSON and NIL in msgpack.
     * See |json_encode()|.  This value is converted to "v:null" when
     * used as a String (e.g. in |expr5| with string concatenation
     * operator) and to zero when used as a Number (e.g. in |expr5|
     * or |expr7| when used with numeric operators). Read-only.
     * In some places `v:null` can be used for a List, Dict, etc.
     * that is not set.  That is slightly different than an empty
     * List, Dict, etc.
     */
    null: any;

    /**
     * Maximum value of a number.
     */
    numbermax: number;

    /**
     * Minimum value of a number (negative).
     */
    numbermin: number;

    /**
     * Number of bits in a Number.  This is normally 64, but on some
     * systems it may be 32.
     */
    numbersize: number;

    /**
     * List of file names that is loaded from the |shada| file on
     * startup.  These are the files that Vim remembers marks for.
     * The length of the List is limited by the ' argument of the
     * 'shada' option (default is 100).
     * When the |shada| file is not used the List is empty.
     * Also see |:oldfiles| and |c_#<|.
     * The List can be modified, but this has no effect on what is
     * stored in the |shada| file later.  If you use values other
     * than String this will cause trouble.
     */
    oldfiles: string[];

    /**
     * New value of the option. Valid while executing an |OptionSet|
     * autocommand.
     */
    option_new: string;

    /**
     * Old value of the option. Valid while executing an |OptionSet|
     * autocommand. Depending on the command used for setting and the
     * kind of option this is either the local old value or the
     * global old value.
     */
    option_old: string;


    /**
     * Old local value of the option. Valid while executing an
     * |OptionSet| autocommand.
     */
    option_oldlocal: string;

    /**
     * Old global value of the option. Valid while executing an
     * |OptionSet| autocommand.
     */
    option_oldglobal: string;

    /**
     * Scope of the set command. Valid while executing an
     * |OptionSet| autocommand. Can be either "global" or "local"
     */
    option_type: string;

    /**
     * Command used to set the option. Valid while executing an
     * |OptionSet| autocommand.
     *    value          option was set via    
     *    "setlocal"     |:setlocal| or ":let l:xxx"
     *    "setglobal"    |:setglobal| or ":let g:xxx"
     *    "set"          |:set| or |:let|
     *    "modeline"     |modeline|
     */
    option_command: string;

    /**
     * The last operator given in Normal mode.  This is a single
     * character except for commands starting with <g> or <z>,
     * in which case it is two characters.  Best used alongside
     * |v:prevcount| and |v:register|.  Useful if you want to cancel
     * Operator-pending mode and then use the operator, e.g.:  
     *     :omap O <Esc>:call MyMotion(v:operator)<CR>
     * The value remains set until another operator is entered, thus
     * don't expect it to be empty.
     * v:operator is not set for |:delete|, |:yank| or other Ex
     * commands.
     * Read-only.
     */
    operator: string;

    /**
     * The count given for the last but one Normal mode command.
     * This is the v:count value of the previous command.  Useful if
     * you want to cancel Visual or Operator-pending mode and then
     * use the count, e.g.:  
     *     :vmap % <Esc>:call MyFilter(v:prevcount)<CR>
     * Read-only.
     */
    prevcount: number;

    /**
     * Normally zero.  Set to one after using ":profile start".
     * See |profiling|.
     */
    profiling: number;

    /**
     * The name by which Nvim was invoked (with path removed).
     * Read-only.
     */
    progname: string;

    /**
     * Absolute path to the current running Nvim.
     * Read-only.
     */
    progpath: string;

    /**
     * The name of the register in effect for the current normal mode
     * command (regardless of whether that command actually used a
     * register).  Or for the currently executing normal mode mapping
     * (use this in custom commands that take a register).
     * If none is supplied it is the default register '"', unless
     * 'clipboard' contains "unnamed" or "unnamedplus", then it is
     * '*' or '+'.
     * Also see |getreg()| and |setreg()|
     */
    register: string;

    /**
     * Relative line number for the 'statuscolumn' expression.
     * Read-only.
     */
    relnum: number;

    /**
     * String describing the script or function that caused the
     * screen to scroll up.  It's only set when it is empty, thus the
     * first reason is remembered.  It is set to "Unknown" for a
     * typed command.
     * This can be used to find out why your script causes the
     * hit-enter prompt.
     */
    scrollstart: string;

    /**
     * Primary listen-address of Nvim, the first item returned by
     * |serverlist()|. Usually this is the named pipe created by Nvim
     * at |startup| or given by |--listen| (or the deprecated
     * |$NVIM_LISTEN_ADDRESS| env var).
     * 
     * See also |serverstart()| |serverstop()|.
     * Read-only.
     * 
     * $NVIM is set by |terminal| and |jobstart()|, and is thus
     * a hint that the current environment is a subprocess of Nvim.
     * Example:  
     *     if $NVIM
     *       echo nvim_get_chan_info(v:parent)
     *     endif
     * 
     * Note the contents of $NVIM may change in the future.
     */
    servername: string;

    /**
     * Search direction:  1 after a forward search, 0 after a
     * backward search.  It is reset to forward when directly setting
     * the last search pattern, see |quote/|.
     * Note that the value is restored when returning from a
     * function. |function-search-undo|.
     * Read-write.
     */
    searchforward: number;

    /**
     * Result of the last shell command.  When non-zero, the last
     * shell command had an error.  When zero, there was no problem.
     * This only works when the shell returns the error code to Vim.
     * The value -1 is often used when the command could not be
     * executed.  Read-only.
     * Example:  
     *     :!mv foo bar
     *     :if v:shell_error
     *     :  echo 'could not rename "foo" to "bar"!'
     *     :endif
     */
    shell_error: number;

    /**
     * Last given status message.
     * Modifiable (can be set).
     */
    statusmsg: string;

    /**
     * |channel-id| corresponding to stderr. The value is always 2;
     * use this variable to make your code more descriptive.
     * Unlike stdin and stdout (see |stdioopen()|), stderr is always
     * open for writing. Example:  
     *     :call chansend(v:stderr, "error: toaster empty\n")
     */
    stderr: number;

    /**
     * Only valid when executing |SwapExists| autocommands: Name of
     * the swap file found.  Read-only.
     */
    swapname: string;

    /**
     * |SwapExists| autocommands can set this to the selected choice
     * for handling an existing swap file:
     *     'o'    Open read-only
     *     'e'    Edit anyway
     *     'r'    Recover
     *     'd'    Delete swapfile
     *     'q'    Quit
     *     'a'    Abort
     * The value should be a single-character string.  An empty value
     * results in the user being asked, as would happen when there is
     * no SwapExists autocommand.  The default is empty.
     */
    swapchoice: "o" | "e" | "r" | "d" | "q" | "a";

    /**
     * Normal mode command to be executed after a file has been
     * opened.  Can be used for a |SwapExists| autocommand to have
     * another Vim open the file and jump to the right place.  For
     * example, when jumping to a tag the value is ":tag tagname\r".
     * For ":edit +cmd file" the value is ":cmd\r".
     */
    swapcommand: string;

    /**
     * Value of |Boolean| type.  Read-only.  See: |type()|
     */
    t_bool: number;

    /**
     * Value of |Dictionary| type.  Read-only.  See: |type()|
     */
    t_dict: number;

    /**
     * Value of |Float| type.  Read-only.  See: |type()|
     */
    t_float: number;

    /**
     * Value of |Funcref| type.  Read-only.  See: |type()|
     */
    t_func: number;

    /**
     * Value of |List| type.  Read-only.  See: |type()|
     */
    t_list: number;

    /**
     * Value of |Number| type.  Read-only.  See: |type()|
     */
    t_number: number;

    /**
     * Value of |String| type.  Read-only.  See: |type()|
     */
    t_string: number;

    /**
     * Value of |Blob| type.  Read-only.  See: |type()|
     */
    t_blob: number;

    /**
     * The escape sequence returned by the terminal for the DA
     * (request primary device attributes) control sequence.  It is
     * set when Vim receives an escape sequence that starts with ESC
     * [ or CSI and ends in a 'c', with only digits, ';' and '.' in
     * between.
     * When this option is set, the TermResponse autocommand event is
     * fired, so that you can react to the response from the
     * terminal.
     * The response from a new xterm is: "<Esc>[ Pp ; Pv ; Pc c".  Pp
     * is the terminal type: 0 for vt100 and 1 for vt220.  Pv is the
     * patch level (since this was introduced in patch 95, it's
     * always 95 or bigger).  Pc is always zero.
     */
    termresponse: string;

    /**
     * Must be set before using `test_garbagecollect_now()`.
     */
    testing: number;

    /**
     * Full filename of the last loaded or saved session file.
     * Empty when no session file has been saved.  See |:mksession|.
     * Modifiable (can be set).
     */
    this_session: string;

    /**
     * The point where the exception most recently caught and not
     * finished was thrown.  Not set when commands are typed.  See
     * also |v:exception| and |throw-variables|.
     * Example:  
     *     :try
     *     :  throw "oops"
     *     :catch /.* /
     *     :  echo "Exception from" v:throwpoint
     *     :endtry
     * Output: "Exception from test.vim, line 2"
     */
    throwpoint: string;

    /**
     * Special value used to put "true" in JSON and msgpack.  See
     * |json_encode()|.  This value is converted to "v:true" when used
     * as a String (e.g. in |expr5| with string concatenation
     * operator) and to one when used as a Number (e.g. in |expr5| or
     * |expr7| when used with numeric operators). Read-only.
     */
    true: true;

    /**
     * Value of the current item of a |List| or |Dictionary|.  Only
     * valid while evaluating the expression used with |map()| and
     * |filter()|.  Read-only.
     */
    val?: any;

    /**
     * Vim version number: major version times 100 plus minor
     * version.  Vim 5.0 is 500, Vim 5.1 is 501.
     * Read-only.
     * Use |has()| to check the Nvim (not Vim) version:  
     *     :if has("nvim-0.2.1")
     */
    version: number;

    /**
     * Virtual line number for the 'statuscolumn' expression.
     * Negative when drawing the status column for virtual lines, zero
     * when drawing an actual buffer line, and positive when drawing
     * the wrapped part of a buffer line.
     * Read-only.
     */
    virtnum: number;

    /**
     * 0 during startup, 1 just before |VimEnter|.
     * Read-only.
     */
    vim_did_enter: number;

    /**
     * Last given warning message.
     * Modifiable (can be set).
     */
    warningmsg: string;

    /**
     * Application-specific window "handle" which may be set by any
     * attached UI. Defaults to zero.
     * Note: For Nvim |windows| use |winnr()| or |win_getid()|, see
     * |window-ID|.
     */
    windowid: number;
}

/** @noSelf **/
declare namespace vim {
    type NIL = {};
    const NIL: NIL;

    const g: { [key: string]: any };
    const v: VimV;
    const b: { [key: number]: { [key: string]: any } };
    const w: { [key: number]: { [key: string]: any } };
    const t: { [key: number]: { [key: string]: any } };

    const o: typeof bo & typeof wo & typeof go;

    const log: {
        levels: {
            TRACE: 0,
            DEBUG: 1,
            INFO: 2,
            WARN: 3,
            ERROR: 4,
            OFF: 5,
        }
    };

    /**
     *  Gets a human-readable representation of the given object.
     * 
     * @see https://github.com/kikito/inspect.lua
     * @see https://github.com/mpeterv/vinspect
     */
    function inspect(_object: object, options?: object): string;

    /**
     *  Paste handler, invoked by |nvim_paste()| when a conforming UI
     *  (such as the |TUI|) pastes text into the editor.
     * 
     *  Example: To remove ANSI color codes when pasting:
     *  <pre>lua
     *  vim.paste = (function(overridden)
     *    return function(lines, phase)
     *      for i,line in ipairs(lines) do
     *        -- Scrub ANSI color codes from paste input.
     *        lines[i] = line:gsub('\27%[[0-9;mK]+', '')
     *      end
     *      overridden(lines, phase)
     *    end
     *  end)(vim.paste)
     *  </pre>
     * 
     * @see |paste|
     * @alias paste_phase -1 | 1 | 2 | 3
     * 
     * @param lines  string[] # |readfile()|-style list of lines to paste. |channel-lines|
     * @param phase paste_phase  -1: "non-streaming" paste: the call contains all lines.
     *               If paste is "streamed", `phase` indicates the stream state:
     *                 - 1: starts the paste (exactly once)
     *                 - 2: continues the paste (zero or more times)
     *                 - 3: ends the paste (exactly once)
     * @returns boolean # false if client should cancel the paste.
     */
    function paste(lines: string[], phase: 1 | 2 | 3): boolean;

    /**
     *  Defers callback `cb` until the Nvim API is safe to call.
     * 
     * @see |lua-loop-callbacks|
     * @see |vim.schedule()|
     * @see |vim.in_fast_event()|
     * @param cb function
     * @return function
     */
    function schedule_wrap(cb: Function): Function;

    /**
     *  Get a table of lines with start, end columns for a region marked by two points.
     *  Input and output positions are (0,0)-indexed and indicate byte positions.
     * 
     * @param bufnr integer number of buffer
     * @param pos1 integer[] (line, column) tuple marking beginning of region
     * @param pos2 integer[] (line, column) tuple marking end of region
     * @param regtype string type of selection, see |setreg()|
     * @param inclusive boolean indicating whether column of pos2 is inclusive
     * @return table region Table of the form `{linenr = {startcol,endcol}}`.
     *         `endcol` is exclusive, and whole lines are marked with
     *         `{startcol,endcol} = {0,-1}`.
     */
    function region(bufnr: number, pos1: [number, number], pos2: [number, number], regtype: string, inclusive: boolean): object;

    /**
     *  Defers calling `fn` until `timeout` ms passes.
     * 
     *  Use to do a one-shot timer that calls `fn`
     *  Note: The {fn} is |vim.schedule_wrap()|ped automatically, so API functions are
     *  safe to call.
     * @param fn function Callback to call once `timeout` expires
     * @param timeout integer Number of milliseconds to wait before calling `fn`
     * @return table timer luv timer object
     */
    function defer_fn(fn: Function, timeout: number): object;

    /**
     *  Display a notification to the user.
     * 
     *  This function can be overridden by plugins to display notifications using a
     *  custom provider (such as the system notification provider). By default,
     *  writes to |:messages|.
     * 
     * @param msg string Content of the notification to show to the user.
     * @param level integer|nil One of the values from |vim.log.levels|.
     * @param opts table|nil Optional parameters. Unused by default.
     */
    function notify(msg: string, level?: number, opts?: any): void;

    /**
     *  Display a notification only one time.
     * 
     *  Like |vim.notify()|, but subsequent calls with the same message will not
     *  display a notification.
     * 
     * @param msg string Content of the notification to show to the user.
     * @param level integer|nil One of the values from |vim.log.levels|.
     * @param opts table|nil Optional parameters. Unused by default.
     * @return boolean true if message was displayed, else false
     */
    function notify_once(msg: string, level?: number, opts?: any): boolean;

    /**
     *  Adds Lua function {fn} with namespace id {ns_id} as a listener to every,
     *  yes every, input key.
     * 
     *  The Nvim command-line option |-w| is related but does not support callbacks
     *  and cannot be toggled dynamically.
     * 
     * @param fn function: Callback function. It should take one string argument.
     *                    On each key press, Nvim passes the key char to fn(). |i_CTRL-V|
     *                    If {fn} is nil, it removes the callback for the associated {ns_id}
     * @param ns_id integer? Namespace ID. If nil or 0, generates and returns a new
     *                     |nvim_create_namespace()| id.
     * 
     * @return integer Namespace id associated with {fn}. Or count of all callbacks
     * if on_key() is called without arguments.
     * 
     * @note {fn} will be removed if an error occurs while calling.
     * @note {fn} will not be cleared by |nvim_buf_clear_namespace()|
     * @note {fn} will receive the keys after mappings have been evaluated
     */
    function on_key(fn?: (key: string) => void, ns_id?: string): number;

    /**
     * Omnifunc for completing lua values from from the runtime lua interpreter,
     * similar to the builtin completion for the `:lua` command.
     *
     * Activate using `set omnifunc=v:lua.vim.lua_omnifunc` in a lua buffer.
     */
    function lua_omnifunc(find_start: any, _: any): any;

    /**
     * "Pretty prints" the given arguments and returns them unmodified.
     *
     * Example:
     * <pre>lua
     *   local hl_normal = vim.print(vim.api.nvim_get_hl_by_name('Normal', true))
     * </pre>
     *
     * @see |vim.inspect()|
     * @return any # given arguments.
     */
    function print(...vargs: any[]): any;

    /**
     *  Shows a deprecation message to the user.
     * 
     * @param name        string     Deprecated feature (function, API, etc.).
     * @param alternative string|nil Suggested alternative feature.
     * @param version     string     Version when the deprecated function will be removed.
     * @param plugin      string|nil Name of the plugin that owns the deprecated feature.
     *                               Defaults to "Nvim".
     * @param backtrace   boolean|nil Prints backtrace. Defaults to true.
     * 
     * @returns Deprecated message, or nil if no message was shown.
     */
    function deprecate(name: string, alternative?: string, version?: string, plugin?: string, backtrace?: boolean): any;

    /**
     *  Returns a deep copy of the given object. Non-table objects are copied as
     *  in a typical Lua assignment, whereas table objects are copied recursively.
     *  Functions are naively copied, so functions in the copied table point to the
     *  same functions as those in the input table. Userdata and threads are not
     *  copied and will throw an error.
     * 
     * @generic T: table
     * @param orig T Table to copy
     * @return T Table of copied keys and (nested) values.
     */
    function deepcopy<T extends object>(orig: T): T;

    /**
     *  Splits a string at each instance of a separator.
     * 
     *  Example:
     *    <pre>lua
     *    for s in vim.gsplit(':aa::b:', ':', {plain=true}) do
     *      print(s)
     *    end
     *    </pre>
     * 
     *  If you want to also inspect the separator itself (instead of discarding it), use
     *  |string.gmatch()|. Example:
     *    <pre>lua
     *    for word, num in ('foo111bar222'):gmatch('([^0-9]*)(%d*)') do
     *      print(('word: %s num: %s'):format(word, num))
     *    end
     *    </pre>
     * 
     *  @see |string.gmatch()|
     *  @see |vim.split()|
     *  @see |luaref-patterns|
     *  @see https://www.lua.org/pil/20.2.html
     *  @see http://lua-users.org/wiki/StringLibraryTutorial
     * 
     *  @param s string String to split
     *  @param sep string Separator or pattern
     *  @param opts (table|nil) Keyword arguments |kwargs|:
     *        - plain: (boolean) Use `sep` literally (as in string.find).
     *        - trimempty: (boolean) Discard empty segments at start and end of the sequence.
     * @return fun():string|nil (function) Iterator over the split components
     */
    function gsplit(s: string, sep: string, opts?: { plain?: boolean, trimempty?: boolean }): () => (string | undefined);

    /**
     *  Splits a string at each instance of a separator.
     * 
     *  Examples:
     *  <pre>lua
     *   split(":aa::b:", ":")                   --> {'','aa','','b',''}
     *   split("axaby", "ab?")                   --> {'','x','y'}
     *   split("x*yz*o", "*", {plain=true})      --> {'x','yz','o'}
     *   split("|x|y|z|", "|", {trimempty=true}) --> {'x', 'y', 'z'}
     *  </pre>
     * 
     * @see |vim.gsplit()|
     * @see |string.gmatch()|
     * 
     * @param s string String to split
     * @param sep string Separator or pattern
     * @param opts (table|nil) Keyword arguments |kwargs| accepted by |vim.gsplit()|
     * @return string[] List of split components
     */
    function split(s: string, sep: string, opts?: { plain?: boolean, trimempty?: boolean }): string[];

    /**
     *  Return a list of all keys used in a table.
     *  However, the order of the return table of keys is not guaranteed.
     * 
     * @see From https://github.com/premake/premake-core/blob/master/src/base/table.lua
     * 
     * @generic T: table
     * @param t table<T, any> (table) Table
     * @return T[] (list) List of keys
     */
    function tbl_keys<T extends object>(t: T): (keyof T)[];

    /**
     *  Return a list of all values used in a table.
     *  However, the order of the return table of values is not guaranteed.
     * 
     * @generic T
     * @param t table<any, T> (table) Table
     * @return T[] (list) List of values
     */
    function tbl_values<T>(t: T): (T[keyof T])[];

    /**
     *  Apply a function to all values of a table.
     * 
     * @generic T
     * @param func fun(value: T): any (function) Function
     * @param t table<any, T> (table) Table
     * @return table Table of transformed values
     */
    function tbl_map(func: (value: any) => any, t: object): object;

    /**
     *  Filter a table using a predicate function
     * 
     * @generic T
     * @param func fun(value: T): boolean (function) Function
     * @param t table<any, T> (table) Table
     * @return T[] (table) Table of filtered values
     */
    function tbl_filter(func: (value: any) => boolean, t: object): object;

    /**
     *  Checks if a list-like (vector) table contains `value`.
     * 
     * @param t table Table to check
     * @param value any Value to compare
     * @return boolean `true` if `t` contains `value`
     */
    function tbl_contains(t: object, value: any): boolean;

    /**
     *  Checks if a table is empty.
     * 
     * @see https://github.com/premake/premake-core/blob/master/src/base/table.lua
     * 
     * @param t table Table to check
     * @return boolean `true` if `t` is empty
     */
    function tbl_isempty(t: object): boolean;

    /**
     *  Merges two or more map-like tables.
     * 
     * @see |extend()|
     * 
     * @param behavior string Decides what to do if a key is found in more than one map:
     *       - "error": raise an error
     *       - "keep":  use value from the leftmost map
     *       - "force": use value from the rightmost map
     * @param ... table Two or more map-like tables
     * @return table Merged table
     */
    function tbl_extend(behavior: "error" | "keep" | "force", ...vargs: [object, object, ...(object[])]): object;

    /**
     *  Merges recursively two or more map-like tables.
     * 
     * @see |vim.tbl_extend()|
     * 
     * @generic T1: table
     * @generic T2: table
     * @param behavior "error"|"keep"|"force" (string) Decides what to do if a key is found in more than one map:
     *       - "error": raise an error
     *       - "keep":  use value from the leftmost map
     *       - "force": use value from the rightmost map
     * @param ... T2 Two or more map-like tables
     * @return T1|T2 (table) Merged table
     */
    function tbl_deep_extend(behavior: "error" | "keep" | "force", ...vargs: [object, object, ...(object[])]): object;

    /**
     *  Deep compare values for equality
     * 
     *  Tables are compared recursively unless they both provide the `eq` metamethod.
     *  All other types are compared using the equality `==` operator.
     * @param a any First value
     * @param b any Second value
     * @return boolean `true` if values are equals, else `false`
     */
    function deep_equal(a: any, b: any): boolean;

    /**
     *  Add the reverse lookup values to an existing table.
     *  For example:
     *  ``tbl_add_reverse_lookup { A = 1 } == { [1] = 'A', A = 1 }``
     * 
     *  Note that this *modifies* the input.
     * @param o table Table to add the reverse to
     * @return table o
     */
    function tbl_add_reverse_lookup(o: object): object;

    /**
     *  Index into a table (first argument) via string keys passed as subsequent arguments.
     *  Return `nil` if the key does not exist.
     * 
     *  Examples:
     *  <pre>lua
     *   vim.tbl_get({ key = { nested_key = true }}, 'key', 'nested_key') == true
     *   vim.tbl_get({ key = {}}, 'key', 'nested_key') == nil
     *  </pre>
     * 
     * @param o table Table to index
     * @param ... string Optional strings (0 or more, variadic) via which to index the table
     * 
     * @return any Nested value indexed by key (if it exists), else nil
     */
    function tbl_get(o: object, ...vargs: string[]): any;

    /**
     *  Extends a list-like table with the values of another list-like table.
     * 
     *  NOTE: This mutates dst!
     * 
     * @see |vim.tbl_extend()|
     * 
     * @generic T: table
     * @param dst T List which will be modified and appended to
     * @param src table List from which values will be inserted
     * @param start (integer|nil) Start index on src. Defaults to 1
     * @param finish (integer|nil) Final index on src. Defaults to `#src`
     * @return T dst
     */
    function list_extend(dst: any[], src: any[], start?: number, finish?: number): any[];

    /**
     *  Creates a copy of a list-like table such that any nested tables are
     *  "unrolled" and appended to the result.
     * 
     * @see From https://github.com/premake/premake-core/blob/master/src/base/table.lua
     * 
     * @param t table List-like table
     * @return table Flattened copy of the given list-like table
     */
    function tbl_flatten(t: any[]): object;

    /**
     *  Enumerate a table sorted by its keys.
     * 
     * @see Based on https://github.com/premake/premake-core/blob/master/src/base/table.lua
     * 
     * @param t table List-like table
     * @return iterator over sorted keys and their values
     */
    function spairs(t: any[]): any;

    /**
     *  Tests if a Lua table can be treated as an array.
     * 
     *  Empty table `{}` is assumed to be an array, unless it was created by
     *  |vim.empty_dict()| or returned as a dict-like |API| or Vimscript result,
     *  for example from |rpcrequest()| or |vim.fn|.
     * 
     * @param t table Table
     * @return boolean `true` if array-like table, else `false`
     */
    function tbl_islist(t: object): boolean;

    /**
     *  Counts the number of non-nil values in table `t`.
     * 
     *  <pre>lua
     *  vim.tbl_count({ a=1, b=2 })  --> 2
     *  vim.tbl_count({ 1, 2 })      --> 2
     *  </pre>
     * 
     * @see https://github.com/Tieske/Penlight/blob/master/lua/pl/tablex.lua
     * @param t table Table
     * @return integer Number of non-nil values in table
     */
    function tbl_count(t: object): number;

    /**
     *  Creates a copy of a table containing only elements from start to end (inclusive)
     * 
     * @generic T
     * @param list T[] (list) Table
     * @param start integer|nil Start range of slice
     * @param finish integer|nil End range of slice
     * @return T[] (list) Copy of table sliced from start to finish (inclusive)
     */
    function list_slice(list: any[], start?: number, finish?: number): any[];

    /**
     *  Trim whitespace (Lua pattern "%s") from both sides of a string.
     * 
     * @see |luaref-patterns|
     * @see https://www.lua.org/pil/20.2.html
     * @param s string String to trim
     * @return string String with whitespace removed from its beginning and end
     */
    function trim(s: string): string;

    /**
     *  Escapes magic chars in |lua-patterns|.
     * 
     * @see https://github.com/rxi/lume
     * @param s string String to escape
     * @return string %-escaped pattern string
     */
    function pesc(s: string): string;

    /**
     *  Tests if `s` starts with `prefix`.
     * 
     * @param s string String
     * @param prefix string Prefix to match
     * @return boolean `true` if `prefix` is a prefix of `s`
     */
    function startswith(s: string, prefix: string): boolean;

    /**
     *  Tests if `s` ends with `suffix`.
     * 
     * @param s string String
     * @param suffix string Suffix to match
     * @return boolean `true` if `suffix` is a suffix of `s`
     */
    function endswith(s: string, suffix: string): boolean;

    /**
     *  Validates a parameter specification (types and values).
     * 
     *  Usage example:
     *  <pre>lua
     *   function user.new(name, age, hobbies)
     *     vim.validate{
     *       name={name, 'string'},
     *       age={age, 'number'},
     *       hobbies={hobbies, 'table'},
     *     }
     *     ...
     *   end
     *  </pre>
     * 
     *  Examples with explicit argument values (can be run directly):
     *  <pre>lua
     *   vim.validate{arg1={{'foo'}, 'table'}, arg2={'foo', 'string'}}
     *      --> NOP (success)
     * 
     *   vim.validate{arg1={1, 'table'}}
     *      --> error('arg1: expected table, got number')
     * 
     *   vim.validate{arg1={3, function(a) return (a % 2) == 0 end, 'even number'}}
     *      --> error('arg1: expected even number, got 3')
     *  </pre>
     * 
     *  If multiple types are valid they can be given as a list.
     *  <pre>lua
     *   vim.validate{arg1={{'foo'}, {'table', 'string'}}, arg2={'foo', {'table', 'string'}}}
     *      --> NOP (success)
     * 
     *   vim.validate{arg1={1, {'string', 'table'}}}
     *      --> error('arg1: expected string|table, got number')
     * 
     *  </pre>
     * 
     * @param opt table Names of parameters to validate. Each key is a parameter
     *           name; each value is a tuple in one of these forms:
     *           1. (arg_value, type_name, optional)
     *              - arg_value: argument value
     *              - type_name: string|table type name, one of: ("table", "t", "string",
     *                "s", "number", "n", "boolean", "b", "function", "f", "nil",
     *                "thread", "userdata") or list of them.
     *              - optional: (optional) boolean, if true, `nil` is valid
     *           2. (arg_value, fn, msg)
     *              - arg_value: argument value
     *              - fn: any function accepting one argument, returns true if and
     *                only if the argument is valid. Can optionally return an additional
     *                informative error message as the second returned value.
     *              - msg: (optional) error string if validation fails
     */
    function validate(opt: any): any;

    /**
     *  Returns true if object `f` can be called as a function.
     * 
     * @param f any Any object
     * @return boolean `true` if `f` is callable, else `false`
     */
    function is_callable(f: any): boolean;

    /**
     *  Creates a table whose members are automatically created when accessed, if they don't already
     *  exist.
     * 
     *  They mimic defaultdict in python.
     * 
     *  If {create} is `nil`, this will create a defaulttable whose constructor function is
     *  this function, effectively allowing to create nested tables on the fly:
     * 
     *  <pre>lua
     *  local a = vim.defaulttable()
     *  a.b.c = 1
     *  </pre>
     * 
     * @param create function?(key:any):any The function called to create a missing value.
     * @return table Empty table with metamethod
     */
    function defaulttable(create: (key: any) => any): object

    export const lsp: any;

    /** @noSelf **/
    interface cmd {
        /**
         * append text
         */
        a: (...args: any[]) => any;

        /**
         * enter abbreviation
         */
        ab: (...args: any[]) => any;

        /**
         * enter abbreviation
         */
        abbreviate: (...args: any[]) => any;

        /**
         * remove all abbreviations
         */
        abc: (...args: any[]) => any;

        /**
         * remove all abbreviations
         */
        abclear: (...args: any[]) => any;

        /**
         * make split window appear left or above
         */
        abo: (...args: any[]) => any;

        /**
         * make split window appear left or above
         */
        aboveleft: (...args: any[]) => any;

        /**
         * open a window for each file in the argument
         */
        al: (...args: any[]) => any;

        /**
         * open a window for each file in the argument
         */
        all: (...args: any[]) => any;

        /**
         * enter new menu item for all modes
         */
        am: (...args: any[]) => any;

        /**
         * enter new menu item for all modes
         */
        amenu: (...args: any[]) => any;

        /**
         * enter a new menu for all modes that will not
         */
        an: (...args: any[]) => any;

        /**
         * enter a new menu for all modes that will not
         */
        anoremenu: (...args: any[]) => any;

        /**
         * append text
         */
        append: (...args: any[]) => any;

        /**
         * print the argument list
         */
        ar: (...args: any[]) => any;

        /**
         * add items to the argument list
         */
        arga: (...args: any[]) => any;

        /**
         * add items to the argument list
         */
        argadd: (...args: any[]) => any;

        /**
         * delete items from the argument list
         */
        argd: (...args: any[]) => any;

        /**
         * remove duplicates from the argument list
         */
        argded: (...args: any[]) => any;

        /**
         * remove duplicates from the argument list
         */
        argdedupe: (...args: any[]) => any;

        /**
         * delete items from the argument list
         */
        argdelete: (...args: any[]) => any;

        /**
         * do a command on all items in the argument list
         */
        argdo: (...args: any[]) => any;

        /**
         * add item to the argument list and edit it
         */
        arge: (...args: any[]) => any;

        /**
         * add item to the argument list and edit it
         */
        argedit: (...args: any[]) => any;

        /**
         * define the global argument list
         */
        argg: (...args: any[]) => any;

        /**
         * define the global argument list
         */
        argglobal: (...args: any[]) => any;

        /**
         * define a local argument list
         */
        argl: (...args: any[]) => any;

        /**
         * define a local argument list
         */
        arglocal: (...args: any[]) => any;

        /**
         * print the argument list
         */
        args: (...args: any[]) => any;

        /**
         * go to specific file in the argument list
         */
        argu: (...args: any[]) => any;

        /**
         * go to specific file in the argument list
         */
        argument: (...args: any[]) => any;

        /**
         * print ascii value of character under the cursor
         */
        as: (...args: any[]) => any;

        /**
         * print ascii value of character under the cursor
         */
        ascii: (...args: any[]) => any;

        /**
         * enter or show autocommands
         */
        au: (...args: any[]) => any;

        /**
         * select the autocommand group to use
         */
        aug: (...args: any[]) => any;

        /**
         * select the autocommand group to use
         */
        augroup: (...args: any[]) => any;

        /**
         * remove menu for all modes
         */
        aun: (...args: any[]) => any;

        /**
         * remove menu for all modes
         */
        aunmenu: (...args: any[]) => any;

        /**
         * enter or show autocommands
         */
        autocmd: (...args: any[]) => any;

        /**
         * go to specific buffer in the buffer list
         */
        b: (...args: any[]) => any;

        /**
         * go to previous buffer in the buffer list
         */
        bN: (...args: any[]) => any;

        /**
         * go to previous buffer in the buffer list
         */
        bNext: (...args: any[]) => any;

        /**
         * open a window for each buffer in the buffer list
         */
        ba: (...args: any[]) => any;

        /**
         * add buffer to the buffer list
         */
        bad: (...args: any[]) => any;

        /**
         * add buffer to the buffer list
         */
        badd: (...args: any[]) => any;

        /**
         * open a window for each buffer in the buffer list
         */
        ball: (...args: any[]) => any;

        /**
         * like ":badd" but also set the alternate file
         */
        balt: (...args: any[]) => any;

        /**
         * remove a buffer from the buffer list
         */
        bd: (...args: any[]) => any;

        /**
         * remove a buffer from the buffer list
         */
        bdelete: (...args: any[]) => any;

        /**
         * set mouse and selection behavior
         */
        be: (...args: any[]) => any;

        /**
         * set mouse and selection behavior
         */
        behave: (...args: any[]) => any;

        /**
         * make split window appear right or below
         */
        bel: (...args: any[]) => any;

        /**
         * make split window appear right or below
         */
        belowright: (...args: any[]) => any;

        /**
         * go to first buffer in the buffer list
         */
        bf: (...args: any[]) => any;

        /**
         * go to first buffer in the buffer list
         */
        bfirst: (...args: any[]) => any;

        /**
         * go to last buffer in the buffer list
         */
        bl: (...args: any[]) => any;

        /**
         * go to last buffer in the buffer list
         */
        blast: (...args: any[]) => any;

        /**
         * go to next buffer in the buffer list that has
         */
        bm: (...args: any[]) => any;

        /**
         * go to next buffer in the buffer list that has
         */
        bmodified: (...args: any[]) => any;

        /**
         * go to next buffer in the buffer list
         */
        bn: (...args: any[]) => any;

        /**
         * go to next buffer in the buffer list
         */
        bnext: (...args: any[]) => any;

        /**
         * make split window appear at bottom or far right
         */
        bo: (...args: any[]) => any;

        /**
         * make split window appear at bottom or far right
         */
        botright: (...args: any[]) => any;

        /**
         * go to previous buffer in the buffer list
         */
        bp: (...args: any[]) => any;

        /**
         * go to previous buffer in the buffer list
         */
        bprevious: (...args: any[]) => any;

        /**
         * go to first buffer in the buffer list
         */
        br: (...args: any[]) => any;

        /**
         * break out of while loop
         */
        brea: (...args: any[]) => any;

        /**
         * break out of while loop
         */
        break: (...args: any[]) => any;

        /**
         * add a debugger breakpoint
         */
        breaka: (...args: any[]) => any;

        /**
         * add a debugger breakpoint
         */
        breakadd: (...args: any[]) => any;

        /**
         * delete a debugger breakpoint
         */
        breakd: (...args: any[]) => any;

        /**
         * delete a debugger breakpoint
         */
        breakdel: (...args: any[]) => any;

        /**
         * list debugger breakpoints
         */
        breakl: (...args: any[]) => any;

        /**
         * list debugger breakpoints
         */
        breaklist: (...args: any[]) => any;

        /**
         * go to first buffer in the buffer list
         */
        brewind: (...args: any[]) => any;

        /**
         * use file selection dialog
         */
        bro: (...args: any[]) => any;

        /**
         * use file selection dialog
         */
        browse: (...args: any[]) => any;

        /**
         * execute command in each listed buffer
         */
        bufdo: (...args: any[]) => any;

        /**
         * go to specific buffer in the buffer list
         */
        buffer: (...args: any[]) => any;

        /**
         * list all files in the buffer list
         */
        buffers: (...args: any[]) => any;

        /**
         * unload a specific buffer
         */
        bun: (...args: any[]) => any;

        /**
         * unload a specific buffer
         */
        bunload: (...args: any[]) => any;

        /**
         * really delete a buffer
         */
        bw: (...args: any[]) => any;

        /**
         * really delete a buffer
         */
        bwipeout: (...args: any[]) => any;

        /**
         * replace a line or series of lines
         */
        c: (...args: any[]) => any;

        /**
         * go to previous error
         */
        cN: (...args: any[]) => any;

        /**
         * go to previous error
         */
        cNext: (...args: any[]) => any;

        /**
         * go to last error in previous file
         */
        cNf: (...args: any[]) => any;

        /**
         * go to last error in previous file
         */
        cNfile: (...args: any[]) => any;

        /**
         * like ":abbreviate" but for Command-line mode
         */
        ca: (...args: any[]) => any;

        /**
         * like ":abbreviate" but for Command-line mode
         */
        cabbrev: (...args: any[]) => any;

        /**
         * clear all abbreviations for Command-line mode
         */
        cabc: (...args: any[]) => any;

        /**
         * clear all abbreviations for Command-line mode
         */
        cabclear: (...args: any[]) => any;

        /**
         * go to error above current line
         */
        cabo: (...args: any[]) => any;

        /**
         * go to error above current line
         */
        cabove: (...args: any[]) => any;

        /**
         * add errors from buffer
         */
        cad: (...args: any[]) => any;

        /**
         * add errors from buffer
         */
        caddbuffer: (...args: any[]) => any;

        /**
         * add errors from expr
         */
        cadde: (...args: any[]) => any;

        /**
         * add errors from expr
         */
        caddexpr: (...args: any[]) => any;

        /**
         * add error message to current quickfix list
         */
        caddf: (...args: any[]) => any;

        /**
         * add error message to current quickfix list
         */
        caddfile: (...args: any[]) => any;

        /**
         * go to error after current cursor
         */
        caf: (...args: any[]) => any;

        /**
         * go to error after current cursor
         */
        cafter: (...args: any[]) => any;

        /**
         * call a function
         */
        cal: (...args: any[]) => any;

        /**
         * call a function
         */
        call: (...args: any[]) => any;

        /**
         * part of a :try command
         */
        cat: (...args: any[]) => any;

        /**
         * part of a :try command
         */
        catch: (...args: any[]) => any;

        /**
         * parse error messages and jump to first error
         */
        cb: (...args: any[]) => any;

        /**
         * go to error before current cursor
         */
        cbef: (...args: any[]) => any;

        /**
         * go to error before current cursor
         */
        cbefore: (...args: any[]) => any;

        /**
         * go to error below current line
         */
        cbel: (...args: any[]) => any;

        /**
         * go to error below current line
         */
        cbelow: (...args: any[]) => any;

        /**
         * scroll to the bottom of the quickfix window
         */
        cbo: (...args: any[]) => any;

        /**
         * scroll to the bottom of the quickfix window
         */
        cbottom: (...args: any[]) => any;

        /**
         * parse error messages and jump to first error
         */
        cbuffer: (...args: any[]) => any;

        /**
         * go to specific error
         */
        cc: (...args: any[]) => any;

        /**
         * close quickfix window
         */
        ccl: (...args: any[]) => any;

        /**
         * close quickfix window
         */
        cclose: (...args: any[]) => any;

        /**
         * change directory
         */
        cd: (...args: any[]) => any;

        /**
         * execute command in each valid error list entry
         */
        cdo: (...args: any[]) => any;

        /**
         * format lines at the center
         */
        ce: (...args: any[]) => any;

        /**
         * format lines at the center
         */
        center: (...args: any[]) => any;

        /**
         * read errors from expr and jump to first
         */
        cex: (...args: any[]) => any;

        /**
         * read errors from expr and jump to first
         */
        cexpr: (...args: any[]) => any;

        /**
         * read file with error messages and jump to first
         */
        cf: (...args: any[]) => any;

        /**
         * execute command in each file in error list
         */
        cfd: (...args: any[]) => any;

        /**
         * execute command in each file in error list
         */
        cfdo: (...args: any[]) => any;

        /**
         * read file with error messages and jump to first
         */
        cfile: (...args: any[]) => any;

        /**
         * go to the specified error, default first one
         */
        cfir: (...args: any[]) => any;

        /**
         * go to the specified error, default first one
         */
        cfirst: (...args: any[]) => any;

        /**
         * read file with error messages
         */
        cg: (...args: any[]) => any;

        /**
         * get errors from buffer
         */
        cgetb: (...args: any[]) => any;

        /**
         * get errors from buffer
         */
        cgetbuffer: (...args: any[]) => any;

        /**
         * get errors from expr
         */
        cgete: (...args: any[]) => any;

        /**
         * get errors from expr
         */
        cgetexpr: (...args: any[]) => any;

        /**
         * read file with error messages
         */
        cgetfile: (...args: any[]) => any;

        /**
         * replace a line or series of lines
         */
        change: (...args: any[]) => any;

        /**
         * print the change list
         */
        changes: (...args: any[]) => any;

        /**
         * change directory
         */
        chd: (...args: any[]) => any;

        /**
         * change directory
         */
        chdir: (...args: any[]) => any;

        /**
         * run healthchecks
         */
        che: (...args: any[]) => any;

        /**
         * run healthchecks
         */
        checkhealth: (...args: any[]) => any;

        /**
         * list included files
         */
        checkp: (...args: any[]) => any;

        /**
         * list included files
         */
        checkpath: (...args: any[]) => any;

        /**
         * check timestamp of loaded buffers
         */
        checkt: (...args: any[]) => any;

        /**
         * check timestamp of loaded buffers
         */
        checktime: (...args: any[]) => any;

        /**
         * list the error lists
         */
        chi: (...args: any[]) => any;

        /**
         * list the error lists
         */
        chistory: (...args: any[]) => any;

        /**
         * list all errors
         */
        cl: (...args: any[]) => any;

        /**
         * go to the specified error, default last one
         */
        cla: (...args: any[]) => any;

        /**
         * go to the specified error, default last one
         */
        clast: (...args: any[]) => any;

        /**
         * clear the jump list
         */
        cle: (...args: any[]) => any;

        /**
         * clear the jump list
         */
        clearjumps: (...args: any[]) => any;

        /**
         * list all errors
         */
        clist: (...args: any[]) => any;

        /**
         * close current window
         */
        clo: (...args: any[]) => any;

        /**
         * close current window
         */
        close: (...args: any[]) => any;

        /**
         * like ":map" but for Command-line mode
         */
        cm: (...args: any[]) => any;

        /**
         * like ":map" but for Command-line mode
         */
        cmap: (...args: any[]) => any;

        /**
         * clear all mappings for Command-line mode
         */
        cmapc: (...args: any[]) => any;

        /**
         * clear all mappings for Command-line mode
         */
        cmapclear: (...args: any[]) => any;

        /**
         * add menu for Command-line mode
         */
        cme: (...args: any[]) => any;

        /**
         * add menu for Command-line mode
         */
        cmenu: (...args: any[]) => any;

        /**
         * go to next error
         */
        cn: (...args: any[]) => any;

        /**
         * go to newer error list
         */
        cnew: (...args: any[]) => any;

        /**
         * go to newer error list
         */
        cnewer: (...args: any[]) => any;

        /**
         * go to next error
         */
        cnext: (...args: any[]) => any;

        /**
         * go to first error in next file
         */
        cnf: (...args: any[]) => any;

        /**
         * go to first error in next file
         */
        cnfile: (...args: any[]) => any;

        /**
         * like ":noremap" but for Command-line mode
         */
        cno: (...args: any[]) => any;

        /**
         * like ":noreabbrev" but for Command-line mode
         */
        cnorea: (...args: any[]) => any;

        /**
         * like ":noreabbrev" but for Command-line mode
         */
        cnoreabbrev: (...args: any[]) => any;

        /**
         * like ":noremap" but for Command-line mode
         */
        cnoremap: (...args: any[]) => any;

        /**
         * like ":noremenu" but for Command-line mode
         */
        cnoreme: (...args: any[]) => any;

        /**
         * like ":noremenu" but for Command-line mode
         */
        cnoremenu: (...args: any[]) => any;

        /**
         * copy lines
         */
        co: (...args: any[]) => any;

        /**
         * go to older error list
         */
        col: (...args: any[]) => any;

        /**
         * go to older error list
         */
        colder: (...args: any[]) => any;

        /**
         * load a specific color scheme
         */
        colo: (...args: any[]) => any;

        /**
         * load a specific color scheme
         */
        colorscheme: (...args: any[]) => any;

        /**
         * create user-defined command
         */
        com: (...args: any[]) => any;

        /**
         * clear all user-defined commands
         */
        comc: (...args: any[]) => any;

        /**
         * clear all user-defined commands
         */
        comclear: (...args: any[]) => any;

        /**
         * create user-defined command
         */
        command: (...args: any[]) => any;

        /**
         * do settings for a specific compiler
         */
        comp: (...args: any[]) => any;

        /**
         * do settings for a specific compiler
         */
        compiler: (...args: any[]) => any;

        /**
         * go back to :while
         */
        con: (...args: any[]) => any;

        /**
         * prompt user when confirmation required
         */
        conf: (...args: any[]) => any;

        /**
         * prompt user when confirmation required
         */
        confirm: (...args: any[]) => any;

        /**
         * create a variable as a constant
         */
        cons: (...args: any[]) => any;

        /**
         * create a variable as a constant
         */
        const: (...args: any[]) => any;

        /**
         * go back to :while
         */
        continue: (...args: any[]) => any;

        /**
         * open quickfix window
         */
        cope: (...args: any[]) => any;

        /**
         * open quickfix window
         */
        copen: (...args: any[]) => any;

        /**
         * copy lines
         */
        copy: (...args: any[]) => any;

        /**
         * go to previous error
         */
        cp: (...args: any[]) => any;

        /**
         * go to last error in previous file
         */
        cpf: (...args: any[]) => any;

        /**
         * go to last error in previous file
         */
        cpfile: (...args: any[]) => any;

        /**
         * go to previous error
         */
        cprevious: (...args: any[]) => any;

        /**
         * quit Vim with an error code
         */
        cq: (...args: any[]) => any;

        /**
         * quit Vim with an error code
         */
        cquit: (...args: any[]) => any;

        /**
         * go to the specified error, default first one
         */
        cr: (...args: any[]) => any;

        /**
         * go to the specified error, default first one
         */
        crewind: (...args: any[]) => any;

        /**
         * like ":unmap" but for Command-line mode
         */
        cu: (...args: any[]) => any;

        /**
         * like ":unabbrev" but for Command-line mode
         */
        cuna: (...args: any[]) => any;

        /**
         * like ":unabbrev" but for Command-line mode
         */
        cunabbrev: (...args: any[]) => any;

        /**
         * like ":unmap" but for Command-line mode
         */
        cunmap: (...args: any[]) => any;

        /**
         * remove menu for Command-line mode
         */
        cunme: (...args: any[]) => any;

        /**
         * remove menu for Command-line mode
         */
        cunmenu: (...args: any[]) => any;

        /**
         * open or close quickfix window
         */
        cw: (...args: any[]) => any;

        /**
         * open or close quickfix window
         */
        cwindow: (...args: any[]) => any;

        /**
         * short for |:delete| with the 'p' flag
         */
        d: (...args: any[]) => any;

        /**
         * run a command in debugging mode
         */
        deb: (...args: any[]) => any;

        /**
         * run a command in debugging mode
         */
        debug: (...args: any[]) => any;

        /**
         * read debug mode commands from normal input
         */
        debugg: (...args: any[]) => any;

        /**
         * read debug mode commands from normal input
         */
        debuggreedy: (...args: any[]) => any;

        /**
         * delete user-defined command
         */
        delc: (...args: any[]) => any;

        /**
         * delete user-defined command
         */
        delcommand: (...args: any[]) => any;

        /**
         * delete lines
         */
        delete: (...args: any[]) => any;

        /**
         * short for |:delete| with the 'p' flag
         */
        deletep: (...args: any[]) => any;

        /**
         * delete a user function
         */
        delf: (...args: any[]) => any;

        /**
         * delete a user function
         */
        delfunction: (...args: any[]) => any;

        /**
         * delete marks
         */
        delm: (...args: any[]) => any;

        /**
         * delete marks
         */
        delmarks: (...args: any[]) => any;

        /**
         * display registers
         */
        di: (...args: any[]) => any;

        /**
         * update 'diff' buffers
         */
        dif: (...args: any[]) => any;

        /**
         * remove differences in current buffer
         */
        diffg: (...args: any[]) => any;

        /**
         * remove differences in current buffer
         */
        diffget: (...args: any[]) => any;

        /**
         * switch off diff mode
         */
        diffo: (...args: any[]) => any;

        /**
         * switch off diff mode
         */
        diffoff: (...args: any[]) => any;

        /**
         * apply a patch and show differences
         */
        diffp: (...args: any[]) => any;

        /**
         * apply a patch and show differences
         */
        diffpatch: (...args: any[]) => any;

        /**
         * remove differences in other buffer
         */
        diffpu: (...args: any[]) => any;

        /**
         * remove differences in other buffer
         */
        diffput: (...args: any[]) => any;

        /**
         * show differences with another file
         */
        diffs: (...args: any[]) => any;

        /**
         * show differences with another file
         */
        diffsplit: (...args: any[]) => any;

        /**
         * make current window a diff window
         */
        diffthis: (...args: any[]) => any;

        /**
         * update 'diff' buffers
         */
        diffupdate: (...args: any[]) => any;

        /**
         * show or enter digraphs
         */
        dig: (...args: any[]) => any;

        /**
         * show or enter digraphs
         */
        digraphs: (...args: any[]) => any;

        /**
         * display registers
         */
        display: (...args: any[]) => any;

        /**
         * jump to #define
         */
        dj: (...args: any[]) => any;

        /**
         * jump to #define
         */
        djump: (...args: any[]) => any;

        /**
         * short for |:delete| with the 'l' flag
         */
        dl: (...args: any[]) => any;

        /**
         * list #defines
         */
        dli: (...args: any[]) => any;

        /**
         * list #defines
         */
        dlist: (...args: any[]) => any;

        /**
         * apply autocommands to current buffer
         */
        do: (...args: any[]) => any;

        /**
         * apply autocommands for all loaded buffers
         */
        doautoa: (...args: any[]) => any;

        /**
         * apply autocommands for all loaded buffers
         */
        doautoall: (...args: any[]) => any;

        /**
         * apply autocommands to current buffer
         */
        doautocmd: (...args: any[]) => any;

        /**
         * jump to window editing file or edit file in
         */
        dr: (...args: any[]) => any;

        /**
         * jump to window editing file or edit file in
         */
        drop: (...args: any[]) => any;

        /**
         * list one #define
         */
        ds: (...args: any[]) => any;

        /**
         * list one #define
         */
        dsearch: (...args: any[]) => any;

        /**
         * split window and jump to #define
         */
        dsp: (...args: any[]) => any;

        /**
         * split window and jump to #define
         */
        dsplit: (...args: any[]) => any;

        /**
         * edit a file
         */
        e: (...args: any[]) => any;

        /**
         * go to older change, undo
         */
        ea: (...args: any[]) => any;

        /**
         * go to older change, undo
         */
        earlier: (...args: any[]) => any;

        /**
         * echoes the result of expressions
         */
        ec: (...args: any[]) => any;

        /**
         * echoes the result of expressions
         */
        echo: (...args: any[]) => any;

        /**
         * like :echo, show like an error and use history
         */
        echoe: (...args: any[]) => any;

        /**
         * like :echo, show like an error and use history
         */
        echoerr: (...args: any[]) => any;

        /**
         * set highlighting for echo commands
         */
        echoh: (...args: any[]) => any;

        /**
         * set highlighting for echo commands
         */
        echohl: (...args: any[]) => any;

        /**
         * same as :echo, put message in history
         */
        echom: (...args: any[]) => any;

        /**
         * same as :echo, put message in history
         */
        echomsg: (...args: any[]) => any;

        /**
         * same as :echo, but without <EOL>
         */
        echon: (...args: any[]) => any;

        /**
         * edit a file
         */
        edit: (...args: any[]) => any;

        /**
         * part of an :if command
         */
        el: (...args: any[]) => any;

        /**
         * part of an :if command
         */
        else: (...args: any[]) => any;

        /**
         * part of an :if command
         */
        elsei: (...args: any[]) => any;

        /**
         * part of an :if command
         */
        elseif: (...args: any[]) => any;

        /**
         * execute a menu by name
         */
        em: (...args: any[]) => any;

        /**
         * execute a menu by name
         */
        emenu: (...args: any[]) => any;

        /**
         * end previous :if
         */
        en: (...args: any[]) => any;

        /**
         * end of a user function started with :function
         */
        endf: (...args: any[]) => any;

        /**
         * end previous :for
         */
        endfo: (...args: any[]) => any;

        /**
         * end previous :for
         */
        endfor: (...args: any[]) => any;

        /**
         * end of a user function started with :function
         */
        endfunction: (...args: any[]) => any;

        /**
         * end previous :if
         */
        endif: (...args: any[]) => any;

        /**
         * end previous :try
         */
        endt: (...args: any[]) => any;

        /**
         * end previous :try
         */
        endtry: (...args: any[]) => any;

        /**
         * end previous :while
         */
        endw: (...args: any[]) => any;

        /**
         * end previous :while
         */
        endwhile: (...args: any[]) => any;

        /**
         * edit a new, unnamed buffer
         */
        ene: (...args: any[]) => any;

        /**
         * edit a new, unnamed buffer
         */
        enew: (...args: any[]) => any;

        /**
         * evaluate an expression and discard the result
         */
        ev: (...args: any[]) => any;

        /**
         * evaluate an expression and discard the result
         */
        eval: (...args: any[]) => any;

        /**
         * same as ":edit"
         */
        ex: (...args: any[]) => any;

        /**
         * execute result of expressions
         */
        exe: (...args: any[]) => any;

        /**
         * execute result of expressions
         */
        execute: (...args: any[]) => any;

        /**
         * same as ":xit"
         */
        exi: (...args: any[]) => any;

        /**
         * same as ":xit"
         */
        exit: (...args: any[]) => any;

        /**
         * overview of Ex commands
         */
        exu: (...args: any[]) => any;

        /**
         * overview of Ex commands
         */
        exusage: (...args: any[]) => any;

        /**
         * show or set the current file name
         */
        f: (...args: any[]) => any;

        /**
         * show or set the current file name
         */
        file: (...args: any[]) => any;

        /**
         * list all files in the buffer list
         */
        files: (...args: any[]) => any;

        /**
         * switch file type detection on/off
         */
        filet: (...args: any[]) => any;

        /**
         * switch file type detection on/off
         */
        filetype: (...args: any[]) => any;

        /**
         * filter output of following command
         */
        filt: (...args: any[]) => any;

        /**
         * filter output of following command
         */
        filter: (...args: any[]) => any;

        /**
         * find file in 'path' and edit it
         */
        fin: (...args: any[]) => any;

        /**
         * part of a :try command
         */
        fina: (...args: any[]) => any;

        /**
         * part of a :try command
         */
        finally: (...args: any[]) => any;

        /**
         * find file in 'path' and edit it
         */
        find: (...args: any[]) => any;

        /**
         * quit sourcing a Vim script
         */
        fini: (...args: any[]) => any;

        /**
         * quit sourcing a Vim script
         */
        finish: (...args: any[]) => any;

        /**
         * go to the first file in the argument list
         */
        fir: (...args: any[]) => any;

        /**
         * go to the first file in the argument list
         */
        first: (...args: any[]) => any;

        /**
         * create a fold
         */
        fo: (...args: any[]) => any;

        /**
         * create a fold
         */
        fold: (...args: any[]) => any;

        /**
         * close folds
         */
        foldc: (...args: any[]) => any;

        /**
         * close folds
         */
        foldclose: (...args: any[]) => any;

        /**
         * execute command on lines not in a closed fold
         */
        foldd: (...args: any[]) => any;

        /**
         * execute command on lines in a closed fold
         */
        folddoc: (...args: any[]) => any;

        /**
         * execute command on lines in a closed fold
         */
        folddoclosed: (...args: any[]) => any;

        /**
         * execute command on lines not in a closed fold
         */
        folddoopen: (...args: any[]) => any;

        /**
         * open folds
         */
        foldo: (...args: any[]) => any;

        /**
         * open folds
         */
        foldopen: (...args: any[]) => any;

        /**
         * for loop
         */
        for: (...args: any[]) => any;

        /**
         * define a user function
         */
        fu: (...args: any[]) => any;

        /**
         * define a user function
         */
        function: (...args: any[]) => any;

        /**
         * execute commands for matching lines
         */
        g: (...args: any[]) => any;

        /**
         * execute commands for matching lines
         */
        global: (...args: any[]) => any;

        /**
         * go to byte in the buffer
         */
        go: (...args: any[]) => any;

        /**
         * go to byte in the buffer
         */
        goto: (...args: any[]) => any;

        /**
         * run 'grepprg' and jump to first match
         */
        gr: (...args: any[]) => any;

        /**
         * run 'grepprg' and jump to first match
         */
        grep: (...args: any[]) => any;

        /**
         * like :grep, but append to current list
         */
        grepa: (...args: any[]) => any;

        /**
         * like :grep, but append to current list
         */
        grepadd: (...args: any[]) => any;

        /**
         * start the GUI
         */
        gu: (...args: any[]) => any;

        /**
         * start the GUI
         */
        gui: (...args: any[]) => any;

        /**
         * start the GUI
         */
        gv: (...args: any[]) => any;

        /**
         * start the GUI
         */
        gvim: (...args: any[]) => any;

        /**
         * open a help window
         */
        h: (...args: any[]) => any;

        /**
         * open a help window
         */
        help: (...args: any[]) => any;

        /**
         * close one help window
         */
        helpc: (...args: any[]) => any;

        /**
         * close one help window
         */
        helpclose: (...args: any[]) => any;

        /**
         * like ":grep" but searches help files
         */
        helpg: (...args: any[]) => any;

        /**
         * like ":grep" but searches help files
         */
        helpgrep: (...args: any[]) => any;

        /**
         * generate help tags for a directory
         */
        helpt: (...args: any[]) => any;

        /**
         * generate help tags for a directory
         */
        helptags: (...args: any[]) => any;

        /**
         * specify highlighting methods
         */
        hi: (...args: any[]) => any;

        /**
         * hide current buffer for a command
         */
        hid: (...args: any[]) => any;

        /**
         * hide current buffer for a command
         */
        hide: (...args: any[]) => any;

        /**
         * specify highlighting methods
         */
        highlight: (...args: any[]) => any;

        /**
         * print a history list
         */
        his: (...args: any[]) => any;

        /**
         * print a history list
         */
        history: (...args: any[]) => any;

        /**
         * following window command work horizontally
         */
        hor: (...args: any[]) => any;

        /**
         * following window command work horizontally
         */
        horizontal: (...args: any[]) => any;

        /**
         * insert text
         */
        i: (...args: any[]) => any;

        /**
         * like ":abbrev" but for Insert mode
         */
        ia: (...args: any[]) => any;

        /**
         * like ":abbrev" but for Insert mode
         */
        iabbrev: (...args: any[]) => any;

        /**
         * like ":abclear" but for Insert mode
         */
        iabc: (...args: any[]) => any;

        /**
         * like ":abclear" but for Insert mode
         */
        iabclear: (...args: any[]) => any;

        /**
         * execute commands when condition met
         */
        if: (...args: any[]) => any;

        /**
         * jump to definition of identifier
         */
        ij: (...args: any[]) => any;

        /**
         * jump to definition of identifier
         */
        ijump: (...args: any[]) => any;

        /**
         * list lines where identifier matches
         */
        il: (...args: any[]) => any;

        /**
         * list lines where identifier matches
         */
        ilist: (...args: any[]) => any;

        /**
         * like ":map" but for Insert mode
         */
        im: (...args: any[]) => any;

        /**
         * like ":map" but for Insert mode
         */
        imap: (...args: any[]) => any;

        /**
         * like ":mapclear" but for Insert mode
         */
        imapc: (...args: any[]) => any;

        /**
         * like ":mapclear" but for Insert mode
         */
        imapclear: (...args: any[]) => any;

        /**
         * add menu for Insert mode
         */
        ime: (...args: any[]) => any;

        /**
         * add menu for Insert mode
         */
        imenu: (...args: any[]) => any;

        /**
         * like ":noremap" but for Insert mode
         */
        ino: (...args: any[]) => any;

        /**
         * like ":noreabbrev" but for Insert mode
         */
        inorea: (...args: any[]) => any;

        /**
         * like ":noreabbrev" but for Insert mode
         */
        inoreabbrev: (...args: any[]) => any;

        /**
         * like ":noremap" but for Insert mode
         */
        inoremap: (...args: any[]) => any;

        /**
         * like ":noremenu" but for Insert mode
         */
        inoreme: (...args: any[]) => any;

        /**
         * like ":noremenu" but for Insert mode
         */
        inoremenu: (...args: any[]) => any;

        /**
         * insert text
         */
        insert: (...args: any[]) => any;

        /**
         * print the introductory message
         */
        int: (...args: any[]) => any;

        /**
         * print the introductory message
         */
        intro: (...args: any[]) => any;

        /**
         * list one line where identifier matches
         */
        is: (...args: any[]) => any;

        /**
         * list one line where identifier matches
         */
        isearch: (...args: any[]) => any;

        /**
         * split window and jump to definition of
         */
        isp: (...args: any[]) => any;

        /**
         * split window and jump to definition of
         */
        isplit: (...args: any[]) => any;

        /**
         * like ":unmap" but for Insert mode
         */
        iu: (...args: any[]) => any;

        /**
         * like ":unabbrev" but for Insert mode
         */
        iuna: (...args: any[]) => any;

        /**
         * like ":unabbrev" but for Insert mode
         */
        iunabbrev: (...args: any[]) => any;

        /**
         * like ":unmap" but for Insert mode
         */
        iunmap: (...args: any[]) => any;

        /**
         * remove menu for Insert mode
         */
        iunme: (...args: any[]) => any;

        /**
         * remove menu for Insert mode
         */
        iunmenu: (...args: any[]) => any;

        /**
         * join lines
         */
        j: (...args: any[]) => any;

        /**
         * join lines
         */
        join: (...args: any[]) => any;

        /**
         * print the jump list
         */
        ju: (...args: any[]) => any;

        /**
         * print the jump list
         */
        jumps: (...args: any[]) => any;

        /**
         * set a mark
         */
        k: (...args: any[]) => any;

        /**
         * following command keeps marks where they are
         */
        kee: (...args: any[]) => any;

        /**
         * following command keeps the alternate file
         */
        keepa: (...args: any[]) => any;

        /**
         * following command keeps the alternate file
         */
        keepalt: (...args: any[]) => any;

        /**
         * following command keeps jumplist and marks
         */
        keepj: (...args: any[]) => any;

        /**
         * following command keeps jumplist and marks
         */
        keepjumps: (...args: any[]) => any;

        /**
         * following command keeps marks where they are
         */
        keepmarks: (...args: any[]) => any;

        /**
         * following command keeps search pattern history
         */
        keepp: (...args: any[]) => any;

        /**
         * following command keeps search pattern history
         */
        keeppatterns: (...args: any[]) => any;

        /**
         * print lines
         */
        l: (...args: any[]) => any;

        /**
         * go to previous entry in location list
         */
        lN: (...args: any[]) => any;

        /**
         * go to previous entry in location list
         */
        lNext: (...args: any[]) => any;

        /**
         * go to last entry in previous file
         */
        lNf: (...args: any[]) => any;

        /**
         * go to last entry in previous file
         */
        lNfile: (...args: any[]) => any;

        /**
         * go to the last file in the argument list
         */
        la: (...args: any[]) => any;

        /**
         * go to location above current line
         */
        lab: (...args: any[]) => any;

        /**
         * go to location above current line
         */
        labove: (...args: any[]) => any;

        /**
         * add locations from expr
         */
        lad: (...args: any[]) => any;

        /**
         * add locations from buffer
         */
        laddb: (...args: any[]) => any;

        /**
         * add locations from buffer
         */
        laddbuffer: (...args: any[]) => any;

        /**
         * add locations from expr
         */
        laddexpr: (...args: any[]) => any;

        /**
         * add locations to current location list
         */
        laddf: (...args: any[]) => any;

        /**
         * add locations to current location list
         */
        laddfile: (...args: any[]) => any;

        /**
         * go to location after current cursor
         */
        laf: (...args: any[]) => any;

        /**
         * go to location after current cursor
         */
        lafter: (...args: any[]) => any;

        /**
         * set the language (locale)
         */
        lan: (...args: any[]) => any;

        /**
         * set the language (locale)
         */
        language: (...args: any[]) => any;

        /**
         * go to the last file in the argument list
         */
        last: (...args: any[]) => any;

        /**
         * go to newer change, redo
         */
        lat: (...args: any[]) => any;

        /**
         * go to newer change, redo
         */
        later: (...args: any[]) => any;

        /**
         * parse locations and jump to first location
         */
        lb: (...args: any[]) => any;

        /**
         * go to location before current cursor
         */
        lbef: (...args: any[]) => any;

        /**
         * go to location before current cursor
         */
        lbefore: (...args: any[]) => any;

        /**
         * go to location below current line
         */
        lbel: (...args: any[]) => any;

        /**
         * go to location below current line
         */
        lbelow: (...args: any[]) => any;

        /**
         * scroll to the bottom of the location window
         */
        lbo: (...args: any[]) => any;

        /**
         * scroll to the bottom of the location window
         */
        lbottom: (...args: any[]) => any;

        /**
         * parse locations and jump to first location
         */
        lbuffer: (...args: any[]) => any;

        /**
         * change directory locally
         */
        lc: (...args: any[]) => any;

        /**
         * change directory locally
         */
        lcd: (...args: any[]) => any;

        /**
         * change directory locally
         */
        lch: (...args: any[]) => any;

        /**
         * change directory locally
         */
        lchdir: (...args: any[]) => any;

        /**
         * close location window
         */
        lcl: (...args: any[]) => any;

        /**
         * close location window
         */
        lclose: (...args: any[]) => any;

        /**
         * execute command in valid location list entries
         */
        ld: (...args: any[]) => any;

        /**
         * execute command in valid location list entries
         */
        ldo: (...args: any[]) => any;

        /**
         * left align lines
         */
        le: (...args: any[]) => any;

        /**
         * left align lines
         */
        left: (...args: any[]) => any;

        /**
         * make split window appear left or above
         */
        lefta: (...args: any[]) => any;

        /**
         * make split window appear left or above
         */
        leftabove: (...args: any[]) => any;

        /**
         * assign a value to a variable or option
         */
        let: (...args: any[]) => any;

        /**
         * read locations from expr and jump to first
         */
        lex: (...args: any[]) => any;

        /**
         * read locations from expr and jump to first
         */
        lexpr: (...args: any[]) => any;

        /**
         * read file with locations and jump to first
         */
        lf: (...args: any[]) => any;

        /**
         * execute command in each file in location list
         */
        lfd: (...args: any[]) => any;

        /**
         * execute command in each file in location list
         */
        lfdo: (...args: any[]) => any;

        /**
         * read file with locations and jump to first
         */
        lfile: (...args: any[]) => any;

        /**
         * go to the specified location, default first one
         */
        lfir: (...args: any[]) => any;

        /**
         * go to the specified location, default first one
         */
        lfirst: (...args: any[]) => any;

        /**
         * read file with locations
         */
        lg: (...args: any[]) => any;

        /**
         * get locations from buffer
         */
        lgetb: (...args: any[]) => any;

        /**
         * get locations from buffer
         */
        lgetbuffer: (...args: any[]) => any;

        /**
         * get locations from expr
         */
        lgete: (...args: any[]) => any;

        /**
         * get locations from expr
         */
        lgetexpr: (...args: any[]) => any;

        /**
         * read file with locations
         */
        lgetfile: (...args: any[]) => any;

        /**
         * run 'grepprg' and jump to first match
         */
        lgr: (...args: any[]) => any;

        /**
         * run 'grepprg' and jump to first match
         */
        lgrep: (...args: any[]) => any;

        /**
         * like :grep, but append to current list
         */
        lgrepa: (...args: any[]) => any;

        /**
         * like :grep, but append to current list
         */
        lgrepadd: (...args: any[]) => any;

        /**
         * like ":helpgrep" but uses location list
         */
        lh: (...args: any[]) => any;

        /**
         * like ":helpgrep" but uses location list
         */
        lhelpgrep: (...args: any[]) => any;

        /**
         * list the location lists
         */
        lhi: (...args: any[]) => any;

        /**
         * list the location lists
         */
        lhistory: (...args: any[]) => any;

        /**
         * print lines
         */
        list: (...args: any[]) => any;

        /**
         * go to specific location
         */
        ll: (...args: any[]) => any;

        /**
         * go to the specified location, default last one
         */
        lla: (...args: any[]) => any;

        /**
         * go to the specified location, default last one
         */
        llast: (...args: any[]) => any;

        /**
         * list all locations
         */
        lli: (...args: any[]) => any;

        /**
         * list all locations
         */
        llist: (...args: any[]) => any;

        /**
         * like ":map!" but includes Lang-Arg mode
         */
        lm: (...args: any[]) => any;

        /**
         * execute external command 'makeprg' and parse
         */
        lmak: (...args: any[]) => any;

        /**
         * execute external command 'makeprg' and parse
         */
        lmake: (...args: any[]) => any;

        /**
         * like ":map!" but includes Lang-Arg mode
         */
        lmap: (...args: any[]) => any;

        /**
         * like ":mapclear!" but includes Lang-Arg mode
         */
        lmapc: (...args: any[]) => any;

        /**
         * like ":mapclear!" but includes Lang-Arg mode
         */
        lmapclear: (...args: any[]) => any;

        /**
         * like ":noremap!" but includes Lang-Arg mode
         */
        ln: (...args: any[]) => any;

        /**
         * go to next location
         */
        lne: (...args: any[]) => any;

        /**
         * go to newer location list
         */
        lnew: (...args: any[]) => any;

        /**
         * go to newer location list
         */
        lnewer: (...args: any[]) => any;

        /**
         * go to next location
         */
        lnext: (...args: any[]) => any;

        /**
         * go to first location in next file
         */
        lnf: (...args: any[]) => any;

        /**
         * go to first location in next file
         */
        lnfile: (...args: any[]) => any;

        /**
         * like ":noremap!" but includes Lang-Arg mode
         */
        lnoremap: (...args: any[]) => any;

        /**
         * load view for current window from a file
         */
        lo: (...args: any[]) => any;

        /**
         * load the following keymaps until EOF
         */
        loadk: (...args: any[]) => any;

        /**
         * load the following keymaps until EOF
         */
        loadkeymap: (...args: any[]) => any;

        /**
         * load view for current window from a file
         */
        loadview: (...args: any[]) => any;

        /**
         * following command keeps marks where they are
         */
        loc: (...args: any[]) => any;

        /**
         * following command keeps marks where they are
         */
        lockmarks: (...args: any[]) => any;

        /**
         * lock variables
         */
        lockv: (...args: any[]) => any;

        /**
         * lock variables
         */
        lockvar: (...args: any[]) => any;

        /**
         * go to older location list
         */
        lol: (...args: any[]) => any;

        /**
         * go to older location list
         */
        lolder: (...args: any[]) => any;

        /**
         * open location window
         */
        lope: (...args: any[]) => any;

        /**
         * open location window
         */
        lopen: (...args: any[]) => any;

        /**
         * go to previous location
         */
        lp: (...args: any[]) => any;

        /**
         * go to last location in previous file
         */
        lpf: (...args: any[]) => any;

        /**
         * go to last location in previous file
         */
        lpfile: (...args: any[]) => any;

        /**
         * go to previous location
         */
        lprevious: (...args: any[]) => any;

        /**
         * go to the specified location, default first one
         */
        lr: (...args: any[]) => any;

        /**
         * go to the specified location, default first one
         */
        lrewind: (...args: any[]) => any;

        /**
         * list all buffers
         */
        ls: (...args: any[]) => any;

        /**
         * jump to tag and add matching tags to the
         */
        lt: (...args: any[]) => any;

        /**
         * jump to tag and add matching tags to the
         */
        ltag: (...args: any[]) => any;

        /**
         * like ":unmap!" but includes Lang-Arg mode
         */
        lu: (...args: any[]) => any;

        /**
         * execute |Lua| command
         */
        lua: (...args: any[]) => any;

        /**
         * execute Lua command for each line
         */
        luad: (...args: any[]) => any;

        /**
         * execute Lua command for each line
         */
        luado: (...args: any[]) => any;

        /**
         * execute |Lua| script file
         */
        luaf: (...args: any[]) => any;

        /**
         * execute |Lua| script file
         */
        luafile: (...args: any[]) => any;

        /**
         * like ":unmap!" but includes Lang-Arg mode
         */
        lunmap: (...args: any[]) => any;

        /**
         * search for pattern in files
         */
        lv: (...args: any[]) => any;

        /**
         * search for pattern in files
         */
        lvimgrep: (...args: any[]) => any;

        /**
         * like :vimgrep, but append to current list
         */
        lvimgrepa: (...args: any[]) => any;

        /**
         * like :vimgrep, but append to current list
         */
        lvimgrepadd: (...args: any[]) => any;

        /**
         * open or close location window
         */
        lw: (...args: any[]) => any;

        /**
         * open or close location window
         */
        lwindow: (...args: any[]) => any;

        /**
         * move lines
         */
        m: (...args: any[]) => any;

        /**
         * set a mark
         */
        ma: (...args: any[]) => any;

        /**
         * execute external command 'makeprg' and parse
         */
        mak: (...args: any[]) => any;

        /**
         * execute external command 'makeprg' and parse
         */
        make: (...args: any[]) => any;

        /**
         * show or enter a mapping
         */
        map: (...args: any[]) => any;

        /**
         * clear all mappings for Normal and Visual mode
         */
        mapc: (...args: any[]) => any;

        /**
         * clear all mappings for Normal and Visual mode
         */
        mapclear: (...args: any[]) => any;

        /**
         * set a mark
         */
        mark: (...args: any[]) => any;

        /**
         * list all marks
         */
        marks: (...args: any[]) => any;

        /**
         * define a match to highlight
         */
        mat: (...args: any[]) => any;

        /**
         * define a match to highlight
         */
        match: (...args: any[]) => any;

        /**
         * enter a new menu item
         */
        me: (...args: any[]) => any;

        /**
         * enter a new menu item
         */
        menu: (...args: any[]) => any;

        /**
         * add a menu translation item
         */
        menut: (...args: any[]) => any;

        /**
         * add a menu translation item
         */
        menutranslate: (...args: any[]) => any;

        /**
         * view previously displayed messages
         */
        mes: (...args: any[]) => any;

        /**
         * view previously displayed messages
         */
        messages: (...args: any[]) => any;

        /**
         * write current mappings and settings to a file
         */
        mk: (...args: any[]) => any;

        /**
         * write current mappings and settings to a file
         */
        mkexrc: (...args: any[]) => any;

        /**
         * write session info to a file
         */
        mks: (...args: any[]) => any;

        /**
         * write session info to a file
         */
        mksession: (...args: any[]) => any;

        /**
         * produce .spl spell file
         */
        mksp: (...args: any[]) => any;

        /**
         * produce .spl spell file
         */
        mkspell: (...args: any[]) => any;

        /**
         * write current mappings and settings to a file
         */
        mkv: (...args: any[]) => any;

        /**
         * write view of current window to a file
         */
        mkvie: (...args: any[]) => any;

        /**
         * write view of current window to a file
         */
        mkview: (...args: any[]) => any;

        /**
         * write current mappings and settings to a file
         */
        mkvimrc: (...args: any[]) => any;

        /**
         * show or change the screen mode
         */
        mod: (...args: any[]) => any;

        /**
         * show or change the screen mode
         */
        mode: (...args: any[]) => any;

        /**
         * move lines
         */
        move: (...args: any[]) => any;

        /**
         * go to next file in the argument list
         */
        n: (...args: any[]) => any;

        /**
         * create a new empty window
         */
        new: (...args: any[]) => any;

        /**
         * go to next file in the argument list
         */
        next: (...args: any[]) => any;

        /**
         * like ":map" but for Normal mode
         */
        nm: (...args: any[]) => any;

        /**
         * like ":map" but for Normal mode
         */
        nmap: (...args: any[]) => any;

        /**
         * clear all mappings for Normal mode
         */
        nmapc: (...args: any[]) => any;

        /**
         * clear all mappings for Normal mode
         */
        nmapclear: (...args: any[]) => any;

        /**
         * add menu for Normal mode
         */
        nme: (...args: any[]) => any;

        /**
         * add menu for Normal mode
         */
        nmenu: (...args: any[]) => any;

        /**
         * like ":noremap" but for Normal mode
         */
        nn: (...args: any[]) => any;

        /**
         * like ":noremap" but for Normal mode
         */
        nnoremap: (...args: any[]) => any;

        /**
         * like ":noremenu" but for Normal mode
         */
        nnoreme: (...args: any[]) => any;

        /**
         * like ":noremenu" but for Normal mode
         */
        nnoremenu: (...args: any[]) => any;

        /**
         * enter a mapping that will not be remapped
         */
        no: (...args: any[]) => any;

        /**
         * following commands don't trigger autocommands
         */
        noa: (...args: any[]) => any;

        /**
         * following commands don't trigger autocommands
         */
        noautocmd: (...args: any[]) => any;

        /**
         * suspend 'hlsearch' highlighting
         */
        noh: (...args: any[]) => any;

        /**
         * suspend 'hlsearch' highlighting
         */
        nohlsearch: (...args: any[]) => any;

        /**
         * enter an abbreviation that will not be
         */
        norea: (...args: any[]) => any;

        /**
         * enter an abbreviation that will not be
         */
        noreabbrev: (...args: any[]) => any;

        /**
         * enter a mapping that will not be remapped
         */
        noremap: (...args: any[]) => any;

        /**
         * enter a menu that will not be remapped
         */
        noreme: (...args: any[]) => any;

        /**
         * enter a menu that will not be remapped
         */
        noremenu: (...args: any[]) => any;

        /**
         * execute Normal mode commands
         */
        norm: (...args: any[]) => any;

        /**
         * execute Normal mode commands
         */
        normal: (...args: any[]) => any;

        /**
         * following commands don't create a swap file
         */
        nos: (...args: any[]) => any;

        /**
         * following commands don't create a swap file
         */
        noswapfile: (...args: any[]) => any;

        /**
         * print lines with line number
         */
        nu: (...args: any[]) => any;

        /**
         * print lines with line number
         */
        number: (...args: any[]) => any;

        /**
         * like ":unmap" but for Normal mode
         */
        nun: (...args: any[]) => any;

        /**
         * like ":unmap" but for Normal mode
         */
        nunmap: (...args: any[]) => any;

        /**
         * remove menu for Normal mode
         */
        nunme: (...args: any[]) => any;

        /**
         * remove menu for Normal mode
         */
        nunmenu: (...args: any[]) => any;

        /**
         * list files that have marks in the |shada| file
         */
        ol: (...args: any[]) => any;

        /**
         * list files that have marks in the |shada| file
         */
        oldfiles: (...args: any[]) => any;

        /**
         * like ":map" but for Operator-pending mode
         */
        om: (...args: any[]) => any;

        /**
         * like ":map" but for Operator-pending mode
         */
        omap: (...args: any[]) => any;

        /**
         * remove all mappings for Operator-pending mode
         */
        omapc: (...args: any[]) => any;

        /**
         * remove all mappings for Operator-pending mode
         */
        omapclear: (...args: any[]) => any;

        /**
         * add menu for Operator-pending mode
         */
        ome: (...args: any[]) => any;

        /**
         * add menu for Operator-pending mode
         */
        omenu: (...args: any[]) => any;

        /**
         * close all windows except the current one
         */
        on: (...args: any[]) => any;

        /**
         * close all windows except the current one
         */
        only: (...args: any[]) => any;

        /**
         * like ":noremap" but for Operator-pending mode
         */
        ono: (...args: any[]) => any;

        /**
         * like ":noremap" but for Operator-pending mode
         */
        onoremap: (...args: any[]) => any;

        /**
         * like ":noremenu" but for Operator-pending mode
         */
        onoreme: (...args: any[]) => any;

        /**
         * like ":noremenu" but for Operator-pending mode
         */
        onoremenu: (...args: any[]) => any;

        /**
         * open the options-window
         */
        opt: (...args: any[]) => any;

        /**
         * open the options-window
         */
        options: (...args: any[]) => any;

        /**
         * like ":unmap" but for Operator-pending mode
         */
        ou: (...args: any[]) => any;

        /**
         * like ":unmap" but for Operator-pending mode
         */
        ounmap: (...args: any[]) => any;

        /**
         * remove menu for Operator-pending mode
         */
        ounme: (...args: any[]) => any;

        /**
         * remove menu for Operator-pending mode
         */
        ounmenu: (...args: any[]) => any;

        /**
         * set new local syntax highlight for this window
         */
        ow: (...args: any[]) => any;

        /**
         * set new local syntax highlight for this window
         */
        ownsyntax: (...args: any[]) => any;

        /**
         * print lines
         */
        p: (...args: any[]) => any;

        /**
         * add a plugin from 'packpath'
         */
        pa: (...args: any[]) => any;

        /**
         * add a plugin from 'packpath'
         */
        packadd: (...args: any[]) => any;

        /**
         * load all packages under 'packpath'
         */
        packl: (...args: any[]) => any;

        /**
         * load all packages under 'packpath'
         */
        packloadall: (...args: any[]) => any;

        /**
         * close preview window
         */
        pc: (...args: any[]) => any;

        /**
         * close preview window
         */
        pclose: (...args: any[]) => any;

        /**
         * execute perl command
         */
        pe: (...args: any[]) => any;

        /**
         * edit file in the preview window
         */
        ped: (...args: any[]) => any;

        /**
         * edit file in the preview window
         */
        pedit: (...args: any[]) => any;

        /**
         * execute perl command
         */
        perl: (...args: any[]) => any;

        /**
         * execute perl command for each line
         */
        perld: (...args: any[]) => any;

        /**
         * execute perl command for each line
         */
        perldo: (...args: any[]) => any;

        /**
         * execute perl script file
         */
        perlf: (...args: any[]) => any;

        /**
         * execute perl script file
         */
        perlfile: (...args: any[]) => any;

        /**
         * jump to older entry in tag stack
         */
        po: (...args: any[]) => any;

        /**
         * jump to older entry in tag stack
         */
        pop: (...args: any[]) => any;

        /**
         * popup a menu by name
         */
        popu: (...args: any[]) => any;

        /**
         * popup a menu by name
         */
        popup: (...args: any[]) => any;

        /**
         * ":pop" in preview window
         */
        pp: (...args: any[]) => any;

        /**
         * ":pop" in preview window
         */
        ppop: (...args: any[]) => any;

        /**
         * write all text to swap file
         */
        pre: (...args: any[]) => any;

        /**
         * write all text to swap file
         */
        preserve: (...args: any[]) => any;

        /**
         * go to previous file in argument list
         */
        prev: (...args: any[]) => any;

        /**
         * go to previous file in argument list
         */
        previous: (...args: any[]) => any;

        /**
         * print lines
         */
        print: (...args: any[]) => any;

        /**
         * profiling functions and scripts
         */
        prof: (...args: any[]) => any;

        /**
         * stop profiling a function or script
         */
        profd: (...args: any[]) => any;

        /**
         * stop profiling a function or script
         */
        profdel: (...args: any[]) => any;

        /**
         * profiling functions and scripts
         */
        profile: (...args: any[]) => any;

        /**
         * like ":ijump" but shows match in preview window
         */
        ps: (...args: any[]) => any;

        /**
         * like ":ijump" but shows match in preview window
         */
        psearch: (...args: any[]) => any;

        /**
         * show tag in preview window
         */
        pt: (...args: any[]) => any;

        /**
         * |:tNext| in preview window
         */
        ptN: (...args: any[]) => any;

        /**
         * |:tNext| in preview window
         */
        ptNext: (...args: any[]) => any;

        /**
         * show tag in preview window
         */
        ptag: (...args: any[]) => any;

        /**
         * |:trewind| in preview window
         */
        ptf: (...args: any[]) => any;

        /**
         * |:trewind| in preview window
         */
        ptfirst: (...args: any[]) => any;

        /**
         * |:tjump| and show tag in preview window
         */
        ptj: (...args: any[]) => any;

        /**
         * |:tjump| and show tag in preview window
         */
        ptjump: (...args: any[]) => any;

        /**
         * |:tlast| in preview window
         */
        ptl: (...args: any[]) => any;

        /**
         * |:tlast| in preview window
         */
        ptlast: (...args: any[]) => any;

        /**
         * |:tnext| in preview window
         */
        ptn: (...args: any[]) => any;

        /**
         * |:tnext| in preview window
         */
        ptnext: (...args: any[]) => any;

        /**
         * |:tprevious| in preview window
         */
        ptp: (...args: any[]) => any;

        /**
         * |:tprevious| in preview window
         */
        ptprevious: (...args: any[]) => any;

        /**
         * |:trewind| in preview window
         */
        ptr: (...args: any[]) => any;

        /**
         * |:trewind| in preview window
         */
        ptrewind: (...args: any[]) => any;

        /**
         * |:tselect| and show tag in preview window
         */
        pts: (...args: any[]) => any;

        /**
         * |:tselect| and show tag in preview window
         */
        ptselect: (...args: any[]) => any;

        /**
         * insert contents of register in the text
         */
        pu: (...args: any[]) => any;

        /**
         * insert contents of register in the text
         */
        put: (...args: any[]) => any;

        /**
         * print current directory
         */
        pw: (...args: any[]) => any;

        /**
         * print current directory
         */
        pwd: (...args: any[]) => any;

        /**
         * execute Python command
         */
        py: (...args: any[]) => any;

        /**
         * execute Python 3 command
         */
        py3: (...args: any[]) => any;

        /**
         * execute Python 3 command for each line
         */
        py3d: (...args: any[]) => any;

        /**
         * execute Python 3 command for each line
         */
        py3do: (...args: any[]) => any;

        /**
         * execute Python 3 script file
         */
        py3f: (...args: any[]) => any;

        /**
         * execute Python 3 script file
         */
        py3file: (...args: any[]) => any;

        /**
         * execute Python command for each line
         */
        pyd: (...args: any[]) => any;

        /**
         * execute Python command for each line
         */
        pydo: (...args: any[]) => any;

        /**
         * execute Python script file
         */
        pyf: (...args: any[]) => any;

        /**
         * execute Python script file
         */
        pyfile: (...args: any[]) => any;

        /**
         * execute Python command
         */
        python: (...args: any[]) => any;

        /**
         * same as :py3
         */
        python3: (...args: any[]) => any;

        /**
         * same as :pyx
         */
        pythonx: (...args: any[]) => any;

        /**
         * execute |python_x| command
         */
        pyx: (...args: any[]) => any;

        /**
         * execute |python_x| command for each line
         */
        pyxd: (...args: any[]) => any;

        /**
         * execute |python_x| command for each line
         */
        pyxdo: (...args: any[]) => any;

        /**
         * execute |python_x| script file
         */
        pyxf: (...args: any[]) => any;

        /**
         * execute |python_x| script file
         */
        pyxfile: (...args: any[]) => any;

        /**
         * quit current window (when one window quit Vim)
         */
        q: (...args: any[]) => any;

        /**
         * quit Vim
         */
        qa: (...args: any[]) => any;

        /**
         * quit Vim
         */
        qall: (...args: any[]) => any;

        /**
         * quit current window (when one window quit Vim)
         */
        quit: (...args: any[]) => any;

        /**
         * quit Vim
         */
        quita: (...args: any[]) => any;

        /**
         * quit Vim
         */
        quitall: (...args: any[]) => any;

        /**
         * read file into the text
         */
        r: (...args: any[]) => any;

        /**
         * read file into the text
         */
        read: (...args: any[]) => any;

        /**
         * recover a file from a swap file
         */
        rec: (...args: any[]) => any;

        /**
         * recover a file from a swap file
         */
        recover: (...args: any[]) => any;

        /**
         * redo one undone change
         */
        red: (...args: any[]) => any;

        /**
         * redirect messages to a file or register
         */
        redi: (...args: any[]) => any;

        /**
         * redirect messages to a file or register
         */
        redir: (...args: any[]) => any;

        /**
         * redo one undone change
         */
        redo: (...args: any[]) => any;

        /**
         * force a redraw of the display
         */
        redr: (...args: any[]) => any;

        /**
         * force a redraw of the display
         */
        redraw: (...args: any[]) => any;

        /**
         * force a redraw of the status line(s) and
         */
        redraws: (...args: any[]) => any;

        /**
         * force a redraw of the status line(s) and
         */
        redrawstatus: (...args: any[]) => any;

        /**
         * force a redraw of the tabline
         */
        redrawt: (...args: any[]) => any;

        /**
         * force a redraw of the tabline
         */
        redrawtabline: (...args: any[]) => any;

        /**
         * display the contents of registers
         */
        reg: (...args: any[]) => any;

        /**
         * display the contents of registers
         */
        registers: (...args: any[]) => any;

        /**
         * change current window height
         */
        res: (...args: any[]) => any;

        /**
         * change current window height
         */
        resize: (...args: any[]) => any;

        /**
         * change tab size
         */
        ret: (...args: any[]) => any;

        /**
         * change tab size
         */
        retab: (...args: any[]) => any;

        /**
         * return from a user function
         */
        retu: (...args: any[]) => any;

        /**
         * return from a user function
         */
        return: (...args: any[]) => any;

        /**
         * go to the first file in the argument list
         */
        rew: (...args: any[]) => any;

        /**
         * go to the first file in the argument list
         */
        rewind: (...args: any[]) => any;

        /**
         * right align text
         */
        ri: (...args: any[]) => any;

        /**
         * right align text
         */
        right: (...args: any[]) => any;

        /**
         * make split window appear right or below
         */
        rightb: (...args: any[]) => any;

        /**
         * make split window appear right or below
         */
        rightbelow: (...args: any[]) => any;

        /**
         * read from |shada| file
         */
        rsh: (...args: any[]) => any;

        /**
         * read from |shada| file
         */
        rshada: (...args: any[]) => any;

        /**
         * source vim scripts in 'runtimepath'
         */
        ru: (...args: any[]) => any;

        /**
         * execute Ruby command
         */
        rub: (...args: any[]) => any;

        /**
         * execute Ruby command
         */
        ruby: (...args: any[]) => any;

        /**
         * execute Ruby command for each line
         */
        rubyd: (...args: any[]) => any;

        /**
         * execute Ruby command for each line
         */
        rubydo: (...args: any[]) => any;

        /**
         * execute Ruby script file
         */
        rubyf: (...args: any[]) => any;

        /**
         * execute Ruby script file
         */
        rubyfile: (...args: any[]) => any;

        /**
         * read undo information from a file
         */
        rund: (...args: any[]) => any;

        /**
         * read undo information from a file
         */
        rundo: (...args: any[]) => any;

        /**
         * source vim scripts in 'runtimepath'
         */
        runtime: (...args: any[]) => any;

        /**
         * find and replace text
         */
        s: (...args: any[]) => any;

        /**
         * split window and go to previous file in
         */
        sN: (...args: any[]) => any;

        /**
         * split window and go to previous file in
         */
        sNext: (...args: any[]) => any;

        /**
         * split window and go to specific file in
         */
        sa: (...args: any[]) => any;

        /**
         * open a window for each file in argument list
         */
        sal: (...args: any[]) => any;

        /**
         * open a window for each file in argument list
         */
        sall: (...args: any[]) => any;

        /**
         * execute a command in the sandbox
         */
        san: (...args: any[]) => any;

        /**
         * execute a command in the sandbox
         */
        sandbox: (...args: any[]) => any;

        /**
         * split window and go to specific file in
         */
        sargument: (...args: any[]) => any;

        /**
         * save file under another name.
         */
        sav: (...args: any[]) => any;

        /**
         * save file under another name.
         */
        saveas: (...args: any[]) => any;

        /**
         * split window and go to specific file in the
         */
        sb: (...args: any[]) => any;

        /**
         * split window and go to previous file in the
         */
        sbN: (...args: any[]) => any;

        /**
         * split window and go to previous file in the
         */
        sbNext: (...args: any[]) => any;

        /**
         * open a window for each file in the buffer list
         */
        sba: (...args: any[]) => any;

        /**
         * open a window for each file in the buffer list
         */
        sball: (...args: any[]) => any;

        /**
         * split window and go to first file in the
         */
        sbf: (...args: any[]) => any;

        /**
         * split window and go to first file in the
         */
        sbfirst: (...args: any[]) => any;

        /**
         * split window and go to last file in buffer
         */
        sbl: (...args: any[]) => any;

        /**
         * split window and go to last file in buffer
         */
        sblast: (...args: any[]) => any;

        /**
         * split window and go to modified file in the
         */
        sbm: (...args: any[]) => any;

        /**
         * split window and go to modified file in the
         */
        sbmodified: (...args: any[]) => any;

        /**
         * split window and go to next file in the buffer
         */
        sbn: (...args: any[]) => any;

        /**
         * split window and go to next file in the buffer
         */
        sbnext: (...args: any[]) => any;

        /**
         * split window and go to previous file in the
         */
        sbp: (...args: any[]) => any;

        /**
         * split window and go to previous file in the
         */
        sbprevious: (...args: any[]) => any;

        /**
         * split window and go to first file in the
         */
        sbr: (...args: any[]) => any;

        /**
         * split window and go to first file in the
         */
        sbrewind: (...args: any[]) => any;

        /**
         * split window and go to specific file in the
         */
        sbuffer: (...args: any[]) => any;

        /**
         * list names of all sourced Vim scripts
         */
        scr: (...args: any[]) => any;

        /**
         * encoding used in sourced Vim script
         */
        scripte: (...args: any[]) => any;

        /**
         * encoding used in sourced Vim script
         */
        scriptencoding: (...args: any[]) => any;

        /**
         * list names of all sourced Vim scripts
         */
        scriptnames: (...args: any[]) => any;

        /**
         * show or set options
         */
        se: (...args: any[]) => any;

        /**
         * show or set options
         */
        set: (...args: any[]) => any;

        /**
         * set 'filetype', unless it was set already
         */
        setf: (...args: any[]) => any;

        /**
         * set 'filetype', unless it was set already
         */
        setfiletype: (...args: any[]) => any;

        /**
         * show global values of options
         */
        setg: (...args: any[]) => any;

        /**
         * show global values of options
         */
        setglobal: (...args: any[]) => any;

        /**
         * show or set options locally
         */
        setl: (...args: any[]) => any;

        /**
         * show or set options locally
         */
        setlocal: (...args: any[]) => any;

        /**
         * split current window and edit file in 'path'
         */
        sf: (...args: any[]) => any;

        /**
         * split current window and edit file in 'path'
         */
        sfind: (...args: any[]) => any;

        /**
         * split window and go to first file in the
         */
        sfir: (...args: any[]) => any;

        /**
         * split window and go to first file in the
         */
        sfirst: (...args: any[]) => any;

        /**
         * manipulate signs
         */
        sig: (...args: any[]) => any;

        /**
         * manipulate signs
         */
        sign: (...args: any[]) => any;

        /**
         * run a command silently
         */
        sil: (...args: any[]) => any;

        /**
         * run a command silently
         */
        silent: (...args: any[]) => any;

        /**
         * do nothing for a few seconds
         */
        sl: (...args: any[]) => any;

        /**
         * split window and go to last file in the
         */
        sla: (...args: any[]) => any;

        /**
         * split window and go to last file in the
         */
        slast: (...args: any[]) => any;

        /**
         * do nothing for a few seconds
         */
        sleep: (...args: any[]) => any;

        /**
         * :substitute with 'magic'
         */
        sm: (...args: any[]) => any;

        /**
         * :substitute with 'magic'
         */
        smagic: (...args: any[]) => any;

        /**
         * like ":map" but for Select mode
         */
        smap: (...args: any[]) => any;

        /**
         * remove all mappings for Select mode
         */
        smapc: (...args: any[]) => any;

        /**
         * remove all mappings for Select mode
         */
        smapclear: (...args: any[]) => any;

        /**
         * add menu for Select mode
         */
        sme: (...args: any[]) => any;

        /**
         * add menu for Select mode
         */
        smenu: (...args: any[]) => any;

        /**
         * split window and go to next file in the
         */
        sn: (...args: any[]) => any;

        /**
         * split window and go to next file in the
         */
        snext: (...args: any[]) => any;

        /**
         * :substitute with 'nomagic'
         */
        sno: (...args: any[]) => any;

        /**
         * :substitute with 'nomagic'
         */
        snomagic: (...args: any[]) => any;

        /**
         * like ":noremap" but for Select mode
         */
        snor: (...args: any[]) => any;

        /**
         * like ":noremap" but for Select mode
         */
        snoremap: (...args: any[]) => any;

        /**
         * like ":noremenu" but for Select mode
         */
        snoreme: (...args: any[]) => any;

        /**
         * like ":noremenu" but for Select mode
         */
        snoremenu: (...args: any[]) => any;

        /**
         * read Vim or Ex commands from a file
         */
        so: (...args: any[]) => any;

        /**
         * sort lines
         */
        sor: (...args: any[]) => any;

        /**
         * sort lines
         */
        sort: (...args: any[]) => any;

        /**
         * read Vim or Ex commands from a file
         */
        source: (...args: any[]) => any;

        /**
         * split current window
         */
        sp: (...args: any[]) => any;

        /**
         * add good word for spelling
         */
        spe: (...args: any[]) => any;

        /**
         * split window and fill with all correct words
         */
        spelld: (...args: any[]) => any;

        /**
         * split window and fill with all correct words
         */
        spelldump: (...args: any[]) => any;

        /**
         * add good word for spelling
         */
        spellgood: (...args: any[]) => any;

        /**
         * show info about loaded spell files
         */
        spelli: (...args: any[]) => any;

        /**
         * show info about loaded spell files
         */
        spellinfo: (...args: any[]) => any;

        /**
         * replace all bad words like last |z=|
         */
        spellr: (...args: any[]) => any;

        /**
         * add rare word for spelling
         */
        spellra: (...args: any[]) => any;

        /**
         * add rare word for spelling
         */
        spellrare: (...args: any[]) => any;

        /**
         * replace all bad words like last |z=|
         */
        spellrepall: (...args: any[]) => any;

        /**
         * remove good or bad word
         */
        spellu: (...args: any[]) => any;

        /**
         * remove good or bad word
         */
        spellundo: (...args: any[]) => any;

        /**
         * add spelling mistake
         */
        spellw: (...args: any[]) => any;

        /**
         * add spelling mistake
         */
        spellwrong: (...args: any[]) => any;

        /**
         * split current window
         */
        split: (...args: any[]) => any;

        /**
         * split window and go to previous file in the
         */
        spr: (...args: any[]) => any;

        /**
         * split window and go to previous file in the
         */
        sprevious: (...args: any[]) => any;

        /**
         * split window and go to first file in the
         */
        sre: (...args: any[]) => any;

        /**
         * split window and go to first file in the
         */
        srewind: (...args: any[]) => any;

        /**
         * suspend the editor or escape to a shell
         */
        st: (...args: any[]) => any;

        /**
         * split window and jump to a tag
         */
        sta: (...args: any[]) => any;

        /**
         * split window and jump to a tag
         */
        stag: (...args: any[]) => any;

        /**
         * start Insert mode
         */
        star: (...args: any[]) => any;

        /**
         * start Virtual Replace mode
         */
        startg: (...args: any[]) => any;

        /**
         * start Virtual Replace mode
         */
        startgreplace: (...args: any[]) => any;

        /**
         * start Insert mode
         */
        startinsert: (...args: any[]) => any;

        /**
         * start Replace mode
         */
        startr: (...args: any[]) => any;

        /**
         * start Replace mode
         */
        startreplace: (...args: any[]) => any;

        /**
         * do ":tjump" and split window
         */
        stj: (...args: any[]) => any;

        /**
         * do ":tjump" and split window
         */
        stjump: (...args: any[]) => any;

        /**
         * suspend the editor or escape to a shell
         */
        stop: (...args: any[]) => any;

        /**
         * stop Insert mode
         */
        stopi: (...args: any[]) => any;

        /**
         * stop Insert mode
         */
        stopinsert: (...args: any[]) => any;

        /**
         * do ":tselect" and split window
         */
        sts: (...args: any[]) => any;

        /**
         * do ":tselect" and split window
         */
        stselect: (...args: any[]) => any;

        /**
         * find and replace text
         */
        substitute: (...args: any[]) => any;

        /**
         * same as ":unhide"
         */
        sun: (...args: any[]) => any;

        /**
         * same as ":unhide"
         */
        sunhide: (...args: any[]) => any;

        /**
         * like ":unmap" but for Select mode
         */
        sunm: (...args: any[]) => any;

        /**
         * like ":unmap" but for Select mode
         */
        sunmap: (...args: any[]) => any;

        /**
         * remove menu for Select mode
         */
        sunme: (...args: any[]) => any;

        /**
         * remove menu for Select mode
         */
        sunmenu: (...args: any[]) => any;

        /**
         * same as ":stop"
         */
        sus: (...args: any[]) => any;

        /**
         * same as ":stop"
         */
        suspend: (...args: any[]) => any;

        /**
         * split window and edit file read-only
         */
        sv: (...args: any[]) => any;

        /**
         * split window and edit file read-only
         */
        sview: (...args: any[]) => any;

        /**
         * show the name of the current swap file
         */
        sw: (...args: any[]) => any;

        /**
         * show the name of the current swap file
         */
        swapname: (...args: any[]) => any;

        /**
         * syntax highlighting
         */
        sy: (...args: any[]) => any;

        /**
         * sync scroll binding
         */
        sync: (...args: any[]) => any;

        /**
         * sync scroll binding
         */
        syncbind: (...args: any[]) => any;

        /**
         * syntax highlighting
         */
        syntax: (...args: any[]) => any;

        /**
         * measure syntax highlighting speed
         */
        synti: (...args: any[]) => any;

        /**
         * measure syntax highlighting speed
         */
        syntime: (...args: any[]) => any;

        /**
         * same as ":copy"
         */
        t: (...args: any[]) => any;

        /**
         * jump to previous matching tag
         */
        tN: (...args: any[]) => any;

        /**
         * jump to previous matching tag
         */
        tNext: (...args: any[]) => any;

        /**
         * jump to tag
         */
        ta: (...args: any[]) => any;

        /**
         * create new tab when opening new window
         */
        tab: (...args: any[]) => any;

        /**
         * go to previous tab page
         */
        tabN: (...args: any[]) => any;

        /**
         * go to previous tab page
         */
        tabNext: (...args: any[]) => any;

        /**
         * close current tab page
         */
        tabc: (...args: any[]) => any;

        /**
         * close current tab page
         */
        tabclose: (...args: any[]) => any;

        /**
         * execute command in each tab page
         */
        tabdo: (...args: any[]) => any;

        /**
         * edit a file in a new tab page
         */
        tabe: (...args: any[]) => any;

        /**
         * edit a file in a new tab page
         */
        tabedit: (...args: any[]) => any;

        /**
         * find file in 'path', edit it in a new tab page
         */
        tabf: (...args: any[]) => any;

        /**
         * find file in 'path', edit it in a new tab page
         */
        tabfind: (...args: any[]) => any;

        /**
         * go to first tab page
         */
        tabfir: (...args: any[]) => any;

        /**
         * go to first tab page
         */
        tabfirst: (...args: any[]) => any;

        /**
         * go to last tab page
         */
        tabl: (...args: any[]) => any;

        /**
         * go to last tab page
         */
        tablast: (...args: any[]) => any;

        /**
         * move tab page to other position
         */
        tabm: (...args: any[]) => any;

        /**
         * move tab page to other position
         */
        tabmove: (...args: any[]) => any;

        /**
         * go to next tab page
         */
        tabn: (...args: any[]) => any;

        /**
         * edit a file in a new tab page
         */
        tabnew: (...args: any[]) => any;

        /**
         * go to next tab page
         */
        tabnext: (...args: any[]) => any;

        /**
         * close all tab pages except the current one
         */
        tabo: (...args: any[]) => any;

        /**
         * close all tab pages except the current one
         */
        tabonly: (...args: any[]) => any;

        /**
         * go to previous tab page
         */
        tabp: (...args: any[]) => any;

        /**
         * go to previous tab page
         */
        tabprevious: (...args: any[]) => any;

        /**
         * go to first tab page
         */
        tabr: (...args: any[]) => any;

        /**
         * go to first tab page
         */
        tabrewind: (...args: any[]) => any;

        /**
         * list the tab pages and what they contain
         */
        tabs: (...args: any[]) => any;

        /**
         * jump to tag
         */
        tag: (...args: any[]) => any;

        /**
         * show the contents of the tag stack
         */
        tags: (...args: any[]) => any;

        /**
         * change directory for tab page
         */
        tc: (...args: any[]) => any;

        /**
         * change directory for tab page
         */
        tcd: (...args: any[]) => any;

        /**
         * change directory for tab page
         */
        tch: (...args: any[]) => any;

        /**
         * change directory for tab page
         */
        tchdir: (...args: any[]) => any;

        /**
         * open a terminal buffer
         */
        te: (...args: any[]) => any;

        /**
         * open a terminal buffer
         */
        terminal: (...args: any[]) => any;

        /**
         * jump to first matching tag
         */
        tf: (...args: any[]) => any;

        /**
         * jump to first matching tag
         */
        tfirst: (...args: any[]) => any;

        /**
         * throw an exception
         */
        th: (...args: any[]) => any;

        /**
         * throw an exception
         */
        throw: (...args: any[]) => any;

        /**
         * like ":tselect", but jump directly when there
         */
        tj: (...args: any[]) => any;

        /**
         * like ":tselect", but jump directly when there
         */
        tjump: (...args: any[]) => any;

        /**
         * jump to last matching tag
         */
        tl: (...args: any[]) => any;

        /**
         * jump to last matching tag
         */
        tlast: (...args: any[]) => any;

        /**
         * add menu for |Terminal-mode|
         */
        tlm: (...args: any[]) => any;

        /**
         * add menu for |Terminal-mode|
         */
        tlmenu: (...args: any[]) => any;

        /**
         * like ":noremenu" but for |Terminal-mode|
         */
        tln: (...args: any[]) => any;

        /**
         * like ":noremenu" but for |Terminal-mode|
         */
        tlnoremenu: (...args: any[]) => any;

        /**
         * remove menu for |Terminal-mode|
         */
        tlu: (...args: any[]) => any;

        /**
         * remove menu for |Terminal-mode|
         */
        tlunmenu: (...args: any[]) => any;

        /**
         * define menu tooltip
         */
        tm: (...args: any[]) => any;

        /**
         * like ":map" but for |Terminal-mode|
         */
        tma: (...args: any[]) => any;

        /**
         * like ":map" but for |Terminal-mode|
         */
        tmap: (...args: any[]) => any;

        /**
         * remove all mappings for |Terminal-mode|
         */
        tmapc: (...args: any[]) => any;

        /**
         * remove all mappings for |Terminal-mode|
         */
        tmapclear: (...args: any[]) => any;

        /**
         * define menu tooltip
         */
        tmenu: (...args: any[]) => any;

        /**
         * jump to next matching tag
         */
        tn: (...args: any[]) => any;

        /**
         * jump to next matching tag
         */
        tnext: (...args: any[]) => any;

        /**
         * like ":noremap" but for |Terminal-mode|
         */
        tno: (...args: any[]) => any;

        /**
         * like ":noremap" but for |Terminal-mode|
         */
        tnoremap: (...args: any[]) => any;

        /**
         * make split window appear at top or far left
         */
        to: (...args: any[]) => any;

        /**
         * make split window appear at top or far left
         */
        topleft: (...args: any[]) => any;

        /**
         * jump to previous matching tag
         */
        tp: (...args: any[]) => any;

        /**
         * jump to previous matching tag
         */
        tprevious: (...args: any[]) => any;

        /**
         * jump to first matching tag
         */
        tr: (...args: any[]) => any;

        /**
         * jump to first matching tag
         */
        trewind: (...args: any[]) => any;

        /**
         * add or remove file from trust database
         */
        trust: (...args: any[]) => any;

        /**
         * execute commands, abort on error or exception
         */
        try: (...args: any[]) => any;

        /**
         * list matching tags and select one
         */
        ts: (...args: any[]) => any;

        /**
         * list matching tags and select one
         */
        tselect: (...args: any[]) => any;

        /**
         * remove menu tooltip
         */
        tu: (...args: any[]) => any;

        /**
         * like ":unmap" but for |Terminal-mode|
         */
        tunma: (...args: any[]) => any;

        /**
         * like ":unmap" but for |Terminal-mode|
         */
        tunmap: (...args: any[]) => any;

        /**
         * remove menu tooltip
         */
        tunmenu: (...args: any[]) => any;

        /**
         * undo last change(s)
         */
        u: (...args: any[]) => any;

        /**
         * remove abbreviation
         */
        una: (...args: any[]) => any;

        /**
         * remove abbreviation
         */
        unabbreviate: (...args: any[]) => any;

        /**
         * undo last change(s)
         */
        undo: (...args: any[]) => any;

        /**
         * join next change with previous undo block
         */
        undoj: (...args: any[]) => any;

        /**
         * join next change with previous undo block
         */
        undojoin: (...args: any[]) => any;

        /**
         * list leafs of the undo tree
         */
        undol: (...args: any[]) => any;

        /**
         * list leafs of the undo tree
         */
        undolist: (...args: any[]) => any;

        /**
         * open a window for each loaded file in the
         */
        unh: (...args: any[]) => any;

        /**
         * open a window for each loaded file in the
         */
        unhide: (...args: any[]) => any;

        /**
         * delete variable
         */
        unl: (...args: any[]) => any;

        /**
         * delete variable
         */
        unlet: (...args: any[]) => any;

        /**
         * unlock variables
         */
        unlo: (...args: any[]) => any;

        /**
         * unlock variables
         */
        unlockvar: (...args: any[]) => any;

        /**
         * remove mapping
         */
        unm: (...args: any[]) => any;

        /**
         * remove mapping
         */
        unmap: (...args: any[]) => any;

        /**
         * remove menu
         */
        unme: (...args: any[]) => any;

        /**
         * remove menu
         */
        unmenu: (...args: any[]) => any;

        /**
         * run a command not silently
         */
        uns: (...args: any[]) => any;

        /**
         * run a command not silently
         */
        unsilent: (...args: any[]) => any;

        /**
         * write buffer if modified
         */
        up: (...args: any[]) => any;

        /**
         * write buffer if modified
         */
        update: (...args: any[]) => any;

        /**
         * execute commands for not matching lines
         */
        v: (...args: any[]) => any;

        /**
         * print version number and other info
         */
        ve: (...args: any[]) => any;

        /**
         * execute command with 'verbose' set
         */
        verb: (...args: any[]) => any;

        /**
         * execute command with 'verbose' set
         */
        verbose: (...args: any[]) => any;

        /**
         * print version number and other info
         */
        version: (...args: any[]) => any;

        /**
         * make following command split vertically
         */
        vert: (...args: any[]) => any;

        /**
         * make following command split vertically
         */
        vertical: (...args: any[]) => any;

        /**
         * execute commands for not matching lines
         */
        vglobal: (...args: any[]) => any;

        /**
         * same as ":edit", but turns off "Ex" mode
         */
        vi: (...args: any[]) => any;

        /**
         * edit a file read-only
         */
        vie: (...args: any[]) => any;

        /**
         * edit a file read-only
         */
        view: (...args: any[]) => any;

        /**
         * search for pattern in files
         */
        vim: (...args: any[]) => any;

        /**
         * search for pattern in files
         */
        vimgrep: (...args: any[]) => any;

        /**
         * like :vimgrep, but append to current list
         */
        vimgrepa: (...args: any[]) => any;

        /**
         * like :vimgrep, but append to current list
         */
        vimgrepadd: (...args: any[]) => any;

        /**
         * same as ":edit", but turns off "Ex" mode
         */
        visual: (...args: any[]) => any;

        /**
         * overview of Normal mode commands
         */
        viu: (...args: any[]) => any;

        /**
         * overview of Normal mode commands
         */
        viusage: (...args: any[]) => any;

        /**
         * like ":map" but for Visual+Select mode
         */
        vm: (...args: any[]) => any;

        /**
         * like ":map" but for Visual+Select mode
         */
        vmap: (...args: any[]) => any;

        /**
         * remove all mappings for Visual+Select mode
         */
        vmapc: (...args: any[]) => any;

        /**
         * remove all mappings for Visual+Select mode
         */
        vmapclear: (...args: any[]) => any;

        /**
         * add menu for Visual+Select mode
         */
        vme: (...args: any[]) => any;

        /**
         * add menu for Visual+Select mode
         */
        vmenu: (...args: any[]) => any;

        /**
         * like ":noremap" but for Visual+Select mode
         */
        vn: (...args: any[]) => any;

        /**
         * create a new empty window, vertically split
         */
        vne: (...args: any[]) => any;

        /**
         * create a new empty window, vertically split
         */
        vnew: (...args: any[]) => any;

        /**
         * like ":noremap" but for Visual+Select mode
         */
        vnoremap: (...args: any[]) => any;

        /**
         * like ":noremenu" but for Visual+Select mode
         */
        vnoreme: (...args: any[]) => any;

        /**
         * like ":noremenu" but for Visual+Select mode
         */
        vnoremenu: (...args: any[]) => any;

        /**
         * split current window vertically
         */
        vs: (...args: any[]) => any;

        /**
         * split current window vertically
         */
        vsplit: (...args: any[]) => any;

        /**
         * like ":unmap" but for Visual+Select mode
         */
        vu: (...args: any[]) => any;

        /**
         * like ":unmap" but for Visual+Select mode
         */
        vunmap: (...args: any[]) => any;

        /**
         * remove menu for Visual+Select mode
         */
        vunme: (...args: any[]) => any;

        /**
         * remove menu for Visual+Select mode
         */
        vunmenu: (...args: any[]) => any;

        /**
         * write to a file
         */
        w: (...args: any[]) => any;

        /**
         * write to a file and go to previous file in
         */
        wN: (...args: any[]) => any;

        /**
         * write to a file and go to previous file in
         */
        wNext: (...args: any[]) => any;

        /**
         * write all (changed) buffers
         */
        wa: (...args: any[]) => any;

        /**
         * write all (changed) buffers
         */
        wall: (...args: any[]) => any;

        /**
         * execute loop for as long as condition met
         */
        wh: (...args: any[]) => any;

        /**
         * execute loop for as long as condition met
         */
        while: (...args: any[]) => any;

        /**
         * get or set window size (obsolete)
         */
        wi: (...args: any[]) => any;

        /**
         * execute a Window (CTRL-W) command
         */
        winc: (...args: any[]) => any;

        /**
         * execute a Window (CTRL-W) command
         */
        wincmd: (...args: any[]) => any;

        /**
         * execute command in each window
         */
        windo: (...args: any[]) => any;

        /**
         * get or set window position
         */
        winp: (...args: any[]) => any;

        /**
         * get or set window position
         */
        winpos: (...args: any[]) => any;

        /**
         * get or set window size (obsolete)
         */
        winsize: (...args: any[]) => any;

        /**
         * write to a file and go to next file in
         */
        wn: (...args: any[]) => any;

        /**
         * write to a file and go to next file in
         */
        wnext: (...args: any[]) => any;

        /**
         * write to a file and go to previous file in
         */
        wp: (...args: any[]) => any;

        /**
         * write to a file and go to previous file in
         */
        wprevious: (...args: any[]) => any;

        /**
         * write to a file and quit window or Vim
         */
        wq: (...args: any[]) => any;

        /**
         * write all changed buffers and quit Vim
         */
        wqa: (...args: any[]) => any;

        /**
         * write all changed buffers and quit Vim
         */
        wqall: (...args: any[]) => any;

        /**
         * write to a file
         */
        write: (...args: any[]) => any;

        /**
         * write to ShaDa file
         */
        wsh: (...args: any[]) => any;

        /**
         * write to ShaDa file
         */
        wshada: (...args: any[]) => any;

        /**
         * write undo information to a file
         */
        wu: (...args: any[]) => any;

        /**
         * write undo information to a file
         */
        wundo: (...args: any[]) => any;

        /**
         * write if buffer changed and close window
         */
        x: (...args: any[]) => any;

        /**
         * same as ":wqall"
         */
        xa: (...args: any[]) => any;

        /**
         * same as ":wqall"
         */
        xall: (...args: any[]) => any;

        /**
         * write if buffer changed and close window
         */
        xit: (...args: any[]) => any;

        /**
         * like ":map" but for Visual mode
         */
        xm: (...args: any[]) => any;

        /**
         * like ":map" but for Visual mode
         */
        xmap: (...args: any[]) => any;

        /**
         * remove all mappings for Visual mode
         */
        xmapc: (...args: any[]) => any;

        /**
         * remove all mappings for Visual mode
         */
        xmapclear: (...args: any[]) => any;

        /**
         * add menu for Visual mode
         */
        xme: (...args: any[]) => any;

        /**
         * add menu for Visual mode
         */
        xmenu: (...args: any[]) => any;

        /**
         * like ":noremap" but for Visual mode
         */
        xn: (...args: any[]) => any;

        /**
         * like ":noremap" but for Visual mode
         */
        xnoremap: (...args: any[]) => any;

        /**
         * like ":noremenu" but for Visual mode
         */
        xnoreme: (...args: any[]) => any;

        /**
         * like ":noremenu" but for Visual mode
         */
        xnoremenu: (...args: any[]) => any;

        /**
         * like ":unmap" but for Visual mode
         */
        xu: (...args: any[]) => any;

        /**
         * like ":unmap" but for Visual mode
         */
        xunmap: (...args: any[]) => any;

        /**
         * remove menu for Visual mode
         */
        xunme: (...args: any[]) => any;

        /**
         * remove menu for Visual mode
         */
        xunmenu: (...args: any[]) => any;

        /**
         * yank lines into a register
         */
        y: (...args: any[]) => any;

        /**
         * yank lines into a register
         */
        yank: (...args: any[]) => any;

        /**
         * print some lines
         */
        z: (...args: any[]) => any;
    }

    export const cmd: cmd & ((value: string | object) => void) & { [key: string]: (...vargs: any[]) => any };

    /** @noSelf **/
    interface fn {

        /**
         * Return the absolute value of {expr}.  When {expr} evaluates to
         * a |Float| abs() returns a |Float|.  When {expr} can be
         * converted to a |Number| abs() returns a |Number|.  Otherwise
         * abs() gives an error message and returns -1.
         * Examples: 
         * ```vim
         *   echo abs(1.456)
         * ```
         *   1.456  >
         *   echo abs(-5.456)
         * <      5.456  
         * ```vim
         *   echo abs(-4)
         * ```
         *   4
         * 
         * Can also be used as a |method|: 
         * ```vim
         *   Compute()->abs()
         * ```
         */
        abs: (expr: number) => number;

        /**
         * Return the arc cosine of {expr} measured in radians, as a
         * |Float| in the range of [0, pi].
         * {expr} must evaluate to a |Float| or a |Number| in the range
         * [-1, 1].
         * Returns NaN if {expr} is outside the range [-1, 1].  Returns
         * 0.0 if {expr} is not a |Float| or a |Number|.
         * Examples: 
         * ```vim
         *   :echo acos(0)
         * ```
         *   1.570796 >
         *   :echo acos(-0.5)
         * <      2.094395
         * 
         * Can also be used as a |method|: 
         * ```vim
         *   Compute()->acos()
         * ```
         */
        acos: (expr: number) => number;

        /**
         * Append the item {expr} to |List| or |Blob| {object}.  Returns
         * the resulting |List| or |Blob|.  Examples: 
         * ```vim
         *   :let alist = add([1, 2, 3], item)
         *   :call add(mylist, "woodstock")
         * ```
         * Note that when {expr} is a |List| it is appended as a single
         * item.  Use |extend()| to concatenate |Lists|.
         * When {object} is a |Blob| then {expr} must be a number.
         * Use |insert()| to add an item at another position.
         * Returns 1 if {object} is not a |List| or a |Blob|.
         * 
         * Can also be used as a |method|: 
         * ```vim
         *   mylist->add(val1)->add(val2)
         * ```
         */
        add: (object: object, expr: any) => any[] | 1;

        /**
         * Bitwise AND on the two arguments.  The arguments are converted
         * to a number.  A List, Dict or Float argument causes an error.
         * Example: 
         * ```vim
         *   :let flag = and(bits, 0x80)
         * ```
         * Can also be used as a |method|: >
         *   :let flag = bits->and(0x80)
         */
        and: (expr: any, expr1: any) => number;

        /**
         * Returns Dictionary of |api-metadata|.
         * 
         * View it in a nice human-readable format: 
         * ```vim
         *        :lua print(vim.inspect(vim.fn.api_info()))
         * ```
         */
        api_info: () => { [key: string]: any };

        /**
         * When {text} is a |List|: Append each item of the |List| as a
         * text line below line {lnum} in the current buffer.
         * Otherwise append {text} as one text line below line {lnum} in
         * the current buffer.
         * Any type of item is accepted and converted to a String.
         * {lnum} can be zero to insert a line before the first one.
         * {lnum} is used like with |getline()|.
         * Returns 1 for failure ({lnum} out of range or out of memory),
         * 0 for success.  Example: 
         * ```vim
         *   :let failed = append(line('$'), "# THE END")
         *   :let failed = append(0, ["Chapter 1", "the beginning"])
         * 
         * ```
         * Can also be used as a |method| after a List: >
         *   mylist->append(lnum)
         */
        append: (lnum: number, text: string) => number;

        /**
         * Like |append()| but append the text in buffer {expr}.
         * 
         * This function works only for loaded buffers. First call
         * |bufload()| if needed.
         * 
         * For the use of {buf}, see |bufname()|.
         * 
         * {lnum} is the line number to append below.  Note that using
         * |line()| would use the current buffer, not the one appending
         * to.  Use "$" to append at the end of the buffer.  Other string
         * values are not supported.
         * 
         * On success 0 is returned, on failure 1 is returned.
         * 
         * If {buf} is not a valid buffer or {lnum} is not valid, an
         * error message is given. Example: 
         * ```vim
         *   :let failed = appendbufline(13, 0, "# THE START")
         * ```
         * Can also be used as a |method| after a List: 
         * ```vim
         *   mylist->appendbufline(buf, lnum)
         * ```
         */
        appendbufline: (buf: number, lnum: number, text: string) => number;

        /**
         * The result is the number of files in the argument list.  See
         * |arglist|.
         * If {winid} is not supplied, the argument list of the current
         * window is used.
         * If {winid} is -1, the global argument list is used.
         * Otherwise {winid} specifies the window of which the argument
         * list is used: either the window number or the window ID.
         * Returns -1 if the {winid} argument is invalid.
         */
        argc: (winid?: number) => number;

        /**
         * The result is the current index in the argument list.  0 is
         *   the first file.  argc() - 1 is the last one.  See |arglist|.
         */
        argidx: () => number;

        /**
         * Return the argument list ID.  This is a number which
         * identifies the argument list being used.  Zero is used for the
         * global argument list.  See |arglist|.
         * Returns -1 if the arguments are invalid.
         * 
         * Without arguments use the current window.
         * With {winnr} only use this window in the current tab page.
         * With {winnr} and {tabnr} use the window in the specified tab
         * page.
         * {winnr} can be the window number or the |window-ID|.
         */
        arglistid: (winnr?: number, tabnr?: number) => number;

        /**
         *   The result is the {nr}th file in the argument list.  See
         *   |arglist|.  "argv(0)" is the first one.  Example: 
         * ```vim
         * :let i = 0
         * :while i < argc()
         * :  let f = escape(fnameescape(argv(i)), '.')
         * :  exe 'amenu Arg.' .. f .. ' :e ' .. f .. '<CR>'
         * :  let i = i + 1
         * :endwhile
         * ```
         *   Without the {nr} argument, or when {nr} is -1, a |List| with
         *   the whole |arglist| is returned.
         * 
         *   The {winid} argument specifies the window ID, see |argc()|.
         *   For the Vim command line arguments see |v:argv|.
         * 
         *   Returns an empty string if {nr}th argument is not present in
         *   the argument list.  Returns an empty List if the {winid}
         *   argument is invalid.
         */
        argv: (nr?: number, winid?: number) => any[] | "";

        /**
         * Return the arc sine of {expr} measured in radians, as a |Float|
         * in the range of [-pi/2, pi/2].
         * {expr} must evaluate to a |Float| or a |Number| in the range
         * [-1, 1].
         * Returns NaN if {expr} is outside the range [-1, 1].  Returns
         * 0.0 if {expr} is not a |Float| or a |Number|.
         * Examples: 
         * ```vim
         *   :echo asin(0.8)
         * ```
         *   0.927295 >
         *   :echo asin(-0.5)
         * <      -0.523599
         * 
         * Can also be used as a |method|: 
         * ```vim
         *   Compute()->asin()
         * ```
         */
        asin: (expr: any) => number;

        /**
         * Number  assert {cmd} causes a beep
         */
        assert_beeps: (cmd: any) => number;

        /**
         * Number  assert {exp} is equal to {act}
         */
        assert_equal: (exp: any, act: any, msg?: any) => number;

        /**
         * Number  assert file contents are equal
         */
        assert_equalfile: (fname_one: any, fname_two: any, msg?: any) => number;

        /**
         * Number  assert {error} is in v:exception
         */
        assert_exception: (error: any, msg?: any) => number;

        /**
         * Number  assert {cmd} fails
         */
        assert_fails: (cmd: any, error?: any) => number;

        /**
         * Number  assert {actual} is false
         */
        assert_false: (actual: any, msg?: any) => number;

        /**
         * Number  assert {actual} is inside the range
         */
        assert_inrange: (lower: any, upper: any, actual: any, msg?: any) => number;

        /**
         * Number  assert {pat} matches {text}
         */
        assert_match: (pat: any, text: string, msg?: any) => number;

        /**
         * Number  assert {cmd} does not cause a beep
         */
        assert_nobeep: (cmd: any) => number;

        /**
         * Number  assert {exp} is not equal {act}
         */
        assert_notequal: (exp: any, act: any, msg?: any) => number;

        /**
         * Number  assert {pat} not matches {text}
         */
        assert_notmatch: (pat: any, text: string, msg?: any) => number;

        /**
         * Number  report a test failure
         */
        assert_report: (msg: any) => number;

        /**
         * Number  assert {actual} is true
         */
        assert_true: (actual: any, msg?: any) => number;

        /**
         * Return the principal value of the arc tangent of {expr}, in
         * the range [-pi/2, +pi/2] radians, as a |Float|.
         * {expr} must evaluate to a |Float| or a |Number|.
         * Returns 0.0 if {expr} is not a |Float| or a |Number|.
         * Examples: 
         * ```vim
         *   :echo atan(100)
         * ```
         *   1.560797 >
         *   :echo atan(-4.01)
         * <      -1.326405
         * 
         * Can also be used as a |method|: 
         * ```vim
         *   Compute()->atan()
         * ```
         */
        atan: (expr: any) => number;

        /**
         * Return the arc tangent of {expr1} / {expr2}, measured in
         * radians, as a |Float| in the range [-pi, pi].
         * {expr1} and {expr2} must evaluate to a |Float| or a |Number|.
         * Returns 0.0 if {expr1} or {expr2} is not a |Float| or a
         * |Number|.
         * Examples: 
         * ```vim
         *   :echo atan2(-1, 1)
         * ```
         *   -0.785398 >
         *   :echo atan2(1, -1)
         * <      2.356194
         * 
         * Can also be used as a |method|: 
         * ```vim
         *   Compute()->atan2(1)
         * ```
         */
        atan2: (expr1: any, expr2: any) => number;

        /**
         * Return a List containing the number value of each byte in Blob
         * {blob}.  Examples: 
         * ```vim
         *   blob2list(0z0102.0304)  returns [1, 2, 3, 4]
         *   blob2list(0z)    returns []
         * ```
         * Returns an empty List on error.  |list2blob()| does the
         * opposite.
         * 
         * Can also be used as a |method|: 
         * ```vim
         *   GetBlob()->blob2list()
         * ```
         */
        blob2list: (blob: any) => any[];

        /**
         * Put up a file requester.  This only works when "has("browse")"
         * returns |TRUE| (only in some GUI versions).
         * The input fields are:
         *     {save}  when |TRUE|, select file to write
         *     {title}  title for the requester
         *     {initdir}  directory to start browsing in
         *     {default}  default file name
         * An empty string is returned when the "Cancel" button is hit,
         * something went wrong, or browsing is not possible.
         */
        browse: (save: any, title: any, initdir: any, _default: any) => string;

        /**
         * Put up a directory requester.  This only works when
         * "has("browse")" returns |TRUE| (only in some GUI versions).
         * On systems where a directory browser is not supported a file
         * browser is used.  In that case: select a file in the directory
         * to be used.
         * The input fields are:
         *     {title}  title for the requester
         *     {initdir}  directory to start browsing in
         * When the "Cancel" button is hit, something went wrong, or
         * browsing is not possible, an empty string is returned.
         */
        browsedir: (title: any, initdir: any) => string;

        /**
         * Add a buffer to the buffer list with name {name} (must be a
         * String).
         * If a buffer for file {name} already exists, return that buffer
         * number.  Otherwise return the buffer number of the newly
         * created buffer.  When {name} is an empty string then a new
         * buffer is always created.
         * The buffer will not have 'buflisted' set and not be loaded
         * yet.  To add some text to the buffer use this: 
         * ```vim
         *   let bufnr = bufadd('someName')
         *   call bufload(bufnr)
         *   call setbufline(bufnr, 1, ['some', 'text'])
         * ```
         * Returns 0 on error.
         * Can also be used as a |method|: 
         * ```vim
         *   let bufnr = 'somename'->bufadd()
         * ```
         */
        bufadd: (name: any) => number;

        /**
         * The result is a Number, which is |TRUE| if a buffer called
         * {buf} exists.
         * If the {buf} argument is a number, buffer numbers are used.
         * Number zero is the alternate buffer for the current window.
         * 
         * If the {buf} argument is a string it must match a buffer name
         * exactly.  The name can be:
         * - Relative to the current directory.
         * - A full path.
         * - The name of a buffer with 'buftype' set to "nofile".
         * - A URL name.
         * Unlisted buffers will be found.
         * Note that help files are listed by their short name in the
         * output of |:buffers|, but bufexists() requires using their
         * long name to be able to find them.
         * bufexists() may report a buffer exists, but to use the name
         * with a |:buffer| command you may need to use |expand()|.  Esp
         * for MS-Windows 8.3 names in the form "c:\DOCUME~1"
         * Use "bufexists(0)" to test for the existence of an alternate
         * file name.
         * 
         * Can also be used as a |method|: 
         * ```vim
         *   let exists = 'somename'->bufexists()
         * ```
         */
        bufexists: (buf: number) => number;

        /**
         * The result is a Number, which is |TRUE| if a buffer called
         * {buf} exists and is listed (has the 'buflisted' option set).
         * The {buf} argument is used like with |bufexists()|.
         * 
         * Can also be used as a |method|: 
         * ```vim
         *   let listed = 'somename'->buflisted()
         * ```
         */
        buflisted: (buf: number) => number;

        /**
         * Ensure the buffer {buf} is loaded.  When the buffer name
         * refers to an existing file then the file is read.  Otherwise
         * the buffer will be empty.  If the buffer was already loaded
         * then there is no change.  If the buffer is not related to a
         * file the no file is read (e.g., when 'buftype' is "nofile").
         * If there is an existing swap file for the file of the buffer,
         * there will be no dialog, the buffer will be loaded anyway.
         * The {buf} argument is used like with |bufexists()|.
         * 
         * Can also be used as a |method|: 
         * ```vim
         *   eval 'somename'->bufload()
         * ```
         */
        bufload: (buf: number) => number;

        /**
         * The result is a Number, which is |TRUE| if a buffer called
         * {buf} exists and is loaded (shown in a window or hidden).
         * The {buf} argument is used like with |bufexists()|.
         * 
         * Can also be used as a |method|: 
         * ```vim
         *   let loaded = 'somename'->bufloaded()
         * ```
         */
        bufloaded: (buf: number) => number;

        /**
         *   The result is the name of a buffer.  Mostly as it is displayed
         *   by the `:ls` command, but not using special names such as
         *   "[No Name]".
         *   If {buf} is omitted the current buffer is used.
         *   If {buf} is a Number, that buffer number's name is given.
         *   Number zero is the alternate buffer for the current window.
         *   If {buf} is a String, it is used as a |file-pattern| to match
         *   with the buffer names.  This is always done like 'magic' is
         *   set and 'cpoptions' is empty.  When there is more than one
         *   match an empty string is returned.
         *   "" or "%" can be used for the current buffer, "#" for the
         *   alternate buffer.
         *   A full match is preferred, otherwise a match at the start, end
         *   or middle of the buffer name is accepted.  If you only want a
         *   full match then put "^" at the start and "$" at the end of the
         *   pattern.
         *   Listed buffers are found first.  If there is a single match
         *   with a listed buffer, that one is returned.  Next unlisted
         *   buffers are searched for.
         *   If the {buf} is a String, but you want to use it as a buffer
         *   number, force it to be a Number by adding zero to it: 
         * ```vim
         *     :echo bufname("3" + 0)
         * ```
         *   Can also be used as a |method|: >
         *     echo bufnr->bufname()
         * 
         * <    If the buffer doesn't exist, or doesn't have a name, an empty
         *   string is returned. 
         * ```vim
         * bufname("#")    alternate buffer name
         * bufname(3)    name of buffer 3
         * bufname("%")    name of current buffer
         * bufname("file2")  name of buffer where "file2" matches.
         * ```
         */
        bufname: (buf?: number) => string;

        /**
         * The result is the number of a buffer, as it is displayed by
         * the `:ls` command.  For the use of {buf}, see |bufname()|
         * above.
         * If the buffer doesn't exist, -1 is returned.  Or, if the
         * {create} argument is present and TRUE, a new, unlisted,
         * buffer is created and its number is returned.
         * bufnr("$") is the last buffer: 
         * ```vim
         *   :let last_buffer = bufnr("$")
         * ```
         * The result is a Number, which is the highest buffer number
         * of existing buffers.  Note that not all buffers with a smaller
         * number necessarily exist, because ":bwipeout" may have removed
         * them.  Use bufexists() to test for the existence of a buffer.
         * 
         * Can also be used as a |method|: 
         * ```vim
         *   echo bufref->bufnr()
         * ```
         */
        bufnr: (buf?: number, create?: any) => number;

        /**
         *   The result is a Number, which is the |window-ID| of the first
         *   window associated with buffer {buf}.  For the use of {buf},
         *   see |bufname()| above.  If buffer {buf} doesn't exist or
         *   there is no such window, -1 is returned.  Example: 
         * ```vim
         * 
         * echo "A window containing buffer 1 is " .. (bufwinid(1))
         * ```
         *   Only deals with the current tab page.  See |win_findbuf()| for
         *   finding more.
         * 
         *   Can also be used as a |method|: 
         * ```vim
         *     FindBuffer()->bufwinid()
         * ```
         */
        bufwinid: (buf: number) => number;

        /**
         *   Like |bufwinid()| but return the window number instead of the
         *   |window-ID|.
         *   If buffer {buf} doesn't exist or there is no such window, -1
         *   is returned.  Example: 
         * ```vim
         * 
         * echo "A window containing buffer 1 is " .. (bufwinnr(1))
         * 
         * ```
         *   The number can be used with |CTRL-W_w| and ":wincmd w"
         *   |:wincmd|.
         * 
         *   Can also be used as a |method|: 
         * ```vim
         *     FindBuffer()->bufwinnr()
         * ```
         */
        bufwinnr: (buf: number) => number;

        /**
         * Return the line number that contains the character at byte
         * count {byte} in the current buffer.  This includes the
         * end-of-line character, depending on the 'fileformat' option
         * for the current buffer.  The first character has byte count
         * one.
         * Also see |line2byte()|, |go| and |:goto|.
         * 
         * Returns -1 if the {byte} value is invalid.
         * 
         * Can also be used as a |method|: 
         * ```vim
         *   GetOffset()->byte2line()
         * ```
         */
        byte2line: (byte: any) => number;

        /**
         * Return byte index of the {nr}th character in the String
         * {expr}.  Use zero for the first character, it then returns
         * zero.
         * If there are no multibyte characters the returned value is
         * equal to {nr}.
         * Composing characters are not counted separately, their byte
         * length is added to the preceding base character.  See
         * |byteidxcomp()| below for counting composing characters
         * separately.
         * Example : 
         * ```vim
         *   echo matchstr(str, ".", byteidx(str, 3))
         * ```
         * will display the fourth character.  Another way to do the
         * same: 
         * ```vim
         *   let s = strpart(str, byteidx(str, 3))
         *   echo strpart(s, 0, byteidx(s, 1))
         * ```
         * Also see |strgetchar()| and |strcharpart()|.
         * 
         * If there are less than {nr} characters -1 is returned.
         * If there are exactly {nr} characters the length of the string
         * in bytes is returned.
         * 
         * Can also be used as a |method|: 
         * ```vim
         *   GetName()->byteidx(idx)
         * ```
         */
        byteidx: (expr: any, nr: number) => number;

        /**
         * Like byteidx(), except that a composing character is counted
         * as a separate character.  Example: 
         * ```vim
         *   let s = 'e' .. nr2char(0x301)
         *   echo byteidx(s, 1)
         *   echo byteidxcomp(s, 1)
         *   echo byteidxcomp(s, 2)
         * ```
         * The first and third echo result in 3 ('e' plus composing
         * character is 3 bytes), the second echo results in 1 ('e' is
         * one byte).
         * 
         * Can also be used as a |method|: 
         * ```vim
         *   GetName()->byteidxcomp(idx)
         * ```
         */
        byteidxcomp: (expr: any, nr: number) => number;

        /**
         * Call function {func} with the items in |List| {arglist} as
         * arguments.
         * {func} can either be a |Funcref| or the name of a function.
         * a:firstline and a:lastline are set to the cursor line.
         * Returns the return value of the called function.
         * {dict} is for functions with the "dict" attribute.  It will be
         * used to set the local variable "self". |Dictionary-function|
         * 
         * Can also be used as a |method|: 
         * ```vim
         *   GetFunc()->call([arg, arg], dict)
         * ```
         */
        call: (func: Function, arglist: any, dict?: { [key: string]: any }) => any;

        /**
         * Return the smallest integral value greater than or equal to
         * {expr} as a |Float| (round up).
         * {expr} must evaluate to a |Float| or a |Number|.
         * Examples: 
         * ```vim
         *   echo ceil(1.456)
         * ```
         *   2.0  >
         *   echo ceil(-5.456)
         * <      -5.0  
         * ```vim
         *   echo ceil(4.0)
         * ```
         *   4.0
         * 
         * Returns 0.0 if {expr} is not a |Float| or a |Number|.
         * 
         * Can also be used as a |method|: 
         * ```vim
         *   Compute()->ceil()
         * ```
         */
        ceil: (expr: any) => number;

        /**
         * Close a channel or a specific stream associated with it.
         * For a job, {stream} can be one of "stdin", "stdout",
         * "stderr" or "rpc" (closes stdin/stdout for a job started
         * with `"rpc":v:true`) If {stream} is omitted, all streams
         * are closed. If the channel is a pty, this will then close the
         * pty master, sending SIGHUP to the job process.
         * For a socket, there is only one stream, and {stream} should be
         * omitted.
         */
        chanclose: (id: any, stream?: any) => number;

        /**
         * Return the number of the most recent change.  This is the same
         * number as what is displayed with |:undolist| and can be used
         * with the |:undo| command.
         * When a change was made it is the number of that change.  After
         * redo it is the number of the redone change.  After undo it is
         * one less than the number of the undone change.
         * Returns 0 if the undo list is empty.
         */
        changenr: () => number;

        /**
         * Send data to channel {id}. For a job, it writes it to the
         * stdin of the process. For the stdio channel |channel-stdio|,
         * it writes to Nvim's stdout.  Returns the number of bytes
         * written if the write succeeded, 0 otherwise.
         * See |channel-bytes| for more information.
         * 
         * {data} may be a string, string convertible, |Blob|, or a list.
         * If {data} is a list, the items will be joined by newlines; any
         * newlines in an item will be sent as NUL. To send a final
         * newline, include a final empty string. Example: 
         * ```vim
         *   :call chansend(id, ["abc", "123\n456", ""])
         * ```
         * will send "abcNL>123NUL>456NL>".
         * 
         * chansend() writes raw data, not RPC messages.  If the channel
         * was created with `"rpc":v:true` then the channel expects RPC
         * messages, use |rpcnotify()| and |rpcrequest()| instead.
         */
        chansend: (id: any, data: any) => number;

        /**
         * Return Number value of the first char in {string}.
         * Examples: 
         * ```vim
         *   char2nr(" ")    returns 32
         *   char2nr("ABC")    returns 65
         *   char2nr("á")    returns 225
         *   char2nr("á"[0])    returns 195
         *   char2nr("\<M-x>")  returns 128
         * ```
         * Non-ASCII characters are always treated as UTF-8 characters.
         * {utf8} is ignored, it exists only for backwards-compatibility.
         * A combining character is a separate character.
         * |nr2char()| does the opposite.
         * 
         * Returns 0 if {string} is not a |String|.
         * 
         * Can also be used as a |method|: 
         * ```vim
         *   GetChar()->char2nr()
         * ```
         */
        char2nr: (string: string, utf8?: any) => number;

        /**
         * Return the character class of the first character in {string}.
         * The character class is one of:
         *   0  blank
         *   1  punctuation
         *   2  word character
         *   3  emoji
         *   other  specific Unicode class
         * The class is used in patterns and word motions.
         * Returns 0 if {string} is not a |String|.
         */
        charclass: (string: string) => number;

        /**
         * Same as |col()| but returns the character index of the column
         * position given with {expr} instead of the byte position.
         * 
         * Example:
         * With the cursor on '세' in line 5 with text "여보세요": 
         * ```vim
         *   charcol('.')    returns 3
         *   col('.')    returns 7
         * 
         * ```
         * Can also be used as a |method|: >
         *   GetPos()->col()
         * <
         */
        charcol: (expr: string | number, winid?: number) => number;

        /**
         * Return the character index of the byte at {idx} in {string}.
         * The index of the first character is zero.
         * If there are no multibyte characters the returned value is
         * equal to {idx}.
         * When {countcc} is omitted or |FALSE|, then composing characters
         * are not counted separately, their byte length is
         * added to the preceding base character.
         * When {countcc} is |TRUE|, then composing characters are
         * counted as separate characters.
         * Returns -1 if the arguments are invalid or if {idx} is greater
         * than the index of the last byte in {string}.  An error is
         * given if the first argument is not a string, the second
         * argument is not a number or when the third argument is present
         * and is not zero or one.
         * See |byteidx()| and |byteidxcomp()| for getting the byte index
         * from the character index.
         * Examples: 
         * ```vim
         *   echo charidx('áb́ć', 3)    returns 1
         *   echo charidx('áb́ć', 6, 1)  returns 4
         *   echo charidx('áb́ć', 16)    returns -1
         * ```
         * Can also be used as a |method|: 
         * ```vim
         *   GetName()->charidx(idx)
         * ```
         */
        charidx: (string: string, idx: any, countcc?: any) => number;

        /**
         * Change the current working directory to {dir}.  The scope of
         * the directory change depends on the directory of the current
         * window:
         *   - If the current window has a window-local directory
         *     (|:lcd|), then changes the window local directory.
         *   - Otherwise, if the current tabpage has a local
         *     directory (|:tcd|) then changes the tabpage local
         *     directory.
         *   - Otherwise, changes the global directory.
         * {dir} must be a String.
         * If successful, returns the previous working directory.  Pass
         * this to another chdir() to restore the directory.
         * On failure, returns an empty string.
         * 
         * Example: 
         * ```vim
         *   let save_dir = chdir(newdir)
         *   if save_dir != ""
         *      " ... do some work
         *      call chdir(save_dir)
         *   endif
         * 
         * ```
         * Can also be used as a |method|: >
         *   GetDir()->chdir()
         * <
         */
        chdir: (dir: any) => string;

        /**
         * Get the amount of indent for line {lnum} according the C
         * indenting rules, as with 'cindent'.
         * The indent is counted in spaces, the value of 'tabstop' is
         * relevant.  {lnum} is used just like in |getline()|.
         * When {lnum} is invalid -1 is returned.
         * See |C-indenting|.
         * 
         * Can also be used as a |method|: 
         * ```vim
         *   GetLnum()->cindent()
         * ```
         */
        cindent: (lnum: number) => number;

        /**
         * Clears all matches previously defined for the current window
         * by |matchadd()| and the |:match| commands.
         * If {win} is specified, use the window with this number or
         * window ID instead of the current window.
         * 
         * Can also be used as a |method|: 
         * ```vim
         *   GetWin()->clearmatches()
         * ```
         */
        clearmatches: (win?: number) => undefined;

        /**
         * The result is a Number, which is the byte index of the column
         * position given with {expr}.  The accepted positions are:
         *     .      the cursor position
         *     $      the end of the cursor line (the result is the
         *       number of bytes in the cursor line plus one)
         *     'x      position of mark x (if the mark is not set, 0 is
         *       returned)
         *     v       In Visual mode: the start of the Visual area (the
         *       cursor is the end).  When not in Visual mode
         *       returns the cursor position.  Differs from |'<| in
         *       that it's updated right away.
         * Additionally {expr} can be [lnum, col]: a |List| with the line
         * and column number. Most useful when the column is "$", to get
         * the last column of a specific line.  When "lnum" or "col" is
         * out of range then col() returns zero.
         * With the optional {winid} argument the values are obtained for
         * that window instead of the current window.
         * To get the line number use |line()|.  To get both use
         * |getpos()|.
         * For the screen column position use |virtcol()|.  For the
         * character position use |charcol()|.
         * Note that only marks in the current file can be used.
         * Examples: 
         * ```vim
         *   col(".")    column of cursor
         *   col("$")    length of cursor line plus one
         *   col("'t")    column of mark t
         *   col("'" .. markname)  column of mark markname
         * ```
         * The first column is 1.  Returns 0 if {expr} is invalid or when
         * the window with ID {winid} is not found.
         * For an uppercase mark the column may actually be in another
         * buffer.
         * For the cursor position, when 'virtualedit' is active, the
         * column is one higher if the cursor is after the end of the
         * line.  Also, when using a <Cmd> mapping the cursor isn't
         * moved, this can be used to obtain the column in Insert mode: 
         * ```vim
         *   :imap <F2> <Cmd>echo col(".").."\n"<CR>
         * 
         * ```
         * Can also be used as a |method|: >
         *   GetPos()->col()
         * <
         */
        col: (expr: string | number, winid?: number) => number;

        /**
         *   Set the matches for Insert mode completion.
         *   Can only be used in Insert mode.  You need to use a mapping
         *   with CTRL-R = (see |i_CTRL-R|).  It does not work after CTRL-O
         *   or with an expression mapping.
         *   {startcol} is the byte offset in the line where the completed
         *   text start.  The text up to the cursor is the original text
         *   that will be replaced by the matches.  Use col('.') for an
         *   empty string.  "col('.') - 1" will replace one character by a
         *   match.
         *   {matches} must be a |List|.  Each |List| item is one match.
         *   See |complete-items| for the kind of items that are possible.
         *   "longest" in 'completeopt' is ignored.
         *   Note that the after calling this function you need to avoid
         *   inserting anything that would cause completion to stop.
         *   The match can be selected with CTRL-N and CTRL-P as usual with
         *   Insert mode completion.  The popup menu will appear if
         *   specified, see |ins-completion-menu|.
         *   Example: 
         * ```vim
         * inoremap <F5> <C-R>=ListMonths()<CR>
         * 
         * func! ListMonths()
         *   call complete(col('.'), ['January', 'February', 'March',
         *   \ 'April', 'May', 'June', 'July', 'August', 'September',
         *   \ 'October', 'November', 'December'])
         *   return ''
         * endfunc
         * ```
         *   This isn't very useful, but it shows how it works.  Note that
         *   an empty string is returned to avoid a zero being inserted.
         * 
         *   Can also be used as a |method|, the base is passed as the
         *   second argument: 
         * ```vim
         *     GetMatches()->complete(col('.'))
         * ```
         */
        complete: (startcol: any, matches: any) => undefined;

        /**
         * Add {expr} to the list of matches.  Only to be used by the
         * function specified with the 'completefunc' option.
         * Returns 0 for failure (empty string or out of memory),
         * 1 when the match was added, 2 when the match was already in
         * the list.
         * See |complete-functions| for an explanation of {expr}.  It is
         * the same as one item in the list that 'omnifunc' would return.
         * 
         * Can also be used as a |method|: 
         * ```vim
         *   GetMoreMatches()->complete_add()
         * ```
         */
        complete_add: (expr: any) => number;

        /**
         * Check for a key typed while looking for completion matches.
         * This is to be used when looking for matches takes some time.
         * Returns |TRUE| when searching for matches is to be aborted,
         * zero otherwise.
         * Only to be used by the function specified with the
         * 'completefunc' option.
         */
        complete_check: () => number;

        /**
         * Returns a |Dictionary| with information about Insert mode
         * completion.  See |ins-completion|.
         * The items are:
         *    mode    Current completion mode name string.
         *     See |complete_info_mode| for the values.
         *    pum_visible  |TRUE| if popup menu is visible.
         *     See |pumvisible()|.
         *    items  List of completion matches.  Each item is a
         *     dictionary containing the entries "word",
         *     "abbr", "menu", "kind", "info" and "user_data".
         *     See |complete-items|.
         *    selected  Selected item index.  First index is zero.
         *     Index is -1 if no item is selected (showing
         *     typed text only, or the last completion after
         *     no item is selected when using the <Up> or
         *     <Down> keys)
         *    inserted  Inserted string. [NOT IMPLEMENTED YET]
         * 
         * 
         * mode values are:
         *    ""         Not in completion mode
         *    "keyword"       Keyword completion |i_CTRL-X_CTRL-N|
         *    "ctrl_x"       Just pressed CTRL-X |i_CTRL-X|
         *    "scroll"       Scrolling with |i_CTRL-X_CTRL-E| or
         *          |i_CTRL-X_CTRL-Y|
         *    "whole_line"       Whole lines |i_CTRL-X_CTRL-L|
         *    "files"       File names |i_CTRL-X_CTRL-F|
         *    "tags"       Tags |i_CTRL-X_CTRL-]|
         *    "path_defines"    Definition completion |i_CTRL-X_CTRL-D|
         *    "path_patterns"   Include completion |i_CTRL-X_CTRL-I|
         *    "dictionary"       Dictionary |i_CTRL-X_CTRL-K|
         *    "thesaurus"       Thesaurus |i_CTRL-X_CTRL-T|
         *    "cmdline"       Vim Command line |i_CTRL-X_CTRL-V|
         *    "function"       User defined completion |i_CTRL-X_CTRL-U|
         *    "omni"       Omni completion |i_CTRL-X_CTRL-O|
         *    "spell"       Spelling suggestions |i_CTRL-X_s|
         *    "eval"       |complete()| completion
         *    "unknown"       Other internal modes
         * 
         * If the optional {what} list argument is supplied, then only
         * the items listed in {what} are returned.  Unsupported items in
         * {what} are silently ignored.
         * 
         * To get the position and size of the popup menu, see
         * |pum_getpos()|. It's also available in |v:event| during the
         * |CompleteChanged| event.
         * 
         * Returns an empty |Dictionary| on error.
         * 
         * Examples: 
         * ```vim
         *   " Get all items
         *   call complete_info()
         *   " Get only 'mode'
         *   call complete_info(['mode'])
         *   " Get only 'mode' and 'pum_visible'
         *   call complete_info(['mode', 'pum_visible'])
         * 
         * ```
         * Can also be used as a |method|: >
         *   GetItems()->complete_info()
         * <
         */
        complete_info: (what?: any) => { [key: string]: any };

        /**
         * confirm() offers the user a dialog, from which a choice can be
         * made.  It returns the number of the choice.  For the first
         * choice this is 1.
         * 
         * {msg} is displayed in a dialog with {choices} as the
         * alternatives.  When {choices} is missing or empty, "&OK" is
         * used (and translated).
         * {msg} is a String, use '\n' to include a newline.  Only on
         * some systems the string is wrapped when it doesn't fit.
         * 
         * {choices} is a String, with the individual choices separated
         * by '\n', e.g. 
         * ```vim
         *   confirm("Save changes?", "&Yes\n&No\n&Cancel")
         * ```
         * The letter after the '&' is the shortcut key for that choice.
         * Thus you can type 'c' to select "Cancel".  The shortcut does
         * not need to be the first letter: 
         * ```vim
         *   confirm("file has been modified", "&Save\nSave &All")
         * ```
         * For the console, the first letter of each choice is used as
         * the default shortcut key.  Case is ignored.
         * 
         * The optional {type} String argument gives the type of dialog.
         * It can be one of these values: "Error", "Question", "Info",
         * "Warning" or "Generic".  Only the first character is relevant.
         * When {type} is omitted, "Generic" is used.
         * 
         * The optional {type} argument gives the type of dialog.  This
         * is only used for the icon of the Win32 GUI.  It can be one of
         * these values: "Error", "Question", "Info", "Warning" or
         * "Generic".  Only the first character is relevant.
         * When {type} is omitted, "Generic" is used.
         * 
         * If the user aborts the dialog by pressing <Esc>, CTRL-C,
         * or another valid interrupt key, confirm() returns 0.
         * 
         * An example: 
         * ```vim
         *    let choice = confirm("What do you want?",
         *       \ "&Apples\n&Oranges\n&Bananas", 2)
         *    if choice == 0
         *   echo "make up your mind!"
         *    elseif choice == 3
         *   echo "tasteful"
         *    else
         *   echo "I prefer bananas myself."
         *    endif
         * ```
         * In a GUI dialog, buttons are used.  The layout of the buttons
         * depends on the 'v' flag in 'guioptions'.  If it is included,
         * the buttons are always put vertically.  Otherwise,  confirm()
         * tries to put the buttons in one horizontal line.  If they
         * don't fit, a vertical layout is used anyway.  For some systems
         * the horizontal layout is always used.
         * 
         * Can also be used as a |method|in: 
         * ```vim
         *   BuildMessage()->confirm("&Yes\n&No")
         * ```
         */
        confirm: (msg: any, choices?: any, _default?: any, type?: any) => number;

        /**
         * Make a copy of {expr}.  For Numbers and Strings this isn't
         *   different from using {expr} directly.
         *   When {expr} is a |List| a shallow copy is created.  This means
         *   that the original |List| can be changed without changing the
         *   copy, and vice versa.  But the items are identical, thus
         *   changing an item changes the contents of both |Lists|.
         *   A |Dictionary| is copied in a similar way as a |List|.
         *   Also see |deepcopy()|.
         *   Can also be used as a |method|: 
         * ```vim
         *     mylist->copy()
         * ```
         */
        copy: (expr: any) => any;

        /**
         * Return the cosine of {expr}, measured in radians, as a |Float|.
         * {expr} must evaluate to a |Float| or a |Number|.
         * Returns 0.0 if {expr} is not a |Float| or a |Number|.
         * Examples: 
         * ```vim
         *   :echo cos(100)
         * ```
         *   0.862319 >
         *   :echo cos(-4.01)
         * <      -0.646043
         * 
         * Can also be used as a |method|: 
         * ```vim
         *   Compute()->cos()
         * ```
         */
        cos: (expr: any) => number;

        /**
         * Return the hyperbolic cosine of {expr} as a |Float| in the range
         * [1, inf].
         * {expr} must evaluate to a |Float| or a |Number|.
         * Returns 0.0 if {expr} is not a |Float| or a |Number|.
         * Examples: 
         * ```vim
         *   :echo cosh(0.5)
         * ```
         *   1.127626 >
         *   :echo cosh(-0.5)
         * <      -1.127626
         * 
         * Can also be used as a |method|: 
         * ```vim
         *   Compute()->cosh()
         * ```
         */
        cosh: (expr: any) => number;

        /**
         * Return the number of times an item with value {expr} appears
         * in |String|, |List| or |Dictionary| {comp}.
         * 
         * If {start} is given then start with the item with this index.
         * {start} can only be used with a |List|.
         * 
         * When {ic} is given and it's |TRUE| then case is ignored.
         * 
         * When {comp} is a string then the number of not overlapping
         * occurrences of {expr} is returned. Zero is returned when
         * {expr} is an empty string.
         * 
         * Can also be used as a |method|: 
         * ```vim
         *   mylist->count(val)
         * ```
         */
        count: (comp: any, expr: any, ic?: any, start?: number) => number;

        /**
         * Returns a |Dictionary| representing the |context| at {index}
         * from the top of the |context-stack| (see |context-dict|).
         * If {index} is not given, it is assumed to be 0 (i.e.: top).
         */
        ctxget: (index?: number) => { [key: string]: any };

        /**
         * Pops and restores the |context| at the top of the
         * |context-stack|.
         */
        ctxpop: () => undefined;

        /**
         * Pushes the current editor state (|context|) on the
         * |context-stack|.
         * If {types} is given and is a |List| of |String|s, it specifies
         * which |context-types| to include in the pushed context.
         * Otherwise, all context types are included.
         */
        ctxpush: (types?: any) => undefined;

        /**
         * Sets the |context| at {index} from the top of the
         * |context-stack| to that represented by {context}.
         * {context} is a Dictionary with context data (|context-dict|).
         * If {index} is not given, it is assumed to be 0 (i.e.: top).
         */
        ctxset: (context: any, index?: number) => undefined;

        /**
         * Returns the size of the |context-stack|.
         */
        ctxsize: () => number;

        /**
         * Positions the cursor at the column (byte count) {col} in the
         * line {lnum}.  The first column is one.
         * 
         * When there is one argument {list} this is used as a |List|
         * with two, three or four item:
         *   [{lnum}, {col}]
         *   [{lnum}, {col}, {off}]
         *   [{lnum}, {col}, {off}, {curswant}]
         * This is like the return value of |getpos()| or |getcurpos()|,
         * but without the first item.
         * 
         * To position the cursor using the character count, use
         * |setcursorcharpos()|.
         * 
         * Does not change the jumplist.
         * {lnum} is used like with |getline()|, except that if {lnum} is
         * zero, the cursor will stay in the current line.
         * If {lnum} is greater than the number of lines in the buffer,
         * the cursor will be positioned at the last line in the buffer.
         * If {col} is greater than the number of bytes in the line,
         * the cursor will be positioned at the last character in the
         * line.
         * If {col} is zero, the cursor will stay in the current column.
         * If {curswant} is given it is used to set the preferred column
         * for vertical movement.  Otherwise {col} is used.
         * 
         * When 'virtualedit' is used {off} specifies the offset in
         * screen columns from the start of the character.  E.g., a
         * position within a <Tab> or after the last character.
         * Returns 0 when the position could be set, -1 otherwise.
         * 
         * Can also be used as a |method|: 
         * ```vim
         *   GetCursorPos()->cursor()
         * ```
         */
        cursor: (list: any[]) => number;

        /**
         * Specifically used to interrupt a program being debugged.  It
         * will cause process {pid} to get a SIGTRAP.  Behavior for other
         * processes is undefined. See |terminal-debug|.
         * (Sends a SIGINT to a process {pid} other than MS-Windows)
         * 
         * Returns |TRUE| if successfully interrupted the program.
         * Otherwise returns |FALSE|.
         * 
         * Can also be used as a |method|: 
         * ```vim
         *   GetPid()->debugbreak()
         * ```
         */
        debugbreak: (pid: any) => number;

        /**
         * Make a copy of {expr}.  For Numbers and Strings this isn't
         * different from using {expr} directly.
         * When {expr} is a |List| a full copy is created.  This means
         * that the original |List| can be changed without changing the
         * copy, and vice versa.  When an item is a |List|, a copy for it
         * is made, recursively.  Thus changing an item in the copy does
         * not change the contents of the original |List|.
         * 
         * When {noref} is omitted or zero a contained |List| or
         * |Dictionary| is only copied once.  All references point to
         * this single copy.  With {noref} set to 1 every occurrence of a
         * |List| or |Dictionary| results in a new copy.  This also means
         * that a cyclic reference causes deepcopy() to fail.
         * 
         * Nesting is possible up to 100 levels.  When there is an item
         * that refers back to a higher level making a deep copy with
         * {noref} set to 1 will fail.
         * Also see |copy()|.
         * 
         * Can also be used as a |method|: 
         * ```vim
         *   GetObject()->deepcopy()
         * ```
         */
        deepcopy: (expr: any, noref?: any) => any;

        /**
         * Without {flags} or with {flags} empty: Deletes the file by the
         * name {fname}.
         * 
         * This also works when {fname} is a symbolic link.  The symbolic
         * link itself is deleted, not what it points to.
         * 
         * When {flags} is "d": Deletes the directory by the name
         * {fname}.  This fails when directory {fname} is not empty.
         * 
         * When {flags} is "rf": Deletes the directory by the name
         * {fname} and everything in it, recursively.  BE CAREFUL!
         * Note: on MS-Windows it is not possible to delete a directory
         * that is being used.
         * 
         * The result is a Number, which is 0/false if the delete
         * operation was successful and -1/true when the deletion failed
         * or partly failed.
         * 
         * Can also be used as a |method|: 
         * ```vim
         *   GetName()->delete()
         * ```
         */
        delete: (fname: any, flags?: any) => number;

        /**
         * Delete lines {first} to {last} (inclusive) from buffer {buf}.
         * If {last} is omitted then delete line {first} only.
         * On success 0 is returned, on failure 1 is returned.
         * 
         * This function works only for loaded buffers. First call
         * |bufload()| if needed.
         * 
         * For the use of {buf}, see |bufname()| above.
         * 
         * {first} and {last} are used like with |getline()|. Note that
         * when using |line()| this refers to the current buffer. Use "$"
         * to refer to the last line in buffer {buf}.
         * 
         * Can also be used as a |method|: 
         * ```vim
         *   GetBuffer()->deletebufline(1)
         * ```
         */
        deletebufline: (buf: number, first: any, last?: any) => number;

        /**
         * Adds a watcher to a dictionary. A dictionary watcher is
         * identified by three components:
         * 
         * - A dictionary({dict});
         * - A key pattern({pattern}).
         * - A function({callback}).
         * 
         * After this is called, every change on {dict} and on keys
         * matching {pattern} will result in {callback} being invoked.
         * 
         * For example, to watch all global variables: 
         * ```vim
         *   silent! call dictwatcherdel(g:, '*', 'OnDictChanged')
         *   function! OnDictChanged(d,k,z)
         *     echomsg string(a:k) string(a:z)
         *   endfunction
         *   call dictwatcheradd(g:, '*', 'OnDictChanged')
         * ```
         * For now {pattern} only accepts very simple patterns that can
         * contain a "*" at the end of the string, in which case it will
         * match every key that begins with the substring before the "*".
         * That means if "*" is not the last character of {pattern}, only
         * keys that are exactly equal as {pattern} will be matched.
         * 
         * The {callback} receives three arguments:
         * 
         * - The dictionary being watched.
         * - The key which changed.
         * - A dictionary containing the new and old values for the key.
         * 
         * The type of change can be determined by examining the keys
         * present on the third argument:
         * 
         * - If contains both `old` and `new`, the key was updated.
         * - If it contains only `new`, the key was added.
         * - If it contains only `old`, the key was deleted.
         * 
         * This function can be used by plugins to implement options with
         * validation and parsing logic.
         */
        dictwatcheradd: (dict: { [key: string]: any }, pattern: any, callback: Function) => any;

        /**
         * Removes a watcher added  with |dictwatcheradd()|. All three
         * arguments must match the ones passed to |dictwatcheradd()| in
         * order for the watcher to be successfully deleted.
         */
        dictwatcherdel: (dict: { [key: string]: any }, pattern: any, callback: Function) => any;

        /**
         * Returns |TRUE| when autocommands are being executed and the
         *   FileType event has been triggered at least once.  Can be used
         *   to avoid triggering the FileType event again in the scripts
         *   that detect the file type. |FileType|
         *   Returns |FALSE| when `:setf FALLBACK` was used.
         *   When editing another file, the counter is reset, thus this
         *   really checks if the FileType event has been triggered for the
         *   current buffer.  This allows an autocommand that starts
         *   editing another buffer to set 'filetype' and load a syntax
         *   file.
         */
        did_filetype: () => number;

        /**
         * Returns the number of filler lines above line {lnum}.
         * These are the lines that were inserted at this point in
         * another diff'ed window.  These filler lines are shown in the
         * display but don't exist in the buffer.
         * {lnum} is used like with |getline()|.  Thus "." is the current
         * line, "'m" mark m, etc.
         * Returns 0 if the current window is not in diff mode.
         * 
         * Can also be used as a |method|: 
         * ```vim
         *   GetLnum()->diff_filler()
         * ```
         */
        diff_filler: (lnum: number) => number;

        /**
         * Returns the highlight ID for diff mode at line {lnum} column
         * {col} (byte index).  When the current line does not have a
         * diff change zero is returned.
         * {lnum} is used like with |getline()|.  Thus "." is the current
         * line, "'m" mark m, etc.
         * {col} is 1 for the leftmost column, {lnum} is 1 for the first
         * line.
         * The highlight ID can be used with |synIDattr()| to obtain
         * syntax information about the highlighting.
         * 
         * Can also be used as a |method|: 
         * ```vim
         *   GetLnum()->diff_hlID(col)
         * ```
         */
        diff_hlID: (lnum: number, col: number) => number;

        /**
         * Return the digraph of {chars}.  This should be a string with
         * exactly two characters.  If {chars} are not just two
         * characters, or the digraph of {chars} does not exist, an error
         * is given and an empty string is returned.
         * 
         * Also see |digraph_getlist()|.
         * 
         * Examples: 
         * ```vim
         * " Get a built-in digraph
         * :echo digraph_get('00')    " Returns '∞'
         * 
         * " Get a user-defined digraph
         * :call digraph_set('aa', 'あ')
         * :echo digraph_get('aa')    " Returns 'あ'
         * ```
         * Can also be used as a |method|: 
         * ```vim
         *   GetChars()->digraph_get()
         * ```
         */
        digraph_get: (chars: any) => string;

        /**
         * Return a list of digraphs.  If the {listall} argument is given
         * and it is TRUE, return all digraphs, including the default
         * digraphs.  Otherwise, return only user-defined digraphs.
         * 
         * Also see |digraph_get()|.
         * 
         * Examples: 
         * ```vim
         * " Get user-defined digraphs
         * :echo digraph_getlist()
         * 
         * " Get all the digraphs, including default digraphs
         * :echo digraph_getlist(1)
         * ```
         * Can also be used as a |method|: 
         * ```vim
         *   GetNumber()->digraph_getlist()
         * ```
         */
        digraph_getlist: (listall?: any) => any[];

        /**
         * Add digraph {chars} to the list.  {chars} must be a string
         * with two characters.  {digraph} is a string with one UTF-8
         * encoded character.
         * Be careful, composing characters are NOT ignored.  This
         * function is similar to |:digraphs| command, but useful to add
         * digraphs start with a white space.
         * 
         * The function result is v:true if |digraph| is registered.  If
         * this fails an error message is given and v:false is returned.
         * 
         * If you want to define multiple digraphs at once, you can use
         * |digraph_setlist()|.
         * 
         * Example: 
         * ```vim
         *   call digraph_set('  ', 'あ')
         * ```
         * Can be used as a |method|: 
         * ```vim
         *   GetString()->digraph_set('あ')
         * ```
         */
        digraph_set: (chars: any, digraph: any) => boolean;

        /**
         * Similar to |digraph_set()| but this function can add multiple
         * digraphs at once.  {digraphlist} is a list composed of lists,
         * where each list contains two strings with {chars} and
         * {digraph} as in |digraph_set()|.
         * Example: 
         * ```vim
         *     call digraph_setlist([['aa', 'あ'], ['ii', 'い']])
         * ```
         * It is similar to the following: 
         * ```vim
         *     for [chars, digraph] in [['aa', 'あ'], ['ii', 'い']]
         *     call digraph_set(chars, digraph)
         *     endfor
         * ```
         * Except that the function returns after the first error,
         * following digraphs will not be added.
         * 
         * Can be used as a |method|: 
         * ```vim
         *     GetList()->digraph_setlist()
         * ```
         */
        digraph_setlist: (digraphlist: any) => boolean;

        /**
         * Return the Number 1 if {expr} is empty, zero otherwise.
         * - A |List| or |Dictionary| is empty when it does not have any
         *   items.
         * - A |String| is empty when its length is zero.
         * - A |Number| and |Float| are empty when their value is zero.
         * - |v:false| and |v:null| are empty, |v:true| is not.
         * - A |Blob| is empty when its length is zero.
         * 
         * Can also be used as a |method|: 
         * ```vim
         *   mylist->empty()
         * ```
         */
        empty: (expr: any) => number;

        /**
         * Return all of environment variables as dictionary. You can
         * check if an environment variable exists like this: 
         * ```vim
         *   :echo has_key(environ(), 'HOME')
         * ```
         * Note that the variable name may be CamelCase; to ignore case
         * use this: 
         * ```vim
         *   :echo index(keys(environ()), 'HOME', 0, 1) != -1
         * ```
         */
        environ: () => { [key: string]: any };

        /**
         * Escape the characters in {chars} that occur in {string} with a
         * backslash.  Example: 
         * ```vim
         *   :echo escape('c:\program files\vim', ' \')
         * ```
         * results in: >
         *   c:\\program\ files\\vim
         * <    Also see |shellescape()| and |fnameescape()|.
         * 
         * Can also be used as a |method|: 
         * ```vim
         *   GetText()->escape(' \')
         * ```
         */
        escape: (string: string, chars: any) => string;

        /**
         * Evaluate {string} and return the result.  Especially useful to
         *   turn the result of |string()| back into the original value.
         *   This works for Numbers, Floats, Strings, Blobs and composites
         *   of them.  Also works for |Funcref|s that refer to existing
         *   functions.
         * 
         *   Can also be used as a |method|: 
         * ```vim
         *     argv->join()->eval()
         * ```
         */
        eval: (string: string) => any;

        /**
         * Returns 1 when inside an event handler.  That is that Vim got
         * interrupted while waiting for the user to type a character,
         * e.g., when dropping a file on Vim.  This means interactive
         * commands cannot be used.  Otherwise zero is returned.
         */
        eventhandler: () => number;

        /**
         * This function checks if an executable with the name {expr}
         * exists.  {expr} must be the name of the program without any
         * arguments.
         * executable() uses the value of $PATH and/or the normal
         * searchpath for programs.
         * On MS-Windows the ".exe", ".bat", etc. can optionally be
         * included.  Then the extensions in $PATHEXT are tried.  Thus if
         * "foo.exe" does not exist, "foo.exe.bat" can be found.  If
         * $PATHEXT is not set then ".exe;.com;.bat;.cmd" is used.  A dot
         * by itself can be used in $PATHEXT to try using the name
         * without an extension.  When 'shell' looks like a Unix shell,
         * then the name is also tried without adding an extension.
         * On MS-Windows it only checks if the file exists and is not a
         * directory, not if it's really executable.
         * On Windows an executable in the same directory as Vim is
         * always found (it is added to $PATH at |startup|).
         * The result is a Number:
         *   1  exists
         *   0  does not exist
         *   -1  not implemented on this system
         * |exepath()| can be used to get the full path of an executable.
         * 
         * Can also be used as a |method|: 
         * ```vim
         *   GetCommand()->executable()
         * ```
         */
        executable: (expr: any) => number;

        /**
         * Execute {command} and capture its output.
         * If {command} is a |String|, returns {command} output.
         * If {command} is a |List|, returns concatenated outputs.
         * Examples: 
         * ```vim
         *   echo execute('echon "foo"')
         * ```
         *   foo >
         *   echo execute(['echon "foo"', 'echon "bar"'])
         * <      foobar
         * 
         * The optional {silent} argument can have these values:
         *   ""    no `:silent` used
         *   "silent"  `:silent` used
         *   "silent!"  `:silent!` used
         * The default is "silent".  Note that with "silent!", unlike
         * `:redir`, error messages are dropped.
         * 
         * To get a list of lines use |split()| on the result: 
         * ```vim
         *   execute('args')->split("\n")
         * 
         * ```
         * This function is not available in the |sandbox|.
         * Note: If nested, an outer execute() will not observe output of
         * the inner calls.
         * Note: Text attributes (highlights) are not captured.
         * To execute a command in another window than the current one
         * use `win_execute()`.
         * 
         * Can also be used as a |method|: 
         * ```vim
         *   GetCommand()->execute()
         * ```
         */
        execute: (command: any, silent?: any) => string;

        /**
         * Returns the full path of {expr} if it is an executable and
         * given as a (partial or full) path or is found in $PATH.
         * Returns empty string otherwise.
         * If {expr} starts with "./" the |current-directory| is used.
         * 
         * Can also be used as a |method|: 
         * ```vim
         *   GetCommand()->exepath()
         * ```
         */
        exepath: (expr: any) => string;

        /**
         * The result is a Number, which is |TRUE| if {expr} is
         *   defined, zero otherwise.
         * 
         *   For checking for a supported feature use |has()|.
         *   For checking if a file exists use |filereadable()|.
         * 
         *   The {expr} argument is a string, which contains one of these:
         *     varname    internal variable (see
         *     dict.key  |internal-variables|).  Also works
         *     list[i]    for |curly-braces-names|, |Dictionary|
         *         entries, |List| items, etc.
         *         Beware that evaluating an index may
         *         cause an error message for an invalid
         *         expression.  E.g.: 
         * ```vim
         *            :let l = [1, 2, 3]
         *            :echo exists("l[5]")
         * ```
         *            0 >
         *            :echo exists("l[xx]")
         * <             E121: Undefined variable: xx
         *            0
         *     &option-name  Vim option (only checks if it exists,
         *         not if it really works)
         *     +option-name  Vim option that works.
         *     $ENVNAME  environment variable (could also be
         *         done by comparing with an empty
         *         string)
         *     *funcname  built-in function (see |functions|)
         *         or user defined function (see
         *         |user-function|). Also works for a
         *         variable that is a Funcref.
         *     :cmdname  Ex command: built-in command, user
         *         command or command modifier |:command|.
         *         Returns:
         *         1  for match with start of a command
         *         2  full match with a command
         *         3  matches several user commands
         *         To check for a supported command
         *         always check the return value to be 2.
         *     :2match    The |:2match| command.
         *     :3match    The |:3match| command (but you
         *         probably should not use it, it is
         *         reserved for internal usage)
         *     #event    autocommand defined for this event
         *     #event#pattern  autocommand defined for this event and
         *         pattern (the pattern is taken
         *         literally and compared to the
         *         autocommand patterns character by
         *         character)
         *     #group    autocommand group exists
         *     #group#event  autocommand defined for this group and
         *         event.
         *     #group#event#pattern
         *         autocommand defined for this group,
         *         event and pattern.
         *     ##event    autocommand for this event is
         *         supported.
         * 
         *   Examples: 
         * ```vim
         *     exists("&mouse")
         *     exists("$HOSTNAME")
         *     exists("*strftime")
         *     exists("*s:MyFunc")
         *     exists("*MyFunc")
         *     exists("bufcount")
         *     exists(":Make")
         *     exists("#CursorHold")
         *     exists("#BufReadPre#*.gz")
         *     exists("#filetypeindent")
         *     exists("#filetypeindent#FileType")
         *     exists("#filetypeindent#FileType#*")
         *     exists("##ColorScheme")
         * ```
         *   There must be no space between the symbol (&/$/* /#) and the
         *   name.
         *   There must be no extra characters after the name, although in
         *   a few cases this is ignored.  That may become stricter in the
         *   future, thus don't count on it!
         *   Working example: 
         * ```vim
         *     exists(":make")
         * ```
         *   NOT working example: >
         *     exists(":make install")
         * 
         * <    Note that the argument must be a string, not the name of the
         *   variable itself.  For example: 
         * ```vim
         *     exists(bufcount)
         * ```
         *   This doesn't check for existence of the "bufcount" variable,
         *   but gets the value of "bufcount", and checks if that exists.
         * 
         *   Can also be used as a |method|: 
         * ```vim
         *     Varname()->exists()
         * ```
         */
        exists: (expr: any) => number;

        /**
         * Return the exponential of {expr} as a |Float| in the range
         * [0, inf].
         * {expr} must evaluate to a |Float| or a |Number|.
         * Returns 0.0 if {expr} is not a |Float| or a |Number|.
         * Examples: 
         * ```vim
         *   :echo exp(2)
         * ```
         *   7.389056 >
         *   :echo exp(-1)
         * <      0.367879
         * 
         * Can also be used as a |method|: 
         * ```vim
         *   Compute()->exp()
         * ```
         */
        exp: (expr: any) => number;

        /**
         * Expand wildcards and the following special keywords in
         * {string}.  'wildignorecase' applies.
         * 
         * If {list} is given and it is |TRUE|, a List will be returned.
         * Otherwise the result is a String and when there are several
         * matches, they are separated by <NL> characters.
         * 
         * If the expansion fails, the result is an empty string.  A name
         * for a non-existing file is not included, unless {string} does
         * not start with '%', '#' or '<', see below.
         * 
         * When {string} starts with '%', '#' or '<', the expansion is
         * done like for the |cmdline-special| variables with their
         * associated modifiers.  Here is a short overview:
         * 
         *   %    current file name
         *   #    alternate file name
         *   #n    alternate file name n
         *   <cfile>    file name under the cursor
         *   <afile>    autocmd file name
         *   <abuf>    autocmd buffer number (as a String!)
         *   <amatch>  autocmd matched name
         *   <cexpr>    C expression under the cursor
         *   <sfile>    sourced script file or function name
         *   <slnum>    sourced script line number or function
         *       line number
         *   <sflnum>  script file line number, also when in
         *       a function
         *   <SID>    "<SNR>123_"  where "123" is the
         *       current script ID  |<SID>|
         *   <script>  sourced script file, or script file
         *       where the current function was defined
         *   <stack>    call stack
         *   <cword>    word under the cursor
         *   <cWORD>    WORD under the cursor
         *   <client>  the {clientid} of the last received
         *       message
         * Modifiers:
         *   :p    expand to full path
         *   :h    head (last path component removed)
         *   :t    tail (last path component only)
         *   :r    root (one extension removed)
         *   :e    extension only
         * 
         * Example: 
         * ```vim
         *   :let &tags = expand("%:p:h") .. "/tags"
         * ```
         * Note that when expanding a string that starts with '%', '#' or
         * '<', any following text is ignored.  This does NOT work: 
         * ```vim
         *   :let doesntwork = expand("%:h.bak")
         * ```
         * Use this: >
         *   :let doeswork = expand("%:h") .. ".bak"
         * <    Also note that expanding "<cfile>" and others only returns the
         * referenced file name without further expansion.  If "<cfile>"
         * is "~/.cshrc", you need to do another expand() to have the
         * "~/" expanded into the path of the home directory: 
         * ```vim
         *   :echo expand(expand("<cfile>"))
         * ```
         * There cannot be white space between the variables and the
         * following modifier.  The |fnamemodify()| function can be used
         * to modify normal file names.
         * 
         * When using '%' or '#', and the current or alternate file name
         * is not defined, an empty string is used.  Using "%:p" in a
         * buffer with no name, results in the current directory, with a
         * '/' added.
         * When 'verbose' is set then expanding '%', '#' and <> items
         * will result in an error message if the argument cannot be
         * expanded.
         * 
         * When {string} does not start with '%', '#' or '<', it is
         * expanded like a file name is expanded on the command line.
         * 'suffixes' and 'wildignore' are used, unless the optional
         * {nosuf} argument is given and it is |TRUE|.
         * Names for non-existing files are included.  The "" item can
         * be used to search in a directory tree.  For example, to find
         * all "README" files in the current directory and below: 
         * ```vim
         *   :echo expand("/README")
         * ```
         * expand() can also be used to expand variables and environment
         * variables that are only known in a shell.  But this can be
         * slow, because a shell may be used to do the expansion.  See
         * |expr-env-expand|.
         * The expanded variable is still handled like a list of file
         * names.  When an environment variable cannot be expanded, it is
         * left unchanged.  Thus ":echo expand('$FOOBAR')" results in
         * "$FOOBAR".
         * 
         * See |glob()| for finding existing files.  See |system()| for
         * getting the raw output of an external command.
         * 
         * Can also be used as a |method|: 
         * ```vim
         *   Getpattern()->expand()
         * ```
         */
        expand: (string: string, nosuf?: any, list?: any[]) => any;

        /**
         * Expand special items in String {string} like what is done for
         * an Ex command such as `:edit`.  This expands special keywords,
         * like with |expand()|, and environment variables, anywhere in
         * {string}.  "~user" and "~/path" are only expanded at the
         * start.
         * 
         * The following items are supported in the {options} Dict
         * argument:
         *     errmsg  If set to TRUE, error messages are displayed
         *     if an error is encountered during expansion.
         *     By default, error messages are not displayed.
         * 
         * Returns the expanded string.  If an error is encountered
         * during expansion, the unmodified {string} is returned.
         * 
         * Example: 
         * ```vim
         *   :echo expandcmd('make %<.o')
         *   make /path/runtime/doc/builtin.o
         *   :echo expandcmd('make %<.o', {'errmsg': v:true})
         * ```
         * Can also be used as a |method|: 
         * ```vim
         *   GetCommand()->expandcmd()
         * ```
         */
        expandcmd: (string: string, options?: { [key: string]: any }) => string;

        /**
         * {expr1} and {expr2} must be both |Lists| or both
         * |Dictionaries|.
         * 
         * If they are |Lists|: Append {expr2} to {expr1}.
         * If {expr3} is given insert the items of {expr2} before the
         * item with index {expr3} in {expr1}.  When {expr3} is zero
         * insert before the first item.  When {expr3} is equal to
         * len({expr1}) then {expr2} is appended.
         * Examples: 
         * ```vim
         *   :echo sort(extend(mylist, [7, 5]))
         *   :call extend(mylist, [2, 3], 1)
         * ```
         * When {expr1} is the same List as {expr2} then the number of
         * items copied is equal to the original length of the List.
         * E.g., when {expr3} is 1 you get N new copies of the first item
         * (where N is the original length of the List).
         * Use |add()| to concatenate one item to a list.  To concatenate
         * two lists into a new list use the + operator: 
         * ```vim
         *   :let newlist = [1, 2, 3] + [4, 5]
         * ```
         * If they are |Dictionaries|:
         * Add all entries from {expr2} to {expr1}.
         * If a key exists in both {expr1} and {expr2} then {expr3} is
         * used to decide what to do:
         * {expr3} = "keep": keep the value of {expr1}
         * {expr3} = "force": use the value of {expr2}
         * {expr3} = "error": give an error message
         * When {expr3} is omitted then "force" is assumed.
         * 
         * {expr1} is changed when {expr2} is not empty.  If necessary
         * make a copy of {expr1} first.
         * {expr2} remains unchanged.
         * When {expr1} is locked and {expr2} is not empty the operation
         * fails.
         * Returns {expr1}.  Returns 0 on error.
         * 
         * Can also be used as a |method|: 
         * ```vim
         *   mylist->extend(otherlist)
         * ```
         */
        extend: (expr1: any, expr2: any, expr3?: any) => any[];

        /**
         * Like |extend()| but instead of adding items to {expr1} a new
         * List or Dictionary is created and returned.  {expr1} remains
         * unchanged.
         */
        extendnew: (expr1: any, expr2: any, expr3?: any) => any[];

        /**
         * Characters in {string} are queued for processing as if they
         * come from a mapping or were typed by the user.
         * 
         * By default the string is added to the end of the typeahead
         * buffer, thus if a mapping is still being executed the
         * characters come after them.  Use the 'i' flag to insert before
         * other characters, they will be executed next, before any
         * characters from a mapping.
         * 
         * The function does not wait for processing of keys contained in
         * {string}.
         * 
         * To include special keys into {string}, use double-quotes
         * and "\..." notation |expr-quote|. For example,
         * feedkeys("\<CR>") simulates pressing of the <Enter> key. But
         * feedkeys('\<CR>') pushes 5 characters.
         * The |<Ignore>| keycode may be used to exit the
         * wait-for-character without doing anything.
         * 
         * {mode} is a String, which can contain these character flags:
         * 'm'  Remap keys. This is default.  If {mode} is absent,
         *   keys are remapped.
         * 'n'  Do not remap keys.
         * 't'  Handle keys as if typed; otherwise they are handled as
         *   if coming from a mapping.  This matters for undo,
         *   opening folds, etc.
         * 'i'  Insert the string instead of appending (see above).
         * 'x'  Execute commands until typeahead is empty.  This is
         *   similar to using ":normal!".  You can call feedkeys()
         *   several times without 'x' and then one time with 'x'
         *   (possibly with an empty {string}) to execute all the
         *   typeahead.  Note that when Vim ends in Insert mode it
         *   will behave as if <Esc> is typed, to avoid getting
         *   stuck, waiting for a character to be typed before the
         *   script continues.
         *   Note that if you manage to call feedkeys() while
         *   executing commands, thus calling it recursively, then
         *   all typeahead will be consumed by the last call.
         * '!'  When used with 'x' will not end Insert mode. Can be
         *   used in a test when a timer is set to exit Insert mode
         *   a little later.  Useful for testing CursorHoldI.
         * 
         * Return value is always 0.
         * 
         * Can also be used as a |method|: 
         * ```vim
         *   GetInput()->feedkeys()
         * ```
         */
        feedkeys: (string: string, mode?: any) => number;

        /**
         * The result is a Number, which is |TRUE| when a file with the
         * name {file} exists, and can be read.  If {file} doesn't exist,
         * or is a directory, the result is |FALSE|.  {file} is any
         * expression, which is used as a String.
         * If you don't care about the file being readable you can use
         * |glob()|.
         * {file} is used as-is, you may want to expand wildcards first: 
         * ```vim
         *   echo filereadable('~/.vimrc')
         *   0
         *   echo filereadable(expand('~/.vimrc'))
         *   1
         * 
         * ```
         * Can also be used as a |method|: >
         *   GetName()->filereadable()
         */
        filereadable: (file: any) => number;

        /**
         * The result is a Number, which is 1 when a file with the
         * name {file} exists, and can be written.  If {file} doesn't
         * exist, or is not writable, the result is 0.  If {file} is a
         * directory, and we can write to it, the result is 2.
         * 
         * Can also be used as a |method|: 
         * ```vim
         *   GetName()->filewritable()
         * ```
         */
        filewritable: (file: any) => number;

        /**
         * {expr1} must be a |List|, |Blob|, or a |Dictionary|.
         * For each item in {expr1} evaluate {expr2} and when the result
         * is zero remove the item from the |List| or |Dictionary|. For a
         * |Blob| each byte is removed.
         * 
         * {expr2} must be a |string| or |Funcref|.
         * 
         * If {expr2} is a |string|, inside {expr2} |v:val| has the value
         * of the current item.  For a |Dictionary| |v:key| has the key
         * of the current item and for a |List| |v:key| has the index of
         * the current item.  For a |Blob| |v:key| has the index of the
         * current byte.
         * 
         * Examples: 
         * ```vim
         *   call filter(mylist, 'v:val !~ "OLD"')
         * ```
         * Removes the items where "OLD" appears. >
         *   call filter(mydict, 'v:key >= 8')
         * <    Removes the items with a key below 8. 
         * ```vim
         *   call filter(var, 0)
         * ```
         * Removes all the items, thus clears the |List| or |Dictionary|.
         * 
         * Note that {expr2} is the result of expression and is then
         * used as an expression again.  Often it is good to use a
         * |literal-string| to avoid having to double backslashes.
         * 
         * If {expr2} is a |Funcref| it must take two arguments:
         *   1. the key or the index of the current item.
         *   2. the value of the current item.
         * The function must return |TRUE| if the item should be kept.
         * Example that keeps the odd items of a list: 
         * ```vim
         *   func Odd(idx, val)
         *     return a:idx % 2 == 1
         *   endfunc
         *   call filter(mylist, function('Odd'))
         * ```
         * It is shorter when using a |lambda|: >
         *   call filter(myList, {idx, val -> idx * val <= 42})
         * <    If you do not use "val" you can leave it out: 
         * ```vim
         *   call filter(myList, {idx -> idx % 2 == 1})
         * ```
         * The operation is done in-place.  If you want a |List| or
         * |Dictionary| to remain unmodified make a copy first: 
         * ```vim
         *   :let l = filter(copy(mylist), 'v:val =~ "KEEP"')
         * 
         * ```
         * Returns {expr1}, the |List|, |Blob| or |Dictionary| that was
         * filtered.  When an error is encountered while evaluating
         * {expr2} no further items in {expr1} are processed.  When
         * {expr2} is a Funcref errors inside a function are ignored,
         * unless it was defined with the "abort" flag.
         * 
         * Can also be used as a |method|: 
         * ```vim
         *   mylist->filter(expr2)
         * ```
         */
        filter: (expr1: any, expr2: any) => any[];

        /**
         * Find directory {name} in {path}.  Supports both downwards and
         * upwards recursive directory searches.  See |file-searching|
         * for the syntax of {path}.
         * 
         * Returns the path of the first found match.  When the found
         * directory is below the current directory a relative path is
         * returned.  Otherwise a full path is returned.
         * If {path} is omitted or empty then 'path' is used.
         * 
         * If the optional {count} is given, find {count}'s occurrence of
         * {name} in {path} instead of the first one.
         * When {count} is negative return all the matches in a |List|.
         * 
         * Returns an empty string if the directory is not found.
         * 
         * This is quite similar to the ex-command `:find`.
         * 
         * Can also be used as a |method|: 
         * ```vim
         *   GetName()->finddir()
         * ```
         */
        finddir: (name: any, path?: any, count?: any) => string;

        /**
         * Just like |finddir()|, but find a file instead of a directory.
         * Uses 'suffixesadd'.
         * Example: 
         * ```vim
         *   :echo findfile("tags.vim", ".;")
         * ```
         * Searches from the directory of the current file upwards until
         * it finds the file "tags.vim".
         * 
         * Can also be used as a |method|: 
         * ```vim
         *   GetName()->findfile()
         * ```
         */
        findfile: (name: any, path?: any, count?: any) => string;

        /**
         * Flatten {list} up to {maxdepth} levels.  Without {maxdepth}
         * the result is a |List| without nesting, as if {maxdepth} is
         * a very large number.
         * The {list} is changed in place, use |flattennew()| if you do
         * not want that.
         * 
         * {maxdepth} means how deep in nested lists changes are made.
         * {list} is not modified when {maxdepth} is 0.
         * {maxdepth} must be positive number.
         * 
         * If there is an error the number zero is returned.
         * 
         * Example: 
         * ```vim
         *   :echo flatten([1, [2, [3, 4]], 5])
         * ```
         *   [1, 2, 3, 4, 5] >
         *   :echo flatten([1, [2, [3, 4]], 5], 1)
         * <      [1, 2, [3, 4], 5]
         * 
         * Can also be used as a |method|: 
         * ```vim
         *   mylist->flatten()
         * ```
         */
        flatten: (list: any[], maxdepth?: any) => any[];

        /**
         * Like |flatten()| but first make a copy of {list}.
         */
        flattennew: (list: any[], maxdepth?: any) => any[];

        /**
         * Convert {expr} to a Number by omitting the part after the
         * decimal point.
         * {expr} must evaluate to a |Float| or a |Number|.
         * Returns 0 if {expr} is not a |Float| or a |Number|.
         * When the value of {expr} is out of range for a |Number| the
         * result is truncated to 0x7fffffff or -0x7fffffff (or when
         * 64-bit Number support is enabled, 0x7fffffffffffffff or
         * -0x7fffffffffffffff).  NaN results in -0x80000000 (or when
         * 64-bit Number support is enabled, -0x8000000000000000).
         * Examples: 
         * ```vim
         *   echo float2nr(3.95)
         * ```
         *   3  >
         *   echo float2nr(-23.45)
         * <      -23  
         * ```vim
         *   echo float2nr(1.0e100)
         * ```
         *   2147483647  (or 9223372036854775807) >
         *   echo float2nr(-1.0e150)
         * <      -2147483647 (or -9223372036854775807) 
         * ```vim
         *   echo float2nr(1.0e-100)
         * ```
         *   0
         * 
         * Can also be used as a |method|: 
         * ```vim
         *   Compute()->float2nr()
         * ```
         */
        float2nr: (expr: any) => number;

        /**
         * Return the largest integral value less than or equal to
         * {expr} as a |Float| (round down).
         * {expr} must evaluate to a |Float| or a |Number|.
         * Returns 0.0 if {expr} is not a |Float| or a |Number|.
         * Examples: 
         * ```vim
         *   echo floor(1.856)
         * ```
         *   1.0  >
         *   echo floor(-5.456)
         * <      -6.0  
         * ```vim
         *   echo floor(4.0)
         * ```
         *   4.0
         * 
         * Can also be used as a |method|: 
         * ```vim
         *   Compute()->floor()
         * ```
         */
        floor: (expr: any) => number;

        /**
         * Return the remainder of {expr1} / {expr2}, even if the
         * division is not representable.  Returns {expr1} - i * {expr2}
         * for some integer i such that if {expr2} is non-zero, the
         * result has the same sign as {expr1} and magnitude less than
         * the magnitude of {expr2}.  If {expr2} is zero, the value
         * returned is zero.  The value returned is a |Float|.
         * {expr1} and {expr2} must evaluate to a |Float| or a |Number|.
         * Returns 0.0 if {expr1} or {expr2} is not a |Float| or a
         * |Number|.
         * Examples: 
         * ```vim
         *   :echo fmod(12.33, 1.22)
         * ```
         *   0.13 >
         *   :echo fmod(-12.33, 1.22)
         * <      -0.13
         * 
         * Can also be used as a |method|: 
         * ```vim
         *   Compute()->fmod(1.22)
         * ```
         */
        fmod: (expr1: any, expr2: any) => number;

        /**
         * Escape {string} for use as file name command argument.  All
         * characters that have a special meaning, such as '%' and '|'
         * are escaped with a backslash.
         * For most systems the characters escaped are
         * " \t\n*?[{`$\\%#'\"|!<".  For systems where a backslash
         * appears in a filename, it depends on the value of 'isfname'.
         * A leading '+' and '>' is also escaped (special after |:edit|
         * and |:write|).  And a "-" by itself (special after |:cd|).
         * Returns an empty string on error.
         * Example: 
         * ```vim
         *   :let fname = '+some str%nge|name'
         *   :exe "edit " .. fnameescape(fname)
         * ```
         * results in executing: >
         *   edit \+some\ str\%nge\|name
         * <
         * Can also be used as a |method|: 
         * ```vim
         *   GetName()->fnameescape()
         * ```
         */
        fnameescape: (string: string) => string;

        /**
         * Modify file name {fname} according to {mods}.  {mods} is a
         * string of characters like it is used for file names on the
         * command line.  See |filename-modifiers|.
         * Example: 
         * ```vim
         *   :echo fnamemodify("main.c", ":p:h")
         * ```
         * results in: >
         *   /home/user/vim/vim/src
         * <    If {mods} is empty or an unsupported modifier is used then
         * {fname} is returned.
         * When {fname} is empty then with {mods} ":h" returns ".", so
         * that `:cd` can be used with it.  This is different from
         * expand('%:h') without a buffer name, which returns an empty
         * string.
         * Note: Environment variables don't work in {fname}, use
         * |expand()| first then.
         * 
         * Can also be used as a |method|: 
         * ```vim
         *   GetName()->fnamemodify(':p:h')
         * ```
         */
        fnamemodify: (fname: any, mods: any) => string;

        /**
         * The result is a Number.  If the line {lnum} is in a closed
         * fold, the result is the number of the first line in that fold.
         * If the line {lnum} is not in a closed fold, -1 is returned.
         * {lnum} is used like with |getline()|.  Thus "." is the current
         * line, "'m" mark m, etc.
         * 
         * Can also be used as a |method|: 
         * ```vim
         *   GetLnum()->foldclosed()
         * ```
         */
        foldclosed: (lnum: number) => number;

        /**
         * The result is a Number.  If the line {lnum} is in a closed
         * fold, the result is the number of the last line in that fold.
         * If the line {lnum} is not in a closed fold, -1 is returned.
         * {lnum} is used like with |getline()|.  Thus "." is the current
         * line, "'m" mark m, etc.
         * 
         * Can also be used as a |method|: 
         * ```vim
         *   GetLnum()->foldclosedend()
         * ```
         */
        foldclosedend: (lnum: number) => number;

        /**
         * The result is a Number, which is the foldlevel of line {lnum}
         * in the current buffer.  For nested folds the deepest level is
         * returned.  If there is no fold at line {lnum}, zero is
         * returned.  It doesn't matter if the folds are open or closed.
         * When used while updating folds (from 'foldexpr') -1 is
         * returned for lines where folds are still to be updated and the
         * foldlevel is unknown.  As a special case the level of the
         * previous line is usually available.
         * {lnum} is used like with |getline()|.  Thus "." is the current
         * line, "'m" mark m, etc.
         * 
         * Can also be used as a |method|: 
         * ```vim
         *   GetLnum()->foldlevel()
         * ```
         */
        foldlevel: (lnum: number) => number;

        /**
         * Returns a String, to be displayed for a closed fold.  This is
         *   the default function used for the 'foldtext' option and should
         *   only be called from evaluating 'foldtext'.  It uses the
         *   |v:foldstart|, |v:foldend| and |v:folddashes| variables.
         *   The returned string looks like this: 
         * ```vim
         *     +-- 45 lines: abcdef
         * ```
         *   The number of leading dashes depends on the foldlevel.  The
         *   "45" is the number of lines in the fold.  "abcdef" is the text
         *   in the first non-blank line of the fold.  Leading white space,
         *   "//" or "/*" and the text from the 'foldmarker' and
         *   'commentstring' options is removed.
         *   When used to draw the actual foldtext, the rest of the line
         *   will be filled with the fold char from the 'fillchars'
         *   setting.
         *   Returns an empty string when there is no fold.
         */
        foldtext: () => string;

        /**
         * Returns the text that is displayed for the closed fold at line
         * {lnum}.  Evaluates 'foldtext' in the appropriate context.
         * When there is no closed fold at {lnum} an empty string is
         * returned.
         * {lnum} is used like with |getline()|.  Thus "." is the current
         * line, "'m" mark m, etc.
         * Useful when exporting folded text, e.g., to HTML.
         * 
         * Can also be used as a |method|: 
         * ```vim
         *   GetLnum()->foldtextresult()
         * ```
         */
        foldtextresult: (lnum: number) => string;

        /**
         * Get the full command name from a short abbreviated command
         * name; see |20.2| for details on command abbreviations.
         * 
         * The string argument {name} may start with a `:` and can
         * include a [range], these are skipped and not returned.
         * Returns an empty string if a command doesn't exist or if it's
         * ambiguous (for user-defined commands).
         * 
         * For example `fullcommand('s')`, `fullcommand('sub')`,
         * `fullcommand(':%substitute')` all return "substitute".
         * 
         * Can also be used as a |method|: 
         * ```vim
         *   GetName()->fullcommand()
         * ```
         */
        fullcommand: (name: any) => string;

        /**
         * Just like |function()|, but the returned Funcref will lookup
         * the function by reference, not by name.  This matters when the
         * function {name} is redefined later.
         * 
         * Unlike |function()|, {name} must be an existing user function.
         * It only works for an autoloaded function if it has already
         * been loaded (to avoid mistakenly loading the autoload script
         * when only intending to use the function name, use |function()|
         * instead). {name} cannot be a builtin function.
         * Returns 0 on error.
         * 
         * Can also be used as a |method|: 
         * ```vim
         *   GetFuncname()->funcref([arg])
         * ```
         */
        funcref: (name: any, arglist?: any, dict?: { [key: string]: any }) => Function;

        /**
         * Return a |Funcref| variable that refers to function {name}.
         * {name} can be the name of a user defined function or an
         * internal function.
         * 
         * {name} can also be a Funcref or a partial. When it is a
         * partial the dict stored in it will be used and the {dict}
         * argument is not allowed. E.g.: 
         * ```vim
         *   let FuncWithArg = function(dict.Func, [arg])
         *   let Broken = function(dict.Func, [arg], dict)
         * ```
         * When using the Funcref the function will be found by {name},
         * also when it was redefined later. Use |funcref()| to keep the
         * same function.
         * 
         * When {arglist} or {dict} is present this creates a partial.
         * That means the argument list and/or the dictionary is stored in
         * the Funcref and will be used when the Funcref is called.
         * 
         * The arguments are passed to the function in front of other
         * arguments, but after any argument from |method|.  Example: 
         * ```vim
         *   func Callback(arg1, arg2, name)
         *   "...
         *   let Partial = function('Callback', ['one', 'two'])
         *   "...
         *   call Partial('name')
         * ```
         * Invokes the function as with: >
         *   call Callback('one', 'two', 'name')
         * 
         * <    With a |method|: 
         * ```vim
         *   func Callback(one, two, three)
         *   "...
         *   let Partial = function('Callback', ['two'])
         *   "...
         *   eval 'one'->Partial('three')
         * ```
         * Invokes the function as with: >
         *   call Callback('one', 'two', 'three')
         * 
         * <    The function() call can be nested to add more arguments to the
         * Funcref.  The extra arguments are appended to the list of
         * arguments.  Example: 
         * ```vim
         *   func Callback(arg1, arg2, name)
         *   "...
         *   let Func = function('Callback', ['one'])
         *   let Func2 = function(Func, ['two'])
         *   "...
         *   call Func2('name')
         * ```
         * Invokes the function as with: >
         *   call Callback('one', 'two', 'name')
         * 
         * <    The Dictionary is only useful when calling a "dict" function.
         * In that case the {dict} is passed in as "self". Example: 
         * ```vim
         *   function Callback() dict
         *      echo "called for " .. self.name
         *   endfunction
         *   "...
         *   let context = {"name": "example"}
         *   let Func = function('Callback', context)
         *   "...
         *   call Func()  " will echo: called for example
         * ```
         * The use of function() is not needed when there are no extra
         * arguments, these two are equivalent, if Callback() is defined
         * as context.Callback(): 
         * ```vim
         *   let Func = function('Callback', context)
         *   let Func = context.Callback
         * 
         * ```
         * The argument list and the Dictionary can be combined: >
         *   function Callback(arg1, count) dict
         *   "...
         *   let context = {"name": "example"}
         *   let Func = function('Callback', ['one'], context)
         *   "...
         *   call Func(500)
         * <    Invokes the function as with: 
         * ```vim
         *   call context.Callback('one', 500)
         * ```
         * Returns 0 on error.
         * 
         * Can also be used as a |method|: 
         * ```vim
         *   GetFuncname()->function([arg])
         * ```
         */
        function: (name: any, arglist?: any, dict?: { [key: string]: any }) => Function;

        /**
         * Cleanup unused |Lists| and |Dictionaries| that have circular
         * references.
         * 
         * There is hardly ever a need to invoke this function, as it is
         * automatically done when Vim runs out of memory or is waiting
         * for the user to press a key after 'updatetime'.  Items without
         * circular references are always freed when they become unused.
         * This is useful if you have deleted a very big |List| and/or
         * |Dictionary| with circular references in a script that runs
         * for a long time.
         * 
         * When the optional {atexit} argument is one, garbage
         * collection will also be done when exiting Vim, if it wasn't
         * done before.  This is useful when checking for memory leaks.
         * 
         * The garbage collection is not done immediately but only when
         * it's safe to perform.  This is when waiting for the user to
         * type a character.
         */
        garbagecollect: (atexit?: any) => undefined;

        /**
         * Get item {what} from Funcref {func}.  Possible values for
         * {what} are:
         *   "name"  The function name
         *   "func"  The function
         *   "dict"  The dictionary
         *   "args"  The list with arguments
         * Returns zero on error.
         */
        get: (func: Function, what: any) => any;

        /**
         * Get information about buffers as a List of Dictionaries.
         * 
         * Without an argument information about all the buffers is
         * returned.
         * 
         * When the argument is a |Dictionary| only the buffers matching
         * the specified criteria are returned.  The following keys can
         * be specified in {dict}:
         *   buflisted  include only listed buffers.
         *   bufloaded  include only loaded buffers.
         *   bufmodified  include only modified buffers.
         * 
         * Otherwise, {buf} specifies a particular buffer to return
         * information for.  For the use of {buf}, see |bufname()|
         * above.  If the buffer is found the returned List has one item.
         * Otherwise the result is an empty list.
         * 
         * Each returned List item is a dictionary with the following
         * entries:
         *   bufnr    Buffer number.
         *   changed    TRUE if the buffer is modified.
         *   changedtick  Number of changes made to the buffer.
         *   hidden    TRUE if the buffer is hidden.
         *   lastused  Timestamp in seconds, like
         *       |localtime()|, when the buffer was
         *       last used.
         *   listed    TRUE if the buffer is listed.
         *   lnum    Line number used for the buffer when
         *       opened in the current window.
         *       Only valid if the buffer has been
         *       displayed in the window in the past.
         *       If you want the line number of the
         *       last known cursor position in a given
         *       window, use |line()|: 
         * ```vim
         *         :echo line('.', {winid})
         * ```
         *   linecount  Number of lines in the buffer (only
         *       valid when loaded)
         *   loaded    TRUE if the buffer is loaded.
         *   name    Full path to the file in the buffer.
         *   signs    List of signs placed in the buffer.
         *       Each list item is a dictionary with
         *       the following fields:
         *           id    sign identifier
         *           lnum  line number
         *           name  sign name
         *   variables  A reference to the dictionary with
         *       buffer-local variables.
         *   windows    List of |window-ID|s that display this
         *       buffer
         * 
         * Examples: 
         * ```vim
         *   for buf in getbufinfo()
         *       echo buf.name
         *   endfor
         *   for buf in getbufinfo({'buflisted':1})
         *       if buf.changed
         *     ....
         *       endif
         *   endfor
         * ```
         * To get buffer-local options use: 
         * ```vim
         *   getbufvar({bufnr}, '&option_name')
         * ```
         * Can also be used as a |method|: 
         * ```vim
         *   GetBufnr()->getbufinfo()
         * ```
         */
        getbufinfo: (dict?: { [key: string]: any }) => any[];

        /**
         * Return a |List| with the lines starting from {lnum} to {end}
         * (inclusive) in the buffer {buf}.  If {end} is omitted, a
         * |List| with only the line {lnum} is returned.  See
         * `getbufoneline()` for only getting the line.
         * 
         * For the use of {buf}, see |bufname()| above.
         * 
         * For {lnum} and {end} "$" can be used for the last line of the
         * buffer.  Otherwise a number must be used.
         * 
         * When {lnum} is smaller than 1 or bigger than the number of
         * lines in the buffer, an empty |List| is returned.
         * 
         * When {end} is greater than the number of lines in the buffer,
         * it is treated as {end} is set to the number of lines in the
         * buffer.  When {end} is before {lnum} an empty |List| is
         * returned.
         * 
         * This function works only for loaded buffers.  For unloaded and
         * non-existing buffers, an empty |List| is returned.
         * 
         * Example: 
         * ```vim
         *   :let lines = getbufline(bufnr("myfile"), 1, "$")
         * 
         * ```
         * Can also be used as a |method|: >
         *   GetBufnr()->getbufline(lnum)
         * <
         */
        getbufline: (buf: number, lnum: number, end?: any) => any[];

        /**
         * Just like `getbufline()` but only get one line and return it
         * as a string.
         */
        getbufoneline: (buf: number, lnum: number) => string;

        /**
         * The result is the value of option or local buffer variable
         * {varname} in buffer {buf}.  Note that the name without "b:"
         * must be used.
         * The {varname} argument is a string.
         * When {varname} is empty returns a |Dictionary| with all the
         * buffer-local variables.
         * When {varname} is equal to "&" returns a |Dictionary| with all
         * the buffer-local options.
         * Otherwise, when {varname} starts with "&" returns the value of
         * a buffer-local option.
         * This also works for a global or buffer-local option, but it
         * doesn't work for a global variable, window-local variable or
         * window-local option.
         * For the use of {buf}, see |bufname()| above.
         * When the buffer or variable doesn't exist {def} or an empty
         * string is returned, there is no error message.
         * Examples: 
         * ```vim
         *   :let bufmodified = getbufvar(1, "&mod")
         *   :echo "todo myvar = " .. getbufvar("todo", "myvar")
         * 
         * ```
         * Can also be used as a |method|: >
         *   GetBufnr()->getbufvar(varname)
         * <
         */
        getbufvar: (buf: number, varname: any, def?: any) => any;

        /**
         * Returns a |List| of cell widths of character ranges overridden
         * by |setcellwidths()|.  The format is equal to the argument of
         * |setcellwidths()|.  If no character ranges have their cell
         * widths overridden, an empty List is returned.
         */
        getcellwidths: () => any[];

        /**
         * Returns the |changelist| for the buffer {buf}. For the use
         * of {buf}, see |bufname()| above. If buffer {buf} doesn't
         * exist, an empty list is returned.
         * 
         * The returned list contains two entries: a list with the change
         * locations and the current position in the list.  Each
         * entry in the change list is a dictionary with the following
         * entries:
         *   col    column number
         *   coladd    column offset for 'virtualedit'
         *   lnum    line number
         * If buffer {buf} is the current buffer, then the current
         * position refers to the position in the list. For other
         * buffers, it is set to the length of the list.
         * 
         * Can also be used as a |method|: 
         * ```vim
         *   GetBufnr()->getchangelist()
         * ```
         */
        getchangelist: (buf?: number) => any[];

        /**
         * Get a single character from the user or input stream.
         * If [expr] is omitted, wait until a character is available.
         * If [expr] is 0, only get a character when one is available.
         *   Return zero otherwise.
         * If [expr] is 1, only check if a character is available, it is
         *   not consumed.  Return zero if no character available.
         * If you prefer always getting a string use |getcharstr()|.
         * 
         * Without [expr] and when [expr] is 0 a whole character or
         * special key is returned.  If it is a single character, the
         * result is a Number.  Use |nr2char()| to convert it to a String.
         * Otherwise a String is returned with the encoded character.
         * For a special key it's a String with a sequence of bytes
         * starting with 0x80 (decimal: 128).  This is the same value as
         * the String "\<Key>", e.g., "\<Left>".  The returned value is
         * also a String when a modifier (shift, control, alt) was used
         * that is not included in the character.
         * 
         * When [expr] is 0 and Esc is typed, there will be a short delay
         * while Vim waits to see if this is the start of an escape
         * sequence.
         * 
         * When [expr] is 1 only the first byte is returned.  For a
         * one-byte character it is the character itself as a number.
         * Use nr2char() to convert it to a String.
         * 
         * Use getcharmod() to obtain any additional modifiers.
         * 
         * When the user clicks a mouse button, the mouse event will be
         * returned.  The position can then be found in |v:mouse_col|,
         * |v:mouse_lnum|, |v:mouse_winid| and |v:mouse_win|.
         * |getmousepos()| can also be used.  Mouse move events will be
         * ignored.
         * This example positions the mouse as it would normally happen: 
         * ```vim
         *   let c = getchar()
         *   if c == "\<LeftMouse>" && v:mouse_win > 0
         *     exe v:mouse_win .. "wincmd w"
         *     exe v:mouse_lnum
         *     exe "normal " .. v:mouse_col .. "|"
         *   endif
         * ```
         * There is no prompt, you will somehow have to make clear to the
         * user that a character has to be typed.  The screen is not
         * redrawn, e.g. when resizing the window.
         * 
         * There is no mapping for the character.
         * Key codes are replaced, thus when the user presses the <Del
         * ```vim
         * key you get the code for the <Del> key, not the raw character
         * sequence.  Examples: >
         *   getchar() == "\<Del>"
         *   getchar() == "\<S-Left>"
         * ```
         * This example redefines "f" to ignore case: >
         *   :nmap f :call FindChar()<CR
         * ```vim
         *   :function FindChar()
         *   :  let c = nr2char(getchar())
         *   :  while col('.') < col('$') - 1
         *   :    normal l
         *   :    if getline('.')[col('.') - 1] ==? c
         *   :      break
         *   :    endif
         *   :  endwhile
         *   :endfunction
         * ```
         */
        getchar: (expr?: any) => number;

        /**
         * The result is a Number which is the state of the modifiers for
         * the last obtained character with getchar() or in another way.
         * These values are added together:
         *   2  shift
         *   4  control
         *   8  alt (meta)
         *   16  meta (when it's different from ALT)
         *   32  mouse double click
         *   64  mouse triple click
         *   96  mouse quadruple click (== 32 + 64)
         *   128  command (Macintosh only)
         * Only the modifiers that have not been included in the
         * character itself are obtained.  Thus Shift-a results in "A"
         * without a modifier.  Returns 0 if no modifiers are used.
         */
        getcharmod: () => number;

        /**
         * Get the position for String {expr}. Same as |getpos()| but the
         * column number in the returned List is a character index
         * instead of a byte index.
         * If |getpos()| returns a very large column number, equal to
         * |v:maxcol|, then getcharpos() will return the character index
         * of the last character.
         * 
         * Example:
         * With the cursor on '세' in line 5 with text "여보세요": 
         * ```vim
         *   getcharpos('.')    returns [0, 5, 3, 0]
         *   getpos('.')    returns [0, 5, 7, 0]
         * ```
         * Can also be used as a |method|: 
         * ```vim
         *   GetMark()->getcharpos()
         * ```
         */
        getcharpos: (expr: any) => number[];

        /**
         * Return the current character search information as a {dict}
         * with the following entries:
         * 
         *     char  character previously used for a character
         *     search (|t|, |f|, |T|, or |F|); empty string
         *     if no character search has been performed
         *     forward  direction of character search; 1 for forward,
         *     0 for backward
         *     until  type of character search; 1 for a |t| or |T|
         *     character search, 0 for an |f| or |F|
         *     character search
         * 
         * This can be useful to always have |;| and |,| search
         * forward/backward regardless of the direction of the previous
         * character search: 
         * ```vim
         *   :nnoremap <expr> ; getcharsearch().forward ? ';' : ','
         *   :nnoremap <expr> , getcharsearch().forward ? ',' : ';'
         * ```
         * Also see |setcharsearch()|.
         */
        getcharsearch: () => { [key: string]: { char: string, search: "t" | "f" | "T" | "F" | "", forward: 1 | 0, until: 1 | 0 } };

        /**
         * Get a single character from the user or input stream as a
         * string.
         * If [expr] is omitted, wait until a character is available.
         * If [expr] is 0 or false, only get a character when one is
         *   available.  Return an empty string otherwise.
         * If [expr] is 1 or true, only check if a character is
         *   available, it is not consumed.  Return an empty string
         *   if no character is available.
         * Otherwise this works like |getchar()|, except that a number
         * result is converted to a string.
         */
        getcharstr: (expr?: boolean | 1 | 0) => string;

        /**
         * Return the type of the current command-line completion.
         * Only works when the command line is being edited, thus
         * requires use of |c_CTRL-\_e| or |c_CTRL-R_=|.
         * See |:command-completion| for the return string.
         * Also see |getcmdtype()|, |setcmdpos()|, |getcmdline()| and
         * |setcmdline()|.
         * Returns an empty string when completion is not defined.
         */
        getcmdcompltype: () => string;

        /**
         * Return the current command-line.  Only works when the command
         * line is being edited, thus requires use of |c_CTRL-\_e| or
         * |c_CTRL-R_=|.
         * Example: 
         * ```vim
         *   :cmap <F7> <C-\>eescape(getcmdline(), ' \')<CR>
         * ```
         * Also see |getcmdtype()|, |getcmdpos()|, |setcmdpos()| and
         * |setcmdline()|.
         * Returns an empty string when entering a password or using
         * |inputsecret()|.
         */
        getcmdline: () => string;

        /**
         * Return the position of the cursor in the command line as a
         * byte count.  The first column is 1.
         * Only works when editing the command line, thus requires use of
         * |c_CTRL-\_e| or |c_CTRL-R_=| or an expression mapping.
         * Returns 0 otherwise.
         * Also see |getcmdtype()|, |setcmdpos()|, |getcmdline()| and
         * |setcmdline()|.
         */
        getcmdpos: () => number;

        /**
         * Return the screen position of the cursor in the command line
         * as a byte count.  The first column is 1.
         * Instead of |getcmdpos()|, it adds the prompt position.
         * Only works when editing the command line, thus requires use of
         * |c_CTRL-\_e| or |c_CTRL-R_=| or an expression mapping.
         * Returns 0 otherwise.
         * Also see |getcmdpos()|, |setcmdpos()|, |getcmdline()| and
         * |setcmdline()|.
         */
        getcmdscreenpos: () => number;

        /**
         * Return the current command-line type. Possible return values
         * are:
         *     :  normal Ex command
         *     >  debug mode command |debug-mode|
         *     /  forward search command
         *     ?  backward search command
         *     @  |input()| command
         *     -  |:insert| or |:append| command
         *     =  |i_CTRL-R_=|
         * Only works when editing the command line, thus requires use of
         * |c_CTRL-\_e| or |c_CTRL-R_=| or an expression mapping.
         * Returns an empty string otherwise.
         * Also see |getcmdpos()|, |setcmdpos()| and |getcmdline()|.
         */
        getcmdtype: () => string;

        /**
         * Return the current |command-line-window| type. Possible return
         * values are the same as |getcmdtype()|. Returns an empty string
         * when not in the command-line window.
         */
        getcmdwintype: () => string;

        /**
         * Return a list of command-line completion matches. The String
         * {type} argument specifies what for.  The following completion
         * types are supported:
         * 
         * arglist       file names in argument list
         * augroup       autocmd groups
         * buffer        buffer names
         * behave        |:behave| suboptions
         * breakpoint    |:breakadd| and |:breakdel| suboptions
         * cmdline       |cmdline-completion| result
         * color         color schemes
         * command       Ex command
         * compiler      compilers
         * diff_buffer   |:diffget| and |:diffput| completion
         * dir           directory names
         * environment   environment variable names
         * event         autocommand events
         * expression    Vim expression
         * file          file and directory names
         * file_in_path  file and directory names in |'path'|
         * filetype      filetype names |'filetype'|
         * function      function name
         * help          help subjects
         * highlight     highlight groups
         * history       |:history| suboptions
         * locale        locale names (as output of locale -a)
         * mapclear      buffer argument
         * mapping       mapping name
         * menu          menus
         * messages      |:messages| suboptions
         * option        options
         * packadd       optional package |pack-add| names
         * runtime       |:runtime| completion
         * scriptnames   sourced script names |:scriptnames|
         * shellcmd      Shell command
         * sign          |:sign| suboptions
         * syntax        syntax file names |'syntax'|
         * syntime       |:syntime| suboptions
         * tag           tags
         * tag_listfiles tags, file names
         * user          user names
         * var           user variables
         * 
         * If {pat} is an empty string, then all the matches are
         * returned.  Otherwise only items matching {pat} are returned.
         * See |wildcards| for the use of special characters in {pat}.
         * 
         * If the optional {filtered} flag is set to 1, then 'wildignore'
         * is applied to filter the results.  Otherwise all the matches
         * are returned. The 'wildignorecase' option always applies.
         * 
         * If the 'wildoptions' option contains "fuzzy", then fuzzy
         * matching is used to get the completion matches. Otherwise
         * regular expression matching is used.  Thus this function
         * follows the user preference, what happens on the command line.
         * If you do not want this you can make 'wildoptions' empty
         * before calling getcompletion() and restore it afterwards.
         * 
         * If {type} is "cmdline", then the |cmdline-completion| result is
         * returned.  For example, to complete the possible values after
         * a ":call" command: 
         * ```vim
         *   echo getcompletion('call ', 'cmdline')
         * ```
         * If there are no matches, an empty list is returned.  An
         * invalid value for {type} produces an error.
         * 
         * Can also be used as a |method|: 
         * ```vim
         *   GetPattern()->getcompletion('color')
         * ```
         */
        getcompletion: (pat: string, type: "arglist" | "augroup" | "buffer" | "behave" | "breakpoint" | "cmdline" | "color" | "command" | "compiler" | "diff_buffer" | "dir" | "environment" | "event" | "expression" | "file" | "file_in_path" | "filetype" | "function" | "help" | "highlight" | "history" | "locale" | "mapclear" | "mapping" | "menu" | "messages" | "option" | "packadd" | "runtime" | "scriptnames" | "shellcmd" | "sign" | "syntax" | "syntime" | "tag" | "tag_listfiles" | "user" | "var", filtered?: 1) => string[];

        /**
         * Get the position of the cursor.  This is like getpos('.'), but
         * includes an extra "curswant" item in the list:
         *     [0, lnum, col, off, curswant] ~
         * The "curswant" number is the preferred column when moving the
         * cursor vertically.  After |$| command it will be a very large
         * number equal to |v:maxcol|.  Also see |getcursorcharpos()| and
         * |getpos()|.
         * The first "bufnum" item is always zero. The byte position of
         * the cursor is returned in "col". To get the character
         * position, use |getcursorcharpos()|.
         * 
         * The optional {winid} argument can specify the window.  It can
         * be the window number or the |window-ID|.  The last known
         * cursor position is returned, this may be invalid for the
         * current value of the buffer if it is not the current window.
         * If {winid} is invalid a list with zeroes is returned.
         * 
         * This can be used to save and restore the cursor position: 
         * ```vim
         *   let save_cursor = getcurpos()
         *   MoveTheCursorAround
         *   call setpos('.', save_cursor)
         * ```
         * Note that this only works within the window.  See
         * |winrestview()| for restoring more state.
         * 
         * Can also be used as a |method|: 
         * ```vim
         *   GetWinid()->getcurpos()
         * ```
         */
        getcurpos: (winid?: number) => [number, number, number, number, number];

        /**
         * Same as |getcurpos()| but the column number in the returned
         * List is a character index instead of a byte index.
         * 
         * Example:
         * With the cursor on '보' in line 3 with text "여보세요": 
         * ```vim
         *   getcursorcharpos()  returns [0, 3, 2, 0, 3]
         *   getcurpos()    returns [0, 3, 4, 0, 3]
         * ```
         * Can also be used as a |method|: 
         * ```vim
         *   GetWinid()->getcursorcharpos()
         * ```
         */
        getcursorcharpos: (winid?: number) => [number, number, number, number, number];

        /**
         * With no arguments, returns the name of the effective
         * |current-directory|. With {winnr} or {tabnr} the working
         * directory of that scope is returned, and 'autochdir' is
         * ignored.
         * Tabs and windows are identified by their respective numbers,
         * 0 means current tab or window. Missing tab number implies 0.
         * Thus the following are equivalent: 
         * ```vim
         *   getcwd(0)
         *   getcwd(0, 0)
         * ```
         * If {winnr} is -1 it is ignored, only the tab is resolved.
         * {winnr} can be the window number or the |window-ID|.
         * If both {winnr} and {tabnr} are -1 the global working
         * directory is returned.
         * Throw error if the arguments are invalid. |E5000| |E5001| |E5002|
         * 
         * Can also be used as a |method|: 
         * ```vim
         *   GetWinnr()->getcwd()
         * ```
         */
        getcwd: (winnr?: number, tabnr?: number) => string;

        /**
         * Return the value of environment variable {name}.  The {name}
         * argument is a string, without a leading '$'.  Example: 
         * ```vim
         *   myHome = getenv('HOME')
         * 
         * ```
         * When the variable does not exist |v:null| is returned.  That
         * is different from a variable set to an empty string.
         * See also |expr-env|.
         * 
         * Can also be used as a |method|: 
         * ```vim
         *   GetVarname()->getenv()
         * ```
         */
        getenv: (name: string) => string | NIL;

        /**
         * Without an argument returns the name of the normal font being
         * used.  Like what is used for the Normal highlight group
         * |hl-Normal|.
         * With an argument a check is done whether String {name} is a
         * valid font name.  If not then an empty string is returned.
         * Otherwise the actual font name is returned, or {name} if the
         * GUI does not support obtaining the real name.
         * Only works when the GUI is running, thus not in your vimrc or
         * gvimrc file.  Use the |GUIEnter| autocommand to use this
         * function just after the GUI has started.
         */
        getfontname: (name?: string) => string;

        /**
         * The result is a String, which is the read, write, and execute
         * permissions of the given file {fname}.
         * If {fname} does not exist or its directory cannot be read, an
         * empty string is returned.
         * The result is of the form "rwxrwxrwx", where each group of
         * "rwx" flags represent, in turn, the permissions of the owner
         * of the file, the group the file belongs to, and other users.
         * If a user does not have a given permission the flag for this
         * is replaced with the string "-".  Examples: 
         * ```vim
         *   :echo getfperm("/etc/passwd")
         *   :echo getfperm(expand("~/.config/nvim/init.vim"))
         * ```
         * This will hopefully (from a security point of view) display
         * the string "rw-r--r--" or even "rw-------".
         * 
         * Can also be used as a |method|: 
         * ```vim
         *   GetFilename()->getfperm()
         * ```
         * For setting permissions use |setfperm()|.
         */
        getfperm: (fname: any) => string;

        /**
         * The result is a Number, which is the size in bytes of the
         * given file {fname}.
         * If {fname} is a directory, 0 is returned.
         * If the file {fname} can't be found, -1 is returned.
         * If the size of {fname} is too big to fit in a Number then -2
         * is returned.
         * 
         * Can also be used as a |method|: 
         * ```vim
         *   GetFilename()->getfsize()
         * ```
         */
        getfsize: (fname: any) => number;

        /**
         * The result is a Number, which is the last modification time of
         * the given file {fname}.  The value is measured as seconds
         * since 1st Jan 1970, and may be passed to strftime().  See also
         * |localtime()| and |strftime()|.
         * If the file {fname} can't be found -1 is returned.
         * 
         * Can also be used as a |method|: 
         * ```vim
         *   GetFilename()->getftime()
         * ```
         */
        getftime: (fname: any) => number;

        /**
         * The result is a String, which is a description of the kind of
         * file of the given file {fname}.
         * If {fname} does not exist an empty string is returned.
         * Here is a table over different kinds of files and their
         * results:
         *   Normal file    "file"
         *   Directory    "dir"
         *   Symbolic link    "link"
         *   Block device    "bdev"
         *   Character device  "cdev"
         *   Socket      "socket"
         *   FIFO      "fifo"
         *   All other    "other"
         * Example: 
         * ```vim
         *   getftype("/home")
         * ```
         * Note that a type such as "link" will only be returned on
         * systems that support it.  On some systems only "dir" and
         * "file" are returned.
         * 
         * Can also be used as a |method|: 
         * ```vim
         *   GetFilename()->getftype()
         * ```
         */
        getftype: (fname: any) => string;

        /**
         * Returns the |jumplist| for the specified window.
         * 
         * Without arguments use the current window.
         * With {winnr} only use this window in the current tab page.
         * {winnr} can also be a |window-ID|.
         * With {winnr} and {tabnr} use the window in the specified tab
         * page.  If {winnr} or {tabnr} is invalid, an empty list is
         * returned.
         * 
         * The returned list contains two entries: a list with the jump
         * locations and the last used jump position number in the list.
         * Each entry in the jump location list is a dictionary with
         * the following entries:
         *   bufnr    buffer number
         *   col    column number
         *   coladd    column offset for 'virtualedit'
         *   filename  filename if available
         *   lnum    line number
         * 
         * Can also be used as a |method|: 
         * ```vim
         *   GetWinnr()->getjumplist()
         * 
         * ```
         */
        getjumplist: (winnr?: number, tabnr?: number) => any[];

        /**
         * Without {end} the result is a String, which is line {lnum}
         * from the current buffer.  Example: 
         * ```vim
         *   getline(1)
         * ```
         * When {lnum} is a String that doesn't start with a
         * digit, |line()| is called to translate the String into a Number.
         * To get the line under the cursor: 
         * ```vim
         *   getline(".")
         * ```
         * When {lnum} is a number smaller than 1 or bigger than the
         * number of lines in the buffer, an empty string is returned.
         * 
         * When {end} is given the result is a |List| where each item is
         * a line from the current buffer in the range {lnum} to {end},
         * including line {end}.
         * {end} is used in the same way as {lnum}.
         * Non-existing lines are silently omitted.
         * When {end} is before {lnum} an empty |List| is returned.
         * Example: 
         * ```vim
         *   :let start = line('.')
         *   :let end = search("^$") - 1
         *   :let lines = getline(start, end)
         * 
         * ```
         * Can also be used as a |method|: >
         *   ComputeLnum()->getline()
         * 
         * <    To get lines from another buffer see |getbufline()| and
         * |getbufoneline()|
         */
        getline: (
            ((lnum: number | string, end: number | string) => string[])
            & ((lnum: number | string) => string));

        /**
         * Returns a |List| with all the entries in the location list for
         * window {nr}.  {nr} can be the window number or the |window-ID|.
         * When {nr} is zero the current window is used.
         * 
         * For a location list window, the displayed location list is
         * returned.  For an invalid window number {nr}, an empty list is
         * returned. Otherwise, same as |getqflist()|.
         * 
         * If the optional {what} dictionary argument is supplied, then
         * returns the items listed in {what} as a dictionary. Refer to
         * |getqflist()| for the supported items in {what}.
         * 
         * In addition to the items supported by |getqflist()| in {what},
         * the following item is supported by |getloclist()|:
         * 
         *   filewinid  id of the window used to display files
         *       from the location list. This field is
         *       applicable only when called from a
         *       location list window. See
         *       |location-list-file-window| for more
         *       details.
         * 
         * Returns a |Dictionary| with default values if there is no
         * location list for the window {nr}.
         * Returns an empty Dictionary if window {nr} does not exist.
         * 
         * Examples (See also |getqflist-examples|): 
         * ```vim
         *   :echo getloclist(3, {'all': 0})
         *   :echo getloclist(5, {'filewinid': 0})
         * ```
         */
        getloclist: (nr: number, what?: any) => { [key: string]: any };

        /**
         * Without the {buf} argument returns a |List| with information
         * about all the global marks. |mark|
         * 
         * If the optional {buf} argument is specified, returns the
         * local marks defined in buffer {buf}.  For the use of {buf},
         * see |bufname()|.  If {buf} is invalid, an empty list is
         * returned.
         * 
         * Each item in the returned List is a |Dict| with the following:
         *     mark   name of the mark prefixed by "'"
         *     pos     a |List| with the position of the mark:
         *     [bufnum, lnum, col, off]
         *      Refer to |getpos()| for more information.
         *     file   file name
         * 
         * Refer to |getpos()| for getting information about a specific
         * mark.
         * 
         * Can also be used as a |method|: 
         * ```vim
         *   GetBufnr()->getmarklist()
         * ```
         */
        getmarklist: (buf?: number) => any[];

        /**
         * Returns a |List| with all matches previously defined for the
         * current window by |matchadd()| and the |:match| commands.
         * |getmatches()| is useful in combination with |setmatches()|,
         * as |setmatches()| can restore a list of matches saved by
         * |getmatches()|.
         * If {win} is specified, use the window with this number or
         * window ID instead of the current window.  If {win} is invalid,
         * an empty list is returned.
         * Example: 
         * ```vim
         *   :echo getmatches()
         * ```
         *   [{"group": "MyGroup1", "pattern": "TODO",
         *   "priority": 10, "id": 1}, {"group": "MyGroup2",
         *   "pattern": "FIXME", "priority": 10, "id": 2}] 
         * ```vim
         *   :let m = getmatches()
         *   :call clearmatches()
         *   :echo getmatches()
         * ```
         *   [] >
         *   :call setmatches(m)
         *   :echo getmatches()
         * <      [{"group": "MyGroup1", "pattern": "TODO",
         *   "priority": 10, "id": 1}, {"group": "MyGroup2",
         *   "pattern": "FIXME", "priority": 10, "id": 2}] 
         * ```vim
         *   :unlet m
         * ```
         */
        getmatches: (win?: number) => any[];

        /**
         * Returns a Dictionary with the last known position of the
         * mouse.  This can be used in a mapping for a mouse click.  The
         * items are:
         *   screenrow  screen row
         *   screencol  screen column
         *   winid    Window ID of the click
         *   winrow    row inside "winid"
         *   wincol    column inside "winid"
         *   line    text line inside "winid"
         *   column    text column inside "winid"
         * All numbers are 1-based.
         * 
         * If not over a window, e.g. when in the command line, then only
         * "screenrow" and "screencol" are valid, the others are zero.
         * 
         * When on the status line below a window or the vertical
         * separator right of a window, the "line" and "column" values
         * are zero.
         * 
         * When the position is after the text then "column" is the
         * length of the text in bytes plus one.
         * 
         * If the mouse is over a focusable floating window then that
         * window is used.
         * 
         * When using |getchar()| the Vim variables |v:mouse_lnum|,
         * |v:mouse_col| and |v:mouse_winid| also provide these values.
         */
        getmousepos: () => { [key: string]: any };

        /**
         * Return a Number which is the process ID of the Vim process.
         *   This is a unique number, until Vim exits.
         */
        getpid: () => number;

        /**
         * Get the position for String {expr}.  For possible values of
         *   {expr} see |line()|.  For getting the cursor position see
         *   |getcurpos()|.
         *   The result is a |List| with four numbers:
         *       [bufnum, lnum, col, off]
         *   "bufnum" is zero, unless a mark like '0 or 'A is used, then it
         *   is the buffer number of the mark.
         *   "lnum" and "col" are the position in the buffer.  The first
         *   column is 1.
         *   The "off" number is zero, unless 'virtualedit' is used.  Then
         *   it is the offset in screen columns from the start of the
         *   character.  E.g., a position within a <Tab> or after the last
         *   character.
         *   Note that for '< and '> Visual mode matters: when it is "V"
         *   (visual line mode) the column of '< is zero and the column of
         *   '> is a large number equal to |v:maxcol|.
         *   The column number in the returned List is the byte position
         *   within the line. To get the character position in the line,
         *   use |getcharpos()|.
         *   A very large column number equal to |v:maxcol| can be returned,
         *   in which case it means "after the end of the line".
         *   If {expr} is invalid, returns a list with all zeros.
         *   This can be used to save and restore the position of a mark: 
         * ```vim
         *     let save_a_mark = getpos("'a")
         *     ...
         *     call setpos("'a", save_a_mark)
         * ```
         *   Also see |getcharpos()|, |getcurpos()| and |setpos()|.
         * 
         *   Can also be used as a |method|: 
         * ```vim
         *     GetMark()->getpos()
         * ```
         */
        getpos: (expr: number | string) => [number, number, number, number];

        /**
         * Returns a |List| with all the current quickfix errors.  Each
         * list item is a dictionary with these entries:
         *   bufnr  number of buffer that has the file name, use
         *     bufname() to get the name
         *   module  module name
         *   lnum  line number in the buffer (first line is 1)
         *   end_lnum
         *     end of line number if the item is multiline
         *   col  column number (first column is 1)
         *   end_col  end of column number if the item has range
         *   vcol  |TRUE|: "col" is visual column
         *     |FALSE|: "col" is byte index
         *   nr  error number
         *   pattern  search pattern used to locate the error
         *   text  description of the error
         *   type  type of the error, 'E', '1', etc.
         *   valid  |TRUE|: recognized error message
         * 
         * When there is no error list or it's empty, an empty list is
         * returned. Quickfix list entries with a non-existing buffer
         * number are returned with "bufnr" set to zero (Note: some
         * functions accept buffer number zero for the alternate buffer,
         * you may need to explicitly check for zero).
         * 
         * Useful application: Find pattern matches in multiple files and
         * do something with them: 
         * ```vim
         *   :vimgrep /theword/jg *.c
         *   :for d in getqflist()
         *   :   echo bufname(d.bufnr) ':' d.lnum '=' d.text
         *   :endfor
         * ```
         * If the optional {what} dictionary argument is supplied, then
         * returns only the items listed in {what} as a dictionary. The
         * following string items are supported in {what}:
         *   changedtick  get the total number of changes made
         *       to the list |quickfix-changedtick|
         *   context  get the |quickfix-context|
         *   efm  errorformat to use when parsing "lines". If
         *     not present, then the 'errorformat' option
         *     value is used.
         *   id  get information for the quickfix list with
         *     |quickfix-ID|; zero means the id for the
         *     current list or the list specified by "nr"
         *   idx  get information for the quickfix entry at this
         *     index in the list specified by "id" or "nr".
         *     If set to zero, then uses the current entry.
         *     See |quickfix-index|
         *   items  quickfix list entries
         *   lines  parse a list of lines using 'efm' and return
         *     the resulting entries.  Only a |List| type is
         *     accepted.  The current quickfix list is not
         *     modified. See |quickfix-parse|.
         *   nr  get information for this quickfix list; zero
         *     means the current quickfix list and "$" means
         *     the last quickfix list
         *   qfbufnr number of the buffer displayed in the quickfix
         *     window. Returns 0 if the quickfix buffer is
         *     not present. See |quickfix-buffer|.
         *   size  number of entries in the quickfix list
         *   title  get the list title |quickfix-title|
         *   winid  get the quickfix |window-ID|
         *   all  all of the above quickfix properties
         * Non-string items in {what} are ignored. To get the value of a
         * particular item, set it to zero.
         * If "nr" is not present then the current quickfix list is used.
         * If both "nr" and a non-zero "id" are specified, then the list
         * specified by "id" is used.
         * To get the number of lists in the quickfix stack, set "nr" to
         * "$" in {what}. The "nr" value in the returned dictionary
         * contains the quickfix stack size.
         * When "lines" is specified, all the other items except "efm"
         * are ignored.  The returned dictionary contains the entry
         * "items" with the list of entries.
         * 
         * The returned dictionary contains the following entries:
         *   changedtick  total number of changes made to the
         *       list |quickfix-changedtick|
         *   context  quickfix list context. See |quickfix-context|
         *     If not present, set to "".
         *   id  quickfix list ID |quickfix-ID|. If not
         *     present, set to 0.
         *   idx  index of the quickfix entry in the list. If not
         *     present, set to 0.
         *   items  quickfix list entries. If not present, set to
         *     an empty list.
         *   nr  quickfix list number. If not present, set to 0
         *   qfbufnr  number of the buffer displayed in the quickfix
         *     window. If not present, set to 0.
         *   size  number of entries in the quickfix list. If not
         *     present, set to 0.
         *   title  quickfix list title text. If not present, set
         *     to "".
         *   winid  quickfix |window-ID|. If not present, set to 0
         * 
         * Examples (See also |getqflist-examples|): 
         * ```vim
         *   :echo getqflist({'all': 1})
         *   :echo getqflist({'nr': 2, 'title': 1})
         *   :echo getqflist({'lines' : ["F1:10:L10"]})
         * ```
         */
        getqflist: (what?: any) => { [key: string]: any };

        /**
         * The result is a String, which is the contents of register
         * {regname}.  Example: 
         * ```vim
         *   :let cliptext = getreg('*')
         * ```
         * When register {regname} was not set the result is an empty
         * string.
         * The {regname} argument must be a string.
         * 
         * getreg('=') returns the last evaluated value of the expression
         * register.  (For use in maps.)
         * getreg('=', 1) returns the expression itself, so that it can
         * be restored with |setreg()|.  For other registers the extra
         * argument is ignored, thus you can always give it.
         * 
         * If {list} is present and |TRUE|, the result type is changed
         * to |List|. Each list item is one text line. Use it if you care
         * about zero bytes possibly present inside register: without
         * third argument both NLs and zero bytes are represented as NLs
         * (see |NL-used-for-Nul|).
         * When the register was not set an empty list is returned.
         * 
         * If {regname} is not specified, |v:register| is used.
         * 
         * Can also be used as a |method|: 
         * ```vim
         *   GetRegname()->getreg()
         * ```
         */
        getreg: (regname?: any, p1?: any, list?: any[]) => string;

        /**
         * Returns detailed information about register {regname} as a
         * Dictionary with the following entries:
         *   regcontents  List of lines contained in register
         *       {regname}, like
         *       getreg({regname}, 1, 1).
         *   regtype    the type of register {regname}, as in
         *       |getregtype()|.
         *   isunnamed  Boolean flag, v:true if this register
         *       is currently pointed to by the unnamed
         *       register.
         *   points_to  for the unnamed register, gives the
         *       single letter name of the register
         *       currently pointed to (see |quotequote|).
         *       For example, after deleting a line
         *       with `dd`, this field will be "1",
         *       which is the register that got the
         *       deleted text.
         * 
         * The {regname} argument is a string.  If {regname} is invalid
         * or not set, an empty Dictionary will be returned.
         * If {regname} is not specified, |v:register| is used.
         * The returned Dictionary can be passed to |setreg()|.
         * 
         * Can also be used as a |method|: 
         * ```vim
         *   GetRegname()->getreginfo()
         * ```
         */
        getreginfo: (regname?: any) => { [key: string]: any };

        /**
         * The result is a String, which is type of register {regname}.
         * The value will be one of:
         *     "v"      for |charwise| text
         *     "V"      for |linewise| text
         *     "<CTRL-V>{width}"  for |blockwise-visual| text
         *     ""      for an empty or unknown register
         * <CTRL-V> is one character with value 0x16.
         * The {regname} argument is a string.  If {regname} is not
         * specified, |v:register| is used.
         * 
         * Can also be used as a |method|: 
         * ```vim
         *   GetRegname()->getregtype()
         * ```
         */
        getregtype: (regname?: any) => string;

        /**
         * Returns a |List| with information about all the sourced Vim
         * scripts in the order they were sourced.
         * 
         * Each item in the returned List is a |Dict| with the following
         * items:
         *     autoload  always set to FALSE.
         *     name  vim script file name.
         *     sid    script ID |<SID>|.
         */
        getscriptinfo: () => any[];

        /**
         * If {tabnr} is not specified, then information about all the
         * tab pages is returned as a |List|. Each List item is a
         * |Dictionary|.  Otherwise, {tabnr} specifies the tab page
         * number and information about that one is returned.  If the tab
         * page does not exist an empty List is returned.
         * 
         * Each List item is a |Dictionary| with the following entries:
         *   tabnr    tab page number.
         *   variables  a reference to the dictionary with
         *       tabpage-local variables
         *   windows    List of |window-ID|s in the tab page.
         * 
         * Can also be used as a |method|: 
         * ```vim
         *   GetTabnr()->gettabinfo()
         * ```
         */
        gettabinfo: (tabnr?: number) => any[];

        /**
         * Get the value of a tab-local variable {varname} in tab page
         * {tabnr}. |t:var|
         * Tabs are numbered starting with one.
         * The {varname} argument is a string.  When {varname} is empty a
         * dictionary with all tab-local variables is returned.
         * Note that the name without "t:" must be used.
         * When the tab or variable doesn't exist {def} or an empty
         * string is returned, there is no error message.
         * 
         * Can also be used as a |method|: 
         * ```vim
         *   GetTabnr()->gettabvar(varname)
         * ```
         */
        gettabvar: (tabnr: number, varname: any, def?: any) => any;

        /**
         * Get the value of window-local variable {varname} in window
         * {winnr} in tab page {tabnr}.
         * The {varname} argument is a string.  When {varname} is empty a
         * dictionary with all window-local variables is returned.
         * When {varname} is equal to "&" get the values of all
         * window-local options in a |Dictionary|.
         * Otherwise, when {varname} starts with "&" get the value of a
         * window-local option.
         * Note that {varname} must be the name without "w:".
         * Tabs are numbered starting with one.  For the current tabpage
         * use |getwinvar()|.
         * {winnr} can be the window number or the |window-ID|.
         * When {winnr} is zero the current window is used.
         * This also works for a global option, buffer-local option and
         * window-local option, but it doesn't work for a global variable
         * or buffer-local variable.
         * When the tab, window or variable doesn't exist {def} or an
         * empty string is returned, there is no error message.
         * Examples: 
         * ```vim
         *   :let list_is_on = gettabwinvar(1, 2, '&list')
         *   :echo "myvar = " .. gettabwinvar(3, 1, 'myvar')
         * ```
         * To obtain all window-local variables use: 
         * ```vim
         *   gettabwinvar({tabnr}, {winnr}, '&')
         * 
         * ```
         * Can also be used as a |method|: >
         *   GetTabnr()->gettabwinvar(winnr, varname)
         */
        gettabwinvar: (tabnr: number, winnr: number, varname: any, def?: any) => any;

        /**
         * The result is a Dict, which is the tag stack of window {winnr}.
         * {winnr} can be the window number or the |window-ID|.
         * When {winnr} is not specified, the current window is used.
         * When window {winnr} doesn't exist, an empty Dict is returned.
         * 
         * The returned dictionary contains the following entries:
         *   curidx    Current index in the stack. When at
         *       top of the stack, set to (length + 1).
         *       Index of bottom of the stack is 1.
         *   items    List of items in the stack. Each item
         *       is a dictionary containing the
         *       entries described below.
         *   length    Number of entries in the stack.
         * 
         * Each item in the stack is a dictionary with the following
         * entries:
         *   bufnr    buffer number of the current jump
         *   from    cursor position before the tag jump.
         *       See |getpos()| for the format of the
         *       returned list.
         *   matchnr    current matching tag number. Used when
         *       multiple matching tags are found for a
         *       name.
         *   tagname    name of the tag
         * 
         * See |tagstack| for more information about the tag stack.
         * 
         * Can also be used as a |method|: 
         * ```vim
         *   GetWinnr()->gettagstack()
         * ```
         */
        gettagstack: (winnr?: number) => { [key: string]: any };

        /**
         * Translate String {text} if possible.
         * This is mainly for use in the distributed Vim scripts.  When
         * generating message translations the {text} is extracted by
         * xgettext, the translator can add the translated message in the
         * .po file and Vim will lookup the translation when gettext() is
         * called.
         * For {text} double quoted strings are preferred, because
         * xgettext does not understand escaping in single quoted
         * strings.
         */
        gettext: (text: string) => string;

        /**
         * Returns information about windows as a |List| with Dictionaries.
         * 
         * If {winid} is given Information about the window with that ID
         * is returned, as a |List| with one item.  If the window does not
         * exist the result is an empty list.
         * 
         * Without {winid} information about all the windows in all the
         * tab pages is returned.
         * 
         * Each List item is a |Dictionary| with the following entries:
         *   botline    last complete displayed buffer line
         *   bufnr    number of buffer in the window
         *   height    window height (excluding winbar)
         *   loclist    1 if showing a location list
         *   quickfix  1 if quickfix or location list window
         *   terminal  1 if a terminal window
         *   tabnr    tab page number
         *   topline    first displayed buffer line
         *   variables  a reference to the dictionary with
         *       window-local variables
         *   width    window width
         *   winbar    1 if the window has a toolbar, 0
         *       otherwise
         *   wincol    leftmost screen column of the window;
         *       "col" from |win_screenpos()|
         *   textoff    number of columns occupied by any
         *       'foldcolumn', 'signcolumn' and line
         *       number in front of the text
         *   winid    |window-ID|
         *   winnr    window number
         *   winrow    topmost screen line of the window;
         *       "row" from |win_screenpos()|
         * 
         * Can also be used as a |method|: 
         * ```vim
         *   GetWinnr()->getwininfo()
         * ```
         */
        getwininfo: (winid?: number) => any[];

        /**
         * The result is a |List| with two numbers, the result of
         * |getwinposx()| and |getwinposy()| combined:
         *   [x-pos, y-pos]
         * {timeout} can be used to specify how long to wait in msec for
         * a response from the terminal.  When omitted 100 msec is used.
         * 
         * Use a longer time for a remote terminal.
         * When using a value less than 10 and no response is received
         * within that time, a previously reported position is returned,
         * if available.  This can be used to poll for the position and
         * do some work in the meantime: 
         * ```vim
         *   while 1
         *     let res = getwinpos(1)
         *     if res[0] >= 0
         *       break
         *     endif
         *     " Do some work here
         *   endwhile
         * ```
         * Can also be used as a |method|: 
         * ```vim
         *   GetTimeout()->getwinpos()
         * ```
         */
        getwinpos: (timeout?: any) => any[];

        /**
         * The result is a Number, which is the X coordinate in pixels of
         *   the left hand side of the GUI Vim window.  The result will be
         *   -1 if the information is not available.
         *   The value can be used with `:winpos`.
         */
        getwinposx: () => number;

        /**
         * The result is a Number, which is the Y coordinate in pixels of
         *   the top of the GUI Vim window.  The result will be -1 if the
         *   information is not available.
         *   The value can be used with `:winpos`.
         */
        getwinposy: () => number;

        /**
         * Like |gettabwinvar()| for the current tabpage.
         * Examples: 
         * ```vim
         *   :let list_is_on = getwinvar(2, '&list')
         *   :echo "myvar = " .. getwinvar(1, 'myvar')
         * 
         * ```
         * Can also be used as a |method|: >
         *   GetWinnr()->getwinvar(varname)
         * <
         */
        getwinvar: (winnr: number, varname: any, def?: any) => any;

        /**
         * Expand the file wildcards in {expr}.  See |wildcards| for the
         * use of special characters.
         * 
         * Unless the optional {nosuf} argument is given and is |TRUE|,
         * the 'suffixes' and 'wildignore' options apply: Names matching
         * one of the patterns in 'wildignore' will be skipped and
         * 'suffixes' affect the ordering of matches.
         * 'wildignorecase' always applies.
         * 
         * When {list} is present and it is |TRUE| the result is a |List|
         * with all matching files. The advantage of using a List is,
         * you also get filenames containing newlines correctly.
         * Otherwise the result is a String and when there are several
         * matches, they are separated by <NL> characters.
         * 
         * If the expansion fails, the result is an empty String or List.
         * 
         * You can also use |readdir()| if you need to do complicated
         * things, such as limiting the number of matches.
         * 
         * A name for a non-existing file is not included.  A symbolic
         * link is only included if it points to an existing file.
         * However, when the {alllinks} argument is present and it is
         * |TRUE| then all symbolic links are included.
         * 
         * For most systems backticks can be used to get files names from
         * any external command.  Example: 
         * ```vim
         *   :let tagfiles = glob("`find . -name tags -print`")
         *   :let &tags = substitute(tagfiles, "\n", ",", "g")
         * ```
         * The result of the program inside the backticks should be one
         * item per line.  Spaces inside an item are allowed.
         * 
         * See |expand()| for expanding special Vim variables.  See
         * |system()| for getting the raw output of an external command.
         * 
         * Can also be used as a |method|: 
         * ```vim
         *   GetExpr()->glob()
         * ```
         */
        glob: (expr: any, nosuf?: any, list?: any[], alllinks?: any) => any;

        /**
         * Convert a file pattern, as used by glob(), into a search
         * pattern.  The result can be used to match with a string that
         * is a file name.  E.g. 
         * ```vim
         *   if filename =~ glob2regpat('Make*.mak')
         * ```
         * This is equivalent to: >
         *   if filename =~ '^Make.*\.mak$'
         * <    When {string} is an empty string the result is "^$", match an
         * empty string.
         * Note that the result depends on the system.  On MS-Windows
         * a backslash usually means a path separator.
         * 
         * Can also be used as a |method|: 
         * ```vim
         *   GetExpr()->glob2regpat()
         * ```
         */
        glob2regpat: (string: string) => string;

        /**
         * Perform glob() for String {expr} on all directories in {path}
         * and concatenate the results.  Example: 
         * ```vim
         *   :echo globpath(&rtp, "syntax/c.vim")
         * ```
         * {path} is a comma-separated list of directory names.  Each
         * directory name is prepended to {expr} and expanded like with
         * |glob()|.  A path separator is inserted when needed.
         * To add a comma inside a directory name escape it with a
         * backslash.  Note that on MS-Windows a directory may have a
         * trailing backslash, remove it if you put a comma after it.
         * If the expansion fails for one of the directories, there is no
         * error message.
         * 
         * Unless the optional {nosuf} argument is given and is |TRUE|,
         * the 'suffixes' and 'wildignore' options apply: Names matching
         * one of the patterns in 'wildignore' will be skipped and
         * 'suffixes' affect the ordering of matches.
         * 
         * When {list} is present and it is |TRUE| the result is a |List|
         * with all matching files. The advantage of using a List is, you
         * also get filenames containing newlines correctly. Otherwise
         * the result is a String and when there are several matches,
         * they are separated by <NL> characters.  Example: 
         * ```vim
         *   :echo globpath(&rtp, "syntax/c.vim", 0, 1)
         * ```
         * {allinks} is used as with |glob()|.
         * 
         * The "" item can be used to search in a directory tree.
         * For example, to find all "README.txt" files in the directories
         * in 'runtimepath' and below: 
         * ```vim
         *   :echo globpath(&rtp, "/README.txt")
         * ```
         * Upwards search and limiting the depth of "" is not
         * supported, thus using 'path' will not always work properly.
         * 
         * Can also be used as a |method|, the base is passed as the
         * second argument: 
         * ```vim
         *   GetExpr()->globpath(&rtp)
         * ```
         */
        globpath: (path: any, expr: any, nosuf?: any, list?: any[], allinks?: any) => string;

        /**
         * Returns 1 if {feature} is supported, 0 otherwise.  The
         *   {feature} argument is a feature name like "nvim-0.2.1" or
         *   "win32", see below.  See also |exists()|.
         * 
         *   To get the system name use |vim.loop|.os_uname() in Lua: 
         * ```vim
         *     :lua print(vim.loop.os_uname().sysname)
         * 
         * ```
         *   If the code has a syntax error then Vimscript may skip the
         *   rest of the line.  Put |:if| and |:endif| on separate lines to
         *   avoid the syntax error: 
         * ```vim
         *     if has('feature')
         *       let x = this->breaks->without->the->feature
         *     endif
         * ```
         *   Vim's compile-time feature-names (prefixed with "+") are not
         *   recognized because Nvim is always compiled with all possible
         *   features. |feature-compile|
         * 
         *   Feature names can be:
         *   1.  Nvim version. For example the "nvim-0.2.1" feature means
         *       that Nvim is version 0.2.1 or later: 
         * ```vim
         *     :if has("nvim-0.2.1")
         * 
         * ```
         *   2.  Runtime condition or other pseudo-feature. For example the
         *       "win32" feature checks if the current system is Windows: 
         * ```vim
         *     :if has("win32")
         * ```
         *       List of supported pseudo-feature names:
         *     acl    |ACL| support.
         *     bsd    BSD system (not macOS, use "mac" for that).
         *     clipboard  |clipboard| provider is available.
         *     fname_case  Case in file names matters (for Darwin and MS-Windows
         *         this is not present).
         *                       gui_running  Nvim has a GUI.
         *     iconv    Can use |iconv()| for conversion.
         *     linux    Linux system.
         *     mac    MacOS system.
         *     nvim    This is Nvim.
         *     python3    Legacy Vim |python3| interface. |has-python|
         *     pythonx    Legacy Vim |python_x| interface. |has-pythonx|
         *     sun    SunOS system.
         *     ttyin    input is a terminal (tty).
         *     ttyout    output is a terminal (tty).
         *     unix    Unix system.
         *       True during |startup|.
         *     win32    Windows system (32 or 64 bit).
         *     win64    Windows system (64 bit).
         *     wsl    WSL (Windows Subsystem for Linux) system.
         * 
         * 
         *   3.  Vim patch. For example the "patch123" feature means that
         *       Vim patch 123 at the current |v:version| was included: 
         * ```vim
         *     :if v:version > 602 || v:version == 602 && has("patch148")
         * 
         * ```
         *   4.  Vim version. For example the "patch-7.4.237" feature means
         *       that Nvim is Vim-compatible to version 7.4.237 or later. 
         * ```vim
         *     :if has("patch-7.4.237")
         * ```
         */
        has: (feature: any) => number;

        /**
         * The result is a Number, which is TRUE if |Dictionary| {dict}
         * has an entry with key {key}.  FALSE otherwise. The {key}
         * argument is a string.
         * 
         * Can also be used as a |method|: 
         * ```vim
         *   mydict->has_key(key)
         * ```
         */
        has_key: (dict: { [key: string]: any }, key: any) => number;

        /**
         * The result is a Number, which is 1 when the window has set a
         * local path via |:lcd| or when {winnr} is -1 and the tabpage
         * has set a local path via |:tcd|, otherwise 0.
         * 
         * Tabs and windows are identified by their respective numbers,
         * 0 means current tab or window. Missing argument implies 0.
         * Thus the following are equivalent: 
         * ```vim
         *   haslocaldir()
         *   haslocaldir(0)
         *   haslocaldir(0, 0)
         * ```
         * With {winnr} use that window in the current tabpage.
         * With {winnr} and {tabnr} use the window in that tabpage.
         * {winnr} can be the window number or the |window-ID|.
         * If {winnr} is -1 it is ignored, only the tab is resolved.
         * Throw error if the arguments are invalid. |E5000| |E5001| |E5002|
         * 
         * Can also be used as a |method|: 
         * ```vim
         *   GetWinnr()->haslocaldir()
         * ```
         */
        haslocaldir: (winnr?: number, tabnr?: number) => number;

        /**
         * The result is a Number, which is TRUE if there is a mapping
         * that contains {what} in somewhere in the rhs (what it is
         * mapped to) and this mapping exists in one of the modes
         * indicated by {mode}.
         * The arguments {what} and {mode} are strings.
         * When {abbr} is there and it is |TRUE| use abbreviations
         * instead of mappings.  Don't forget to specify Insert and/or
         * Command-line mode.
         * Both the global mappings and the mappings local to the current
         * buffer are checked for a match.
         * If no matching mapping is found FALSE is returned.
         * The following characters are recognized in {mode}:
         *   n  Normal mode
         *   v  Visual and Select mode
         *   x  Visual mode
         *   s  Select mode
         *   o  Operator-pending mode
         *   i  Insert mode
         *   l  Language-Argument ("r", "f", "t", etc.)
         *   c  Command-line mode
         * When {mode} is omitted, "nvo" is used.
         * 
         * This function is useful to check if a mapping already exists
         * to a function in a Vim script.  Example: 
         * ```vim
         *   :if !hasmapto('\ABCdoit')
         *   :   map <Leader>d \ABCdoit
         *   :endif
         * ```
         * This installs the mapping to "\ABCdoit" only if there isn't
         * already a mapping to "\ABCdoit".
         * 
         * Can also be used as a |method|: 
         * ```vim
         *   GetRHS()->hasmapto()
         * ```
         */
        hasmapto: (what: any, mode?: any, abbr?: any) => number;

        /**
         * Add the String {item} to the history {history} which can be
         * one of:
         *   "cmd"   or ":"    command line history
         *   "search" or "/"   search pattern history
         *   "expr"   or "="   typed expression history
         *   "input"  or "@"    input line history
         *   "debug"  or ">"   debug command history
         *   empty      the current or last used history
         * The {history} string does not need to be the whole name, one
         * character is sufficient.
         * If {item} does already exist in the history, it will be
         * shifted to become the newest entry.
         * The result is a Number: TRUE if the operation was successful,
         * otherwise FALSE is returned.
         * 
         * Example: 
         * ```vim
         *   :call histadd("input", strftime("%Y %b %d"))
         *   :let date=input("Enter date: ")
         * ```
         * This function is not available in the |sandbox|.
         * 
         * Can also be used as a |method|, the base is passed as the
         * second argument: 
         * ```vim
         *   GetHistory()->histadd('search')
         * ```
         */
        histadd: (history: any, item: any) => number;

        /**
         * Clear {history}, i.e. delete all its entries.  See |hist-names|
         * for the possible values of {history}.
         * 
         * If the parameter {item} evaluates to a String, it is used as a
         * regular expression.  All entries matching that expression will
         * be removed from the history (if there are any).
         * Upper/lowercase must match, unless "\c" is used |/\c|.
         * If {item} evaluates to a Number, it will be interpreted as
         * an index, see |:history-indexing|.  The respective entry will
         * be removed if it exists.
         * 
         * The result is TRUE for a successful operation, otherwise FALSE
         * is returned.
         * 
         * Examples:
         * Clear expression register history: 
         * ```vim
         *   :call histdel("expr")
         * ```
         * Remove all entries starting with "*" from the search history: 
         * ```vim
         *   :call histdel("/", '^\*')
         * ```
         * The following three are equivalent: 
         * ```vim
         *   :call histdel("search", histnr("search"))
         *   :call histdel("search", -1)
         *   :call histdel("search", '^' .. histget("search", -1) .. '$')
         * ```
         * To delete the last search pattern and use the last-but-one for
         * the "n" command and 'hlsearch': 
         * ```vim
         *   :call histdel("search", -1)
         *   :let @/ = histget("search", -1)
         * ```
         * Can also be used as a |method|: 
         * ```vim
         *   GetHistory()->histdel()
         * ```
         */
        histdel: (history: any, item?: any) => number;

        /**
         * The result is a String, the entry with Number {index} from
         * {history}.  See |hist-names| for the possible values of
         * {history}, and |:history-indexing| for {index}.  If there is
         * no such entry, an empty String is returned.  When {index} is
         * omitted, the most recent item from the history is used.
         * 
         * Examples:
         * Redo the second last search from history. 
         * ```vim
         *   :execute '/' .. histget("search", -2)
         * 
         * ```
         * Define an Ex command ":H {num}" that supports re-execution of
         * the {num}th entry from the output of |:history|. 
         * ```vim
         *   :command -nargs=1 H execute histget("cmd", 0+<args>)
         * ```
         * Can also be used as a |method|: 
         * ```vim
         *   GetHistory()->histget()
         * ```
         */
        histget: (history: any, index?: number) => string;

        /**
         * The result is the Number of the current entry in {history}.
         * See |hist-names| for the possible values of {history}.
         * If an error occurred, -1 is returned.
         * 
         * Example: 
         * ```vim
         *   :let inp_index = histnr("expr")
         * 
         * ```
         * Can also be used as a |method|: >
         *   GetHistory()->histnr()
         * <
         */
        histnr: (history: any) => number;

        /**
         * The result is a Number, which is the ID of the highlight group
         *   with name {name}.  When the highlight group doesn't exist,
         *   zero is returned.
         *   This can be used to retrieve information about the highlight
         *   group.  For example, to get the background color of the
         *   "Comment" group: 
         * ```vim
         * :echo synIDattr(synIDtrans(hlID("Comment")), "bg")
         * ```
         *   Can also be used as a |method|: 
         * ```vim
         *     GetName()->hlID()
         * ```
         */
        hlID: (name: any) => number;

        /**
         * The result is a Number, which is TRUE if a highlight group
         * called {name} exists.  This is when the group has been
         * defined in some way.  Not necessarily when highlighting has
         * been defined for it, it may also have been used for a syntax
         * item.
         * 
         * Can also be used as a |method|: 
         * ```vim
         *   GetName()->hlexists()
         * ```
         */
        hlexists: (name: any) => number;

        /**
         * The result is a String, which is the name of the machine on
         * which Vim is currently running.  Machine names greater than
         * 256 characters long are truncated.
         */
        hostname: () => string;

        /**
         * The result is a String, which is the text {string} converted
         * from encoding {from} to encoding {to}.
         * When the conversion completely fails an empty string is
         * returned.  When some characters could not be converted they
         * are replaced with "?".
         * The encoding names are whatever the iconv() library function
         * can accept, see ":!man 3 iconv".
         * Note that Vim uses UTF-8 for all Unicode encodings, conversion
         * from/to UCS-2 is automatically changed to use UTF-8.  You
         * cannot use UCS-2 in a string anyway, because of the NUL bytes.
         * 
         * Can also be used as a |method|: 
         * ```vim
         *   GetText()->iconv('latin1', 'utf-8')
         * ```
         */
        iconv: (string: string, from: number, to: number) => string;

        /**
         * Returns a |String| which is a unique identifier of the
         * container type (|List|, |Dict|, |Blob| and |Partial|). It is
         * guaranteed that for the mentioned types `id(v1) ==# id(v2)`
         * returns true iff `type(v1) == type(v2) && v1 is v2`.
         * Note that |v:_null_string|, |v:_null_list|, |v:_null_dict| and
         * |v:_null_blob| have the same `id()` with different types
         * because they are internally represented as NULL pointers.
         * `id()` returns a hexadecimal representanion of the pointers to
         * the containers (i.e. like `0x994a40`), same as `printf("%p",
         * {expr})`, but it is advised against counting on the exact
         * format of the return value.
         * 
         * It is not guaranteed that `id(no_longer_existing_container)`
         * will not be equal to some other `id()`: new containers may
         * reuse identifiers of the garbage-collected ones.
         */
        id: (expr: any) => string;

        /**
         * The result is a Number, which is indent of line {lnum} in the
         *   current buffer.  The indent is counted in spaces, the value
         *   of 'tabstop' is relevant.  {lnum} is used just like in
         *   |getline()|.
         *   When {lnum} is invalid -1 is returned.
         * 
         *   Can also be used as a |method|: 
         * ```vim
         *     GetLnum()->indent()
         * ```
         */
        indent: (lnum: number) => number;

        /**
         * Find {expr} in {object} and return its index.  See
         * |indexof()| for using a lambda to select the item.
         * 
         * If {object} is a |List| return the lowest index where the item
         * has a value equal to {expr}.  There is no automatic
         * conversion, so the String "4" is different from the Number 4.
         * And the Number 4 is different from the Float 4.0.  The value
         * of 'ignorecase' is not used here, case matters as indicated by
         * the {ic} argument.
         * 
         * If {object} is a |Blob| return the lowest index where the byte
         * value is equal to {expr}.
         * 
         * If {start} is given then start looking at the item with index
         * {start} (may be negative for an item relative to the end).
         * 
         * When {ic} is given and it is |TRUE|, ignore case.  Otherwise
         * case must match.
         * 
         * -1 is returned when {expr} is not found in {object}.
         * Example: 
         * ```vim
         *   :let idx = index(words, "the")
         *   :if index(numbers, 123) >= 0
         * 
         * ```
         * Can also be used as a |method|: >
         *   GetObject()->index(what)
         */
        index: (object: any, expr: any, start?: number, ic?: any) => number;

        /**
         * Returns the index of an item in {object} where {expr} is
         * v:true.  {object} must be a |List| or a |Blob|.
         * 
         * If {object} is a |List|, evaluate {expr} for each item in the
         * List until the expression is v:true and return the index of
         * this item.
         * 
         * If {object} is a |Blob| evaluate {expr} for each byte in the
         * Blob until the expression is v:true and return the index of
         * this byte.
         * 
         * {expr} must be a |string| or |Funcref|.
         * 
         * If {expr} is a |string|: If {object} is a |List|, inside
         * {expr} |v:key| has the index of the current List item and
         * |v:val| has the value of the item.  If {object} is a |Blob|,
         * inside {expr} |v:key| has the index of the current byte and
         * |v:val| has the byte value.
         * 
         * If {expr} is a |Funcref| it must take two arguments:
         *   1. the key or the index of the current item.
         *   2. the value of the current item.
         * The function must return |TRUE| if the item is found and the
         * search should stop.
         * 
         * The optional argument {opts} is a Dict and supports the
         * following items:
         *     startidx  start evaluating {expr} at the item with this
         *     index; may be negative for an item relative to
         *     the end
         * Returns -1 when {expr} evaluates to v:false for all the items.
         * Example: 
         * ```vim
         *   :let l = [#{n: 10}, #{n: 20}, #{n: 30}]
         *   :echo indexof(l, "v:val.n == 20")
         *   :echo indexof(l, {i, v -> v.n == 30})
         *   :echo indexof(l, "v:val.n == 20", #{startidx: 1})
         * 
         * ```
         * Can also be used as a |method|: >
         *   mylist->indexof(expr)
         */
        indexof: (object: any, expr: any, opts?: { [key: string]: any }) => number;

        /**
         * The result is a String, which is whatever the user typed on
         * the command-line.  The {prompt} argument is either a prompt
         * string, or a blank string (for no prompt).  A '\n' can be used
         * in the prompt to start a new line.
         * 
         * In the second form it accepts a single dictionary with the
         * following keys, any of which may be omitted:
         * 
         * Key           Default  Description ~
         * prompt        ""       Same as {prompt} in the first form.
         * default       ""       Same as {text} in the first form.
         * completion    nothing  Same as {completion} in the first form.
         * cancelreturn  ""       The value returned when the dialog is
         *                        cancelled.
         * highlight     nothing  Highlight handler: |Funcref|.
         * 
         * The highlighting set with |:echohl| is used for the prompt.
         * The input is entered just like a command-line, with the same
         * editing commands and mappings.  There is a separate history
         * for lines typed for input().
         * Example: 
         * ```vim
         *   :if input("Coffee or beer? ") == "beer"
         *   :  echo "Cheers!"
         *   :endif
         * ```
         * If the optional {text} argument is present and not empty, this
         * is used for the default reply, as if the user typed this.
         * Example: 
         * ```vim
         *   :let color = input("Color? ", "white")
         * 
         * ```
         * The optional {completion} argument specifies the type of
         * completion supported for the input.  Without it completion is
         * not performed.  The supported completion types are the same as
         * that can be supplied to a user-defined command using the
         * "-complete=" argument.  Refer to |:command-completion| for
         * more information.  Example: 
         * ```vim
         *   let fname = input("File: ", "", "file")
         * 
         * ```
         * The optional `highlight` key allows specifying function which
         * will be used for highlighting user input.  This function
         * receives user input as its only argument and must return
         * a list of 3-tuples [hl_start_col, hl_end_col + 1, hl_group]
         * where
         *   hl_start_col is the first highlighted column,
         *   hl_end_col is the last highlighted column (+ 1!),
         *   hl_group is |:hi| group used for highlighting.
         * 
         * Both hl_start_col and hl_end_col + 1 must point to the start
         * of the multibyte character (highlighting must not break
         * multibyte characters), hl_end_col + 1 may be equal to the
         * input length.  Start column must be in range [0, len(input)),
         * end column must be in range (hl_start_col, len(input)],
         * sections must be ordered so that next hl_start_col is greater
         * then or equal to previous hl_end_col.
         * 
         * Example (try some input with parentheses): 
         * ```vim
         *   highlight RBP1 guibg=Red ctermbg=red
         *   highlight RBP2 guibg=Yellow ctermbg=yellow
         *   highlight RBP3 guibg=Green ctermbg=green
         *   highlight RBP4 guibg=Blue ctermbg=blue
         *   let g:rainbow_levels = 4
         *   function! RainbowParens(cmdline)
         *     let ret = []
         *     let i = 0
         *     let lvl = 0
         *     while i < len(a:cmdline)
         *       if a:cmdline[i] is# '('
         *         call add(ret, [i, i + 1, 'RBP' .. ((lvl % g:rainbow_levels) + 1)])
         *         let lvl += 1
         *       elseif a:cmdline[i] is# ')'
         *         let lvl -= 1
         *         call add(ret, [i, i + 1, 'RBP' .. ((lvl % g:rainbow_levels) + 1)])
         *       endif
         *       let i += 1
         *     endwhile
         *     return ret
         *   endfunction
         *   call input({'prompt':'>','highlight':'RainbowParens'})
         * ```
         * Highlight function is called at least once for each new
         * displayed input string, before command-line is redrawn.  It is
         * expected that function is pure for the duration of one input()
         * call, i.e. it produces the same output for the same input, so
         * output may be memoized.  Function is run like under |:silent|
         * modifier. If the function causes any errors, it will be
         * skipped for the duration of the current input() call.
         * 
         * Highlighting is disabled if command-line contains arabic
         * characters.
         * 
         * NOTE: This function must not be used in a startup file, for
         * the versions that only run in GUI mode (e.g., the Win32 GUI).
         * Note: When input() is called from within a mapping it will
         * consume remaining characters from that mapping, because a
         * mapping is handled like the characters were typed.
         * Use |inputsave()| before input() and |inputrestore()|
         * after input() to avoid that.  Another solution is to avoid
         * that further characters follow in the mapping, e.g., by using
         * |:execute| or |:normal|.
         * 
         * Example with a mapping: 
         * ```vim
         *   :nmap \x :call GetFoo()<CR>:exe "/" .. Foo<CR>
         *   :function GetFoo()
         *   :  call inputsave()
         *   :  let g:Foo = input("enter search pattern: ")
         *   :  call inputrestore()
         *   :endfunction
         * 
         * ```
         * Can also be used as a |method|: >
         *   GetPrompt()->input()
         */
        input: (opts: { [key: string]: any }) => string;

        /**
         * {textlist} must be a |List| of strings.  This |List| is
         * displayed, one string per line.  The user will be prompted to
         * enter a number, which is returned.
         * The user can also select an item by clicking on it with the
         * mouse, if the mouse is enabled in the command line ('mouse' is
         * "a" or includes "c").  For the first string 0 is returned.
         * When clicking above the first item a negative number is
         * returned.  When clicking on the prompt one more than the
         * length of {textlist} is returned.
         * Make sure {textlist} has less than 'lines' entries, otherwise
         * it won't work.  It's a good idea to put the entry number at
         * the start of the string.  And put a prompt in the first item.
         * Example: 
         * ```vim
         *   let color = inputlist(['Select color:', '1. red',
         *     \ '2. green', '3. blue'])
         * 
         * ```
         * Can also be used as a |method|: >
         *   GetChoices()->inputlist()
         */
        inputlist: (textlist: any) => number;

        /**
         * Restore typeahead that was saved with a previous |inputsave()|.
         * Should be called the same number of times inputsave() is
         * called.  Calling it more often is harmless though.
         * Returns TRUE when there is nothing to restore, FALSE otherwise.
         */
        inputrestore: () => number;

        /**
         * Preserve typeahead (also from mappings) and clear it, so that
         * a following prompt gets input from the user.  Should be
         * followed by a matching inputrestore() after the prompt.  Can
         * be used several times, in which case there must be just as
         * many inputrestore() calls.
         * Returns TRUE when out of memory, FALSE otherwise.
         */
        inputsave: () => number;

        /**
         * This function acts much like the |input()| function with but
         * two exceptions:
         * a) the user's response will be displayed as a sequence of
         * asterisks ("*") thereby keeping the entry secret, and
         * b) the user's response will not be recorded on the input
         * |history| stack.
         * The result is a String, which is whatever the user actually
         * typed on the command-line in response to the issued prompt.
         * NOTE: Command-line completion is not supported.
         * 
         * Can also be used as a |method|: 
         * ```vim
         *   GetPrompt()->inputsecret()
         * ```
         */
        inputsecret: (prompt: any, text?: string) => string;

        /**
         * When {object} is a |List| or a |Blob| insert {item} at the start
         * of it.
         * 
         * If {idx} is specified insert {item} before the item with index
         * {idx}.  If {idx} is zero it goes before the first item, just
         * like omitting {idx}.  A negative {idx} is also possible, see
         * |list-index|.  -1 inserts just before the last item.
         * 
         * Returns the resulting |List| or |Blob|.  Examples: 
         * ```vim
         *   :let mylist = insert([2, 3, 5], 1)
         *   :call insert(mylist, 4, -1)
         *   :call insert(mylist, 6, len(mylist))
         * ```
         * The last example can be done simpler with |add()|.
         * Note that when {item} is a |List| it is inserted as a single
         * item.  Use |extend()| to concatenate |Lists|.
         * 
         * Can also be used as a |method|: 
         * ```vim
         *   mylist->insert(item)
         * ```
         */
        insert: (object: any, item: any, idx?: any) => any[];

        /**
         * Interrupt script execution.  It works more or less like the
         * user typing CTRL-C, most commands won't execute and control
         * returns to the user.  This is useful to abort execution
         * from lower down, e.g. in an autocommand.  Example: 
         * ```vim
         * :function s:check_typoname(file)
         * :   if fnamemodify(a:file, ':t') == '['
         * :       echomsg 'Maybe typo'
         * :       call interrupt()
         * :   endif
         * :endfunction
         * :au BufWritePre * call s:check_typoname(expand('<amatch>'))
         * ```
         */
        interrupt: () => undefined;

        /**
         * Bitwise invert.  The argument is converted to a number.  A
         * List, Dict or Float argument causes an error.  Example: 
         * ```vim
         *   :let bits = invert(bits)
         * ```
         * Can also be used as a |method|: >
         *   :let bits = bits->invert()
         */
        invert: (expr: any) => number;

        /**
         * The result is a Number, which is |TRUE| when a directory
         * with the name {directory} exists.  If {directory} doesn't
         * exist, or isn't a directory, the result is |FALSE|.  {directory}
         * is any expression, which is used as a String.
         * 
         * Can also be used as a |method|: 
         * ```vim
         *   GetName()->isdirectory()
         * ```
         */
        isdirectory: (directory: any) => number;

        /**
         * Return 1 if {expr} is a positive infinity, or -1 a negative
         * infinity, otherwise 0. 
         * ```vim
         *   :echo isinf(1.0 / 0.0)
         * ```
         *   1 >
         *   :echo isinf(-1.0 / 0.0)
         * <      -1
         * 
         * Can also be used as a |method|: 
         * ```vim
         *   Compute()->isinf()
         * ```
         */
        isinf: (expr: any) => number;

        /**
         * The result is a Number, which is |TRUE| when {expr} is the
         * name of a locked variable.
         * The string argument {expr} must be the name of a variable,
         * |List| item or |Dictionary| entry, not the variable itself!
         * Example: 
         * ```vim
         *   :let alist = [0, ['a', 'b'], 2, 3]
         *   :lockvar 1 alist
         *   :echo islocked('alist')    " 1
         *   :echo islocked('alist[1]')  " 0
         * 
         * ```
         * When {expr} is a variable that does not exist you get an error
         * message.  Use |exists()| to check for existence.
         * 
         * Can also be used as a |method|: 
         * ```vim
         *   GetName()->islocked()
         * ```
         */
        islocked: (expr: any) => number;

        /**
         * Return |TRUE| if {expr} is a float with value NaN. 
         * ```vim
         *   echo isnan(0.0 / 0.0)
         * ```
         *   1
         * 
         * Can also be used as a |method|: 
         * ```vim
         *   Compute()->isnan()
         * ```
         */
        isnan: (expr: any) => number;

        /**
         * Return a |List| with all the key-value pairs of {dict}.  Each
         * |List| item is a list with two items: the key of a {dict}
         * entry and the value of this entry.  The |List| is in arbitrary
         * order.  Also see |keys()| and |values()|.
         * Example: 
         * ```vim
         *   for [key, value] in items(mydict)
         *      echo key .. ': ' .. value
         *   endfor
         * 
         * ```
         * Can also be used as a |method|: >
         *   mydict->items()
         */
        items: (dict: { [key: string]: any }) => any[];

        /**
         * Return the PID (process id) of |job-id| {job}.
         */
        jobpid: (job: any) => number;

        /**
         * Resize the pseudo terminal window of |job-id| {job} to {width}
         * columns and {height} rows.
         * Fails if the job was not started with `"pty":v:true`.
         */
        jobresize: (job: any, width: any, height: any) => number;

        /**
         * Spawns {cmd} as a job.
         * If {cmd} is a List it runs directly (no 'shell').
         * If {cmd} is a String it runs in the 'shell', like this: 
         * ```vim
         *   :call jobstart(split(&shell) + split(&shellcmdflag) + ['{cmd}'])
         * ```
         * (See |shell-unquoting| for details.)
         * 
         * Example: 
         * ```vim
         *   :call jobstart('nvim -h', {'on_stdout':{j,d,e->append(line('.'),d)}})
         * ```
         * Returns |job-id| on success, 0 on invalid arguments (or job
         * table is full), -1 if {cmd}[0] or 'shell' is not executable.
         * The returned job-id is a valid |channel-id| representing the
         * job's stdio streams. Use |chansend()| (or |rpcnotify()| and
         * |rpcrequest()| if "rpc" was enabled) to send data to stdin and
         * |chanclose()| to close the streams without stopping the job.
         * 
         * See |job-control| and |RPC|.
         * 
         * NOTE: on Windows if {cmd} is a List:
         *   - cmd[0] must be an executable (not a "built-in"). If it is
         *     in $PATH it can be called by name, without an extension: 
         * ```vim
         *       :call jobstart(['ping', 'neovim.io'])
         * ```
         *     If it is a full or partial path, extension is required: >
         *       :call jobstart(['System32\ping.exe', 'neovim.io'])
         * <      - {cmd} is collapsed to a string of quoted args as expected
         *     by CommandLineToArgvW https://msdn.microsoft.com/bb776391
         *     unless cmd[0] is some form of "cmd.exe".
         * 
         * 
         * The job environment is initialized as follows:
         *   $NVIM                is set to |v:servername| of the parent Nvim
         *   $NVIM_LISTEN_ADDRESS is unset
         *   $NVIM_LOG_FILE       is unset
         *   $VIM                 is unset
         *   $VIMRUNTIME          is unset
         * You can set these with the `env` option.
         * 
         * 
         * {opts} is a dictionary with these keys:
         *   clear_env:  (boolean) `env` defines the job environment
         *         exactly, instead of merging current environment.
         *   cwd:        (string, default=|current-directory|) Working
         *         directory of the job.
         *   detach:     (boolean) Detach the job process: it will not be
         *         killed when Nvim exits. If the process exits
         *         before Nvim, `on_exit` will be invoked.
         *   env:        (dict) Map of environment variable name:value
         *         pairs extending (or replace with "clear_env")
         *         the current environment. |jobstart-env|
         *   height:     (number) Height of the `pty` terminal.
         *   |on_exit|:    (function) Callback invoked when the job exits.
         *   |on_stdout|:  (function) Callback invoked when the job emits
         *         stdout data.
         *   |on_stderr|:  (function) Callback invoked when the job emits
         *         stderr data.
         *   overlapped: (boolean) Set FILE_FLAG_OVERLAPPED for the
         *         standard input/output passed to the child process.
         *         Normally you do not need to set this.
         *         (Only available on MS-Windows, On other
         *         platforms, this option is silently ignored.)
         *   pty:        (boolean) Connect the job to a new pseudo
         *         terminal, and its streams to the master file
         *         descriptor. `on_stdout` receives all output,
         *         `on_stderr` is ignored. |terminal-start|
         *   rpc:        (boolean) Use |msgpack-rpc| to communicate with
         *         the job over stdio. Then `on_stdout` is ignored,
         *         but `on_stderr` can still be used.
         *   stderr_buffered: (boolean) Collect data until EOF (stream closed)
         *         before invoking `on_stderr`. |channel-buffered|
         *   stdout_buffered: (boolean) Collect data until EOF (stream
         *         closed) before invoking `on_stdout`. |channel-buffered|
         *   stdin:      (string) Either "pipe" (default) to connect the
         *         job's stdin to a channel or "null" to disconnect
         *         stdin.
         *   width:      (number) Width of the `pty` terminal.
         * 
         * {opts} is passed as |self| dictionary to the callback; the
         * caller may set other keys to pass application-specific data.
         * 
         * Returns:
         *   - |channel-id| on success
         *   - 0 on invalid arguments
         *   - -1 if {cmd}[0] is not executable.
         * See also |job-control|, |channel|, |msgpack-rpc|.
         */
        jobstart: (cmd: any, opts?: { [key: string]: any }) => number;

        /**
         * Stop |job-id| {id} by sending SIGTERM to the job process. If
         * the process does not terminate after a timeout then SIGKILL
         * will be sent. When the job terminates its |on_exit| handler
         * (if any) will be invoked.
         * See |job-control|.
         * 
         * Returns 1 for valid job id, 0 for invalid id, including jobs have
         * exited or stopped.
         */
        jobstop: (id: any) => number;

        /**
         * Waits for jobs and their |on_exit| handlers to complete.
         * 
         * {jobs} is a List of |job-id|s to wait for.
         * {timeout} is the maximum waiting time in milliseconds. If
         * omitted or -1, wait forever.
         * 
         * Timeout of 0 can be used to check the status of a job: 
         * ```vim
         *   let running = jobwait([{job-id}], 0)[0] == -1
         * ```
         * During jobwait() callbacks for jobs not in the {jobs} list may
         * be invoked. The screen will not redraw unless |:redraw| is
         * invoked by a callback.
         * 
         * Returns a list of len({jobs}) integers, where each integer is
         * the status of the corresponding job:
         *   Exit-code, if the job exited
         *   -1 if the timeout was exceeded
         *   -2 if the job was interrupted (by |CTRL-C|)
         *   -3 if the job-id is invalid
         */
        jobwait: (jobs: any, timeout?: any) => number;

        /**
         * Join the items in {list} together into one String.
         * When {sep} is specified it is put in between the items.  If
         * {sep} is omitted a single space is used.
         * Note that {sep} is not added at the end.  You might want to
         * add it there too: 
         * ```vim
         *   let lines = join(mylist, "\n") .. "\n"
         * ```
         * String items are used as-is.  |Lists| and |Dictionaries| are
         * converted into a string like with |string()|.
         * The opposite function is |split()|.
         * 
         * Can also be used as a |method|: 
         * ```vim
         *   mylist->join()
         * ```
         */
        join: (list: any[], sep?: any) => string;

        /**
         * Convert {expr} from JSON object.  Accepts |readfile()|-style
         * list as the input, as well as regular string.  May output any
         * Vim value. In the following cases it will output
         * |msgpack-special-dict|:
         * 1. Dictionary contains duplicate key.
         * 2. Dictionary contains empty key.
         * 3. String contains NUL byte.  Two special dictionaries: for
         *    dictionary and for string will be emitted in case string
         *    with NUL byte was a dictionary key.
         * 
         * Note: function treats its input as UTF-8 always.  The JSON
         * standard allows only a few encodings, of which UTF-8 is
         * recommended and the only one required to be supported.
         * Non-UTF-8 characters are an error.
         * 
         * Can also be used as a |method|: 
         * ```vim
         *   ReadObject()->json_decode()
         * ```
         */
        json_decode: (expr: any) => any;

        /**
         * Convert {expr} into a JSON string.  Accepts
         * |msgpack-special-dict| as the input.  Will not convert
         * |Funcref|s, mappings with non-string keys (can be created as
         * |msgpack-special-dict|), values with self-referencing
         * containers, strings which contain non-UTF-8 characters,
         * pseudo-UTF-8 strings which contain codepoints reserved for
         * surrogate pairs (such strings are not valid UTF-8 strings).
         * Non-printable characters are converted into "\u1234" escapes
         * or special escapes like "\t", other are dumped as-is.
         * |Blob|s are converted to arrays of the individual bytes.
         * 
         * Can also be used as a |method|: 
         * ```vim
         *   GetObject()->json_encode()
         * ```
         */
        json_encode: (expr: any) => string;

        /**
         * Return a |List| with all the keys of {dict}.  The |List| is in
         * arbitrary order.  Also see |items()| and |values()|.
         * 
         * Can also be used as a |method|: 
         * ```vim
         *   mydict->keys()
         * ```
         */
        keys: (dict: { [key: string]: any }) => any[];

        /**
         * Turn the internal byte representation of keys into a form that
         * can be used for |:map|.  E.g. 
         * ```vim
         *   :let xx = "\<C-Home>"
         *   :echo keytrans(xx)
         * ```
         *   C-Home>
         * 
         * Can also be used as a |method|: 
         * ```vim
         *   "\<C-Home>"->keytrans()
         * 
         * ```
         */
        keytrans: (string: string) => string;

        /**
         * The result is a Number, which is the length of the argument.
         *   When {expr} is a String or a Number the length in bytes is
         *   used, as with |strlen()|.
         *   When {expr} is a |List| the number of items in the |List| is
         *   returned.
         *   When {expr} is a |Blob| the number of bytes is returned.
         *   When {expr} is a |Dictionary| the number of entries in the
         *   |Dictionary| is returned.
         *   Otherwise an error is given and returns zero.
         * 
         *   Can also be used as a |method|: 
         * ```vim
         *     mylist->len()
         * 
         * ```
         */
        len: (expr: any) => number;

        /**
         * Call function {funcname} in the run-time library {libname}
         * with single argument {argument}.
         * This is useful to call functions in a library that you
         * especially made to be used with Vim.  Since only one argument
         * is possible, calling standard library functions is rather
         * limited.
         * The result is the String returned by the function.  If the
         * function returns NULL, this will appear as an empty string ""
         * to Vim.
         * If the function returns a number, use libcallnr()!
         * If {argument} is a number, it is passed to the function as an
         * int; if {argument} is a string, it is passed as a
         * null-terminated string.
         * 
         * libcall() allows you to write your own 'plug-in' extensions to
         * Vim without having to recompile the program.  It is NOT a
         * means to call system functions!  If you try to do so Vim will
         * very probably crash.
         * 
         * For Win32, the functions you write must be placed in a DLL
         * and use the normal C calling convention (NOT Pascal which is
         * used in Windows System DLLs).  The function must take exactly
         * one parameter, either a character pointer or a long integer,
         * and must return a character pointer or NULL.  The character
         * pointer returned must point to memory that will remain valid
         * after the function has returned (e.g. in static data in the
         * DLL).  If it points to allocated memory, that memory will
         * leak away.  Using a static buffer in the function should work,
         * it's then freed when the DLL is unloaded.
         * 
         * WARNING: If the function returns a non-valid pointer, Vim may
         * crash!  This also happens if the function returns a number,
         * because Vim thinks it's a pointer.
         * For Win32 systems, {libname} should be the filename of the DLL
         * without the ".DLL" suffix.  A full path is only required if
         * the DLL is not in the usual places.
         * For Unix: When compiling your own plugins, remember that the
         * object code must be compiled as position-independent ('PIC').
         * Examples: 
         * ```vim
         *   :echo libcall("libc.so", "getenv", "HOME")
         * 
         * ```
         * Can also be used as a |method|, the base is passed as the
         * third argument: 
         * ```vim
         *   GetValue()->libcall("libc.so", "getenv")
         * ```
         */
        libcall: (libname: any, funcname: any, argument: any) => string;

        /**
         * Just like |libcall()|, but used for a function that returns an
         * int instead of a string.
         * Examples: 
         * ```vim
         *   :echo libcallnr("/usr/lib/libc.so", "getpid", "")
         *   :call libcallnr("libc.so", "printf", "Hello World!\n")
         *   :call libcallnr("libc.so", "sleep", 10)
         * ```
         * Can also be used as a |method|, the base is passed as the
         * third argument: 
         * ```vim
         *   GetValue()->libcallnr("libc.so", "printf")
         * ```
         */
        libcallnr: (libname: any, funcname: any, argument: any) => number;

        /**
         * The result is a Number, which is the line number of the file
         * position given with {expr}.  The {expr} argument is a string.
         * The accepted positions are:
         *     .      the cursor position
         *     $      the last line in the current buffer
         *     'x      position of mark x (if the mark is not set, 0 is
         *       returned)
         *     w0      first line visible in current window (one if the
         *       display isn't updated, e.g. in silent Ex mode)
         *     w$      last line visible in current window (this is one
         *       less than "w0" if no lines are visible)
         *     v      In Visual mode: the start of the Visual area (the
         *       cursor is the end).  When not in Visual mode
         *       returns the cursor position.  Differs from |'<| in
         *       that it's updated right away.
         * Note that a mark in another file can be used.  The line number
         * then applies to another buffer.
         * To get the column number use |col()|.  To get both use
         * |getpos()|.
         * With the optional {winid} argument the values are obtained for
         * that window instead of the current window.
         * Returns 0 for invalid values of {expr} and {winid}.
         * Examples: 
         * ```vim
         *   line(".")    line number of the cursor
         *   line(".", winid)  idem, in window "winid"
         *   line("'t")    line number of mark t
         *   line("'" .. marker)  line number of mark marker
         * ```
         * To jump to the last known position when opening a file see
         * |last-position-jump|.
         * 
         * Can also be used as a |method|: 
         * ```vim
         *   GetValue()->line()
         * ```
         */
        line: (expr: number | string, winid?: number) => number;

        /**
         * Return the byte count from the start of the buffer for line
         * {lnum}.  This includes the end-of-line character, depending on
         * the 'fileformat' option for the current buffer.  The first
         * line returns 1. UTF-8 encoding is used, 'fileencoding' is
         * ignored.  This can also be used to get the byte count for the
         * line just below the last line: 
         * ```vim
         *   line2byte(line("$") + 1)
         * ```
         * This is the buffer size plus one.  If 'fileencoding' is empty
         * it is the file size plus one.  {lnum} is used like with
         * |getline()|.  When {lnum} is invalid -1 is returned.
         * Also see |byte2line()|, |go| and |:goto|.
         * 
         * Can also be used as a |method|: 
         * ```vim
         *   GetLnum()->line2byte()
         * ```
         */
        line2byte: (lnum: number) => number;

        /**
         * Get the amount of indent for line {lnum} according the lisp
         * indenting rules, as with 'lisp'.
         * The indent is counted in spaces, the value of 'tabstop' is
         * relevant.  {lnum} is used just like in |getline()|.
         * When {lnum} is invalid, -1 is returned.
         * 
         * Can also be used as a |method|: 
         * ```vim
         *   GetLnum()->lispindent()
         * ```
         */
        lispindent: (lnum: number) => number;

        /**
         * Return a Blob concatenating all the number values in {list}.
         * Examples: 
         * ```vim
         *   list2blob([1, 2, 3, 4])  returns 0z01020304
         *   list2blob([])    returns 0z
         * ```
         * Returns an empty Blob on error.  If one of the numbers is
         * negative or more than 255 error  is given.
         * 
         * |blob2list()| does the opposite.
         * 
         * Can also be used as a |method|: 
         * ```vim
         *   GetList()->list2blob()
         * ```
         */
        list2blob: (list: any[]) => any;

        /**
         * Convert each number in {list} to a character string can
         * concatenate them all.  Examples: 
         * ```vim
         *   list2str([32])    returns " "
         *   list2str([65, 66, 67])  returns "ABC"
         * ```
         * The same can be done (slowly) with: >
         *   join(map(list, {nr, val -> nr2char(val)}), '')
         * <    |str2list()| does the opposite.
         * 
         * UTF-8 encoding is always used, {utf8} option has no effect,
         * and exists only for backwards-compatibility.
         * With UTF-8 composing characters work as expected: 
         * ```vim
         *   list2str([97, 769])  returns "á"
         * ```
         * Returns an empty string on error.
         * 
         * Can also be used as a |method|: 
         * ```vim
         *   GetList()->list2str()
         * ```
         */
        list2str: (list: any[], utf8?: any) => string;

        /**
         * Return the current time, measured as seconds since 1st Jan
         * 1970.  See also |strftime()|, |strptime()| and |getftime()|.
         */
        localtime: () => number;

        /**
         * Return the natural logarithm (base e) of {expr} as a |Float|.
         * {expr} must evaluate to a |Float| or a |Number| in the range
         * (0, inf].
         * Returns 0.0 if {expr} is not a |Float| or a |Number|.
         * Examples: 
         * ```vim
         *   :echo log(10)
         * ```
         *   2.302585 >
         *   :echo log(exp(5))
         * <      5.0
         * 
         * Can also be used as a |method|: 
         * ```vim
         *   Compute()->log()
         * ```
         */
        log: (expr: any) => number;

        /**
         * Return the logarithm of Float {expr} to base 10 as a |Float|.
         * {expr} must evaluate to a |Float| or a |Number|.
         * Returns 0.0 if {expr} is not a |Float| or a |Number|.
         * Examples: 
         * ```vim
         *   :echo log10(1000)
         * ```
         *   3.0 >
         *   :echo log10(0.01)
         * <      -2.0
         * 
         * Can also be used as a |method|: 
         * ```vim
         *   Compute()->log10()
         * ```
         */
        log10: (expr: any) => number;

        /**
         * Evaluate Lua expression {expr} and return its result converted
         * to Vim data structures. See |lua-eval| for more details.
         * 
         * Can also be used as a |method|: 
         * ```vim
         *   GetExpr()->luaeval()
         * ```
         */
        luaeval: (expr: any, expr1?: any) => any;

        /**
         * {expr1} must be a |List|, |Blob| or |Dictionary|.
         * Replace each item in {expr1} with the result of evaluating
         * {expr2}.  For a |Blob| each byte is replaced.
         * 
         * {expr2} must be a |string| or |Funcref|.
         * 
         * If {expr2} is a |string|, inside {expr2} |v:val| has the value
         * of the current item.  For a |Dictionary| |v:key| has the key
         * of the current item and for a |List| |v:key| has the index of
         * the current item.  For a |Blob| |v:key| has the index of the
         * current byte.
         * Example: 
         * ```vim
         *   :call map(mylist, '"> " .. v:val .. " <"')
         * ```
         * This puts "> " before and " " after each item in "mylist".
         * 
         * Note that {expr2} is the result of an expression and is then
         * used as an expression again.  Often it is good to use a
         * |literal-string| to avoid having to double backslashes.  You
         * still have to double ' quotes
         * 
         * If {expr2} is a |Funcref| it is called with two arguments:
         *   1. The key or the index of the current item.
         *   2. the value of the current item.
         * The function must return the new value of the item. Example
         * that changes each value by "key-value": 
         * ```vim
         *   func KeyValue(key, val)
         *     return a:key .. '-' .. a:val
         *   endfunc
         *   call map(myDict, function('KeyValue'))
         * ```
         * It is shorter when using a |lambda|: >
         *   call map(myDict, {key, val -> key .. '-' .. val})
         * <    If you do not use "val" you can leave it out: 
         * ```vim
         *   call map(myDict, {key -> 'item: ' .. key})
         * ```
         * If you do not use "key" you can use a short name: >
         *   call map(myDict, {_, val -> 'item: ' .. val})
         * <
         * The operation is done in-place.  If you want a |List| or
         * |Dictionary| to remain unmodified make a copy first: 
         * ```vim
         *   :let tlist = map(copy(mylist), ' v:val .. "\t"')
         * 
         * ```
         * Returns {expr1}, the |List|, |Blob| or |Dictionary| that was
         * filtered.  When an error is encountered while evaluating
         * {expr2} no further items in {expr1} are processed.  When
         * {expr2} is a Funcref errors inside a function are ignored,
         * unless it was defined with the "abort" flag.
         * 
         * Can also be used as a |method|: 
         * ```vim
         *   mylist->map(expr2)
         * ```
         */
        map: (expr1: any, expr2: any) => any[];

        /**
         * When {dict} is omitted or zero: Return the rhs of mapping
         * {name} in mode {mode}.  The returned String has special
         * characters translated like in the output of the ":map" command
         * listing.
         * 
         * When there is no mapping for {name}, an empty String is
         * returned if {dict} is FALSE, otherwise returns an empty Dict.
         * When the mapping for {name} is empty, then "<Nop>" is
         * returned.
         * 
         * The {name} can have special key names, like in the ":map"
         * command.
         * 
         * {mode} can be one of these strings:
         *   "n"  Normal
         *   "v"  Visual (including Select)
         *   "o"  Operator-pending
         *   "i"  Insert
         *   "c"  Cmd-line
         *   "s"  Select
         *   "x"  Visual
         *   "l"  langmap |language-mapping|
         *   "t"  Terminal
         *   ""  Normal, Visual and Operator-pending
         * When {mode} is omitted, the modes for "" are used.
         * 
         * When {abbr} is there and it is |TRUE| use abbreviations
         * instead of mappings.
         * 
         * When {dict} is there and it is |TRUE| return a dictionary
         * containing all the information of the mapping with the
         * following items:
         *   "lhs"       The {lhs} of the mapping as it would be typed
         *   "lhsraw"   The {lhs} of the mapping as raw bytes
         *   "lhsrawalt" The {lhs} of the mapping as raw bytes, alternate
         *         form, only present when it differs from "lhsraw"
         *   "rhs"       The {rhs} of the mapping as typed.
         *   "silent"   1 for a |:map-silent| mapping, else 0.
         *   "noremap"  1 if the {rhs} of the mapping is not remappable.
         *   "script"   1 if mapping was defined with <script>.
         *   "expr"     1 for an expression mapping (|:map-<expr>|).
         *   "buffer"   1 for a buffer local mapping (|:map-local|).
         *   "mode"     Modes for which the mapping is defined. In
         *        addition to the modes mentioned above, these
         *        characters will be used:
         *        " "     Normal, Visual and Operator-pending
         *        "!"     Insert and Commandline mode
         *          (|mapmode-ic|)
         *   "sid"       The script local ID, used for <sid> mappings
         *        (|<SID>|).
         *   "lnum"     The line number in "sid", zero if unknown.
         *   "nowait"   Do not wait for other, longer mappings.
         *        (|:map-<nowait>|).
         * 
         * The dictionary can be used to restore a mapping with
         * |mapset()|.
         * 
         * The mappings local to the current buffer are checked first,
         * then the global mappings.
         * This function can be used to map a key even when it's already
         * mapped, and have it do the original mapping too.  Sketch: 
         * ```vim
         *   exe 'nnoremap <Tab> ==' .. maparg('<Tab>', 'n')
         * 
         * ```
         * Can also be used as a |method|: >
         *   GetKey()->maparg('n')
         */
        maparg: (name: any, mode?: any, abbr?: any, dict?: { [key: string]: any }) => string;

        /**
         *   Check if there is a mapping that matches with {name} in mode
         *   {mode}.  See |maparg()| for {mode} and special names in
         *   {name}.
         *   When {abbr} is there and it is non-zero use abbreviations
         *   instead of mappings.
         *   A match happens with a mapping that starts with {name} and
         *   with a mapping which is equal to the start of {name}.
         * 
         *     matches mapping "a"  "ab"  "abc" ~
         *      mapcheck("a")  yes  yes   yes
         *      mapcheck("abc")  yes  yes   yes
         *      mapcheck("ax")  yes  no   no
         *      mapcheck("b")  no  no   no
         * 
         *   The difference with maparg() is that mapcheck() finds a
         *   mapping that matches with {name}, while maparg() only finds a
         *   mapping for {name} exactly.
         *   When there is no mapping that starts with {name}, an empty
         *   String is returned.  If there is one, the RHS of that mapping
         *   is returned.  If there are several mappings that start with
         *   {name}, the RHS of one of them is returned.  This will be
         *   "<Nop>" if the RHS is empty.
         *   The mappings local to the current buffer are checked first,
         *   then the global mappings.
         *   This function can be used to check if a mapping can be added
         *   without being ambiguous.  Example: 
         * ```vim
         * :if mapcheck("_vv") == ""
         * :   map _vv :set guifont=7x13<CR>
         * :endif
         * ```
         *   This avoids adding the "_vv" mapping when there already is a
         *   mapping for "_v" or for "_vvv".
         * 
         *   Can also be used as a |method|: 
         * ```vim
         *     GetKey()->mapcheck('n')
         * ```
         */
        mapcheck: (name: any, mode?: any, abbr?: any) => string;

        /**
         * Restore a mapping from a dictionary returned by |maparg()|.
         * {mode} and {abbr} should be the same as for the call to
         * |maparg()|.
         * {mode} is used to define the mode in which the mapping is set,
         * not the "mode" entry in {dict}.
         * Example for saving and restoring a mapping: 
         * ```vim
         *   let save_map = maparg('K', 'n', 0, 1)
         *   nnoremap K somethingelse
         *   ...
         *   call mapset('n', 0, save_map)
         * ```
         * Note that if you are going to replace a map in several modes,
         * e.g. with `:map!`, you need to save the mapping for all of
         * them, since they can differ.
         */
        mapset: (mode: any, abbr: any, dict: { [key: string]: any }) => undefined;

        /**
         * When {expr} is a |List| then this returns the index of the
         * first item where {pat} matches.  Each item is used as a
         * String, |Lists| and |Dictionaries| are used as echoed.
         * 
         * Otherwise, {expr} is used as a String.  The result is a
         * Number, which gives the index (byte offset) in {expr} where
         * {pat} matches.
         * 
         * A match at the first character or |List| item returns zero.
         * If there is no match -1 is returned.
         * 
         * For getting submatches see |matchlist()|.
         * Example: 
         * ```vim
         *   :echo match("testing", "ing")  " results in 4
         *   :echo match([1, 'x'], '\a')  " results in 1
         * ```
         * See |string-match| for how {pat} is used.
         * 
         * Vim doesn't have a strpbrk() function.  But you can do: 
         * ```vim
         *   :let sepidx = match(line, '[.,;: \t]')
         * ```
         * Vim doesn't have a strcasestr() function.  But you can add
         * "\c" to the pattern to ignore case: 
         * ```vim
         *   :let idx = match(haystack, '\cneedle')
         * ```
         * If {start} is given, the search starts from byte index
         * {start} in a String or item {start} in a |List|.
         * The result, however, is still the index counted from the
         * first character/item.  Example: 
         * ```vim
         *   :echo match("testing", "ing", 2)
         * ```
         * result is again "4". >
         *   :echo match("testing", "ing", 4)
         * <    result is again "4". 
         * ```vim
         *   :echo match("testing", "t", 2)
         * ```
         * result is "3".
         * For a String, if {start} > 0 then it is like the string starts
         * {start} bytes later, thus "^" will match at {start}.  Except
         * when {count} is given, then it's like matches before the
         * {start} byte are ignored (this is a bit complicated to keep it
         * backwards compatible).
         * For a String, if {start} < 0, it will be set to 0.  For a list
         * the index is counted from the end.
         * If {start} is out of range ({start} > strlen({expr}) for a
         * String or {start} > len({expr}) for a |List|) -1 is returned.
         * 
         * When {count} is given use the {count}th match.  When a match
         * is found in a String the search for the next one starts one
         * character further.  Thus this example results in 1: 
         * ```vim
         *   echo match("testing", "..", 0, 2)
         * ```
         * In a |List| the search continues in the next item.
         * Note that when {count} is added the way {start} works changes,
         * see above.
         * 
         * See |pattern| for the patterns that are accepted.
         * The 'ignorecase' option is used to set the ignore-caseness of
         * the pattern.  'smartcase' is NOT used.  The matching is always
         * done like 'magic' is set and 'cpoptions' is empty.
         * Note that a match at the start is preferred, thus when the
         * pattern is using "*" (any number of matches) it tends to find
         * zero matches at the start instead of a number of matches
         * further down in the text.
         * 
         * Can also be used as a |method|: 
         * ```vim
         *   GetText()->match('word')
         *   GetList()->match('word')
         * ```
         */
        match: (expr: any, pat: any, start?: number, count?: any) => number;

        /**
         * Defines a pattern to be highlighted in the current window (a
         * "match").  It will be highlighted with {group}.  Returns an
         * identification number (ID), which can be used to delete the
         * match using |matchdelete()|.  The ID is bound to the window.
         * Matching is case sensitive and magic, unless case sensitivity
         * or magicness are explicitly overridden in {pattern}.  The
         * 'magic', 'smartcase' and 'ignorecase' options are not used.
         * The "Conceal" value is special, it causes the match to be
         * concealed.
         * 
         * The optional {priority} argument assigns a priority to the
         * match.  A match with a high priority will have its
         * highlighting overrule that of a match with a lower priority.
         * A priority is specified as an integer (negative numbers are no
         * exception).  If the {priority} argument is not specified, the
         * default priority is 10.  The priority of 'hlsearch' is zero,
         * hence all matches with a priority greater than zero will
         * overrule it.  Syntax highlighting (see 'syntax') is a separate
         * mechanism, and regardless of the chosen priority a match will
         * always overrule syntax highlighting.
         * 
         * The optional {id} argument allows the request for a specific
         * match ID.  If a specified ID is already taken, an error
         * message will appear and the match will not be added.  An ID
         * is specified as a positive integer (zero excluded).  IDs 1, 2
         * and 3 are reserved for |:match|, |:2match| and |:3match|,
         * respectively.  3 is reserved for use by the |matchparen|
         * plugin.
         * If the {id} argument is not specified or -1, |matchadd()|
         * automatically chooses a free ID, which is at least 1000.
         * 
         * The optional {dict} argument allows for further custom
         * values. Currently this is used to specify a match specific
         * conceal character that will be shown for |hl-Conceal|
         * highlighted matches. The dict can have the following members:
         * 
         *   conceal      Special character to show instead of the
         *         match (only for |hl-Conceal| highlighted
         *         matches, see |:syn-cchar|)
         *   window      Instead of the current window use the
         *         window with this number or window ID.
         * 
         * The number of matches is not limited, as it is the case with
         * the |:match| commands.
         * 
         * Returns -1 on error.
         * 
         * Example: 
         * ```vim
         *   :highlight MyGroup ctermbg=green guibg=green
         *   :let m = matchadd("MyGroup", "TODO")
         * ```
         * Deletion of the pattern: >
         *   :call matchdelete(m)
         * 
         * <    A list of matches defined by |matchadd()| and |:match| are
         * available from |getmatches()|.  All matches can be deleted in
         * one operation by |clearmatches()|.
         * 
         * Can also be used as a |method|: 
         * ```vim
         *   GetGroup()->matchadd('TODO')
         * ```
         */
        matchadd: (group: any, pattern: any, priority?: any, id?: any, dict?: { [key: string]: any }) => number;

        /**
         * Same as |matchadd()|, but requires a list of positions {pos}
         * instead of a pattern. This command is faster than |matchadd()|
         * because it does not require to handle regular expressions and
         * sets buffer line boundaries to redraw screen. It is supposed
         * to be used when fast match additions and deletions are
         * required, for example to highlight matching parentheses.
         * 
         * {pos} is a list of positions.  Each position can be one of
         * these:
         * - A number.  This whole line will be highlighted.  The first
         *   line has number 1.
         * - A list with one number, e.g., [23]. The whole line with this
         *   number will be highlighted.
         * - A list with two numbers, e.g., [23, 11]. The first number is
         *   the line number, the second one is the column number (first
         *   column is 1, the value must correspond to the byte index as
         *   |col()| would return).  The character at this position will
         *   be highlighted.
         * - A list with three numbers, e.g., [23, 11, 3]. As above, but
         *   the third number gives the length of the highlight in bytes.
         * 
         * Entries with zero and negative line numbers are silently
         * ignored, as well as entries with negative column numbers and
         * lengths.
         * 
         * Returns -1 on error.
         * 
         * Example: 
         * ```vim
         *   :highlight MyGroup ctermbg=green guibg=green
         *   :let m = matchaddpos("MyGroup", [[23, 24], 34])
         * ```
         * Deletion of the pattern: >
         *   :call matchdelete(m)
         * 
         * <    Matches added by |matchaddpos()| are returned by
         * |getmatches()|.
         * 
         * Can also be used as a |method|: 
         * ```vim
         *   GetGroup()->matchaddpos([23, 11])
         * ```
         */
        matchaddpos: (group: any, pos: number, priority?: any, id?: any, dict?: { [key: string]: any }) => number;

        /**
         * Selects the {nr} match item, as set with a |:match|,
         * |:2match| or |:3match| command.
         * Return a |List| with two elements:
         *   The name of the highlight group used
         *   The pattern used.
         * When {nr} is not 1, 2 or 3 returns an empty |List|.
         * When there is no match item set returns ['', ''].
         * This is useful to save and restore a |:match|.
         * Highlighting matches using the |:match| commands are limited
         * to three matches. |matchadd()| does not have this limitation.
         * 
         * Can also be used as a |method|: 
         * ```vim
         *   GetMatch()->matcharg()
         * ```
         */
        matcharg: (nr: number) => any[];

        /**
         * Deletes a match with ID {id} previously defined by |matchadd()|
         * or one of the |:match| commands.  Returns 0 if successful,
         * otherwise -1.  See example for |matchadd()|.  All matches can
         * be deleted in one operation by |clearmatches()|.
         * If {win} is specified, use the window with this number or
         * window ID instead of the current window.
         * 
         * Can also be used as a |method|: 
         * ```vim
         *   GetMatch()->matchdelete()
         * ```
         */
        matchdelete: (id: any, win?: number) => number;

        /**
         * Same as |match()|, but return the index of first character
         * after the match.  Example: 
         * ```vim
         *   :echo matchend("testing", "ing")
         * ```
         * results in "7".
         * 
         * Vim doesn't have a strspn() or strcspn() function, but you can
         * do it with matchend(): 
         * ```vim
         *   :let span = matchend(line, '[a-zA-Z]')
         *   :let span = matchend(line, '[^a-zA-Z]')
         * ```
         * Except that -1 is returned when there are no matches.
         * 
         * The {start}, if given, has the same meaning as for |match()|. 
         * ```vim
         *   :echo matchend("testing", "ing", 2)
         * ```
         * results in "7". >
         *   :echo matchend("testing", "ing", 5)
         * <    result is "-1".
         * When {expr} is a |List| the result is equal to |match()|.
         * 
         * Can also be used as a |method|: 
         * ```vim
         *   GetText()->matchend('word')
         * ```
         */
        matchend: (expr: any, pat: any, start?: number, count?: any) => number;

        /**
         * If {list} is a list of strings, then returns a |List| with all
         * the strings in {list} that fuzzy match {str}. The strings in
         * the returned list are sorted based on the matching score.
         * 
         * The optional {dict} argument always supports the following
         * items:
         *     matchseq  When this item is present return only matches
         *     that contain the characters in {str} in the
         *     given sequence.
         *     limit  Maximum number of matches in {list} to be
         *     returned.  Zero means no limit.
         * 
         * If {list} is a list of dictionaries, then the optional {dict}
         * argument supports the following additional items:
         *     key    Key of the item which is fuzzy matched against
         *     {str}. The value of this item should be a
         *     string.
         *     text_cb  |Funcref| that will be called for every item
         *     in {list} to get the text for fuzzy matching.
         *     This should accept a dictionary item as the
         *     argument and return the text for that item to
         *     use for fuzzy matching.
         * 
         * {str} is treated as a literal string and regular expression
         * matching is NOT supported.  The maximum supported {str} length
         * is 256.
         * 
         * When {str} has multiple words each separated by white space,
         * then the list of strings that have all the words is returned.
         * 
         * If there are no matching strings or there is an error, then an
         * empty list is returned. If length of {str} is greater than
         * 256, then returns an empty list.
         * 
         * When {limit} is given, matchfuzzy() will find up to this
         * number of matches in {list} and return them in sorted order.
         * 
         * Refer to |fuzzy-matching| for more information about fuzzy
         * matching strings.
         * 
         * Example: 
         * ```vim
         *    :echo matchfuzzy(["clay", "crow"], "cay")
         * ```
         * results in ["clay"]. >
         *    :echo getbufinfo()->map({_, v -> v.name})->matchfuzzy("ndl")
         * <    results in a list of buffer names fuzzy matching "ndl". 
         * ```vim
         *    :echo getbufinfo()->matchfuzzy("ndl", {'key' : 'name'})
         * ```
         * results in a list of buffer information dicts with buffer
         * names fuzzy matching "ndl". 
         * ```vim
         *    :echo getbufinfo()->matchfuzzy("spl",
         *         \ {'text_cb' : {v -> v.name}})
         * ```
         * results in a list of buffer information dicts with buffer
         * names fuzzy matching "spl". 
         * ```vim
         *    :echo v:oldfiles->matchfuzzy("test")
         * ```
         * results in a list of file names fuzzy matching "test". >
         *    :let l = readfile("buffer.c")->matchfuzzy("str")
         * <    results in a list of lines in "buffer.c" fuzzy matching "str". 
         * ```vim
         *    :echo ['one two', 'two one']->matchfuzzy('two one')
         * ```
         * results in `['two one', 'one two']` . >
         *    :echo ['one two', 'two one']->matchfuzzy('two one',
         *         \ {'matchseq': 1})
         * <    results in ['two one'].
         */
        matchfuzzy: (list: any[], str: string, dict?: { [key: string]: any }) => any[];

        /**
         * Same as |matchfuzzy()|, but returns the list of matched
         * strings, the list of character positions where characters
         * in {str} matches and a list of matching scores.  You can
         * use |byteidx()| to convert a character position to a byte
         * position.
         * 
         * If {str} matches multiple times in a string, then only the
         * positions for the best match is returned.
         * 
         * If there are no matching strings or there is an error, then a
         * list with three empty list items is returned.
         * 
         * Example: 
         * ```vim
         *   :echo matchfuzzypos(['testing'], 'tsg')
         * ```
         * results in [["testing"], [[0, 2, 6]], [99]] >
         *   :echo matchfuzzypos(['clay', 'lacy'], 'la')
         * <    results in [["lacy", "clay"], [[0, 1], [1, 2]], [153, 133]] 
         * ```vim
         *   :echo [{'text': 'hello', 'id' : 10}]
         *     \ ->matchfuzzypos('ll', {'key' : 'text'})
         * ```
         * results in [[{"id": 10, "text": "hello"}], [[2, 3]], [127]]
         */
        matchfuzzypos: (list: any[], str: string, dict?: { [key: string]: any }) => any[];

        /**
         * Same as |match()|, but return a |List|.  The first item in the
         * list is the matched string, same as what matchstr() would
         * return.  Following items are submatches, like "\1", "\2", etc.
         * in |:substitute|.  When an optional submatch didn't match an
         * empty string is used.  Example: 
         * ```vim
         *   echo matchlist('acd', '\(a\)\?\(b\)\?\(c\)\?\(.*\)')
         * ```
         * Results in: ['acd', 'a', '', 'c', 'd', '', '', '', '', '']
         * When there is no match an empty list is returned.
         * 
         * You can pass in a List, but that is not very useful.
         * 
         * Can also be used as a |method|: 
         * ```vim
         *   GetText()->matchlist('word')
         * ```
         */
        matchlist: (expr: any, pat: any, start?: number, count?: any) => any[];

        /**
         * Same as |match()|, but return the matched string.  Example: 
         * ```vim
         *   :echo matchstr("testing", "ing")
         * ```
         * results in "ing".
         * When there is no match "" is returned.
         * The {start}, if given, has the same meaning as for |match()|. 
         * ```vim
         *   :echo matchstr("testing", "ing", 2)
         * ```
         * results in "ing". >
         *   :echo matchstr("testing", "ing", 5)
         * <    result is "".
         * When {expr} is a |List| then the matching item is returned.
         * The type isn't changed, it's not necessarily a String.
         * 
         * Can also be used as a |method|: 
         * ```vim
         *   GetText()->matchstr('word')
         * ```
         */
        matchstr: (expr: any, pat: any, start?: number, count?: any) => string;

        /**
         * Same as |matchstr()|, but return the matched string, the start
         * position and the end position of the match.  Example: 
         * ```vim
         *   :echo matchstrpos("testing", "ing")
         * ```
         * results in ["ing", 4, 7].
         * When there is no match ["", -1, -1] is returned.
         * The {start}, if given, has the same meaning as for |match()|. 
         * ```vim
         *   :echo matchstrpos("testing", "ing", 2)
         * ```
         * results in ["ing", 4, 7]. >
         *   :echo matchstrpos("testing", "ing", 5)
         * <    result is ["", -1, -1].
         * When {expr} is a |List| then the matching item, the index
         * of first item where {pat} matches, the start position and the
         * end position of the match are returned. 
         * ```vim
         *   :echo matchstrpos([1, '__x'], '\a')
         * ```
         * result is ["x", 1, 2, 3].
         * The type isn't changed, it's not necessarily a String.
         * 
         * Can also be used as a |method|: 
         * ```vim
         *   GetText()->matchstrpos('word')
         * ```
         */
        matchstrpos: (expr: any, pat: any, start?: number, count?: any) => any[];

        /**
         * Return the maximum value of all items in {expr}. Example: 
         * ```vim
         *     echo max([apples, pears, oranges])
         * 
         * ```
         *   {expr} can be a |List| or a |Dictionary|.  For a Dictionary,
         *   it returns the maximum of all values in the Dictionary.
         *   If {expr} is neither a List nor a Dictionary, or one of the
         *   items in {expr} cannot be used as a Number this results in
         *               an error.  An empty |List| or |Dictionary| results in zero.
         * 
         *   Can also be used as a |method|: 
         * ```vim
         *     mylist->max()
         * ```
         */
        max: (expr: any) => number;

        /**
         * Returns a |List| of |Dictionaries| describing |menus| (defined
         * by |:menu|, |:amenu|, …), including |hidden-menus|.
         * 
         * {path} matches a menu by name, or all menus if {path} is an
         * empty string.  Example: 
         * ```vim
         *   :echo menu_get('File','')
         *   :echo menu_get('')
         * ```
         * {modes} is a string of zero or more modes (see |maparg()| or
         * |creating-menus| for the list of modes). "a" means "all".
         * 
         * Example: 
         * ```vim
         *   nnoremenu &Test.Test inormal
         *   inoremenu Test.Test insert
         *   vnoremenu Test.Test x
         *   echo menu_get("")
         * 
         * ```
         * returns something like this: >
         * 
         *   [ {
         *     "hidden": 0,
         *     "name": "Test",
         *     "priority": 500,
         *     "shortcut": 84,
         *     "submenus": [ {
         *       "hidden": 0,
         *       "mappings": {
         *         i": {
         *     "enabled": 1,
         *     "noremap": 1,
         *     "rhs": "insert",
         *     "sid": 1,
         *     "silent": 0
         *         },
         *         n": { ... },
         *         s": { ... },
         *         v": { ... }
         *       },
         *       "name": "Test",
         *       "priority": 500,
         *       "shortcut": 0
         *     } ]
         *   } ]
         * <
         */
        menu_get: (path: any, modes?: any) => any[];

        /**
         * Return information about the specified menu {name} in
         * mode {mode}. The menu name should be specified without the
         * shortcut character ('&'). If {name} is "", then the top-level
         * menu names are returned.
         * 
         * {mode} can be one of these strings:
         *   "n"  Normal
         *   "v"  Visual (including Select)
         *   "o"  Operator-pending
         *   "i"  Insert
         *   "c"  Cmd-line
         *   "s"  Select
         *   "x"  Visual
         *   "t"  Terminal-Job
         *   ""  Normal, Visual and Operator-pending
         *   "!"  Insert and Cmd-line
         * When {mode} is omitted, the modes for "" are used.
         * 
         * Returns a |Dictionary| containing the following items:
         *   accel    menu item accelerator text |menu-text|
         *   display  display name (name without '&')
         *   enabled  v:true if this menu item is enabled
         *     Refer to |:menu-enable|
         *   icon    name of the icon file (for toolbar)
         *     |toolbar-icon|
         *   iconidx  index of a built-in icon
         *   modes    modes for which the menu is defined. In
         *     addition to the modes mentioned above, these
         *     characters will be used:
         *     " "  Normal, Visual and Operator-pending
         *   name    menu item name.
         *   noremenu  v:true if the {rhs} of the menu item is not
         *     remappable else v:false.
         *   priority  menu order priority |menu-priority|
         *   rhs    right-hand-side of the menu item. The returned
         *     string has special characters translated like
         *     in the output of the ":menu" command listing.
         *     When the {rhs} of a menu item is empty, then
         *     "<Nop>" is returned.
         *   script  v:true if script-local remapping of {rhs} is
         *     allowed else v:false.  See |:menu-script|.
         *   shortcut  shortcut key (character after '&' in
         *     the menu name) |menu-shortcut|
         *   silent  v:true if the menu item is created
         *     with <silent> argument |:menu-silent|
         *   submenus  |List| containing the names of
         *     all the submenus.  Present only if the menu
         *     item has submenus.
         * 
         * Returns an empty dictionary if the menu item is not found.
         * 
         * Examples: 
         * ```vim
         *   :echo menu_info('Edit.Cut')
         *   :echo menu_info('File.Save', 'n')
         * 
         *   " Display the entire menu hierarchy in a buffer
         *   func ShowMenu(name, pfx)
         *     let m = menu_info(a:name)
         *     call append(line('$'), a:pfx .. m.display)
         *     for child in m->get('submenus', [])
         *       call ShowMenu(a:name .. '.' .. escape(child, '.'),
         *           \ a:pfx .. '    ')
         *     endfor
         *   endfunc
         *   new
         *   for topmenu in menu_info('').submenus
         *     call ShowMenu(topmenu, '')
         *   endfor
         * ```
         * Can also be used as a |method|: 
         * ```vim
         *   GetMenuName()->menu_info('v')
         * 
         * 
         * ```
         */
        menu_info: (name: any, mode?: any) => { [key: string]: any };

        /**
         * Return the minimum value of all items in {expr}. Example:  
         * ```vim
         *     echo min([apples, pears, oranges])
         * 
         * ```
         *   {expr} can be a |List| or a |Dictionary|.  For a Dictionary,
         *   it returns the minimum of all values in the Dictionary.
         *   If {expr} is neither a List nor a Dictionary, or one of the
         *   items in {expr} cannot be used as a Number this results in
         *   an error.  An empty |List| or |Dictionary| results in zero.
         * 
         *   Can also be used as a |method|: 
         * ```vim
         *     mylist->min()
         * 
         * ```
         */
        min: (expr: any) => number;

        /**
         * Create directory {name}.
         * 
         * When {flags} is present it must be a string.  An empty string
         * has no effect.
         * 
         * If {flags} is "p" then intermediate directories are created as
         * necessary.
         * 
         * If {prot} is given it is used to set the protection bits of
         * the new directory.  The default is 0o755 (rwxr-xr-x: r/w for
         * the user, readable for others).  Use 0o700 to make it
         * unreadable for others.
         * 
         * {prot} is applied for all parts of {name}.  Thus if you create
         * /tmp/foo/bar then /tmp/foo will be created with 0o700. Example: 
         * ```vim
         *   :call mkdir($HOME .. "/tmp/foo/bar", "p", 0o700)
         * 
         * ```
         * This function is not available in the |sandbox|.
         * 
         * If you try to create an existing directory with {flags} set to
         * "p" mkdir() will silently exit.
         * 
         * The function result is a Number, which is TRUE if the call was
         * successful or FALSE if the directory creation failed or partly
         * failed.
         * 
         * Can also be used as a |method|: 
         * ```vim
         *   GetName()->mkdir()
         * ```
         */
        mkdir: (name: any, flags?: any, prot?: any) => number;

        /**
         * Return a string that indicates the current mode.
         *   If [expr] is supplied and it evaluates to a non-zero Number or
         *   a non-empty String (|non-zero-arg|), then the full mode is
         *   returned, otherwise only the first letter is returned.
         * 
         *      n      Normal
         *      no      Operator-pending
         *      nov      Operator-pending (forced charwise |o_v|)
         *      noV      Operator-pending (forced linewise |o_V|)
         *      noCTRL-V Operator-pending (forced blockwise |o_CTRL-V|)
         *       CTRL-V is one character
         *      niI      Normal using |i_CTRL-O| in |Insert-mode|
         *      niR      Normal using |i_CTRL-O| in |Replace-mode|
         *      niV      Normal using |i_CTRL-O| in |Virtual-Replace-mode|
         *      nt      Normal in |terminal-emulator| (insert goes to
         *       Terminal mode)
         *      ntT      Normal using |t_CTRL-\_CTRL-O| in |Terminal-mode|
         *      v      Visual by character
         *      vs      Visual by character using |v_CTRL-O| in Select mode
         *      V      Visual by line
         *      Vs      Visual by line using |v_CTRL-O| in Select mode
         *      CTRL-V   Visual blockwise
         *      CTRL-Vs  Visual blockwise using |v_CTRL-O| in Select mode
         *      s      Select by character
         *      S      Select by line
         *      CTRL-S   Select blockwise
         *      i      Insert
         *      ic      Insert mode completion |compl-generic|
         *      ix      Insert mode |i_CTRL-X| completion
         *      R      Replace |R|
         *      Rc      Replace mode completion |compl-generic|
         *      Rx      Replace mode |i_CTRL-X| completion
         *      Rv      Virtual Replace |gR|
         *      Rvc      Virtual Replace mode completion |compl-generic|
         *      Rvx      Virtual Replace mode |i_CTRL-X| completion
         *      c      Command-line editing
         *      cv      Vim Ex mode |gQ|
         *      r      Hit-enter prompt
         *      rm      The -- more -- prompt
         *      r?      A |:confirm| query of some sort
         *      !      Shell or external command is executing
         *      t      Terminal mode: keys go to the job
         * 
         *   This is useful in the 'statusline' option or RPC calls. In
         *   most other places it always returns "c" or "n".
         *   Note that in the future more modes and more specific modes may
         *   be added. It's better not to compare the whole string but only
         *   the leading character(s).
         *   Also see |visualmode()|.
         * 
         *   Can also be used as a |method|: 
         * ```vim
         *     DoFull()->mode()
         * ```
         */
        mode: (expr?: any) => string;

        /**
         * Convert a list of VimL objects to msgpack. Returned value is a
         * |readfile()|-style list. When {type} contains "B", a |Blob| is
         * returned instead. Example: 
         * ```vim
         *   call writefile(msgpackdump([{}]), 'fname.mpack', 'b')
         * ```
         * or, using a |Blob|: >
         *   call writefile(msgpackdump([{}], 'B'), 'fname.mpack')
         * <
         * This will write the single 0x80 byte to a `fname.mpack` file
         * (dictionary with zero items is represented by 0x80 byte in
         * messagepack).
         * 
         * Limitations:
         * 1. |Funcref|s cannot be dumped.
         * 2. Containers that reference themselves cannot be dumped.
         * 3. Dictionary keys are always dumped as STR strings.
         * 4. Other strings and |Blob|s are always dumped as BIN strings.
         * 5. Points 3. and 4. do not apply to |msgpack-special-dict|s.
         */
        msgpackdump: (list: any[], type?: any) => any[];

        /**
         * Convert a |readfile()|-style list or a |Blob| to a list of
         * VimL objects.
         * Example: 
         * ```vim
         *   let fname = expand('~/.config/nvim/shada/main.shada')
         *   let mpack = readfile(fname, 'b')
         *   let shada_objects = msgpackparse(mpack)
         * ```
         * This will read ~/.config/nvim/shada/main.shada file to
         * `shada_objects` list.
         * 
         * Limitations:
         * 1. Mapping ordering is not preserved unless messagepack
         *    mapping is dumped using generic mapping
         *    (|msgpack-special-map|).
         * 2. Since the parser aims to preserve all data untouched
         *    (except for 1.) some strings are parsed to
         *    |msgpack-special-dict| format which is not convenient to
         *    use.
         * 
         * Some messagepack strings may be parsed to special
         * dictionaries. Special dictionaries are dictionaries which
         * 
         * 1. Contain exactly two keys: `_TYPE` and `_VAL`.
         * 2. `_TYPE` key is one of the types found in |v:msgpack_types|
         *    variable.
         * 3. Value for `_VAL` has the following format (Key column
         *    contains name of the key from |v:msgpack_types|):
         * 
         * Key  Value ~
         * nil  Zero, ignored when dumping.  Not returned by
         *   |msgpackparse()| since |v:null| was introduced.
         * boolean  One or zero.  When dumping it is only checked that
         *   value is a |Number|.  Not returned by |msgpackparse()|
         *   since |v:true| and |v:false| were introduced.
         * integer  |List| with four numbers: sign (-1 or 1), highest two
         *   bits, number with bits from 62nd to 31st, lowest 31
         *   bits. I.e. to get actual number one will need to use
         *   code like 
         * ```vim
         *     _VAL[0] * ((_VAL[1] << 62)
         *                & (_VAL[2] << 31)
         *                & _VAL[3])
         * ```
         *   Special dictionary with this type will appear in
         *   |msgpackparse()| output under one of the following
         *   circumstances:
         *   1. |Number| is 32-bit and value is either above
         *      INT32_MAX or below INT32_MIN.
         *   2. |Number| is 64-bit and value is above INT64_MAX. It
         *      cannot possibly be below INT64_MIN because msgpack
         *      C parser does not support such values.
         * float  |Float|. This value cannot possibly appear in
         *   |msgpackparse()| output.
         * string  |readfile()|-style list of strings. This value will
         *   appear in |msgpackparse()| output if string contains
         *   zero byte or if string is a mapping key and mapping is
         *   being represented as special dictionary for other
         *   reasons.
         * binary  |String|, or |Blob| if binary string contains zero
         *   byte. This value cannot appear in |msgpackparse()|
         *   output since blobs were introduced.
         * array  |List|. This value cannot appear in |msgpackparse()|
         *   output.
         * 
         * map  |List| of |List|s with two items (key and value) each.
         *   This value will appear in |msgpackparse()| output if
         *   parsed mapping contains one of the following keys:
         *   1. Any key that is not a string (including keys which
         *      are binary strings).
         *   2. String with NUL byte inside.
         *   3. Duplicate key.
         *   4. Empty key.
         * ext  |List| with two values: first is a signed integer
         *   representing extension type. Second is
         *   |readfile()|-style list of strings.
         */
        msgpackparse: (data: any) => any[];

        /**
         * Return the line number of the first line at or below {lnum}
         * that is not blank.  Example: 
         * ```vim
         *   if getline(nextnonblank(1)) =~ "Java"
         * ```
         * When {lnum} is invalid or there is no non-blank line at or
         * below it, zero is returned.
         * {lnum} is used like with |getline()|.
         * See also |prevnonblank()|.
         * 
         * Can also be used as a |method|: 
         * ```vim
         *   GetLnum()->nextnonblank()
         * ```
         */
        nextnonblank: (lnum: number) => number;

        /**
         * Return a string with a single character, which has the number
         * value {expr}.  Examples: 
         * ```vim
         *   nr2char(64)    returns "@"
         *   nr2char(32)    returns " "
         * ```
         * Example for "utf-8": >
         *   nr2char(300)    returns I with bow character
         * <    UTF-8 encoding is always used, {utf8} option has no effect,
         * and exists only for backwards-compatibility.
         * Note that a NUL character in the file is specified with
         * nr2char(10), because NULs are represented with newline
         * characters.  nr2char(0) is a real NUL and terminates the
         * string, thus results in an empty string.
         * 
         * Can also be used as a |method|: 
         * ```vim
         *   GetNumber()->nr2char()
         * ```
         */
        nr2char: (expr: any, utf8?: any) => string;

        /**
         * Bitwise OR on the two arguments.  The arguments are converted
         * to a number.  A List, Dict or Float argument causes an error.
         * Also see `and()` and `xor()`.
         * Example: 
         * ```vim
         *   :let bits = or(bits, 0x80)
         * ```
         * Can also be used as a |method|: >
         *   :let bits = bits->or(0x80)
         * 
         * <    Rationale: The reason this is a function and not using the "|"
         * character like many languages, is that Vi has always used "|"
         * to separate commands.  In many places it would not be clear if
         * "|" is an operator or a command separator.
         */
        or: (expr: any, expr1: any) => number;

        /**
         * Shorten directory names in the path {path} and return the
         * result.  The tail, the file name, is kept as-is.  The other
         * components in the path are reduced to {len} letters in length.
         * If {len} is omitted or smaller than 1 then 1 is used (single
         * letters).  Leading '~' and '.' characters are kept.  Examples: 
         * ```vim
         *   :echo pathshorten('~/.config/nvim/autoload/file1.vim')
         * ```
         *   ~/.c/n/a/file1.vim ~
         * ```vim
         *   :echo pathshorten('~/.config/nvim/autoload/file2.vim', 2)
         * ```
         *   ~/.co/nv/au/file2.vim ~
         * It doesn't matter if the path exists or not.
         * Returns an empty string on error.
         * 
         * Can also be used as a |method|: 
         * ```vim
         *   GetDirectories()->pathshorten()
         * ```
         */
        pathshorten: (path: any, len?: any) => string;

        /**
         * Evaluate |perl| expression {expr} and return its result
         * converted to Vim data structures.
         * Numbers and strings are returned as they are (strings are
         * copied though).
         * Lists are represented as Vim |List| type.
         * Dictionaries are represented as Vim |Dictionary| type,
         * non-string keys result in error.
         * 
         * Note: If you want an array or hash, {expr} must return a
         * reference to it.
         * Example: 
         * ```vim
         *   :echo perleval('[1 .. 4]')
         * ```
         *   [1, 2, 3, 4]
         * 
         * Can also be used as a |method|: 
         * ```vim
         *   GetExpr()->perleval()
         * ```
         */
        perleval: (expr: any) => any;

        /**
         * Return the power of {x} to the exponent {y} as a |Float|.
         * {x} and {y} must evaluate to a |Float| or a |Number|.
         * Returns 0.0 if {x} or {y} is not a |Float| or a |Number|.
         * Examples: 
         * ```vim
         *   :echo pow(3, 3)
         * ```
         *   27.0 >
         *   :echo pow(2, 16)
         * <      65536.0 
         * ```vim
         *   :echo pow(32, 0.20)
         * ```
         *   2.0
         * 
         * Can also be used as a |method|: 
         * ```vim
         *   Compute()->pow(3)
         * ```
         */
        pow: (x: any, y: any) => number;

        /**
         * Return the line number of the first line at or above {lnum}
         * that is not blank.  Example: 
         * ```vim
         *   let ind = indent(prevnonblank(v:lnum - 1))
         * ```
         * When {lnum} is invalid or there is no non-blank line at or
         * above it, zero is returned.
         * {lnum} is used like with |getline()|.
         * Also see |nextnonblank()|.
         * 
         * Can also be used as a |method|: 
         * ```vim
         *   GetLnum()->prevnonblank()
         * ```
         */
        prevnonblank: (lnum: number) => number;

        /**
         * Return a String with {fmt}, where "%" items are replaced by
         * the formatted form of their respective arguments.  Example: 
         * ```vim
         *   printf("%4d: E%d %.30s", lnum, errno, msg)
         * ```
         * May result in:
         *   "  99: E42 asdfasdfasdfasdfasdfasdfasdfas" ~
         * 
         * When used as a |method| the base is passed as the second
         * argument: 
         * ```vim
         *   Compute()->printf("result: %d")
         * ```
         * You can use `call()` to pass the items as a list.
         * 
         * Often used items are:
         *   %s  string
         *   %6S  string right-aligned in 6 display cells
         *   %6s  string right-aligned in 6 bytes
         *   %.9s  string truncated to 9 bytes
         *   %c  single byte
         *   %d  decimal number
         *   %5d  decimal number padded with spaces to 5 characters
         *   %b  binary number
         *   %08b  binary number padded with zeros to at least 8 characters
         *   %B  binary number using upper case letters
         *   %x  hex number
         *   %04x  hex number padded with zeros to at least 4 characters
         *   %X  hex number using upper case letters
         *   %o  octal number
         *   %f  floating point number as 12.23, inf, -inf or nan
         *   %F  floating point number as 12.23, INF, -INF or NAN
         *   %e  floating point number as 1.23e3, inf, -inf or nan
         *   %E  floating point number as 1.23E3, INF, -INF or NAN
         *   %g  floating point number, as %f or %e depending on value
         *   %G  floating point number, as %F or %E depending on value
         *   %%  the % character itself
         *   %p  representation of the pointer to the container
         * 
         * Conversion specifications start with '%' and end with the
         * conversion type.  All other characters are copied unchanged to
         * the result.
         * 
         * The "%" starts a conversion specification.  The following
         * arguments appear in sequence:
         * 
         *   %  [flags]  [field-width]  [.precision]  type
         * 
         * flags
         *   Zero or more of the following flags:
         * 
         *     #        The value should be converted to an "alternate
         *         form".  For c, d, and s conversions, this option
         *         has no effect.  For o conversions, the precision
         *         of the number is increased to force the first
         *         character of the output string to a zero (except
         *         if a zero value is printed with an explicit
         *         precision of zero).
         *         For x and X conversions, a non-zero result has
         *         the string "0x" (or "0X" for X conversions)
         *         prepended to it.
         * 
         *     0 (zero)  Zero padding.  For all conversions the converted
         *         value is padded on the left with zeros rather
         *         than blanks.  If a precision is given with a
         *         numeric conversion (d, o, x, and X), the 0 flag
         *         is ignored.
         * 
         *     -        A negative field width flag; the converted value
         *         is to be left adjusted on the field boundary.
         *         The converted value is padded on the right with
         *         blanks, rather than on the left with blanks or
         *         zeros.  A - overrides a 0 if both are given.
         * 
         *     ' ' (space)  A blank should be left before a positive
         *         number produced by a signed conversion (d).
         * 
         *     +        A sign must always be placed before a number
         *         produced by a signed conversion.  A + overrides
         *         a space if both are used.
         * 
         * field-width
         *   An optional decimal digit string specifying a minimum
         *   field width.  If the converted value has fewer bytes
         *   than the field width, it will be padded with spaces on
         *   the left (or right, if the left-adjustment flag has
         *   been given) to fill out the field width.  For the S
         *   conversion the count is in cells.
         * 
         * .precision
         *   An optional precision, in the form of a period '.'
         *   followed by an optional digit string.  If the digit
         *   string is omitted, the precision is taken as zero.
         *   This gives the minimum number of digits to appear for
         *   d, o, x, and X conversions, the maximum number of
         *   bytes to be printed from a string for s conversions,
         *   or the maximum number of cells to be printed from a
         *   string for S conversions.
         *   For floating point it is the number of digits after
         *   the decimal point.
         * 
         * type
         *   A character that specifies the type of conversion to
         *   be applied, see below.
         * 
         * A field width or precision, or both, may be indicated by an
         * asterisk '*' instead of a digit string.  In this case, a
         * Number argument supplies the field width or precision.  A
         * negative field width is treated as a left adjustment flag
         * followed by a positive field width; a negative precision is
         * treated as though it were missing.  Example: 
         * ```vim
         *   :echo printf("%d: %.*s", nr, width, line)
         * ```
         * This limits the length of the text used from "line" to
         * "width" bytes.
         * 
         * The conversion specifiers and their meanings are:
         * 
         * 
         * dbBoxX  The Number argument is converted to signed decimal (d),
         *   unsigned binary (b and B), unsigned octal (o), or
         *   unsigned hexadecimal (x and X) notation.  The letters
         *   "abcdef" are used for x conversions; the letters
         *   "ABCDEF" are used for X conversions.  The precision, if
         *   any, gives the minimum number of digits that must
         *   appear; if the converted value requires fewer digits, it
         *   is padded on the left with zeros.  In no case does a
         *   non-existent or small field width cause truncation of a
         *   numeric field; if the result of a conversion is wider
         *   than the field width, the field is expanded to contain
         *   the conversion result.
         *   The 'h' modifier indicates the argument is 16 bits.
         *   The 'l' modifier indicates the argument is 32 bits.
         *   The 'L' modifier indicates the argument is 64 bits.
         *   Generally, these modifiers are not useful. They are
         *   ignored when type is known from the argument.
         * 
         * i  alias for d
         * D  alias for ld
         * U  alias for lu
         * O  alias for lo
         * 
         * 
         * c  The Number argument is converted to a byte, and the
         *   resulting character is written.
         * 
         * 
         * s  The text of the String argument is used.  If a
         *   precision is specified, no more bytes than the number
         *   specified are used.
         *   If the argument is not a String type, it is
         *   automatically converted to text with the same format
         *   as ":echo".
         * 
         * S  The text of the String argument is used.  If a
         *   precision is specified, no more display cells than the
         *   number specified are used.
         * 
         * 
         * f F  The Float argument is converted into a string of the
         *   form 123.456.  The precision specifies the number of
         *   digits after the decimal point.  When the precision is
         *   zero the decimal point is omitted.  When the precision
         *   is not specified 6 is used.  A really big number
         *   (out of range or dividing by zero) results in "inf"
         *    or "-inf" with %f (INF or -INF with %F).
         *    "0.0 / 0.0" results in "nan" with %f (NAN with %F).
         *   Example: 
         * ```vim
         *     echo printf("%.2f", 12.115)
         * ```
         *     12.12
         *   Note that roundoff depends on the system libraries.
         *   Use |round()| when in doubt.
         * 
         * 
         * e E  The Float argument is converted into a string of the
         *   form 1.234e+03 or 1.234E+03 when using 'E'.  The
         *   precision specifies the number of digits after the
         *   decimal point, like with 'f'.
         * 
         * 
         * g G  The Float argument is converted like with 'f' if the
         *   value is between 0.001 (inclusive) and 10000000.0
         *   (exclusive).  Otherwise 'e' is used for 'g' and 'E'
         *   for 'G'.  When no precision is specified superfluous
         *   zeroes and '+' signs are removed, except for the zero
         *   immediately after the decimal point.  Thus 10000000.0
         *   results in 1.0e7.
         * 
         * 
         * %  A '%' is written.  No argument is converted.  The
         *   complete conversion specification is "%%".
         * 
         * When a Number argument is expected a String argument is also
         * accepted and automatically converted.
         * When a Float or String argument is expected a Number argument
         * is also accepted and automatically converted.
         * Any other argument type results in an error message.
         * 
         * 
         * The number of {exprN} arguments must exactly match the number
         * of "%" items.  If there are not sufficient or too many
         * arguments an error is given.  Up to 18 arguments can be used.
         */
        printf: (fmt: any, expr1: any, ...vargs: any) => string;

        /**
         * Returns the effective prompt text for buffer {buf}.  {buf} can
         * be a buffer name or number.  See |prompt-buffer|.
         * 
         * If the buffer doesn't exist or isn't a prompt buffer, an empty
         * string is returned.
         * 
         * Can also be used as a |method|: 
         * ```vim
         *   GetBuffer()->prompt_getprompt()
         * ```
         */
        prompt_getprompt: (buf: number) => string;

        /**
         * Set prompt callback for buffer {buf} to {expr}.  When {expr}
         * is an empty string the callback is removed.  This has only
         * effect if {buf} has 'buftype' set to "prompt".
         * 
         * The callback is invoked when pressing Enter.  The current
         * buffer will always be the prompt buffer.  A new line for a
         * prompt is added before invoking the callback, thus the prompt
         * for which the callback was invoked will be in the last but one
         * line.
         * If the callback wants to add text to the buffer, it must
         * insert it above the last line, since that is where the current
         * prompt is.  This can also be done asynchronously.
         * The callback is invoked with one argument, which is the text
         * that was entered at the prompt.  This can be an empty string
         * if the user only typed Enter.
         * Example: 
         * ```vim
         *    call prompt_setcallback(bufnr(''), function('s:TextEntered'))
         *    func s:TextEntered(text)
         *      if a:text == 'exit' || a:text == 'quit'
         *        stopinsert
         *        close
         *      else
         *        call append(line('$') - 1, 'Entered: "' .. a:text .. '"')
         *        " Reset 'modified' to allow the buffer to be closed.
         *        set nomodified
         *      endif
         *    endfunc
         * 
         * ```
         * Can also be used as a |method|: >
         *   GetBuffer()->prompt_setcallback(callback)
         */
        prompt_setcallback: (buf: number, expr: any) => undefined;

        /**
         * Set a callback for buffer {buf} to {expr}.  When {expr} is an
         * empty string the callback is removed.  This has only effect if
         * {buf} has 'buftype' set to "prompt".
         * 
         * This callback will be invoked when pressing CTRL-C in Insert
         * mode.  Without setting a callback Vim will exit Insert mode,
         * as in any buffer.
         * 
         * Can also be used as a |method|: 
         * ```vim
         *   GetBuffer()->prompt_setinterrupt(callback)
         * ```
         */
        prompt_setinterrupt: (buf: number, expr: any) => undefined;

        /**
         * Set prompt for buffer {buf} to {text}.  You most likely want
         * {text} to end in a space.
         * The result is only visible if {buf} has 'buftype' set to
         * "prompt".  Example: 
         * ```vim
         *   call prompt_setprompt(bufnr(''), 'command: ')
         * ```
         * Can also be used as a |method|: 
         * ```vim
         *   GetBuffer()->prompt_setprompt('command: ')
         * ```
         */
        prompt_setprompt: (buf: number, text: string) => undefined;

        /**
         * If the popup menu (see |ins-completion-menu|) is not visible,
         * returns an empty |Dictionary|, otherwise, returns a
         * |Dictionary| with the following keys:
         *   height    nr of items visible
         *   width    screen cells
         *   row    top screen row (0 first row)
         *   col    leftmost screen column (0 first col)
         *   size    total nr of items
         *   scrollbar  |TRUE| if scrollbar is visible
         * 
         * The values are the same as in |v:event| during |CompleteChanged|.
         */
        pum_getpos: () => { [key: string]: any };

        /**
         * Returns non-zero when the popup menu is visible, zero
         * otherwise.  See |ins-completion-menu|.
         * This can be used to avoid some things that would remove the
         * popup menu.
         */
        pumvisible: () => number;

        /**
         * Evaluate Python expression {expr} and return its result
         * converted to Vim data structures.
         * Numbers and strings are returned as they are (strings are
         * copied though, Unicode strings are additionally converted to
         * UTF-8).
         * Lists are represented as Vim |List| type.
         * Dictionaries are represented as Vim |Dictionary| type with
         * keys converted to strings.
         * 
         * Can also be used as a |method|: 
         * ```vim
         *   GetExpr()->py3eval()
         * ```
         */
        py3eval: (expr: any) => any;

        /**
         * Evaluate Python expression {expr} and return its result
         * converted to Vim data structures.
         * Numbers and strings are returned as they are (strings are
         * copied though).
         * Lists are represented as Vim |List| type.
         * Dictionaries are represented as Vim |Dictionary| type,
         * non-string keys result in error.
         * 
         * Can also be used as a |method|: 
         * ```vim
         *   GetExpr()->pyeval()
         * ```
         */
        pyeval: (expr: any) => any;

        /**
         * Evaluate Python expression {expr} and return its result
         * converted to Vim data structures.
         * Uses Python 2 or 3, see |python_x| and 'pyxversion'.
         * See also: |pyeval()|, |py3eval()|
         * 
         * Can also be used as a |method|: 
         * ```vim
         *   GetExpr()->pyxeval()
         * ```
         */
        pyxeval: (expr: any) => any;

        /**
         * Return a pseudo-random Number generated with an xoshiro128
         * algorithm using seed {expr}.  The returned number is 32 bits,
         * also on 64 bits systems, for consistency.
         * {expr} can be initialized by |srand()| and will be updated by
         * rand().  If {expr} is omitted, an internal seed value is used
         * and updated.
         * Returns -1 if {expr} is invalid.
         * 
         * Examples: 
         * ```vim
         *   :echo rand()
         *   :let seed = srand()
         *   :echo rand(seed)
         *   :echo rand(seed) % 16  " random number 0 - 15
         * ```
         * Can also be used as a |method|: 
         * ```vim
         *   seed->rand()
         * ```
         */
        rand: (expr?: any) => number;

        /**
         * Returns a |List| with Numbers:
         * - If only {expr} is specified: [0, 1, ..., {expr} - 1]
         * - If {max} is specified: [{expr}, {expr} + 1, ..., {max}]
         * - If {stride} is specified: [{expr}, {expr} + {stride}, ...,
         *   {max}] (increasing {expr} with {stride} each time, not
         *   producing a value past {max}).
         * When the maximum is one before the start the result is an
         * empty list.  When the maximum is more than one before the
         * start this is an error.
         * Examples: 
         * ```vim
         *   range(4)    " [0, 1, 2, 3]
         *   range(2, 4)    " [2, 3, 4]
         *   range(2, 9, 3)    " [2, 5, 8]
         *   range(2, -2, -1)  " [2, 1, 0, -1, -2]
         *   range(0)    " []
         *   range(2, 0)    " error!
         * ```
         * Can also be used as a |method|: 
         * ```vim
         *   GetExpr()->range()
         * ```
         */
        range: (expr: any, max?: any, stride?: any) => any[];

        /**
         * Read file {fname} in binary mode and return a |Blob|.
         * If {offset} is specified, read the file from the specified
         * offset.  If it is a negative value, it is used as an offset
         * from the end of the file.  E.g., to read the last 12 bytes: 
         * ```vim
         *   readblob('file.bin', -12)
         * ```
         * If {size} is specified, only the specified size will be read.
         * E.g. to read the first 100 bytes of a file: 
         * ```vim
         *   readblob('file.bin', 0, 100)
         * ```
         * If {size} is -1 or omitted, the whole data starting from
         * {offset} will be read.
         * This can be also used to read the data from a character device
         * on Unix when {size} is explicitly set.  Only if the device
         * supports seeking {offset} can be used.  Otherwise it should be
         * zero.  E.g. to read 10 bytes from a serial console: 
         * ```vim
         *   readblob('/dev/ttyS0', 0, 10)
         * ```
         * When the file can't be opened an error message is given and
         * the result is an empty |Blob|.
         * When the offset is beyond the end of the file the result is an
         * empty blob.
         * When trying to read more bytes than are available the result
         * is truncated.
         * Also see |readfile()| and |writefile()|.
         */
        readblob: (fname: any, offset?: any, size?: any) => any;

        /**
         * Return a list with file and directory names in {directory}.
         * You can also use |glob()| if you don't need to do complicated
         * things, such as limiting the number of matches.
         * 
         * When {expr} is omitted all entries are included.
         * When {expr} is given, it is evaluated to check what to do:
         *   If {expr} results in -1 then no further entries will
         *   be handled.
         *   If {expr} results in 0 then this entry will not be
         *   added to the list.
         *   If {expr} results in 1 then this entry will be added
         *   to the list.
         * Each time {expr} is evaluated |v:val| is set to the entry name.
         * When {expr} is a function the name is passed as the argument.
         * For example, to get a list of files ending in ".txt": 
         * ```vim
         *   readdir(dirname, {n -> n =~ '.txt$'})
         * ```
         * To skip hidden and backup files: >
         *   readdir(dirname, {n -> n !~ '^\.\|\~$'})
         * 
         * <    If you want to get a directory tree: 
         * ```vim
         *               function! s:tree(dir)
         *                   return {a:dir : map(readdir(a:dir),
         *       \ {_, x -> isdirectory(x) ?
         *       \          {x : s:tree(a:dir .. '/' .. x)} : x})}
         *               endfunction
         *               echo s:tree(".")
         * ```
         * Returns an empty List on error.
         * 
         * Can also be used as a |method|: 
         * ```vim
         *   GetDirName()->readdir()
         * ```
         */
        readdir: (directory: any, expr?: any) => any[];

        /**
         * Read file {fname} and return a |List|, each line of the file
         * as an item.  Lines are broken at NL characters.  Macintosh
         * files separated with CR will result in a single long line
         * (unless a NL appears somewhere).
         * All NUL characters are replaced with a NL character.
         * When {type} contains "b" binary mode is used:
         * - When the last line ends in a NL an extra empty list item is
         *   added.
         * - No CR characters are removed.
         * Otherwise:
         * - CR characters that appear before a NL are removed.
         * - Whether the last line ends in a NL or not does not matter.
         * - Any UTF-8 byte order mark is removed from the text.
         * When {max} is given this specifies the maximum number of lines
         * to be read.  Useful if you only want to check the first ten
         * lines of a file: 
         * ```vim
         *   :for line in readfile(fname, '', 10)
         *   :  if line =~ 'Date' | echo line | endif
         *   :endfor
         * ```
         * When {max} is negative -{max} lines from the end of the file
         * are returned, or as many as there are.
         * When {max} is zero the result is an empty list.
         * Note that without {max} the whole file is read into memory.
         * Also note that there is no recognition of encoding.  Read a
         * file into a buffer if you need to.
         * Deprecated (use |readblob()| instead): When {type} contains
         * "B" a |Blob| is returned with the binary data of the file
         * unmodified.
         * When the file can't be opened an error message is given and
         * the result is an empty list.
         * Also see |writefile()|.
         * 
         * Can also be used as a |method|: 
         * ```vim
         *   GetFileName()->readfile()
         * ```
         */
        readfile: (fname: any, type?: any, max?: any) => any[];

        /**
         * {func} is called for every item in {object}, which can be a
         * |List| or a |Blob|.  {func} is called with two arguments: the
         * result so far and current item.  After processing all items
         * the result is returned.
         * 
         * {initial} is the initial result.  When omitted, the first item
         * in {object} is used and {func} is first called for the second
         * item.  If {initial} is not given and {object} is empty no
         * result can be computed, an E998 error is given.
         * 
         * Examples: 
         * ```vim
         *   echo reduce([1, 3, 5], { acc, val -> acc + val })
         *   echo reduce(['x', 'y'], { acc, val -> acc .. val }, 'a')
         *   echo reduce(0z1122, { acc, val -> 2 * acc + val })
         * ```
         * Can also be used as a |method|: 
         * ```vim
         *   echo mylist->reduce({ acc, val -> acc + val }, 0)
         * ```
         */
        reduce: (object: any, func: Function, initial?: any) => any;

        /**
         * Returns the single letter name of the register being executed.
         * Returns an empty string when no register is being executed.
         * See |@|.
         */
        reg_executing: () => string;

        /**
         * Returns the single letter name of the last recorded register.
         * Returns an empty string when nothing was recorded yet.
         * See |q| and |Q|.
         */
        reg_recorded: () => string;

        /**
         * Returns the single letter name of the register being recorded.
         * Returns an empty string when not recording.  See |q|.
         */
        reg_recording: () => string;

        /**
         * Return an item that represents a time value.  The item is a
         * list with items that depend on the system.
         * The item can be passed to |reltimestr()| to convert it to a
         * string or |reltimefloat()| to convert to a Float.
         * 
         * Without an argument it returns the current "relative time", an
         * implementation-defined value meaningful only when used as an
         * argument to |reltime()|, |reltimestr()| and |reltimefloat()|.
         * 
         * With one argument it returns the time passed since the time
         * specified in the argument.
         * With two arguments it returns the time passed between {start}
         * and {end}.
         * 
         * The {start} and {end} arguments must be values returned by
         * reltime().  Returns zero on error.
         * 
         * Can also be used as a |method|: 
         * ```vim
         *   GetStart()->reltime()
         * ```
         * Note: |localtime()| returns the current (non-relative) time.
         */
        reltime: (start: number, end: any) => any[];

        /**
         * Return a Float that represents the time value of {time}.
         * Unit of time is seconds.
         * Example:
         *   let start = reltime()
         *   call MyFunction()
         *   let seconds = reltimefloat(reltime(start))
         * See the note of reltimestr() about overhead.
         * Also see |profiling|.
         * If there is an error an empty string is returned
         * 
         * Can also be used as a |method|: 
         * ```vim
         *   reltime(start)->reltimefloat()
         * ```
         */
        reltimefloat: (time: any) => number;

        /**
         * Return a String that represents the time value of {time}.
         * This is the number of seconds, a dot and the number of
         * microseconds.  Example: 
         * ```vim
         *   let start = reltime()
         *   call MyFunction()
         *   echo reltimestr(reltime(start))
         * ```
         * Note that overhead for the commands will be added to the time.
         * Leading spaces are used to make the string align nicely.  You
         * can use split() to remove it. 
         * ```vim
         *   echo split(reltimestr(reltime(start)))[0]
         * ```
         * Also see |profiling|.
         * If there is an error an empty string is returned
         * 
         * Can also be used as a |method|: 
         * ```vim
         *   reltime(start)->reltimestr()
         * ```
         */
        reltimestr: (time: any) => string;

        /**
         * Remove the entry from {dict} with key {key} and return it.
         * Example: 
         * ```vim
         *   :echo "removed " .. remove(dict, "one")
         * ```
         * If there is no {key} in {dict} this is an error.
         * Returns zero on error.
         */
        remove: (dict: { [key: string]: any }, key: any) => any;

        /**
         * Rename the file by the name {from} to the name {to}.  This
         * should also work to move files across file systems.  The
         * result is a Number, which is 0 if the file was renamed
         * successfully, and non-zero when the renaming failed.
         * NOTE: If {to} exists it is overwritten without warning.
         * This function is not available in the |sandbox|.
         * 
         * Can also be used as a |method|: 
         * ```vim
         *   GetOldName()->rename(newname)
         * ```
         */
        rename: (from: number, to: number) => number;

        /**
         * Repeat {expr} {count} times and return the concatenated
         * result.  Example: 
         * ```vim
         *   :let separator = repeat('-', 80)
         * ```
         * When {count} is zero or negative the result is empty.
         * When {expr} is a |List| or a |Blob| the result is {expr}
         * concatenated {count} times.  Example: 
         * ```vim
         *   :let longlist = repeat(['a', 'b'], 3)
         * ```
         * Results in ['a', 'b', 'a', 'b', 'a', 'b'].
         * 
         * Can also be used as a |method|: 
         * ```vim
         *   mylist->repeat(count)
         * ```
         */
        repeat: (expr: any, count: any) => any[];

        /**
         * On MS-Windows, when {filename} is a shortcut (a .lnk file),
         * returns the path the shortcut points to in a simplified form.
         * On Unix, repeat resolving symbolic links in all path
         * components of {filename} and return the simplified result.
         * To cope with link cycles, resolving of symbolic links is
         * stopped after 100 iterations.
         * On other systems, return the simplified {filename}.
         * The simplification step is done as by |simplify()|.
         * resolve() keeps a leading path component specifying the
         * current directory (provided the result is still a relative
         * path name) and also keeps a trailing path separator.
         * 
         * Can also be used as a |method|: 
         * ```vim
         *   GetName()->resolve()
         * ```
         */
        resolve: (filename: any) => string;

        /**
         * Reverse the order of items in {object} in-place.
         * {object} can be a |List| or a |Blob|.
         * Returns {object}.
         * Returns zero if {object} is not a List or a Blob.
         * If you want an object to remain unmodified make a copy first: 
         * ```vim
         *   :let revlist = reverse(copy(mylist))
         * ```
         * Can also be used as a |method|: >
         *   mylist->reverse()
         */
        reverse: (object: any) => any[];

        /**
         * Round off {expr} to the nearest integral value and return it
         * as a |Float|.  If {expr} lies halfway between two integral
         * values, then use the larger one (away from zero).
         * {expr} must evaluate to a |Float| or a |Number|.
         * Returns 0.0 if {expr} is not a |Float| or a |Number|.
         * Examples: 
         * ```vim
         *   echo round(0.456)
         * ```
         *   0.0  >
         *   echo round(4.5)
         * <      5.0 
         * ```vim
         *   echo round(-4.5)
         * ```
         *   -5.0
         * 
         * Can also be used as a |method|: 
         * ```vim
         *   Compute()->round()
         * ```
         */
        round: (expr: any) => number;

        /**
         * Sends {event} to {channel} via |RPC| and returns immediately.
         * If {channel} is 0, the event is broadcast to all channels.
         * Example: 
         * ```vim
         *   :au VimLeave call rpcnotify(0, "leaving")
         * ```
         */
        rpcnotify: (channel: any, event: any, args?: any[], ...vargs: any) => any;

        /**
         * Sends a request to {channel} to invoke {method} via
         * |RPC| and blocks until a response is received.
         * Example: 
         * ```vim
         *   :let result = rpcrequest(rpc_chan, "func", 1, 2, 3)
         * ```
         */
        rpcrequest: (channel: any, method: any, args?: any[], ...vargs: any) => any;

        /**
         * Deprecated. Replace  
         * ```vim
         *   :let id = rpcstart('prog', ['arg1', 'arg2'])
         * ```
         * with >
         *   :let id = jobstart(['prog', 'arg1', 'arg2'], {'rpc': v:true})
         */
        rpcstart: (prog: any, argv?: any) => any;

        /**
         * Evaluate Ruby expression {expr} and return its result
         * converted to Vim data structures.
         * Numbers, floats and strings are returned as they are (strings
         * are copied though).
         * Arrays are represented as Vim |List| type.
         * Hashes are represented as Vim |Dictionary| type.
         * Other objects are represented as strings resulted from their
         * "Object#to_s" method.
         * 
         * Can also be used as a |method|: 
         * ```vim
         *   GetRubyExpr()->rubyeval()
         * ```
         */
        rubyeval: (expr: any) => any;

        /**
         * Like |screenchar()|, but return the attribute.  This is a rather
         * arbitrary number that can only be used to compare to the
         * attribute at other positions.
         * Returns -1 when row or col is out of range.
         * 
         * Can also be used as a |method|: 
         * ```vim
         *   GetRow()->screenattr(col)
         * ```
         */
        screenattr: (row: any, col: number) => number;

        /**
         * The result is a Number, which is the character at position
         * [row, col] on the screen.  This works for every possible
         * screen position, also status lines, window separators and the
         * command line.  The top left position is row one, column one
         * The character excludes composing characters.  For double-byte
         * encodings it may only be the first byte.
         * This is mainly to be used for testing.
         * Returns -1 when row or col is out of range.
         * 
         * Can also be used as a |method|: 
         * ```vim
         *   GetRow()->screenchar(col)
         * ```
         */
        screenchar: (row: any, col: number) => number;

        /**
         * The result is a List of Numbers.  The first number is the same
         * as what |screenchar()| returns.  Further numbers are
         * composing characters on top of the base character.
         * This is mainly to be used for testing.
         * Returns an empty List when row or col is out of range.
         * 
         * Can also be used as a |method|: 
         * ```vim
         *   GetRow()->screenchars(col)
         * ```
         */
        screenchars: (row: any, col: number) => any[];

        /**
         * The result is a Number, which is the current screen column of
         * the cursor. The leftmost column has number 1.
         * This function is mainly used for testing.
         * 
         * Note: Always returns the current screen column, thus if used
         * in a command (e.g. ":echo screencol()") it will return the
         * column inside the command line, which is 1 when the command is
         * executed. To get the cursor position in the file use one of
         * the following mappings: 
         * ```vim
         *   nnoremap <expr> GG ":echom " .. screencol() .. "\n"
         *   nnoremap <silent> GG :echom screencol()<CR>
         *   noremap GG <Cmd>echom screencol()<Cr>
         * ```
         */
        screencol: () => number;

        /**
         * The result is a Dict with the screen position of the text
         * character in window {winid} at buffer line {lnum} and column
         * {col}.  {col} is a one-based byte index.
         * The Dict has these members:
         *   row  screen row
         *   col  first screen column
         *   endcol  last screen column
         *   curscol  cursor screen column
         * If the specified position is not visible, all values are zero.
         * The "endcol" value differs from "col" when the character
         * occupies more than one screen cell.  E.g. for a Tab "col" can
         * be 1 and "endcol" can be 8.
         * The "curscol" value is where the cursor would be placed.  For
         * a Tab it would be the same as "endcol", while for a double
         * width character it would be the same as "col".
         * The |conceal| feature is ignored here, the column numbers are
         * as if 'conceallevel' is zero.  You can set the cursor to the
         * right position and use |screencol()| to get the value with
         * |conceal| taken into account.
         * If the position is in a closed fold the screen position of the
         * first character is returned, {col} is not used.
         * Returns an empty Dict if {winid} is invalid.
         * 
         * Can also be used as a |method|: 
         * ```vim
         *   GetWinid()->screenpos(lnum, col)
         * ```
         */
        screenpos: (winid: number, lnum: number, col: number) => { [key: string]: any };

        /**
         * The result is a Number, which is the current screen row of the
         * cursor.  The top line has number one.
         * This function is mainly used for testing.
         * Alternatively you can use |winline()|.
         * 
         * Note: Same restrictions as with |screencol()|.
         */
        screenrow: () => number;

        /**
         * The result is a String that contains the base character and
         * any composing characters at position [row, col] on the screen.
         * This is like |screenchars()| but returning a String with the
         * characters.
         * This is mainly to be used for testing.
         * Returns an empty String when row or col is out of range.
         * 
         * Can also be used as a |method|: 
         * ```vim
         *   GetRow()->screenstring(col)
         * ```
         */
        screenstring: (row: any, col: number) => string;

        /**
         * Search for regexp pattern {pattern}.  The search starts at the
         * cursor position (you can use |cursor()| to set it).
         * 
         * When a match has been found its line number is returned.
         * If there is no match a 0 is returned and the cursor doesn't
         * move.  No error message is given.
         * 
         * {flags} is a String, which can contain these character flags:
         * 'b'  search Backward instead of forward
         * 'c'  accept a match at the Cursor position
         * 'e'  move to the End of the match
         * 'n'  do Not move the cursor
         * 'p'  return number of matching sub-Pattern (see below)
         * 's'  Set the ' mark at the previous location of the cursor
         * 'w'  Wrap around the end of the file
         * 'W'  don't Wrap around the end of the file
         * 'z'  start searching at the cursor column instead of Zero
         * If neither 'w' or 'W' is given, the 'wrapscan' option applies.
         * 
         * If the 's' flag is supplied, the ' mark is set, only if the
         * cursor is moved. The 's' flag cannot be combined with the 'n'
         * flag.
         * 
         * 'ignorecase', 'smartcase' and 'magic' are used.
         * 
         * When the 'z' flag is not given, forward searching always
         * starts in column zero and then matches before the cursor are
         * skipped.  When the 'c' flag is present in 'cpo' the next
         * search starts after the match.  Without the 'c' flag the next
         * search starts one column after the start of the match.  This
         * matters for overlapping matches.  See |cpo-c|.  You can also
         * insert "\ze" to change where the match ends, see  |/\ze|.
         * 
         * When searching backwards and the 'z' flag is given then the
         * search starts in column zero, thus no match in the current
         * line will be found (unless wrapping around the end of the
         * file).
         * 
         * When the {stopline} argument is given then the search stops
         * after searching this line.  This is useful to restrict the
         * search to a range of lines.  Examples: 
         * ```vim
         *   let match = search('(', 'b', line("w0"))
         *   let end = search('END', '', line("w$"))
         * ```
         * When {stopline} is used and it is not zero this also implies
         * that the search does not wrap around the end of the file.
         * A zero value is equal to not giving the argument.
         * 
         * When the {timeout} argument is given the search stops when
         * more than this many milliseconds have passed.  Thus when
         * {timeout} is 500 the search stops after half a second.
         * The value must not be negative.  A zero value is like not
         * giving the argument.
         * 
         * If the {skip} expression is given it is evaluated with the
         * cursor positioned on the start of a match.  If it evaluates to
         * non-zero this match is skipped.  This can be used, for
         * example, to skip a match in a comment or a string.
         * {skip} can be a string, which is evaluated as an expression, a
         * function reference or a lambda.
         * When {skip} is omitted or empty, every match is accepted.
         * When evaluating {skip} causes an error the search is aborted
         * and -1 returned.
         * 
         * With the 'p' flag the returned value is one more than the
         * first sub-match in \(\).  One if none of them matched but the
         * whole pattern did match.
         * To get the column number too use |searchpos()|.
         * 
         * The cursor will be positioned at the match, unless the 'n'
         * flag is used.
         * 
         * Example (goes over all files in the argument list): 
         * ```vim
         *     :let n = 1
         *     :while n <= argc()      " loop over all files in arglist
         *     :  exe "argument " .. n
         *     :  " start at the last char in the file and wrap for the
         *     :  " first search to find match at start of file
         *     :  normal G$
         *     :  let flags = "w"
         *     :  while search("foo", flags) > 0
         *     :   s/foo/bar/g
         *     :   let flags = "W"
         *     :  endwhile
         *     :  update        " write the file if modified
         *     :  let n = n + 1
         *     :endwhile
         * ```
         * Example for using some flags: 
         * ```vim
         *     :echo search('\<if\|\(else\)\|\(endif\)', 'ncpe')
         * ```
         * This will search for the keywords "if", "else", and "endif"
         * under or after the cursor.  Because of the 'p' flag, it
         * returns 1, 2, or 3 depending on which keyword is found, or 0
         * if the search fails.  With the cursor on the first word of the
         * line:
         *     if (foo == 0) | let foo = foo + 1 | endif ~
         * the function returns 1.  Without the 'c' flag, the function
         * finds the "endif" and returns 3.  The same thing happens
         * without the 'e' flag if the cursor is on the "f" of "if".
         * The 'n' flag tells the function not to move the cursor.
         * 
         * Can also be used as a |method|: 
         * ```vim
         *   GetPattern()->search()
         * ```
         */
        search: (pattern: any, flags?: any, stopline?: any, timeout?: any, skip?: any) => number;

        /**
         * Get or update the last search count, like what is displayed
         * without the "S" flag in 'shortmess'.  This works even if
         * 'shortmess' does contain the "S" flag.
         * 
         * This returns a Dictionary. The dictionary is empty if the
         * previous pattern was not set and "pattern" was not specified.
         * 
         *   key    type    meaning ~
         *   current  |Number|  current position of match;
         *         0 if the cursor position is
         *         before the first match
         *   exact_match  |Boolean|  1 if "current" is matched on
         *         "pos", otherwise 0
         *   total    |Number|  total count of matches found
         *   incomplete  |Number|  0: search was fully completed
         *         1: recomputing was timed out
         *         2: max count exceeded
         * 
         * For {options} see further down.
         * 
         * To get the last search count when |n| or |N| was pressed, call
         * this function with `recompute: 0` . This sometimes returns
         * wrong information because |n| and |N|'s maximum count is 99.
         * If it exceeded 99 the result must be max count + 1 (100). If
         * you want to get correct information, specify `recompute: 1`: 
         * ```vim
         * 
         *   " result == maxcount + 1 (100) when many matches
         *   let result = searchcount(#{recompute: 0})
         * 
         *   " Below returns correct result (recompute defaults
         *   " to 1)
         *   let result = searchcount()
         * ```
         * The function is useful to add the count to 'statusline': 
         * ```vim
         *   function! LastSearchCount() abort
         *     let result = searchcount(#{recompute: 0})
         *     if empty(result)
         *       return ''
         *     endif
         *     if result.incomplete ==# 1     " timed out
         *       return printf(' /%s [?/??]', @/)
         *     elseif result.incomplete ==# 2 " max count exceeded
         *       if result.total > result.maxcount &&
         *       \  result.current > result.maxcount
         *         return printf(' /%s [>%d/>%d]', @/,
         *         \             result.current, result.total)
         *       elseif result.total > result.maxcount
         *         return printf(' /%s [%d/>%d]', @/,
         *         \             result.current, result.total)
         *       endif
         *     endif
         *     return printf(' /%s [%d/%d]', @/,
         *     \             result.current, result.total)
         *   endfunction
         *   let &statusline ..= '%{LastSearchCount()}'
         * 
         *   " Or if you want to show the count only when
         *   " 'hlsearch' was on
         *   " let &statusline ..=
         *   " \   '%{v:hlsearch ? LastSearchCount() : ""}'
         * ```
         * You can also update the search count, which can be useful in a
         * |CursorMoved| or |CursorMovedI| autocommand: 
         * ```vim
         * 
         *   autocmd CursorMoved,CursorMovedI *
         *     \ let s:searchcount_timer = timer_start(
         *     \   200, function('s:update_searchcount'))
         *   function! s:update_searchcount(timer) abort
         *     if a:timer ==# s:searchcount_timer
         *       call searchcount(#{
         *       \ recompute: 1, maxcount: 0, timeout: 100})
         *       redrawstatus
         *     endif
         *   endfunction
         * ```
         * This can also be used to count matched texts with specified
         * pattern in the current buffer using "pattern":  
         * ```vim
         * 
         *   " Count '\<foo\>' in this buffer
         *   " (Note that it also updates search count)
         *   let result = searchcount(#{pattern: '\<foo\>'})
         * 
         *   " To restore old search count by old pattern,
         *   " search again
         *   call searchcount()
         * ```
         * {options} must be a Dictionary. It can contain:
         *   key    type    meaning ~
         *   recompute  |Boolean|  if |TRUE|, recompute the count
         *         like |n| or |N| was executed.
         *         otherwise returns the last
         *         computed result (when |n| or
         *         |N| was used when "S" is not
         *         in 'shortmess', or this
         *         function was called).
         *         (default: |TRUE|)
         *   pattern  |String|  recompute if this was given
         *         and different with |@/|.
         *         this works as same as the
         *         below command is executed
         *         before calling this function 
         * ```vim
         *           let @/ = pattern
         * ```
         *         (default: |@/|)
         *   timeout  |Number|  0 or negative number is no
         *         timeout. timeout milliseconds
         *         for recomputing the result
         *         (default: 0)
         *   maxcount  |Number|  0 or negative number is no
         *         limit. max count of matched
         *         text while recomputing the
         *         result.  if search exceeded
         *         total count, "total" value
         *         becomes `maxcount + 1`
         *         (default: 0)
         *   pos    |List|    `[lnum, col, off]` value
         *         when recomputing the result.
         *         this changes "current" result
         *         value. see |cursor()|, |getpos()|
         *         (default: cursor's position)
         * 
         * Can also be used as a |method|: 
         * ```vim
         *   GetSearchOpts()->searchcount()
         * ```
         */
        searchcount: (options?: { [key: string]: any }) => { [key: string]: any };

        /**
         * Search for the declaration of {name}.
         * 
         * With a non-zero {global} argument it works like |gD|, find
         * first match in the file.  Otherwise it works like |gd|, find
         * first match in the function.
         * 
         * With a non-zero {thisblock} argument matches in a {} block
         * that ends before the cursor position are ignored.  Avoids
         * finding variable declarations only valid in another scope.
         * 
         * Moves the cursor to the found match.
         * Returns zero for success, non-zero for failure.
         * Example: 
         * ```vim
         *   if searchdecl('myvar') == 0
         *      echo getline('.')
         *   endif
         * ```
         * Can also be used as a |method|: 
         * ```vim
         *   GetName()->searchdecl()
         * ```
         */
        searchdecl: (name: any, global?: any, thisblock?: any) => number;

        /**
         *   Search for the match of a nested start-end pair.  This can be
         *   used to find the "endif" that matches an "if", while other
         *   if/endif pairs in between are ignored.
         *   The search starts at the cursor.  The default is to search
         *   forward, include 'b' in {flags} to search backward.
         *   If a match is found, the cursor is positioned at it and the
         *   line number is returned.  If no match is found 0 or -1 is
         *   returned and the cursor doesn't move.  No error message is
         *   given.
         * 
         *   {start}, {middle} and {end} are patterns, see |pattern|.  They
         *   must not contain \( \) pairs.  Use of \%( \) is allowed.  When
         *   {middle} is not empty, it is found when searching from either
         *   direction, but only when not in a nested start-end pair.  A
         *   typical use is: 
         * ```vim
         *     searchpair('\<if\>', '\<else\>', '\<endif\>')
         * ```
         *   By leaving {middle} empty the "else" is skipped.
         * 
         *   {flags} 'b', 'c', 'n', 's', 'w' and 'W' are used like with
         *   |search()|.  Additionally:
         *   'r'  Repeat until no more matches found; will find the
         *     outer pair.  Implies the 'W' flag.
         *   'm'  Return number of matches instead of line number with
         *     the match; will be > 1 when 'r' is used.
         *   Note: it's nearly always a good idea to use the 'W' flag, to
         *   avoid wrapping around the end of the file.
         * 
         *   When a match for {start}, {middle} or {end} is found, the
         *   {skip} expression is evaluated with the cursor positioned on
         *   the start of the match.  It should return non-zero if this
         *   match is to be skipped.  E.g., because it is inside a comment
         *   or a string.
         *   When {skip} is omitted or empty, every match is accepted.
         *   When evaluating {skip} causes an error the search is aborted
         *   and -1 returned.
         *   {skip} can be a string, a lambda, a funcref or a partial.
         *   Anything else makes the function fail.
         * 
         *   For {stopline} and {timeout} see |search()|.
         * 
         *   The value of 'ignorecase' is used.  'magic' is ignored, the
         *   patterns are used like it's on.
         * 
         *   The search starts exactly at the cursor.  A match with
         *   {start}, {middle} or {end} at the next character, in the
         *   direction of searching, is the first one found.  Example: 
         * ```vim
         *     if 1
         *       if 2
         *       endif 2
         *     endif 1
         * ```
         *   When starting at the "if 2", with the cursor on the "i", and
         *   searching forwards, the "endif 2" is found.  When starting on
         *   the character just before the "if 2", the "endif 1" will be
         *   found.  That's because the "if 2" will be found first, and
         *   then this is considered to be a nested if/endif from "if 2" to
         *   "endif 2".
         *   When searching backwards and {end} is more than one character,
         *   it may be useful to put "\zs" at the end of the pattern, so
         *   that when the cursor is inside a match with the end it finds
         *   the matching start.
         * 
         *   Example, to find the "endif" command in a Vim script: 
         * ```vim
         * 
         * :echo searchpair('\<if\>', '\<el\%[seif]\>', '\<en\%[dif]\>', 'W',
         *     \ 'getline(".") =~ "^\\s*\""')
         * 
         * ```
         *   The cursor must be at or after the "if" for which a match is
         *   to be found.  Note that single-quote strings are used to avoid
         *   having to double the backslashes.  The skip expression only
         *   catches comments at the start of a line, not after a command.
         *   Also, a word "en" or "if" halfway through a line is considered
         *   a match.
         *   Another example, to search for the matching "{" of a "}": 
         * ```vim
         * 
         * :echo searchpair('{', '', '}', 'bW')
         * 
         * ```
         *   This works when the cursor is at or before the "}" for which a
         *   match is to be found.  To reject matches that syntax
         *   highlighting recognized as strings: 
         * ```vim
         * 
         * :echo searchpair('{', '', '}', 'bW',
         *      \ 'synIDattr(synID(line("."), col("."), 0), "name") =~? "string"')
         * ```
         */
        searchpair: (start: number, middle: any, end: any, flags?: any, skip?: any, stopline?: any, timeout?: any) => number;

        /**
         * Same as |searchpair()|, but returns a |List| with the line and
         * column position of the match. The first element of the |List|
         * is the line number and the second element is the byte index of
         * the column position of the match.  If no match is found,
         * returns [0, 0]. 
         * ```vim
         * 
         *   :let 
         * ```
         * See |match-parens| for a bigger and more useful example.
         */
        searchpairpos: (start: number, middle: any, end: any, flags?: any, skip?: any, stopline?: any, timeout?: any) => any[];

        /**
         *   Same as |search()|, but returns a |List| with the line and
         *   column position of the match. The first element of the |List|
         *   is the line number and the second element is the byte index of
         *   the column position of the match. If no match is found,
         *   returns [0, 0].
         *   Example: 
         * ```vim
         * :let [lnum, col] = searchpos('mypattern', 'n')
         * 
         * ```
         *   When the 'p' flag is given then there is an extra item with
         *   the sub-pattern match number |search()-sub-match|.  Example: 
         * ```vim
         * :let [lnum, col, submatch] = searchpos('\(\l\)\|\(\u\)', 'np')
         * ```
         *   In this example "submatch" is 2 when a lowercase letter is
         *   found |/\l|, 3 when an uppercase letter is found |/\u|.
         * 
         *   Can also be used as a |method|: 
         * ```vim
         *     GetPattern()->searchpos()
         * ```
         */
        searchpos: (pattern: any, flags?: any, stopline?: any, timeout?: any, skip?: any) => any[];

        /**
         * Returns a list of server addresses, or empty if all servers
         * were stopped. |serverstart()| |serverstop()|
         * Example: 
         * ```vim
         *   :echo serverlist()
         * ```
         */
        serverlist: () => string;

        /**
         * Opens a socket or named pipe at {address} and listens for
         * |RPC| messages. Clients can send |API| commands to the
         * returned address to control Nvim.
         * 
         * Returns the address string (which may differ from the
         * {address} argument, see below).
         * 
         * - If {address} has a colon (":") it is a TCP/IPv4/IPv6 address
         *   where the last ":" separates host and port (empty or zero
         *   assigns a random port).
         * - Else {address} is the path to a named pipe (except on Windows).
         *   - If {address} has no slashes ("/") it is treated as the
         *     "name" part of a generated path in this format: 
         * ```vim
         *   stdpath("run").."/{name}.{pid}.{counter}"
         * ```
         *   - If {address} is omitted the name is "nvim". >
         *   :echo serverstart()
         *   => /tmp/nvim.bram/oknANW/nvim.15430.5
         * 
         * <    Example bash command to list all Nvim servers: 
         * ```vim
         *   ls ${XDG_RUNTIME_DIR:-${TMPDIR}nvim.${USER}}/.0
         * 
         * ```
         * Example named pipe: >
         *   if has('win32')
         *     echo serverstart('\\.\pipe\nvim-pipe-1234')
         *   else
         *     echo serverstart('nvim.sock')
         *   endif
         * <
         * Example TCP/IP address: 
         * ```vim
         *   echo serverstart('::1:12345')
         * ```
         */
        serverstart: (address?: any) => any;

        /**
         * Closes the pipe or socket at {address}.
         * Returns TRUE if {address} is valid, else FALSE.
         * If |v:servername| is stopped it is set to the next available
         * address in |serverlist()|.
         */
        serverstop: (address: any) => any;

        /**
         * Set line {lnum} to {text} in buffer {buf}.  This works like
         * |setline()| for the specified buffer.
         * 
         * This function works only for loaded buffers. First call
         * |bufload()| if needed.
         * 
         * To insert lines use |appendbufline()|.
         * 
         * {text} can be a string to set one line, or a list of strings
         * to set multiple lines.  If the list extends below the last
         * line then those lines are added.
         * 
         * For the use of {buf}, see |bufname()| above.
         * 
         * {lnum} is used like with |setline()|.
         * Use "$" to refer to the last line in buffer {buf}.
         * When {lnum} is just below the last line the {text} will be
         * added below the last line.
         * On success 0 is returned, on failure 1 is returned.
         * 
         * If {buf} is not a valid buffer or {lnum} is not valid, an
         * error message is given.
         * 
         * Can also be used as a |method|, the base is passed as the
         * third argument: 
         * ```vim
         *   GetText()->setbufline(buf, lnum)
         * ```
         */
        setbufline: (buf: number, lnum: number, text: string) => number;

        /**
         * Set option or local variable {varname} in buffer {buf} to
         * {val}.
         * This also works for a global or local window option, but it
         * doesn't work for a global or local window variable.
         * For a local window option the global value is unchanged.
         * For the use of {buf}, see |bufname()| above.
         * The {varname} argument is a string.
         * Note that the variable name without "b:" must be used.
         * Examples: 
         * ```vim
         *   :call setbufvar(1, "&mod", 1)
         *   :call setbufvar("todo", "myvar", "foobar")
         * ```
         * This function is not available in the |sandbox|.
         * 
         * Can also be used as a |method|, the base is passed as the
         * third argument: 
         * ```vim
         *   GetValue()->setbufvar(buf, varname)
         * ```
         */
        setbufvar: (buf: number, varname: any, val: any) => boolean;

        /**
         * Specify overrides for cell widths of character ranges.  This
         * tells Vim how wide characters are when displayed in the
         * terminal, counted in screen cells.  The values override
         * 'ambiwidth'.  Example: 
         * ```vim
         *    call setcellwidths([
         *     \ [0x111, 0x111, 1],
         *     \ [0x2194, 0x2199, 2],
         *     \ ])
         * 
         * ```
         * The {list} argument is a List of Lists with each three
         * numbers: [{low}, {high}, {width}].
         * {low} and {high} can be the same, in which case this refers to
         * one character.  Otherwise it is the range of characters from
         * {low} to {high} (inclusive).
         * Only characters with value 0x80 and higher can be used.
         * 
         * {width} must be either 1 or 2, indicating the character width
         * in screen cells.
         * An error is given if the argument is invalid, also when a
         * range overlaps with another.
         * 
         * If the new value causes 'fillchars' or 'listchars' to become
         * invalid it is rejected and an error is given.
         * 
         * To clear the overrides pass an empty {list}: 
         * ```vim
         *    call setcellwidths([])
         * 
         * ```
         * You can use the script $VIMRUNTIME/tools/emoji_list.vim to see
         * the effect for known emoji characters.  Move the cursor
         * through the text to check if the cell widths of your terminal
         * match with what Vim knows about each emoji.  If it doesn't
         * look right you need to adjust the {list} argument.
         */
        setcellwidths: (list: any[]) => undefined;

        /**
         * Same as |setpos()| but uses the specified column number as the
         * character index instead of the byte index in the line.
         * 
         * Example:
         * With the text "여보세요" in line 8: 
         * ```vim
         *   call setcharpos('.', [0, 8, 4, 0])
         * ```
         * positions the cursor on the fourth character '요'. >
         *   call setpos('.', [0, 8, 4, 0])
         * <    positions the cursor on the second character '보'.
         * 
         * Can also be used as a |method|: 
         * ```vim
         *   GetPosition()->setcharpos('.')
         * ```
         */
        setcharpos: (expr: any, list: any[]) => number;

        /**
         * Set the current character search information to {dict},
         * which contains one or more of the following entries:
         * 
         *     char  character which will be used for a subsequent
         *     |,| or |;| command; an empty string clears the
         *     character search
         *     forward  direction of character search; 1 for forward,
         *     0 for backward
         *     until  type of character search; 1 for a |t| or |T|
         *     character search, 0 for an |f| or |F|
         *     character search
         * 
         * This can be useful to save/restore a user's character search
         * from a script: 
         * ```vim
         *   :let prevsearch = getcharsearch()
         *   :" Perform a command which clobbers user's search
         *   :call setcharsearch(prevsearch)
         * ```
         * Also see |getcharsearch()|.
         * 
         * Can also be used as a |method|: 
         * ```vim
         *   SavedSearch()->setcharsearch()
         * ```
         */
        setcharsearch: (dict: { [key: string]: any }) => { [key: string]: any };

        /**
         * Set the command line to {str} and set the cursor position to
         * {pos}.
         * If {pos} is omitted, the cursor is positioned after the text.
         * Returns 0 when successful, 1 when not editing the command
         * line.
         * 
         * Can also be used as a |method|: 
         * ```vim
         *   GetText()->setcmdline()
         * ```
         */
        setcmdline: (str: string, pos?: number) => number;

        /**
         * Set the cursor position in the command line to byte position
         * {pos}.  The first position is 1.
         * Use |getcmdpos()| to obtain the current position.
         * Only works while editing the command line, thus you must use
         * |c_CTRL-\_e|, |c_CTRL-R_=| or |c_CTRL-R_CTRL-R| with '='.  For
         * |c_CTRL-\_e| and |c_CTRL-R_CTRL-R| with '=' the position is
         * set after the command line is set to the expression.  For
         * |c_CTRL-R_=| it is set after evaluating the expression but
         * before inserting the resulting text.
         * When the number is too big the cursor is put at the end of the
         * line.  A number smaller than one has undefined results.
         * Returns 0 when successful, 1 when not editing the command
         * line.
         * 
         * Can also be used as a |method|: 
         * ```vim
         *   GetPos()->setcmdpos()
         * ```
         */
        setcmdpos: (pos: number) => number;

        /**
         * Same as |cursor()| but uses the specified column number as the
         * character index instead of the byte index in the line.
         * 
         * Example:
         * With the text "여보세요" in line 4: 
         * ```vim
         *   call setcursorcharpos(4, 3)
         * ```
         * positions the cursor on the third character '세'. >
         *   call cursor(4, 3)
         * <    positions the cursor on the first character '여'.
         * 
         * Can also be used as a |method|: 
         * ```vim
         *   GetCursorPos()->setcursorcharpos()
         * ```
         */
        setcursorcharpos: (list: any[]) => number;

        /**
         * Set environment variable {name} to {val}.  Example: 
         * ```vim
         *   call setenv('HOME', '/home/myhome')
         * 
         * ```
         * When {val} is |v:null| the environment variable is deleted.
         * See also |expr-env|.
         * 
         * Can also be used as a |method|, the base is passed as the
         * second argument: 
         * ```vim
         *   GetPath()->setenv('PATH')
         * ```
         */
        setenv: (name: any, val: any) => undefined;

        /**
         * Set the file permissions for {fname} to {mode}.
         * {mode} must be a string with 9 characters.  It is of the form
         * "rwxrwxrwx", where each group of "rwx" flags represent, in
         * turn, the permissions of the owner of the file, the group the
         * file belongs to, and other users.  A '-' character means the
         * permission is off, any other character means on.  Multi-byte
         * characters are not supported.
         * 
         * For example "rw-r-----" means read-write for the user,
         * readable by the group, not accessible by others.  "xx-x-----"
         * would do the same thing.
         * 
         * Returns non-zero for success, zero for failure.
         * 
         * Can also be used as a |method|: 
         * ```vim
         *   GetFilename()->setfperm(mode)
         * ```
         * To read permissions see |getfperm()|.
         */
        setfperm: (fname: any, mode: any) => any;

        /**
         * Set line {lnum} of the current buffer to {text}.  To insert
         * lines use |append()|. To set lines in another buffer use
         * |setbufline()|.
         * 
         * {lnum} is used like with |getline()|.
         * When {lnum} is just below the last line the {text} will be
         * added below the last line.
         * {text} can be any type or a List of any type, each item is
         * converted to a String.
         * 
         * If this succeeds, FALSE is returned.  If this fails (most likely
         * because {lnum} is invalid) TRUE is returned.
         * 
         * Example: 
         * ```vim
         *   :call setline(5, strftime("%c"))
         * 
         * ```
         * When {text} is a |List| then line {lnum} and following lines
         * will be set to the items in the list.  Example: 
         * ```vim
         *   :call setline(5, ['aaa', 'bbb', 'ccc'])
         * ```
         * This is equivalent to: >
         *   :for [n, l] in [[5, 'aaa'], [6, 'bbb'], [7, 'ccc']]
         *   :  call setline(n, l)
         *   :endfor
         * 
         * <    Note: The '[ and '] marks are not set.
         * 
         * Can also be used as a |method|, the base is passed as the
         * second argument: 
         * ```vim
         *   GetText()->setline(lnum)
         * ```
         */
        setline: (lnum: number, text: string) => number;

        /**
         * Create or replace or add to the location list for window {nr}.
         * {nr} can be the window number or the |window-ID|.
         * When {nr} is zero the current window is used.
         * 
         * For a location list window, the displayed location list is
         * modified.  For an invalid window number {nr}, -1 is returned.
         * Otherwise, same as |setqflist()|.
         * Also see |location-list|.
         * 
         * For {action} see |setqflist-action|.
         * 
         * If the optional {what} dictionary argument is supplied, then
         * only the items listed in {what} are set. Refer to |setqflist()|
         * for the list of supported keys in {what}.
         * 
         * Can also be used as a |method|, the base is passed as the
         * second argument: 
         * ```vim
         *   GetLoclist()->setloclist(winnr)
         * ```
         */
        setloclist: (nr: number, list: any[], action?: any, what?: any) => number;

        /**
         * Restores a list of matches saved by |getmatches()| for the
         * current window.  Returns 0 if successful, otherwise -1.  All
         * current matches are cleared before the list is restored.  See
         * example for |getmatches()|.
         * If {win} is specified, use the window with this number or
         * window ID instead of the current window.
         * 
         * Can also be used as a |method|: 
         * ```vim
         *   GetMatches()->setmatches()
         * ```
         */
        setmatches: (list: any[], win?: number) => number;

        /**
         * Set the position for String {expr}.  Possible values:
         *   .  the cursor
         *   'x  mark x
         * 
         * {list} must be a |List| with four or five numbers:
         *     [bufnum, lnum, col, off]
         *     [bufnum, lnum, col, off, curswant]
         * 
         * "bufnum" is the buffer number.  Zero can be used for the
         * current buffer.  When setting an uppercase mark "bufnum" is
         * used for the mark position.  For other marks it specifies the
         * buffer to set the mark in.  You can use the |bufnr()| function
         * to turn a file name into a buffer number.
         * For setting the cursor and the ' mark "bufnum" is ignored,
         * since these are associated with a window, not a buffer.
         * Does not change the jumplist.
         * 
         * "lnum" and "col" are the position in the buffer.  The first
         * column is 1.  Use a zero "lnum" to delete a mark.  If "col" is
         * smaller than 1 then 1 is used. To use the character count
         * instead of the byte count, use |setcharpos()|.
         * 
         * The "off" number is only used when 'virtualedit' is set. Then
         * it is the offset in screen columns from the start of the
         * character.  E.g., a position within a <Tab> or after the last
         * character.
         * 
         * The "curswant" number is only used when setting the cursor
         * position.  It sets the preferred column for when moving the
         * cursor vertically.  When the "curswant" number is missing the
         * preferred column is not set.  When it is present and setting a
         * mark position it is not used.
         * 
         * Note that for '< and '> changing the line number may result in
         * the marks to be effectively be swapped, so that '< is always
         * before '>.
         * 
         * Returns 0 when the position could be set, -1 otherwise.
         * An error message is given if {expr} is invalid.
         * 
         * Also see |setcharpos()|, |getpos()| and |getcurpos()|.
         * 
         * This does not restore the preferred column for moving
         * vertically; if you set the cursor position with this, |j| and
         * |k| motions will jump to previous columns!  Use |cursor()| to
         * also set the preferred column.  Also see the "curswant" key in
         * |winrestview()|.
         * 
         * Can also be used as a |method|: 
         * ```vim
         *   GetPosition()->setpos('.')
         * ```
         */
        setpos: (expr: any, list: any[]) => number;

        /**
         * Create or replace or add to the quickfix list.
         * 
         * If the optional {what} dictionary argument is supplied, then
         * only the items listed in {what} are set. The first {list}
         * argument is ignored.  See below for the supported items in
         * {what}.
         * 
         * When {what} is not present, the items in {list} are used.  Each
         * item must be a dictionary.  Non-dictionary items in {list} are
         * ignored.  Each dictionary item can contain the following
         * entries:
         * 
         *     bufnr  buffer number; must be the number of a valid
         *     buffer
         *     filename  name of a file; only used when "bufnr" is not
         *     present or it is invalid.
         *     module  name of a module; if given it will be used in
         *     quickfix error window instead of the filename.
         *     lnum  line number in the file
         *     end_lnum  end of lines, if the item spans multiple lines
         *     pattern  search pattern used to locate the error
         *     col    column number
         *     vcol  when non-zero: "col" is visual column
         *     when zero: "col" is byte index
         *     end_col  end column, if the item spans multiple columns
         *     nr    error number
         *     text  description of the error
         *     type  single-character error type, 'E', 'W', etc.
         *     valid  recognized error message
         * 
         * The "col", "vcol", "nr", "type" and "text" entries are
         * optional.  Either "lnum" or "pattern" entry can be used to
         * locate a matching error line.
         * If the "filename" and "bufnr" entries are not present or
         * neither the "lnum" or "pattern" entries are present, then the
         * item will not be handled as an error line.
         * If both "pattern" and "lnum" are present then "pattern" will
         * be used.
         * If the "valid" entry is not supplied, then the valid flag is
         * set when "bufnr" is a valid buffer or "filename" exists.
         * If you supply an empty {list}, the quickfix list will be
         * cleared.
         * Note that the list is not exactly the same as what
         * |getqflist()| returns.
         * 
         * {action} values:
         * 'a'  The items from {list} are added to the existing
         *   quickfix list. If there is no existing list, then a
         *   new list is created.
         * 
         * 'r'  The items from the current quickfix list are replaced
         *   with the items from {list}.  This can also be used to
         *   clear the list: 
         * ```vim
         *     :call setqflist([], 'r')
         * ```
         * 'f'  All the quickfix lists in the quickfix stack are
         *   freed.
         * 
         * If {action} is not present or is set to ' ', then a new list
         * is created. The new quickfix list is added after the current
         * quickfix list in the stack and all the following lists are
         * freed. To add a new quickfix list at the end of the stack,
         * set "nr" in {what} to "$".
         * 
         * The following items can be specified in dictionary {what}:
         *     context  quickfix list context. See |quickfix-context|
         *     efm    errorformat to use when parsing text from
         *     "lines". If this is not present, then the
         *     'errorformat' option value is used.
         *     See |quickfix-parse|
         *     id    quickfix list identifier |quickfix-ID|
         *     idx    index of the current entry in the quickfix
         *     list specified by "id" or "nr". If set to '$',
         *     then the last entry in the list is set as the
         *     current entry.  See |quickfix-index|
         *     items  list of quickfix entries. Same as the {list}
         *     argument.
         *     lines  use 'errorformat' to parse a list of lines and
         *     add the resulting entries to the quickfix list
         *     {nr} or {id}.  Only a |List| value is supported.
         *     See |quickfix-parse|
         *     nr    list number in the quickfix stack; zero
         *     means the current quickfix list and "$" means
         *     the last quickfix list.
         *     quickfixtextfunc
         *     function to get the text to display in the
         *     quickfix window.  The value can be the name of
         *     a function or a funcref or a lambda.  Refer to
         *     |quickfix-window-function| for an explanation
         *     of how to write the function and an example.
         *     title  quickfix list title text. See |quickfix-title|
         * Unsupported keys in {what} are ignored.
         * If the "nr" item is not present, then the current quickfix list
         * is modified. When creating a new quickfix list, "nr" can be
         * set to a value one greater than the quickfix stack size.
         * When modifying a quickfix list, to guarantee that the correct
         * list is modified, "id" should be used instead of "nr" to
         * specify the list.
         * 
         * Examples (See also |setqflist-examples|): 
         * ```vim
         *    :call setqflist([], 'r', {'title': 'My search'})
         *    :call setqflist([], 'r', {'nr': 2, 'title': 'Errors'})
         *    :call setqflist([], 'a', {'id':qfid, 'lines':["F1:10:L10"]})
         * ```
         * Returns zero for success, -1 for failure.
         * 
         * This function can be used to create a quickfix list
         * independent of the 'errorformat' setting.  Use a command like
         * `:cc 1` to jump to the first position.
         * 
         * Can also be used as a |method|, the base is passed as the
         * second argument: 
         * ```vim
         *   GetErrorlist()->setqflist()
         * ```
         */
        setqflist: (list: any[], action?: any, what?: any) => number;

        /**
         * Set the register {regname} to {value}.
         * If {regname} is "" or "@", the unnamed register '"' is used.
         * The {regname} argument is a string.
         * 
         * {value} may be any value returned by |getreg()| or
         * |getreginfo()|, including a |List| or |Dict|.
         * If {options} contains "a" or {regname} is upper case,
         * then the value is appended.
         * 
         * {options} can also contain a register type specification:
         *     "c" or "v"        |charwise| mode
         *     "l" or "V"        |linewise| mode
         *     "b" or "<CTRL-V>" |blockwise-visual| mode
         * If a number immediately follows "b" or "<CTRL-V>" then this is
         * used as the width of the selection - if it is not specified
         * then the width of the block is set to the number of characters
         * in the longest line (counting a <Tab> as 1 character).
         * If {options} contains "u" or '"', then the unnamed register is
         * set to point to register {regname}.
         * 
         * If {options} contains no register settings, then the default
         * is to use character mode unless {value} ends in a <NL> for
         * string {value} and linewise mode for list {value}. Blockwise
         * mode is never selected automatically.
         * Returns zero for success, non-zero for failure.
         * 
         * 
         * Note: you may not use |List| containing more than one item to
         *       set search and expression registers. Lists containing no
         *       items act like empty strings.
         * 
         * Examples: 
         * ```vim
         *   :call setreg(v:register, @*)
         *   :call setreg('*', @%, 'ac')
         *   :call setreg('a', "1\n2\n3", 'b5')
         *   :call setreg('"', { 'points_to': 'a'})
         * 
         * ```
         * This example shows using the functions to save and restore a
         * register: 
         * ```vim
         *   :let var_a = getreginfo()
         *   :call setreg('a', var_a)
         * ```
         * or: >
         *   :let var_a = getreg('a', 1, 1)
         *   :let var_amode = getregtype('a')
         *       ....
         *   :call setreg('a', var_a, var_amode)
         * <    Note: you may not reliably restore register value
         * without using the third argument to |getreg()| as without it
         * newlines are represented as newlines AND Nul bytes are
         * represented as newlines as well, see |NL-used-for-Nul|.
         * 
         * You can also change the type of a register by appending
         * nothing: 
         * ```vim
         *   :call setreg('a', '', 'al')
         * 
         * ```
         * Can also be used as a |method|, the base is passed as the
         * second argument: 
         * ```vim
         *   GetText()->setreg('a')
         * ```
         */
        setreg: (regname: any, value: any, options?: { [key: string]: any }) => number;

        /**
         * Set tab-local variable {varname} to {val} in tab page {tabnr}.
         * |t:var|
         * The {varname} argument is a string.
         * Note that the variable name without "t:" must be used.
         * Tabs are numbered starting with one.
         * This function is not available in the |sandbox|.
         * 
         * Can also be used as a |method|, the base is passed as the
         * third argument: 
         * ```vim
         *   GetValue()->settabvar(tab, name)
         * ```
         */
        settabvar: (tabnr: number, varname: any, val: any) => boolean;

        /**
         * Set option or local variable {varname} in window {winnr} to
         * {val}.
         * Tabs are numbered starting with one.  For the current tabpage
         * use |setwinvar()|.
         * {winnr} can be the window number or the |window-ID|.
         * When {winnr} is zero the current window is used.
         * This also works for a global or local buffer option, but it
         * doesn't work for a global or local buffer variable.
         * For a local buffer option the global value is unchanged.
         * Note that the variable name without "w:" must be used.
         * Examples: 
         * ```vim
         *   :call settabwinvar(1, 1, "&list", 0)
         *   :call settabwinvar(3, 2, "myvar", "foobar")
         * ```
         * This function is not available in the |sandbox|.
         * 
         * Can also be used as a |method|, the base is passed as the
         * fourth argument: 
         * ```vim
         *   GetValue()->settabwinvar(tab, winnr, name)
         * ```
         */
        settabwinvar: (tabnr: number, winnr: number, varname: any, val: any) => boolean;

        /**
         * Modify the tag stack of the window {nr} using {dict}.
         * {nr} can be the window number or the |window-ID|.
         * 
         * For a list of supported items in {dict}, refer to
         * |gettagstack()|. "curidx" takes effect before changing the tag
         * stack.
         * 
         * How the tag stack is modified depends on the {action}
         * argument:
         * - If {action} is not present or is set to 'r', then the tag
         *   stack is replaced.
         * - If {action} is set to 'a', then new entries from {dict} are
         *   pushed (added) onto the tag stack.
         * - If {action} is set to 't', then all the entries from the
         *   current entry in the tag stack or "curidx" in {dict} are
         *   removed and then new entries are pushed to the stack.
         * 
         * The current index is set to one after the length of the tag
         * stack after the modification.
         * 
         * Returns zero for success, -1 for failure.
         * 
         * Examples (for more examples see |tagstack-examples|):
         *     Empty the tag stack of window 3: 
         * ```vim
         *   call settagstack(3, {'items' : []})
         * 
         * ```
         *     Save and restore the tag stack: >
         *   let stack = gettagstack(1003)
         *   " do something else
         *   call settagstack(1003, stack)
         *   unlet stack
         * <
         * Can also be used as a |method|, the base is passed as the
         * second argument: 
         * ```vim
         *   GetStack()->settagstack(winnr)
         * ```
         */
        settagstack: (nr: number, dict: { [key: string]: any }, action?: any) => number;

        /**
         * Like |settabwinvar()| for the current tab page.
         * Examples: 
         * ```vim
         *   :call setwinvar(1, "&list", 0)
         *   :call setwinvar(2, "myvar", "foobar")
         * 
         * ```
         * Can also be used as a |method|, the base is passed as the
         * third argument: 
         * ```vim
         *   GetValue()->setwinvar(winnr, name)
         * ```
         */
        setwinvar: (nr: number, varname: any, val: any) => boolean;

        /**
         * Returns a String with 64 hex characters, which is the SHA256
         * checksum of {string}.
         * 
         * Can also be used as a |method|: 
         * ```vim
         *   GetText()->sha256()
         * ```
         */
        sha256: (string: string) => string;

        /**
         * Escape {string} for use as a shell command argument.
         * 
         * On Windows when 'shellslash' is not set, encloses {string} in
         * double-quotes and doubles all double-quotes within {string}.
         * Otherwise encloses {string} in single-quotes and replaces all
         * "'" with "'\''".
         * 
         * If {special} is a |non-zero-arg|:
         * - Special items such as "!", "%", "#" and "<cword>" will be
         *   preceded by a backslash. The backslash will be removed again
         *   by the |:!| command.
         * - The <NL> character is escaped.
         * 
         * If 'shell' contains "csh" in the tail:
         * - The "!" character will be escaped. This is because csh and
         *   tcsh use "!" for history replacement even in single-quotes.
         * - The <NL> character is escaped (twice if {special} is
         *   a |non-zero-arg|).
         * 
         * If 'shell' contains "fish" in the tail, the "\" character will
         * be escaped because in fish it is used as an escape character
         * inside single quotes.
         * 
         * Example of use with a |:!| command: 
         * ```vim
         *     :exe '!dir ' .. shellescape(expand('<cfile>'), 1)
         * ```
         * This results in a directory listing for the file under the
         * cursor.  Example of use with |system()|: 
         * ```vim
         *     :call system("chmod +w -- " .. shellescape(expand("%")))
         * ```
         * See also |::S|.
         * 
         * Can also be used as a |method|: 
         * ```vim
         *   GetCommand()->shellescape()
         * ```
         */
        shellescape: (string: string, special?: any) => string;

        /**
         * Returns the effective value of 'shiftwidth'. This is the
         * 'shiftwidth' value unless it is zero, in which case it is the
         * 'tabstop' value.  To be backwards compatible in indent
         * plugins, use this: 
         * ```vim
         *   if exists('*shiftwidth')
         *     func s:sw()
         *       return shiftwidth()
         *     endfunc
         *   else
         *     func s:sw()
         *       return &sw
         *     endfunc
         *   endif
         * ```
         * And then use s:sw() instead of &sw.
         * 
         * When there is one argument {col} this is used as column number
         * for which to return the 'shiftwidth' value. This matters for the
         * 'vartabstop' feature. If no {col} argument is given, column 1
         * will be assumed.
         * 
         * Can also be used as a |method|: 
         * ```vim
         *   GetColumn()->shiftwidth()
         * ```
         */
        shiftwidth: (col?: number) => number;

        /**
         * List  define or update a list of signs
         */
        sign_define: (list: any[]) => any[];

        /**
         * List  get a list of defined signs
         */
        sign_getdefined: (name?: any) => any[];

        /**
         * List  get a list of placed signs
         */
        sign_getplaced: (buf?: number, dict?: { [key: string]: any }) => any[];

        /**
         * Number  jump to a sign
         */
        sign_jump: (id: any, group: any, buf: number) => number;

        /**
         * Number  place a sign
         */
        sign_place: (id: any, group: any, name: any, buf: number, dict?: { [key: string]: any }) => number;

        /**
         * List  place a list of signs
         */
        sign_placelist: (list: any[]) => any[];

        /**
         * List  undefine a list of signs
         */
        sign_undefine: (list: any[]) => any[];

        /**
         * Number  unplace a sign
         */
        sign_unplace: (group: any, dict?: { [key: string]: any }) => number;

        /**
         * List  unplace a list of signs
         */
        sign_unplacelist: (list: any[]) => any[];

        /**
         * Simplify the file name as much as possible without changing
         * the meaning.  Shortcuts (on MS-Windows) or symbolic links (on
         * Unix) are not resolved.  If the first path component in
         * {filename} designates the current directory, this will be
         * valid for the result as well.  A trailing path separator is
         * not removed either. On Unix "//path" is unchanged, but
         * "///path" is simplified to "/path" (this follows the Posix
         * standard).
         * Example: 
         * ```vim
         *   simplify("./dir/.././/file/") == "./file/"
         * ```
         * Note: The combination "dir/.." is only removed if "dir" is
         * a searchable directory or does not exist.  On Unix, it is also
         * removed when "dir" is a symbolic link within the same
         * directory.  In order to resolve all the involved symbolic
         * links before simplifying the path name, use |resolve()|.
         * 
         * Can also be used as a |method|: 
         * ```vim
         *   GetName()->simplify()
         * ```
         */
        simplify: (filename: any) => string;

        /**
         * Return the sine of {expr}, measured in radians, as a |Float|.
         * {expr} must evaluate to a |Float| or a |Number|.
         * Returns 0.0 if {expr} is not a |Float| or a |Number|.
         * Examples: 
         * ```vim
         *   :echo sin(100)
         * ```
         *   -0.506366 >
         *   :echo sin(-4.01)
         * <      0.763301
         * 
         * Can also be used as a |method|: 
         * ```vim
         *   Compute()->sin()
         * ```
         */
        sin: (expr: any) => number;

        /**
         * Return the hyperbolic sine of {expr} as a |Float| in the range
         * [-inf, inf].
         * {expr} must evaluate to a |Float| or a |Number|.
         * Returns 0.0 if {expr} is not a |Float| or a |Number|.
         * Examples: 
         * ```vim
         *   :echo sinh(0.5)
         * ```
         *   0.521095 >
         *   :echo sinh(-0.9)
         * <      -1.026517
         * 
         * Can also be used as a |method|: 
         * ```vim
         *   Compute()->sinh()
         * ```
         */
        sinh: (expr: any) => number;

        /**
         * Connect a socket to an address. If {mode} is "pipe" then
         * {address} should be the path of a local domain socket (on
         * unix) or named pipe (on Windows). If {mode} is "tcp" then
         * {address} should be of the form "host:port" where the host
         * should be an ip adderess or host name, and port the port
         * number.
         * 
         * For "pipe" mode, see |luv-pipe-handle|. For "tcp" mode, see
         * |luv-tcp-handle|.
         * 
         * Returns a |channel| ID. Close the socket with |chanclose()|.
         * Use |chansend()| to send data over a bytes socket, and
         * |rpcrequest()| and |rpcnotify()| to communicate with a RPC
         * socket.
         * 
         * {opts} is an optional dictionary with these keys:
         *   |on_data| : callback invoked when data was read from socket
         *   data_buffered : read socket data in |channel-buffered| mode.
         *   rpc     : If set, |msgpack-rpc| will be used to communicate
         *       over the socket.
         * Returns:
         *   - The channel ID on success (greater than zero)
         *   - 0 on invalid arguments or connection failure.
         */
        sockconnect: (mode: any, address: any, opts?: { [key: string]: any }) => number;

        /**
         * Sort the items in {list} in-place.  Returns {list}.
         * 
         * If you want a list to remain unmodified make a copy first: 
         * ```vim
         *   :let sortedlist = sort(copy(mylist))
         * 
         * ```
         * When {func} is omitted, is empty or zero, then sort() uses the
         * string representation of each item to sort on.  Numbers sort
         * after Strings, |Lists| after Numbers.  For sorting text in the
         * current buffer use |:sort|.
         * 
         * When {func} is given and it is '1' or 'i' then case is
         * ignored.
         * 
         * When {func} is given and it is 'l' then the current collation
         * locale is used for ordering. Implementation details: strcoll()
         * is used to compare strings. See |:language| check or set the
         * collation locale. |v:collate| can also be used to check the
         * current locale. Sorting using the locale typically ignores
         * case. Example: 
         * ```vim
         *   " ö is sorted similarly to o with English locale.
         *   :language collate en_US.UTF8
         *   :echo sort(['n', 'o', 'O', 'ö', 'p', 'z'], 'l')
         * ```
         *   ['n', 'o', 'O', 'ö', 'p', 'z'] ~
         * ```vim
         *   " ö is sorted after z with Swedish locale.
         *   :language collate sv_SE.UTF8
         *   :echo sort(['n', 'o', 'O', 'ö', 'p', 'z'], 'l')
         * ```
         *   ['n', 'o', 'O', 'p', 'z', 'ö'] ~
         * This does not work properly on Mac.
         * 
         * When {func} is given and it is 'n' then all items will be
         * sorted numerical (Implementation detail: this uses the
         * strtod() function to parse numbers, Strings, Lists, Dicts and
         * Funcrefs will be considered as being 0).
         * 
         * When {func} is given and it is 'N' then all items will be
         * sorted numerical. This is like 'n' but a string containing
         * digits will be used as the number they represent.
         * 
         * When {func} is given and it is 'f' then all items will be
         * sorted numerical. All values must be a Number or a Float.
         * 
         * When {func} is a |Funcref| or a function name, this function
         * is called to compare items.  The function is invoked with two
         * items as argument and must return zero if they are equal, 1 or
         * bigger if the first one sorts after the second one, -1 or
         * smaller if the first one sorts before the second one.
         * 
         * {dict} is for functions with the "dict" attribute.  It will be
         * used to set the local variable "self". |Dictionary-function|
         * 
         * The sort is stable, items which compare equal (as number or as
         * string) will keep their relative position. E.g., when sorting
         * on numbers, text strings will sort next to each other, in the
         * same order as they were originally.
         * 
         * Can also be used as a |method|: 
         * ```vim
         *   mylist->sort()
         * 
         * ```
         * Also see |uniq()|.
         * 
         * Example: 
         * ```vim
         *   func MyCompare(i1, i2)
         *      return a:i1 == a:i2 ? 0 : a:i1 > a:i2 ? 1 : -1
         *   endfunc
         *   eval mylist->sort("MyCompare")
         * ```
         * A shorter compare version for this specific simple case, which
         * ignores overflow: 
         * ```vim
         *   func MyCompare(i1, i2)
         *      return a:i1 - a:i2
         *   endfunc
         * ```
         * For a simple expression you can use a lambda: >
         *   eval mylist->sort({i1, i2 -> i1 - i2})
         * <
         */
        sort: (list: any[], func?: Function, dict?: { [key: string]: any }) => any[];

        /**
         * Return the sound-folded equivalent of {word}.  Uses the first
         * language in 'spelllang' for the current window that supports
         * soundfolding.  'spell' must be set.  When no sound folding is
         * possible the {word} is returned unmodified.
         * This can be used for making spelling suggestions.  Note that
         * the method can be quite slow.
         * 
         * Can also be used as a |method|: 
         * ```vim
         *   GetWord()->soundfold()
         * ```
         */
        soundfold: (word: any) => string;

        /**
         * Without argument: The result is the badly spelled word under
         * or after the cursor.  The cursor is moved to the start of the
         * bad word.  When no bad word is found in the cursor line the
         * result is an empty string and the cursor doesn't move.
         * 
         * With argument: The result is the first word in {sentence} that
         * is badly spelled.  If there are no spelling mistakes the
         * result is an empty string.
         * 
         * The return value is a list with two items:
         * - The badly spelled word or an empty string.
         * - The type of the spelling error:
         *   "bad"    spelling mistake
         *   "rare"    rare word
         *   "local"    word only valid in another region
         *   "caps"    word should start with Capital
         * Example: 
         * ```vim
         *   echo spellbadword("the quik brown fox")
         * ```
         *   ['quik', 'bad'] ~
         * 
         * The spelling information for the current window and the value
         * of 'spelllang' are used.
         * 
         * Can also be used as a |method|: 
         * ```vim
         *   GetText()->spellbadword()
         * ```
         */
        spellbadword: (sentence?: any) => string;

        /**
         * Return a |List| with spelling suggestions to replace {word}.
         * When {max} is given up to this number of suggestions are
         * returned.  Otherwise up to 25 suggestions are returned.
         * 
         * When the {capital} argument is given and it's non-zero only
         * suggestions with a leading capital will be given.  Use this
         * after a match with 'spellcapcheck'.
         * 
         * {word} can be a badly spelled word followed by other text.
         * This allows for joining two words that were split.  The
         * suggestions also include the following text, thus you can
         * replace a line.
         * 
         * {word} may also be a good word.  Similar words will then be
         * returned.  {word} itself is not included in the suggestions,
         * although it may appear capitalized.
         * 
         * The spelling information for the current window is used.  The
         * values of 'spelllang' and 'spellsuggest' are used.
         * 
         * Can also be used as a |method|: 
         * ```vim
         *   GetWord()->spellsuggest()
         * ```
         */
        spellsuggest: (word: any, max?: any, capital?: any) => any[];

        /**
         * Make a |List| out of {string}.  When {pattern} is omitted or
         * empty each white-separated sequence of characters becomes an
         * item.
         * Otherwise the string is split where {pattern} matches,
         * removing the matched characters. 'ignorecase' is not used
         * here, add \c to ignore case. |/\c|
         * When the first or last item is empty it is omitted, unless the
         * {keepempty} argument is given and it's non-zero.
         * Other empty items are kept when {pattern} matches at least one
         * character or when {keepempty} is non-zero.
         * Example: 
         * ```vim
         *   :let words = split(getline('.'), '\W\+')
         * ```
         * To split a string in individual characters: >
         *   :for c in split(mystring, '\zs')
         * <    If you want to keep the separator you can also use '\zs' at
         * the end of the pattern: 
         * ```vim
         *   :echo split('abc:def:ghi', ':\zs')
         * ```
         *   ['abc:', 'def:', 'ghi'] ~
         * Splitting a table where the first element can be empty: 
         * ```vim
         *   :let items = split(line, ':', 1)
         * ```
         * The opposite function is |join()|.
         * 
         * Can also be used as a |method|: 
         * ```vim
         *   GetString()->split()
         * ```
         */
        split: (string: string, pattern?: any, keepempty?: any) => any[];

        /**
         * Return the non-negative square root of Float {expr} as a
         * |Float|.
         * {expr} must evaluate to a |Float| or a |Number|.  When {expr}
         * is negative the result is NaN (Not a Number).  Returns 0.0 if
         * {expr} is not a |Float| or a |Number|.
         * Examples: 
         * ```vim
         *   :echo sqrt(100)
         * ```
         *   10.0 >
         *   :echo sqrt(-4.01)
         * <      str2float("nan")
         * NaN may be different, it depends on system libraries.
         * 
         * Can also be used as a |method|: 
         * ```vim
         *   Compute()->sqrt()
         * ```
         */
        sqrt: (expr: any) => number;

        /**
         * Initialize seed used by |rand()|:
         * - If {expr} is not given, seed values are initialized by
         *   reading from /dev/urandom, if possible, or using time(NULL)
         *   a.k.a. epoch time otherwise; this only has second accuracy.
         * - If {expr} is given it must be a Number.  It is used to
         *   initialize the seed values.  This is useful for testing or
         *   when a predictable sequence is intended.
         * 
         * Examples: 
         * ```vim
         *   :let seed = srand()
         *   :let seed = srand(userinput)
         *   :echo rand(seed)
         * ```
         * Can also be used as a |method|: 
         * ```vim
         *   userinput->srand()
         * ```
         */
        srand: (expr?: any) => any[];

        /**
         * With |--headless| this opens stdin and stdout as a |channel|.
         * May be called only once. See |channel-stdio|. stderr is not
         * handled by this function, see |v:stderr|.
         * 
         * Close the stdio handles with |chanclose()|. Use |chansend()|
         * to send data to stdout, and |rpcrequest()| and |rpcnotify()|
         * to communicate over RPC.
         * 
         * {opts} is a dictionary with these keys:
         *   |on_stdin| : callback invoked when stdin is written to.
         *   on_print : callback invoked when Nvim needs to print a
         *        message, with the message (whose type is string)
         *        as sole argument.
         *   stdin_buffered : read stdin in |channel-buffered| mode.
         *   rpc      : If set, |msgpack-rpc| will be used to communicate
         *        over stdio
         * Returns:
         *   - |channel-id| on success (value is always 1)
         *   - 0 on invalid arguments
         */
        stdioopen: (opts: { [key: string]: any }) => number;

        /**
         * Returns |standard-path| locations of various default files and
         * directories.
         * 
         * {what}       Type    Description ~
         * cache        String  Cache directory: arbitrary temporary
         *                      storage for plugins, etc.
         * config       String  User configuration directory. |init.vim|
         *                      is stored here.
         * config_dirs  List    Other configuration directories.
         * data         String  User data directory.
         * data_dirs    List    Other data directories.
         * log          String  Logs directory (for use by plugins too).
         * run          String  Run directory: temporary, local storage
         *          for sockets, named pipes, etc.
         * state        String  Session state directory: storage for file
         *          drafts, swap, undo, |shada|.
         * 
         * Example: 
         * ```vim
         *   :echo stdpath("config")
         * ```
         */
        stdpath: (what: any) => string;

        /**
         * Convert String {string} to a Float.  This mostly works the
         * same as when using a floating point number in an expression,
         * see |floating-point-format|.  But it's a bit more permissive.
         * E.g., "1e40" is accepted, while in an expression you need to
         * write "1.0e40".  The hexadecimal form "0x123" is also
         * accepted, but not others, like binary or octal.
         * When {quoted} is present and non-zero then embedded single
         * quotes before the dot are ignored, thus "1'000.0" is a
         * thousand.
         * Text after the number is silently ignored.
         * The decimal point is always '.', no matter what the locale is
         * set to.  A comma ends the number: "12,345.67" is converted to
         * 12.0.  You can strip out thousands separators with
         * |substitute()|: 
         * ```vim
         *   let f = str2float(substitute(text, ',', '', 'g'))
         * ```
         * Returns 0.0 if the conversion fails.
         * 
         * Can also be used as a |method|: 
         * ```vim
         *   let f = text->substitute(',', '', 'g')->str2float()
         * ```
         */
        str2float: (string: string, quoted?: any) => number;

        /**
         * Return a list containing the number values which represent
         * each character in String {string}.  Examples: 
         * ```vim
         *   str2list(" ")    returns [32]
         *   str2list("ABC")    returns [65, 66, 67]
         * ```
         * |list2str()| does the opposite.
         * 
         * UTF-8 encoding is always used, {utf8} option has no effect,
         * and exists only for backwards-compatibility.
         * With UTF-8 composing characters are handled properly: 
         * ```vim
         *   str2list("á")    returns [97, 769]
         * 
         * ```
         * Can also be used as a |method|: >
         *   GetString()->str2list()
         */
        str2list: (string: string, utf8?: any) => any[];

        /**
         * Convert string {string} to a number.
         * {base} is the conversion base, it can be 2, 8, 10 or 16.
         * When {quoted} is present and non-zero then embedded single
         * quotes are ignored, thus "1'000'000" is a million.
         * 
         * When {base} is omitted base 10 is used.  This also means that
         * a leading zero doesn't cause octal conversion to be used, as
         * with the default String to Number conversion.  Example: 
         * ```vim
         *   let nr = str2nr('0123')
         * ```
         * When {base} is 16 a leading "0x" or "0X" is ignored.  With a
         * different base the result will be zero. Similarly, when
         * {base} is 8 a leading "0", "0o" or "0O" is ignored, and when
         * {base} is 2 a leading "0b" or "0B" is ignored.
         * Text after the number is silently ignored.
         * 
         * Returns 0 if {string} is empty or on error.
         * 
         * Can also be used as a |method|: 
         * ```vim
         *   GetText()->str2nr()
         * ```
         */
        str2nr: (string: string, base?: any) => number;

        /**
         * The result is a Number, which is the number of characters
         * in String {string}.  Composing characters are ignored.
         * |strchars()| can count the number of characters, counting
         * composing characters separately.
         * 
         * Returns 0 if {string} is empty or on error.
         * 
         * Also see |strlen()|, |strdisplaywidth()| and |strwidth()|.
         * 
         * Can also be used as a |method|: 
         * ```vim
         *   GetText()->strcharlen()
         * ```
         */
        strcharlen: (string: string) => number;

        /**
         * Like |strpart()| but using character index and length instead
         * of byte index and length.  Composing characters are counted
         * separately.
         * When a character index is used where a character does not
         * exist it is assumed to be one character.  For example: 
         * ```vim
         *   strcharpart('abc', -1, 2)
         * ```
         * results in 'a'.
         * 
         * Returns an empty string on error.
         * 
         * Can also be used as a |method|: 
         * ```vim
         *   GetText()->strcharpart(5)
         * ```
         */
        strcharpart: (src: any, start: number, len?: any) => string;

        /**
         * The result is a Number, which is the number of characters
         * in String {string}.
         * When {skipcc} is omitted or zero, composing characters are
         * counted separately.
         * When {skipcc} set to 1, Composing characters are ignored.
         * |strcharlen()| always does this.
         * 
         * Returns zero on error.
         * 
         * Also see |strlen()|, |strdisplaywidth()| and |strwidth()|.
         * 
         * {skipcc} is only available after 7.4.755.  For backward
         * compatibility, you can define a wrapper function: 
         * ```vim
         *     if has("patch-7.4.755")
         *       function s:strchars(str, skipcc)
         *   return strchars(a:str, a:skipcc)
         *       endfunction
         *     else
         *       function s:strchars(str, skipcc)
         *   if a:skipcc
         *     return strlen(substitute(a:str, ".", "x", "g"))
         *   else
         *     return strchars(a:str)
         *   endif
         *       endfunction
         *     endif
         * ```
         * Can also be used as a |method|: 
         * ```vim
         *   GetText()->strchars()
         * ```
         */
        strchars: (string: string, skipcc?: any) => number;

        /**
         * The result is a Number, which is the number of display cells
         * String {string} occupies on the screen when it starts at {col}
         * (first column is zero).  When {col} is omitted zero is used.
         * Otherwise it is the screen column where to start.  This
         * matters for Tab characters.
         * The option settings of the current window are used.  This
         * matters for anything that's displayed differently, such as
         * 'tabstop' and 'display'.
         * When {string} contains characters with East Asian Width Class
         * Ambiguous, this function's return value depends on 'ambiwidth'.
         * Returns zero on error.
         * Also see |strlen()|, |strwidth()| and |strchars()|.
         * 
         * Can also be used as a |method|: 
         * ```vim
         *   GetText()->strdisplaywidth()
         * ```
         */
        strdisplaywidth: (string: string, col?: number) => number;

        /**
         * The result is a String, which is a formatted date and time, as
         * specified by the {format} string.  The given {time} is used,
         * or the current time if no time is given.  The accepted
         * {format} depends on your system, thus this is not portable!
         * See the manual page of the C function strftime() for the
         * format.  The maximum length of the result is 80 characters.
         * See also |localtime()|, |getftime()| and |strptime()|.
         * The language can be changed with the |:language| command.
         * Examples: 
         * ```vim
         *   :echo strftime("%c")       Sun Apr 27 11:49:23 1997
         *   :echo strftime("%Y %b %d %X")     1997 Apr 27 11:53:25
         *   :echo strftime("%y%m%d %T")     970427 11:53:55
         *   :echo strftime("%H:%M")     11:55
         *   :echo strftime("%c", getftime("file.c"))
         *            Show mod time of file.c.
         * 
         * ```
         * Can also be used as a |method|: >
         *   GetFormat()->strftime()
         */
        strftime: (format: any, time?: any) => string;

        /**
         * Get a Number corresponding to the character at {index} in
         * {str}.  This uses a zero-based character index, not a byte
         * index.  Composing characters are considered separate
         * characters here.  Use |nr2char()| to convert the Number to a
         * String.
         * Returns -1 if {index} is invalid.
         * Also see |strcharpart()| and |strchars()|.
         * 
         * Can also be used as a |method|: 
         * ```vim
         *   GetText()->strgetchar(5)
         * ```
         */
        strgetchar: (str: string, index: number) => number;

        /**
         * The result is a Number, which gives the byte index in
         * {haystack} of the first occurrence of the String {needle}.
         * If {start} is specified, the search starts at index {start}.
         * This can be used to find a second match: 
         * ```vim
         *   :let colon1 = stridx(line, ":")
         *   :let colon2 = stridx(line, ":", colon1 + 1)
         * ```
         * The search is done case-sensitive.
         * For pattern searches use |match()|.
         * -1 is returned if the {needle} does not occur in {haystack}.
         * See also |strridx()|.
         * Examples: 
         * ```vim
         *   :echo stridx("An Example", "Example")       3
         *   :echo stridx("Starting point", "Start")    0
         *   :echo stridx("Starting point", "start")   -1
         * ```
         * stridx() works similar to the C function strstr().  When used
         * with a single character it works similar to strchr().
         * 
         * Can also be used as a |method|: 
         * ```vim
         *   GetHaystack()->stridx(needle)
         * ```
         */
        stridx: (haystack: any, needle: any, start?: number) => number;

        /**
         * Return {expr} converted to a String.  If {expr} is a Number,
         *   Float, String, Blob or a composition of them, then the result
         *   can be parsed back with |eval()|.
         *     {expr} type  result ~
         *     String    'string'
         *     Number    123
         *     Float    123.123456 or 1.123456e8 or
         *         `str2float('inf')`
         *     Funcref    `function('name')`
         *     Blob    0z00112233.44556677.8899
         *     List    [item, item]
         *     Dictionary  {key: value, key: value}
         *   Note that in String values the ' character is doubled.
         *   Also see |strtrans()|.
         *   Note 2: Output format is mostly compatible with YAML, except
         *   for infinite and NaN floating-point values representations
         *   which use |str2float()|.  Strings are also dumped literally,
         *   only single quote is escaped, which does not allow using YAML
         *   for parsing back binary strings.  |eval()| should always work for
         *   strings and floats though and this is the only official
         *   method, use |msgpackdump()| or |json_encode()| if you need to
         *   share data with other application.
         * 
         *   Can also be used as a |method|: 
         * ```vim
         *     mylist->string()
         * ```
         */
        string: (expr: any) => string;

        /**
         * The result is a Number, which is the length of the String
         * {string} in bytes.
         * If the argument is a Number it is first converted to a String.
         * For other types an error is given and zero is returned.
         * If you want to count the number of multibyte characters use
         * |strchars()|.
         * Also see |len()|, |strdisplaywidth()| and |strwidth()|.
         * 
         * Can also be used as a |method|: 
         * ```vim
         *   GetString()->strlen()
         * ```
         */
        strlen: (string: string) => number;

        /**
         * The result is a String, which is part of {src}, starting from
         * byte {start}, with the byte length {len}.
         * When {chars} is present and TRUE then {len} is the number of
         * characters positions (composing characters are not counted
         * separately, thus "1" means one base character and any
         * following composing characters).
         * To count {start} as characters instead of bytes use
         * |strcharpart()|.
         * 
         * When bytes are selected which do not exist, this doesn't
         * result in an error, the bytes are simply omitted.
         * If {len} is missing, the copy continues from {start} till the
         * end of the {src}. 
         * ```vim
         *   strpart("abcdefg", 3, 2)    == "de"
         *   strpart("abcdefg", -2, 4)   == "ab"
         *   strpart("abcdefg", 5, 4)    == "fg"
         *   strpart("abcdefg", 3)      == "defg"
         * 
         * ```
         * Note: To get the first character, {start} must be 0.  For
         * example, to get the character under the cursor: 
         * ```vim
         *   strpart(getline("."), col(".") - 1, 1, v:true)
         * ```
         * Returns an empty string on error.
         * 
         * Can also be used as a |method|: 
         * ```vim
         *   GetText()->strpart(5)
         * ```
         */
        strpart: (src: any, start: number, len?: any, chars?: any) => string;

        /**
         * The result is a Number, which is a unix timestamp representing
         * the date and time in {timestring}, which is expected to match
         * the format specified in {format}.
         * 
         * The accepted {format} depends on your system, thus this is not
         * portable!  See the manual page of the C function strptime()
         * for the format.  Especially avoid "%c".  The value of $TZ also
         * matters.
         * 
         * If the {timestring} cannot be parsed with {format} zero is
         * returned.  If you do not know the format of {timestring} you
         * can try different {format} values until you get a non-zero
         * result.
         * 
         * See also |strftime()|.
         * Examples: 
         * ```vim
         *   :echo strptime("%Y %b %d %X", "1997 Apr 27 11:49:23")
         * ```
         *   862156163 >
         *   :echo strftime("%c", strptime("%y%m%d %T", "970427 11:53:55"))
         * <      Sun Apr 27 11:53:55 1997 
         * ```vim
         *   :echo strftime("%c", strptime("%Y%m%d%H%M%S", "19970427115355") + 3600)
         * ```
         *   Sun Apr 27 12:53:55 1997
         * 
         * Can also be used as a |method|: 
         * ```vim
         *   GetFormat()->strptime(timestring)
         * ```
         */
        strptime: (format: any, timestring: any) => number;

        /**
         * The result is a Number, which gives the byte index in
         * {haystack} of the last occurrence of the String {needle}.
         * When {start} is specified, matches beyond this index are
         * ignored.  This can be used to find a match before a previous
         * match: 
         * ```vim
         *   :let lastcomma = strridx(line, ",")
         *   :let comma2 = strridx(line, ",", lastcomma - 1)
         * ```
         * The search is done case-sensitive.
         * For pattern searches use |match()|.
         * -1 is returned if the {needle} does not occur in {haystack}.
         * If the {needle} is empty the length of {haystack} is returned.
         * See also |stridx()|.  Examples: 
         * ```vim
         *   :echo strridx("an angry armadillo", "an")       3
         * ```
         * When used with a single character it works similar to the C
         * function strrchr().
         * 
         * Can also be used as a |method|: 
         * ```vim
         *   GetHaystack()->strridx(needle)
         * ```
         */
        strridx: (haystack: any, needle: any, start?: number) => number;

        /**
         * The result is a String, which is {string} with all unprintable
         * characters translated into printable characters |'isprint'|.
         * Like they are shown in a window.  Example: 
         * ```vim
         *   echo strtrans(@a)
         * ```
         * This displays a newline in register a as "^@" instead of
         * starting a new line.
         * 
         * Returns an empty string on error.
         * 
         * Can also be used as a |method|: 
         * ```vim
         *   GetString()->strtrans()
         * ```
         */
        strtrans: (string: string) => string;

        /**
         * The result is a Number, which is the number of display cells
         * String {string} occupies.  A Tab character is counted as one
         * cell, alternatively use |strdisplaywidth()|.
         * When {string} contains characters with East Asian Width Class
         * Ambiguous, this function's return value depends on 'ambiwidth'.
         * Returns zero on error.
         * Also see |strlen()|, |strdisplaywidth()| and |strchars()|.
         * 
         * Can also be used as a |method|: 
         * ```vim
         *   GetString()->strwidth()
         * ```
         */
        strwidth: (string: string) => number;

        /**
         * Only for an expression in a |:substitute| command or
         * substitute() function.
         * Returns the {nr}th submatch of the matched text.  When {nr}
         * is 0 the whole matched text is returned.
         * Note that a NL in the string can stand for a line break of a
         * multi-line match or a NUL character in the text.
         * Also see |sub-replace-expression|.
         * 
         * If {list} is present and non-zero then submatch() returns
         * a list of strings, similar to |getline()| with two arguments.
         * NL characters in the text represent NUL characters in the
         * text.
         * Only returns more than one item for |:substitute|, inside
         * |substitute()| this list will always contain one or zero
         * items, since there are no real line breaks.
         * 
         * When substitute() is used recursively only the submatches in
         * the current (deepest) call can be obtained.
         * 
         * Returns an empty string or list on error.
         * 
         * Examples: 
         * ```vim
         *   :s/\d\+/\=submatch(0) + 1/
         *   :echo substitute(text, '\d\+', '\=submatch(0) + 1', '')
         * ```
         * This finds the first number in the line and adds one to it.
         * A line break is included as a newline character.
         * 
         * Can also be used as a |method|: 
         * ```vim
         *   GetNr()->submatch()
         * ```
         */
        submatch: (nr: number, list?: any[]) => string;

        /**
         * The result is a String, which is a copy of {string}, in which
         * the first match of {pat} is replaced with {sub}.
         * When {flags} is "g", all matches of {pat} in {string} are
         * replaced.  Otherwise {flags} should be "".
         * 
         * This works like the ":substitute" command (without any flags).
         * But the matching with {pat} is always done like the 'magic'
         * option is set and 'cpoptions' is empty (to make scripts
         * portable).  'ignorecase' is still relevant, use |/\c| or |/\C|
         * if you want to ignore or match case and ignore 'ignorecase'.
         * 'smartcase' is not used.  See |string-match| for how {pat} is
         * used.
         * 
         * A "~" in {sub} is not replaced with the previous {sub}.
         * Note that some codes in {sub} have a special meaning
         * |sub-replace-special|.  For example, to replace something with
         * "\n" (two characters), use "\\\\n" or '\\n'.
         * 
         * When {pat} does not match in {string}, {string} is returned
         * unmodified.
         * 
         * Example: 
         * ```vim
         *   :let &path = substitute(&path, ",\\=[^,]*$", "", "")
         * ```
         * This removes the last component of the 'path' option. >
         *   :echo substitute("testing", ".*", "\\U\\0", "")
         * <    results in "TESTING".
         * 
         * When {sub} starts with "\=", the remainder is interpreted as
         * an expression. See |sub-replace-expression|.  Example: 
         * ```vim
         *   :echo substitute(s, '%\(\x\x\)',
         *      \ '\=nr2char("0x" .. submatch(1))', 'g')
         * 
         * ```
         * When {sub} is a Funcref that function is called, with one
         * optional argument.  Example: 
         * ```vim
         *    :echo substitute(s, '%\(\x\x\)', SubNr, 'g')
         * ```
         * The optional argument is a list which contains the whole
         * matched string and up to nine submatches, like what
         * |submatch()| returns.  Example: 
         * ```vim
         *    :echo substitute(s, '%\(\x\x\)', {m -> '0x' .. m[1]}, 'g')
         * 
         * ```
         * Returns an empty string on error.
         * 
         * Can also be used as a |method|: 
         * ```vim
         *   GetString()->substitute(pat, sub, flags)
         * ```
         */
        substitute: (string: string, pat: any, sub: any, flags: any) => string;

        /**
         * The result is a dictionary, which holds information about the
         * swapfile {fname}. The available fields are:
         *   version Vim version
         *   user  user name
         *   host  host name
         *   fname  original file name
         *   pid  PID of the Vim process that created the swap
         *     file
         *   mtime  last modification time in seconds
         *   inode  Optional: INODE number of the file
         *   dirty  1 if file was modified, 0 if not
         * In case of failure an "error" item is added with the reason:
         *   Cannot open file: file not found or in accessible
         *   Cannot read file: cannot read first block
         *   Not a swap file: does not contain correct block ID
         *   Magic number mismatch: Info in first block is invalid
         * 
         * Can also be used as a |method|: 
         * ```vim
         *   GetFilename()->swapinfo()
         * ```
         */
        swapinfo: (fname: any) => { [key: string]: any };

        /**
         * The result is the swap file path of the buffer {buf}.
         * For the use of {buf}, see |bufname()| above.
         * If buffer {buf} is the current buffer, the result is equal to
         * |:swapname| (unless there is no swap file).
         * If buffer {buf} has no swap file, returns an empty string.
         * 
         * Can also be used as a |method|: 
         * ```vim
         *   GetBufname()->swapname()
         * ```
         */
        swapname: (buf: number) => string;

        /**
         * The result is a Number, which is the syntax ID at the position
         * {lnum} and {col} in the current window.
         * The syntax ID can be used with |synIDattr()| and
         * |synIDtrans()| to obtain syntax information about text.
         * 
         * {col} is 1 for the leftmost column, {lnum} is 1 for the first
         * line.  'synmaxcol' applies, in a longer line zero is returned.
         * Note that when the position is after the last character,
         * that's where the cursor can be in Insert mode, synID() returns
         * zero.  {lnum} is used like with |getline()|.
         * 
         * When {trans} is |TRUE|, transparent items are reduced to the
         * item that they reveal.  This is useful when wanting to know
         * the effective color.  When {trans} is |FALSE|, the transparent
         * item is returned.  This is useful when wanting to know which
         * syntax item is effective (e.g. inside parens).
         * Warning: This function can be very slow.  Best speed is
         * obtained by going through the file in forward direction.
         * 
         * Returns zero on error.
         * 
         * Example (echoes the name of the syntax item under the cursor): 
         * ```vim
         *   :echo synIDattr(synID(line("."), col("."), 1), "name")
         * ```
         */
        synID: (lnum: number, col: number, trans: any) => number;

        /**
         *   The result is a String, which is the {what} attribute of
         *   syntax ID {synID}.  This can be used to obtain information
         *   about a syntax item.
         *   {mode} can be "gui" or "cterm", to get the attributes
         *   for that mode.  When {mode} is omitted, or an invalid value is
         *   used, the attributes for the currently active highlighting are
         *   used (GUI or cterm).
         *   Use synIDtrans() to follow linked highlight groups.
         *   {what}    result
         *   "name"    the name of the syntax item
         *   "fg"    foreground color (GUI: color name used to set
         *       the color, cterm: color number as a string,
         *       term: empty string)
         *   "bg"    background color (as with "fg")
         *   "font"    font name (only available in the GUI)
         *       |highlight-font|
         *   "sp"    special color (as with "fg") |guisp|
         *   "fg#"    like "fg", but for the GUI and the GUI is
         *       running the name in "#RRGGBB" form
         *   "bg#"    like "fg#" for "bg"
         *   "sp#"    like "fg#" for "sp"
         *   "bold"    "1" if bold
         *   "italic"  "1" if italic
         *   "reverse"  "1" if reverse
         *   "inverse"  "1" if inverse (= reverse)
         *   "standout"  "1" if standout
         *   "underline"  "1" if underlined
         *   "undercurl"  "1" if undercurled
         *   "underdouble"  "1" if double underlined
         *   "underdotted"  "1" if dotted underlined
         *   "underdashed"  "1" if dashed underlined
         *   "strikethrough"  "1" if struckthrough
         *   "altfont"  "1" if alternative font
         *   "nocombine"  "1" if nocombine
         * 
         *   Returns an empty string on error.
         * 
         *   Example (echoes the color of the syntax item under the
         *   cursor): 
         * ```vim
         * :echo synIDattr(synIDtrans(synID(line("."), col("."), 1)), "fg")
         * ```
         *   Can also be used as a |method|: 
         * ```vim
         * :echo synID(line("."), col("."), 1)->synIDtrans()->synIDattr("fg")
         * ```
         */
        synIDattr: (synID: any, what: any, mode?: any) => string;

        /**
         *   The result is a Number, which is the translated syntax ID of
         *   {synID}.  This is the syntax group ID of what is being used to
         *   highlight the character.  Highlight links given with
         *   ":highlight link" are followed.
         * 
         *   Returns zero on error.
         * 
         *   Can also be used as a |method|: 
         * ```vim
         * :echo synID(line("."), col("."), 1)->synIDtrans()->synIDattr("fg")
         * ```
         */
        synIDtrans: (synID: any) => number;

        /**
         * The result is a |List| with currently three items:
         * 1. The first item in the list is 0 if the character at the
         *    position {lnum} and {col} is not part of a concealable
         *    region, 1 if it is.  {lnum} is used like with |getline()|.
         * 2. The second item in the list is a string. If the first item
         *    is 1, the second item contains the text which will be
         *    displayed in place of the concealed text, depending on the
         *    current setting of 'conceallevel' and 'listchars'.
         * 3. The third and final item in the list is a number
         *    representing the specific syntax region matched in the
         *    line. When the character is not concealed the value is
         *    zero. This allows detection of the beginning of a new
         *    concealable region if there are two consecutive regions
         *    with the same replacement character.  For an example, if
         *    the text is "123456" and both "23" and "45" are concealed
         *    and replaced by the character "X", then:
         *   call      returns ~
         *   synconcealed(lnum, 1)   [0, '', 0]
         *   synconcealed(lnum, 2)   [1, 'X', 1]
         *   synconcealed(lnum, 3)   [1, 'X', 1]
         *   synconcealed(lnum, 4)   [1, 'X', 2]
         *   synconcealed(lnum, 5)   [1, 'X', 2]
         *   synconcealed(lnum, 6)   [0, '', 0]
         */
        synconcealed: (lnum: number, col: number) => any[];

        /**
         * Return a |List|, which is the stack of syntax items at the
         * position {lnum} and {col} in the current window.  {lnum} is
         * used like with |getline()|.  Each item in the List is an ID
         * like what |synID()| returns.
         * The first item in the List is the outer region, following are
         * items contained in that one.  The last one is what |synID()|
         * returns, unless not the whole item is highlighted or it is a
         * transparent item.
         * This function is useful for debugging a syntax file.
         * Example that shows the syntax stack under the cursor: 
         * ```vim
         *   for id in synstack(line("."), col("."))
         *      echo synIDattr(id, "name")
         *   endfor
         * ```
         * When the position specified with {lnum} and {col} is invalid
         * an empty list is returned.  The position just after the last
         * character in a line and the first column in an empty line are
         * valid positions.
         */
        synstack: (lnum: number, col: number) => any[];

        /**
         * Gets the output of {cmd} as a |string| (|systemlist()| returns
         * a |List|) and sets |v:shell_error| to the error code.
         * {cmd} is treated as in |jobstart()|:
         * If {cmd} is a List it runs directly (no 'shell').
         * If {cmd} is a String it runs in the 'shell', like this: 
         * ```vim
         *   :call jobstart(split(&shell) + split(&shellcmdflag) + ['{cmd}'])
         * 
         * ```
         * Not to be used for interactive commands.
         * 
         * Result is a String, filtered to avoid platform-specific quirks:
         * - <CR><NL> is replaced with <NL
         * ```vim
         * - NUL characters are replaced with SOH (0x01)
         * 
         * Example: >
         *     :echo system(['ls', expand('%:h')])
         * 
         * ```
         * If {input} is a string it is written to a pipe and passed as
         * stdin to the command.  The string is written as-is, line
         * separators are not changed.
         * If {input} is a |List| it is written to the pipe as
         * |writefile()| does with {binary} set to "b" (i.e. with
         * a newline between each list item, and newlines inside list
         * items converted to NULs).
         * When {input} is given and is a valid buffer id, the content of
         * the buffer is written to the file line by line, each line
         * terminated by NL (and NUL where the text has NL).
         * 
         * Note: system() cannot write to or read from backgrounded ("&")
         * shell commands, e.g.: 
         * ```vim
         *     :echo system("cat - &", "foo")
         * ```
         * which is equivalent to: >
         *     $ echo foo | bash -c 'cat - &'
         * <    The pipes are disconnected (unless overridden by shell
         * redirection syntax) before input can reach it. Use
         * |jobstart()| instead.
         * 
         * Note: Use |shellescape()| or |::S| with |expand()| or
         * |fnamemodify()| to escape special characters in a command
         * argument. 'shellquote' and 'shellxquote' must be properly
         * configured. Example: 
         * ```vim
         *     :echo system('ls '..shellescape(expand('%:h')))
         *     :echo system('ls '..expand('%:h:S'))
         * 
         * ```
         * Unlike ":!cmd" there is no automatic check for changed files.
         * Use |:checktime| to force a check.
         * 
         * Can also be used as a |method|: 
         * ```vim
         *   :echo GetCmd()->system()
         * ```
         */
        system: (cmd: any, input?: any) => string;

        /**
         * Same as |system()|, but returns a |List| with lines (parts of
         * output separated by NL) with NULs transformed into NLs. Output
         * is the same as |readfile()| will output with {binary} argument
         * set to "b", except that a final newline is not preserved,
         * unless {keepempty} is non-zero.
         * Note that on MS-Windows you may get trailing CR characters.
         * 
         * To see the difference between "echo hello" and "echo -n hello"
         * use |system()| and |split()|: 
         * ```vim
         *   echo split(system('echo hello'), '\n', 1)
         * ```
         * Returns an empty string on error.
         * 
         * Can also be used as a |method|: 
         * ```vim
         *   :echo GetCmd()->systemlist()
         * ```
         */
        systemlist: (cmd: any, input?: any, keepempty?: any) => any[];

        /**
         * The result is a |List|, where each item is the number of the
         * buffer associated with each window in the current tab page.
         * {arg} specifies the number of the tab page to be used. When
         * omitted the current tab page is used.
         * When {arg} is invalid the number zero is returned.
         * To get a list of all buffers in all tabs use this: 
         * ```vim
         *   let buflist = []
         *   for i in range(tabpagenr('$'))
         *      call extend(buflist, tabpagebuflist(i + 1))
         *   endfor
         * ```
         * Note that a buffer may appear in more than one window.
         * 
         * Can also be used as a |method|: 
         * ```vim
         *   GetTabpage()->tabpagebuflist()
         * ```
         */
        tabpagebuflist: (arg?: any) => any[];

        /**
         * The result is a Number, which is the number of the current
         * tab page.  The first tab page has number 1.
         * 
         * The optional argument {arg} supports the following values:
         *   $  the number of the last tab page (the tab page
         *     count).
         *   #  the number of the last accessed tab page
         *     (where |g<Tab>| goes to).  If there is no
         *     previous tab page, 0 is returned.
         * The number can be used with the |:tab| command.
         * 
         * Returns zero on error.
         */
        tabpagenr: (arg?: any) => number;

        /**
         * Like |winnr()| but for tab page {tabarg}.
         * {tabarg} specifies the number of tab page to be used.
         * {arg} is used like with |winnr()|:
         * - When omitted the current window number is returned.  This is
         *   the window which will be used when going to this tab page.
         * - When "$" the number of windows is returned.
         * - When "#" the previous window nr is returned.
         * Useful examples: 
         * ```vim
         *     tabpagewinnr(1)      " current window of tab page 1
         *     tabpagewinnr(4, '$')    " number of windows in tab page 4
         * ```
         * When {tabarg} is invalid zero is returned.
         * 
         * Can also be used as a |method|: 
         * ```vim
         *   GetTabpage()->tabpagewinnr()
         * ```
         */
        tabpagewinnr: (tabarg: any, arg?: any) => number;

        /**
         * Returns a |List| with the file names used to search for tags
         *   for the current buffer.  This is the 'tags' option expanded.
         */
        tagfiles: () => any[];

        /**
         * Returns a |List| of tags matching the regular expression {expr}.
         * 
         * If {filename} is passed it is used to prioritize the results
         * in the same way that |:tselect| does. See |tag-priority|.
         * {filename} should be the full path of the file.
         * 
         * Each list item is a dictionary with at least the following
         * entries:
         *   name    Name of the tag.
         *   filename  Name of the file where the tag is
         *       defined.  It is either relative to the
         *       current directory or a full path.
         *   cmd    Ex command used to locate the tag in
         *       the file.
         *   kind    Type of the tag.  The value for this
         *       entry depends on the language specific
         *       kind values.  Only available when
         *       using a tags file generated by
         *       Universal/Exuberant ctags or hdrtag.
         *   static    A file specific tag.  Refer to
         *       |static-tag| for more information.
         * More entries may be present, depending on the content of the
         * tags file: access, implementation, inherits and signature.
         * Refer to the ctags documentation for information about these
         * fields.  For C code the fields "struct", "class" and "enum"
         * may appear, they give the name of the entity the tag is
         * contained in.
         * 
         * The ex-command "cmd" can be either an ex search pattern, a
         * line number or a line number followed by a byte number.
         * 
         * If there are no matching tags, then an empty list is returned.
         * 
         * To get an exact tag match, the anchors '^' and '$' should be
         * used in {expr}.  This also make the function work faster.
         * Refer to |tag-regexp| for more information about the tag
         * search regular expression pattern.
         * 
         * Refer to |'tags'| for information about how the tags file is
         * located by Vim. Refer to |tags-file-format| for the format of
         * the tags file generated by the different ctags tools.
         * 
         * Can also be used as a |method|: 
         * ```vim
         *   GetTagpattern()->taglist()
         * ```
         */
        taglist: (expr: any, filename?: any) => any[];

        /**
         * Return the tangent of {expr}, measured in radians, as a |Float|
         * in the range [-inf, inf].
         * {expr} must evaluate to a |Float| or a |Number|.
         * Returns 0.0 if {expr} is not a |Float| or a |Number|.
         * Examples: 
         * ```vim
         *   :echo tan(10)
         * ```
         *   0.648361 >
         *   :echo tan(-4.01)
         * <      -1.181502
         * 
         * Can also be used as a |method|: 
         * ```vim
         *   Compute()->tan()
         * ```
         */
        tan: (expr: any) => number;

        /**
         * Return the hyperbolic tangent of {expr} as a |Float| in the
         * range [-1, 1].
         * {expr} must evaluate to a |Float| or a |Number|.
         * Returns 0.0 if {expr} is not a |Float| or a |Number|.
         * Examples: 
         * ```vim
         *   :echo tanh(0.5)
         * ```
         *   0.462117 >
         *   :echo tanh(-1)
         * <      -0.761594
         * 
         * Can also be used as a |method|: 
         * ```vim
         *   Compute()->tanh()
         * ```
         */
        tanh: (expr: any) => number;

        /**
         * Generates a (non-existent) filename located in the Nvim root
         * |tempdir|. Scripts can use the filename as a temporary file.
         * Example: 
         * ```vim
         *   :let tmpfile = tempname()
         *   :exe "redir > " .. tmpfile
         * ```
         */
        tempname: () => string;

        /**
         * Spawns {cmd} in a new pseudo-terminal session connected
         * to the current (unmodified) buffer. Parameters and behavior
         * are the same as |jobstart()| except "pty", "width", "height",
         * and "TERM" are ignored: "height" and "width" are taken from
         * the current window.
         * Returns the same values as |jobstart()|.
         * 
         * Terminal environment is initialized as in ||jobstart-env|,
         * except $TERM is set to "xterm-256color". Full behavior is
         * described in |terminal|.
         */
        termopen: (cmd: any, opts?: { [key: string]: any }) => any;

        /**
         * none  free memory right now for testing
         */
        test_garbagecollect_now: () => undefined;

        /**
         * Return a list with information about timers.
         * When {id} is given only information about this timer is
         * returned.  When timer {id} does not exist an empty list is
         * returned.
         * When {id} is omitted information about all timers is returned.
         * 
         * For each timer the information is stored in a |Dictionary| with
         * these items:
         *     "id"      the timer ID
         *     "time"      time the timer was started with
         *     "repeat"      number of times the timer will still fire;
         *         -1 means forever
         *     "callback"      the callback
         * 
         * Can also be used as a |method|: 
         * ```vim
         *   GetTimer()->timer_info()
         * ```
         */
        timer_info: (id?: any) => any[];

        /**
         * Pause or unpause a timer.  A paused timer does not invoke its
         * callback when its time expires.  Unpausing a timer may cause
         * the callback to be invoked almost immediately if enough time
         * has passed.
         * 
         * Pausing a timer is useful to avoid the callback to be called
         * for a short time.
         * 
         * If {paused} evaluates to a non-zero Number or a non-empty
         * String, then the timer is paused, otherwise it is unpaused.
         * See |non-zero-arg|.
         * 
         * Can also be used as a |method|: 
         * ```vim
         *   GetTimer()->timer_pause(1)
         * ```
         */
        timer_pause: (timer: any, paused: any) => undefined;

        /**
         * Create a timer and return the timer ID.
         * 
         * {time} is the waiting time in milliseconds. This is the
         * minimum time before invoking the callback.  When the system is
         * busy or Vim is not waiting for input the time will be longer.
         * Zero can be used to execute the callback when Vim is back in
         * the main loop.
         * 
         * {callback} is the function to call.  It can be the name of a
         * function or a |Funcref|.  It is called with one argument, which
         * is the timer ID.  The callback is only invoked when Vim is
         * waiting for input.
         * 
         * {options} is a dictionary.  Supported entries:
         *    "repeat"  Number of times to repeat the callback.
         *     -1 means forever.  Default is 1.
         *     If the timer causes an error three times in a
         *     row the repeat is cancelled.
         * 
         * Returns -1 on error.
         * 
         * Example: 
         * ```vim
         *   func MyHandler(timer)
         *     echo 'Handler called'
         *   endfunc
         *   let timer = timer_start(500, 'MyHandler',
         *     \ {'repeat': 3})
         * ```
         * This invokes MyHandler() three times at 500 msec intervals.
         * 
         * Can also be used as a |method|: 
         * ```vim
         *   GetMsec()->timer_start(callback)
         * 
         * ```
         * Not available in the |sandbox|.
         */
        timer_start: (time: any, callback: Function, options?: { [key: string]: any }) => number;

        /**
         * Stop a timer.  The timer callback will no longer be invoked.
         * {timer} is an ID returned by timer_start(), thus it must be a
         * Number.  If {timer} does not exist there is no error.
         * 
         * Can also be used as a |method|: 
         * ```vim
         *   GetTimer()->timer_stop()
         * ```
         */
        timer_stop: (timer: any) => undefined;

        /**
         * Stop all timers.  The timer callbacks will no longer be
         * invoked.  Useful if some timers is misbehaving.  If there are
         * no timers there is no error.
         */
        timer_stopall: () => undefined;

        /**
         * The result is a copy of the String given, with all uppercase
         * characters turned into lowercase (just like applying |gu| to
         * the string).  Returns an empty string on error.
         * 
         * Can also be used as a |method|: 
         * ```vim
         *   GetText()->tolower()
         * ```
         */
        tolower: (expr: any) => string;

        /**
         * The result is a copy of the String given, with all lowercase
         * characters turned into uppercase (just like applying |gU| to
         * the string).  Returns an empty string on error.
         * 
         * Can also be used as a |method|: 
         * ```vim
         *   GetText()->toupper()
         * ```
         */
        toupper: (expr: any) => string;

        /**
         * The result is a copy of the {src} string with all characters
         * which appear in {fromstr} replaced by the character in that
         * position in the {tostr} string.  Thus the first character in
         * {fromstr} is translated into the first character in {tostr}
         * and so on.  Exactly like the unix "tr" command.
         * This code also deals with multibyte characters properly.
         * 
         * Returns an empty string on error.
         * 
         * Examples: 
         * ```vim
         *   echo tr("hello there", "ht", "HT")
         * ```
         * returns "Hello THere" >
         *   echo tr("<blob>", "<>", "{}")
         * <    returns "{blob}"
         * 
         * Can also be used as a |method|: 
         * ```vim
         *   GetText()->tr(from, to)
         * ```
         */
        tr: (src: any, fromstr: any, tostr: any) => string;

        /**
         * Return {text} as a String where any character in {mask} is
         * removed from the beginning and/or end of {text}.
         * If {mask} is not given, {mask} is all characters up to 0x20,
         * which includes Tab, space, NL and CR, plus the non-breaking
         * space character 0xa0.
         * The optional {dir} argument specifies where to remove the
         * characters:
         *   0  remove from the beginning and end of {text}
         *   1  remove only at the beginning of {text}
         *   2  remove only at the end of {text}
         * When omitted both ends are trimmed.
         * This function deals with multibyte characters properly.
         * Returns an empty string on error.
         * 
         * Examples: 
         * ```vim
         *   echo trim("   some text ")
         * ```
         * returns "some text" >
         *   echo trim("  \r\t\t\r RESERVE \t\n\x0B\xA0") .. "_TAIL"
         * <    returns "RESERVE_TAIL" 
         * ```vim
         *   echo trim("rm<Xrm<>X>rrm", "rm<>")
         * ```
         * returns "Xrm>X" (characters in the middle are not removed) >
         *   echo trim("  vim  ", " ", 2)
         * <    returns "  vim"
         * 
         * Can also be used as a |method|: 
         * ```vim
         *   GetText()->trim()
         * ```
         */
        trim: (text: string, mask?: any, dir?: any) => string;

        /**
         * Return the largest integral value with magnitude less than or
         * equal to {expr} as a |Float| (truncate towards zero).
         * {expr} must evaluate to a |Float| or a |Number|.
         * Returns 0.0 if {expr} is not a |Float| or a |Number|.
         * Examples: 
         * ```vim
         *   echo trunc(1.456)
         * ```
         *   1.0  >
         *   echo trunc(-5.456)
         * <      -5.0  
         * ```vim
         *   echo trunc(4.0)
         * ```
         *   4.0
         * 
         * Can also be used as a |method|: 
         * ```vim
         *   Compute()->trunc()
         * ```
         */
        trunc: (expr: any) => number;

        /**
         * The result is a Number representing the type of {expr}.
         * Instead of using the number directly, it is better to use the
         * v:t_ variable that has the value:
         *         Number:     0 (|v:t_number|)
         *   String:     1 (|v:t_string|)
         *   Funcref:    2 (|v:t_func|)
         *   List:       3 (|v:t_list|)
         *   Dictionary: 4 (|v:t_dict|)
         *   Float:      5 (|v:t_float|)
         *   Boolean:    6 (|v:true| and |v:false|)
         *   Null:       7 (|v:null|)
         *   Blob:      10 (|v:t_blob|)
         * For backward compatibility, this method can be used: 
         * ```vim
         *   :if type(myvar) == type(0)
         *   :if type(myvar) == type("")
         *   :if type(myvar) == type(function("tr"))
         *   :if type(myvar) == type([])
         *   :if type(myvar) == type({})
         *   :if type(myvar) == type(0.0)
         *   :if type(myvar) == type(v:true)
         * ```
         * In place of checking for |v:null| type it is better to check
         * for |v:null| directly as it is the only value of this type: 
         * ```vim
         *   :if myvar is v:null
         * ```
         *            To check if the v:t_ variables exist use this: >
         *                     :if exists('v:t_number')
         * 
         * <    Can also be used as a |method|: 
         * ```vim
         *   mylist->type()
         * ```
         */
        type: (expr: any) => number;

        /**
         * Return the name of the undo file that would be used for a file
         * with name {name} when writing.  This uses the 'undodir'
         * option, finding directories that exist.  It does not check if
         * the undo file exists.
         * {name} is always expanded to the full path, since that is what
         * is used internally.
         * If {name} is empty undofile() returns an empty string, since a
         * buffer without a file name will not write an undo file.
         * Useful in combination with |:wundo| and |:rundo|.
         * 
         * Can also be used as a |method|: 
         * ```vim
         *   GetFilename()->undofile()
         * ```
         */
        undofile: (name: any) => string;

        /**
         * Return the current state of the undo tree in a dictionary with
         * the following items:
         *   "seq_last"  The highest undo sequence number used.
         *   "seq_cur"  The sequence number of the current position in
         *     the undo tree.  This differs from "seq_last"
         *     when some changes were undone.
         *   "time_cur"  Time last used for |:earlier| and related
         *     commands.  Use |strftime()| to convert to
         *     something readable.
         *   "save_last"  Number of the last file write.  Zero when no
         *     write yet.
         *   "save_cur"  Number of the current position in the undo
         *     tree.
         *   "synced"  Non-zero when the last undo block was synced.
         *     This happens when waiting from input from the
         *     user.  See |undo-blocks|.
         *   "entries"  A list of dictionaries with information about
         *     undo blocks.
         * 
         * The first item in the "entries" list is the oldest undo item.
         * Each List item is a |Dictionary| with these items:
         *   "seq"    Undo sequence number.  Same as what appears in
         *     |:undolist|.
         *   "time"  Timestamp when the change happened.  Use
         *     |strftime()| to convert to something readable.
         *   "newhead"  Only appears in the item that is the last one
         *     that was added.  This marks the last change
         *     and where further changes will be added.
         *   "curhead"  Only appears in the item that is the last one
         *     that was undone.  This marks the current
         *     position in the undo tree, the block that will
         *     be used by a redo command.  When nothing was
         *     undone after the last change this item will
         *     not appear anywhere.
         *   "save"  Only appears on the last block before a file
         *     write.  The number is the write count.  The
         *     first write has number 1, the last one the
         *     "save_last" mentioned above.
         *   "alt"    Alternate entry.  This is again a List of undo
         *     blocks.  Each item may again have an "alt"
         *     item.
         */
        undotree: () => any[];

        /**
         * Remove second and succeeding copies of repeated adjacent
         * {list} items in-place.  Returns {list}.  If you want a list
         * to remain unmodified make a copy first: 
         * ```vim
         *   :let newlist = uniq(copy(mylist))
         * ```
         * The default compare function uses the string representation of
         * each item.  For the use of {func} and {dict} see |sort()|.
         * 
         * Returns zero if {list} is not a |List|.
         * 
         * Can also be used as a |method|: 
         * ```vim
         *   mylist->uniq()
         * ```
         */
        uniq: (list: any[], func?: Function, dict?: { [key: string]: any }) => any[];

        /**
         * Return a |List| with all the values of {dict}.  The |List| is
         * in arbitrary order.  Also see |items()| and |keys()|.
         * Returns zero if {dict} is not a |Dict|.
         * 
         * Can also be used as a |method|: 
         * ```vim
         *   mydict->values()
         * ```
         */
        values: (dict: { [key: string]: any }) => any[];

        /**
         *   The result is a Number, which is the screen column of the file
         *   position given with {expr}.  That is, the last screen position
         *   occupied by the character at that position, when the screen
         *   would be of unlimited width.  When there is a <Tab> at the
         *   position, the returned Number will be the column at the end of
         *   the <Tab>.  For example, for a <Tab> in column 1, with 'ts'
         *   set to 8, it returns 8. |conceal| is ignored.
         *   For the byte position use |col()|.
         *   For the use of {expr} see |col()|.
         *   When 'virtualedit' is used {expr} can be [lnum, col, off], where
         *   "off" is the offset in screen columns from the start of the
         *   character.  E.g., a position within a <Tab> or after the last
         *   character.  When "off" is omitted zero is used.
         *   When Virtual editing is active in the current mode, a position
         *   beyond the end of the line can be returned. |'virtualedit'|
         *   The accepted positions are:
         *       .      the cursor position
         *       $      the end of the cursor line (the result is the
         *         number of displayed characters in the cursor line
         *         plus one)
         *       'x      position of mark x (if the mark is not set, 0 is
         *         returned)
         *       v       In Visual mode: the start of the Visual area (the
         *         cursor is the end).  When not in Visual mode
         *         returns the cursor position.  Differs from |'<| in
         *         that it's updated right away.
         *   Note that only marks in the current file can be used.
         *   Examples: 
         * ```vim
         * virtcol(".")     with text "foo^Lbar", with cursor on the "^L", returns 5
         * virtcol("$")     with text "foo^Lbar", returns 9
         * virtcol("'t")    with text "    there", with 't at 'h', returns 6
         * ```
         *   The first column is 1.  0 is returned for an error.
         *   A more advanced example that echoes the maximum length of
         *   all lines: 
         * ```vim
         *       echo max(map(range(1, line('$')), "virtcol([v:val, '$'])"))
         * 
         * ```
         *   Can also be used as a |method|: >
         *     GetPos()->virtcol()
         */
        virtcol: (expr: any) => number;

        /**
         * The result is a Number, which is the byte index of the
         * character in window {winid} at buffer line {lnum} and virtual
         * column {col}.
         * 
         * If {col} is greater than the last virtual column in line
         * {lnum}, then the byte index of the character at the last
         * virtual column is returned.
         * 
         * The {winid} argument can be the window number or the
         * |window-ID|. If this is zero, then the current window is used.
         * 
         * Returns -1 if the window {winid} doesn't exist or the buffer
         * line {lnum} or virtual column {col} is invalid.
         * 
         * See also |screenpos()|, |virtcol()| and |col()|.
         * 
         * Can also be used as a |method|: 
         * ```vim
         *   GetWinid()->virtcol2col(lnum, col)
         * ```
         */
        virtcol2col: (winid: number, lnum: number, col: number) => number;

        /**
         * The result is a String, which describes the last Visual mode
         * used in the current buffer.  Initially it returns an empty
         * string, but once Visual mode has been used, it returns "v",
         * "V", or "<CTRL-V>" (a single CTRL-V character) for
         * character-wise, line-wise, or block-wise Visual mode
         * respectively.
         * Example: 
         * ```vim
         *   :exe "normal " .. visualmode()
         * ```
         * This enters the same Visual mode as before.  It is also useful
         * in scripts if you wish to act differently depending on the
         * Visual mode that was used.
         * If Visual mode is active, use |mode()| to get the Visual mode
         * (e.g., in a |:vmap|).
         * If {expr} is supplied and it evaluates to a non-zero Number or
         * a non-empty String, then the Visual mode will be cleared and
         * the old value is returned.  See |non-zero-arg|.
         */
        visualmode: (expr?: any) => string;

        /**
         * Waits until {condition} evaluates to |TRUE|, where {condition}
         * is a |Funcref| or |string| containing an expression.
         * 
         * {timeout} is the maximum waiting time in milliseconds, -1
         * means forever.
         * 
         * Condition is evaluated on user events, internal events, and
         * every {interval} milliseconds (default: 200).
         * 
         * Returns a status integer:
         *   0 if the condition was satisfied before timeout
         *   -1 if the timeout was exceeded
         *   -2 if the function was interrupted (by |CTRL-C|)
         *   -3 if an error occurred
         */
        wait: (timeout: any, condition: any, interval?: any) => number;

        /**
         * Returns |TRUE| when the wildmenu is active and |FALSE|
         * otherwise.  See 'wildmenu' and 'wildmode'.
         * This can be used in mappings to handle the 'wildcharm' option
         * gracefully. (Makes only sense with |mapmode-c| mappings).
         * 
         * For example to make <c-j> work like <down> in wildmode, use: 
         * ```vim
         * :cnoremap <expr> <C-j> wildmenumode() ? "\<Down>\<Tab>" : "\<c-j>"
         * ```
         * (Note, this needs the 'wildcharm' option set appropriately).
         */
        wildmenumode: () => number;

        /**
         * Like `execute()` but in the context of window {id}.
         * The window will temporarily be made the current window,
         * without triggering autocommands or changing directory.  When
         * executing {command} autocommands will be triggered, this may
         * have unexpected side effects.  Use |:noautocmd| if needed.
         * Example: 
         * ```vim
         *   call win_execute(winid, 'syntax enable')
         * ```
         * Doing the same with `setwinvar()` would not trigger
         * autocommands and not actually show syntax highlighting.
         * 
         * When window {id} does not exist then no error is given and
         * an empty string is returned.
         * 
         * Can also be used as a |method|, the base is passed as the
         * second argument: 
         * ```vim
         *   GetCommand()->win_execute(winid)
         * ```
         */
        win_execute: (id: any, command: any, silent?: any) => string;

        /**
         * Returns a |List| with |window-ID|s for windows that contain
         * buffer {bufnr}.  When there is none the list is empty.
         * 
         * Can also be used as a |method|: 
         * ```vim
         *   GetBufnr()->win_findbuf()
         * ```
         */
        win_findbuf: (bufnr: number) => any[];

        /**
         * Get the |window-ID| for the specified window.
         * When {win} is missing use the current window.
         * With {win} this is the window number.  The top window has
         * number 1.
         * Without {tab} use the current tab, otherwise the tab with
         * number {tab}.  The first tab has number one.
         * Return zero if the window cannot be found.
         * 
         * Can also be used as a |method|: 
         * ```vim
         *   GetWinnr()->win_getid()
         * ```
         */
        win_getid: (win?: number, tab?: any) => number;

        /**
         * Return the type of the window:
         *   "autocmd"  autocommand window. Temporary window
         *       used to execute autocommands.
         *   "command"  command-line window |cmdwin|
         *   (empty)    normal window
         *   "loclist"  |location-list-window|
         *   "popup"    floating window |api-floatwin|
         *   "preview"  preview window |preview-window|
         *   "quickfix"  |quickfix-window|
         *   "unknown"  window {nr} not found
         * 
         * When {nr} is omitted return the type of the current window.
         * When {nr} is given return the type of this window by number or
         * |window-ID|.
         * 
         * Also see the 'buftype' option.
         * 
         * Can also be used as a |method|: 
         * ```vim
         *   GetWinid()->win_gettype()
         * ```
         */
        win_gettype: (nr?: number) => string;

        /**
         * Go to window with ID {expr}.  This may also change the current
         * tabpage.
         * Return TRUE if successful, FALSE if the window cannot be found.
         * 
         * Can also be used as a |method|: 
         * ```vim
         *   GetWinid()->win_gotoid()
         * ```
         */
        win_gotoid: (expr: any) => number;

        /**
         * Return a list with the tab number and window number of window
         * with ID {expr}: [tabnr, winnr].
         * Return [0, 0] if the window cannot be found.
         * 
         * Can also be used as a |method|: 
         * ```vim
         *   GetWinid()->win_id2tabwin()
         * ```
         */
        win_id2tabwin: (expr: any) => any[];

        /**
         * Return the window number of window with ID {expr}.
         * Return 0 if the window cannot be found in the current tabpage.
         * 
         * Can also be used as a |method|: 
         * ```vim
         *   GetWinid()->win_id2win()
         * ```
         */
        win_id2win: (expr: any) => number;

        /**
         * Move window {nr}'s vertical separator (i.e., the right border)
         * by {offset} columns, as if being dragged by the mouse. {nr}
         * can be a window number or |window-ID|. A positive {offset}
         * moves right and a negative {offset} moves left. Moving a
         * window's vertical separator will change the width of the
         * window and the width of other windows adjacent to the vertical
         * separator. The magnitude of movement may be smaller than
         * specified (e.g., as a consequence of maintaining
         * 'winminwidth'). Returns TRUE if the window can be found and
         * FALSE otherwise.
         * This will fail for the rightmost window and a full-width
         * window, since it has no separator on the right.
         * Only works for the current tab page.
         * 
         * Can also be used as a |method|: 
         * ```vim
         *   GetWinnr()->win_move_separator(offset)
         * ```
         */
        win_move_separator: (nr: number, offset: any) => number;

        /**
         * Move window {nr}'s status line (i.e., the bottom border) by
         * {offset} rows, as if being dragged by the mouse. {nr} can be a
         * window number or |window-ID|. A positive {offset} moves down
         * and a negative {offset} moves up. Moving a window's status
         * line will change the height of the window and the height of
         * other windows adjacent to the status line. The magnitude of
         * movement may be smaller than specified (e.g., as a consequence
         * of maintaining 'winminheight'). Returns TRUE if the window can
         * be found and FALSE otherwise.
         * Only works for the current tab page.
         * 
         * Can also be used as a |method|: 
         * ```vim
         *   GetWinnr()->win_move_statusline(offset)
         * ```
         */
        win_move_statusline: (nr: number, offset: any) => number;

        /**
         * Return the screen position of window {nr} as a list with two
         * numbers: [row, col].  The first window always has position
         * [1, 1], unless there is a tabline, then it is [2, 1].
         * {nr} can be the window number or the |window-ID|.  Use zero
         * for the current window.
         * Returns [0, 0] if the window cannot be found in the current
         * tabpage.
         * 
         * Can also be used as a |method|: 
         * ```vim
         *   GetWinid()->win_screenpos()
         * ```
         */
        win_screenpos: (nr: number) => any[];

        /**
         * Move the window {nr} to a new split of the window {target}.
         * This is similar to moving to {target}, creating a new window
         * using |:split| but having the same contents as window {nr}, and
         * then closing {nr}.
         * 
         * Both {nr} and {target} can be window numbers or |window-ID|s.
         * Both must be in the current tab page.
         * 
         * Returns zero for success, non-zero for failure.
         * 
         * {options} is a |Dictionary| with the following optional entries:
         *   "vertical"  When TRUE, the split is created vertically,
         *     like with |:vsplit|.
         *   "rightbelow"  When TRUE, the split is made below or to the
         *     right (if vertical).  When FALSE, it is done
         *     above or to the left (if vertical).  When not
         *     present, the values of 'splitbelow' and
         *     'splitright' are used.
         * 
         * Can also be used as a |method|: 
         * ```vim
         *   GetWinid()->win_splitmove(target)
         * ```
         */
        win_splitmove: (nr: number, target: any, options?: { [key: string]: any }) => number;

        /**
         * The result is a Number, which is the number of the buffer
         *   associated with window {nr}.  {nr} can be the window number or
         *   the |window-ID|.
         *   When {nr} is zero, the number of the buffer in the current
         *   window is returned.
         *   When window {nr} doesn't exist, -1 is returned.
         *   Example: 
         * ```vim
         * :echo "The file in the current window is " .. bufname(winbufnr(0))
         * ```
         *   Can also be used as a |method|: 
         * ```vim
         *     FindWindow()->winbufnr()->bufname()
         * ```
         */
        winbufnr: (nr: number) => number;

        /**
         * The result is a Number, which is the virtual column of the
         *   cursor in the window.  This is counting screen cells from the
         *   left side of the window.  The leftmost column is one.
         */
        wincol: () => number;

        /**
         * The result is a String.  For MS-Windows it indicates the OS
         * version.  E.g, Windows 10 is "10.0", Windows 8 is "6.2",
         * Windows XP is "5.1".  For non-MS-Windows systems the result is
         * an empty string.
         */
        windowsversion: () => string;

        /**
         *   The result is a Number, which is the height of window {nr}.
         *   {nr} can be the window number or the |window-ID|.
         *   When {nr} is zero, the height of the current window is
         *   returned.  When window {nr} doesn't exist, -1 is returned.
         *   An existing window always has a height of zero or more.
         *   This excludes any window toolbar line.
         *   Examples: 
         * ```vim
         * :echo "The current window has " .. winheight(0) .. " lines."
         * 
         * ```
         *   Can also be used as a |method|: >
         *     GetWinid()->winheight()
         * <
         */
        winheight: (nr: number) => number;

        /**
         * The result is a nested List containing the layout of windows
         * in a tabpage.
         * 
         * Without {tabnr} use the current tabpage, otherwise the tabpage
         * with number {tabnr}. If the tabpage {tabnr} is not found,
         * returns an empty list.
         * 
         * For a leaf window, it returns:
         *   ["leaf", {winid}]
         * For horizontally split windows, which form a column, it
         * returns:
         *   ["col", [{nested list of windows}]]
         * For vertically split windows, which form a row, it returns:
         *   ["row", [{nested list of windows}]]
         * 
         * Example: 
         * ```vim
         *   " Only one window in the tab page
         *   :echo winlayout()
         *   ['leaf', 1000]
         *   " Two horizontally split windows
         *   :echo winlayout()
         *   ['col', [['leaf', 1000], ['leaf', 1001]]]
         *   " The second tab page, with three horizontally split
         *   " windows, with two vertically split windows in the
         *   " middle window
         *   :echo winlayout(2)
         *   ['col', [['leaf', 1002], ['row', [['leaf', 1003],
         *           ['leaf', 1001]]], ['leaf', 1000]]]
         * ```
         * Can also be used as a |method|: 
         * ```vim
         *   GetTabnr()->winlayout()
         * ```
         */
        winlayout: (tabnr?: number) => any[];

        /**
         * The result is a Number, which is the screen line of the cursor
         *   in the window.  This is counting screen lines from the top of
         *   the window.  The first line is one.
         *   If the cursor was moved the view on the file will be updated
         *   first, this may cause a scroll.
         */
        winline: () => number;

        /**
         * The result is a Number, which is the number of the current
         *   window.  The top window has number 1.
         *   Returns zero for a popup window.
         * 
         *   The optional argument {arg} supports the following values:
         *     $  the number of the last window (the window
         *       count).
         *     #  the number of the last accessed window (where
         *       |CTRL-W_p| goes to).  If there is no previous
         *       window or it is in another tab page 0 is
         *       returned.
         *     {N}j  the number of the Nth window below the
         *       current window (where |CTRL-W_j| goes to).
         *     {N}k  the number of the Nth window above the current
         *       window (where |CTRL-W_k| goes to).
         *     {N}h  the number of the Nth window left of the
         *       current window (where |CTRL-W_h| goes to).
         *     {N}l  the number of the Nth window right of the
         *       current window (where |CTRL-W_l| goes to).
         *   The number can be used with |CTRL-W_w| and ":wincmd w"
         *   |:wincmd|.
         *   When {arg} is invalid an error is given and zero is returned.
         *   Also see |tabpagewinnr()| and |win_getid()|.
         *   Examples: 
         * ```vim
         *     let window_count = winnr('$')
         *     let prev_window = winnr('#')
         *     let wnum = winnr('3k')
         * 
         * ```
         *   Can also be used as a |method|: >
         *     GetWinval()->winnr()
         * <
         */
        winnr: (arg?: any) => number;

        /**
         * Returns a sequence of |:resize| commands that should restore
         *   the current window sizes.  Only works properly when no windows
         *   are opened or closed and the current window and tab page is
         *   unchanged.
         *   Example: 
         * ```vim
         *     :let cmd = winrestcmd()
         *     :call MessWithWindowSizes()
         *     :exe cmd
         * ```
         */
        winrestcmd: () => string;

        /**
         * Uses the |Dictionary| returned by |winsaveview()| to restore
         * the view of the current window.
         * Note: The {dict} does not have to contain all values, that are
         * returned by |winsaveview()|. If values are missing, those
         * settings won't be restored. So you can use: 
         * ```vim
         *     :call winrestview({'curswant': 4})
         * ```
         * This will only set the curswant value (the column the cursor
         * wants to move on vertical movements) of the cursor to column 5
         * (yes, that is 5), while all other settings will remain the
         * same. This is useful, if you set the cursor position manually.
         * 
         * If you have changed the values the result is unpredictable.
         * If the window size changed the result won't be the same.
         * 
         * Can also be used as a |method|: 
         * ```vim
         *   GetView()->winrestview()
         * ```
         */
        winrestview: (dict: { [key: string]: any }) => undefined;

        /**
         * Returns a |Dictionary| that contains information to restore
         *   the view of the current window.  Use |winrestview()| to
         *   restore the view.
         *   This is useful if you have a mapping that jumps around in the
         *   buffer and you want to go back to the original view.
         *   This does not save fold information.  Use the 'foldenable'
         *   option to temporarily switch off folding, so that folds are
         *   not opened when moving around. This may have side effects.
         *   The return value includes:
         *     lnum    cursor line number
         *     col    cursor column (Note: the first column
         *         zero, as opposed to what |getcurpos()|
         *         returns)
         *     coladd    cursor column offset for 'virtualedit'
         *     curswant  column for vertical movement (Note:
         *         the first column is zero, as opposed
         *         to what |getcurpos()| returns).  After
         *         |$| command it will be a very large
         *         number equal to |v:maxcol|.
         *     topline    first line in the window
         *     topfill    filler lines, only in diff mode
         *     leftcol    first column displayed; only used when
         *         'wrap' is off
         *     skipcol    columns skipped
         *   Note that no option values are saved.
         */
        winsaveview: () => { [key: string]: any };

        /**
         *   The result is a Number, which is the width of window {nr}.
         *   {nr} can be the window number or the |window-ID|.
         *   When {nr} is zero, the width of the current window is
         *   returned.  When window {nr} doesn't exist, -1 is returned.
         *   An existing window always has a width of zero or more.
         *   Examples: 
         * ```vim
         * :echo "The current window has " .. winwidth(0) .. " columns."
         * :if winwidth(0) <= 50
         * :  50 wincmd |
         * :endif
         * ```
         *   For getting the terminal or screen size, see the 'columns'
         *   option.
         * 
         *   Can also be used as a |method|: 
         * ```vim
         *     GetWinid()->winwidth()
         * ```
         */
        winwidth: (nr: number) => number;

        /**
         * The result is a dictionary of byte/chars/word statistics for
         * the current buffer.  This is the same info as provided by
         * |g_CTRL-G|
         * The return value includes:
         *   bytes    Number of bytes in the buffer
         *   chars    Number of chars in the buffer
         *   words    Number of words in the buffer
         *   cursor_bytes    Number of bytes before cursor position
         *       (not in Visual mode)
         *   cursor_chars    Number of chars before cursor position
         *       (not in Visual mode)
         *   cursor_words    Number of words before cursor position
         *       (not in Visual mode)
         *   visual_bytes    Number of bytes visually selected
         *       (only in Visual mode)
         *   visual_chars    Number of chars visually selected
         *       (only in Visual mode)
         *   visual_words    Number of words visually selected
         *       (only in Visual mode)
         */
        wordcount: () => { [key: string]: any };

        /**
         * When {object} is a |List| write it to file {fname}.  Each list
         * item is separated with a NL.  Each list item must be a String
         * or Number.
         * When {flags} contains "b" then binary mode is used: There will
         * not be a NL after the last list item.  An empty item at the
         * end does cause the last line in the file to end in a NL.
         * 
         * When {object} is a |Blob| write the bytes to file {fname}
         * unmodified.
         * 
         * When {flags} contains "a" then append mode is used, lines are
         * appended to the file: 
         * ```vim
         *   :call writefile(["foo"], "event.log", "a")
         *   :call writefile(["bar"], "event.log", "a")
         * ```
         * When {flags} contains "S" fsync() call is not used, with "s"
         * it is used, 'fsync' option applies by default. No fsync()
         * means that writefile() will finish faster, but writes may be
         * left in OS buffers and not yet written to disk. Such changes
         * will disappear if system crashes before OS does writing.
         * 
         * All NL characters are replaced with a NUL character.
         * Inserting CR characters needs to be done before passing {list}
         * to writefile().
         * An existing file is overwritten, if possible.
         * When the write fails -1 is returned, otherwise 0.  There is an
         * error message if the file can't be created or when writing
         * fails.
         * Also see |readfile()|.
         * To copy a file byte for byte: 
         * ```vim
         *   :let fl = readfile("foo", "b")
         *   :call writefile(fl, "foocopy", "b")
         * 
         * ```
         * Can also be used as a |method|: >
         *   GetText()->writefile("thefile")
         */
        writefile: (object: any, fname: any, flags?: any) => number;

        /**
         * Bitwise XOR on the two arguments.  The arguments are converted
         * to a number.  A List, Dict or Float argument causes an error.
         * Also see `and()` and `or()`.
         * Example: 
         * ```vim
         *   :let bits = xor(bits, 0x80)
         * ```
         * Can also be used as a |method|: 
         * ```vim
         *   :let bits = bits->xor(0x80)
         * ```
         */
        xor: (expr: any, expr1: any) => number;
    }

    export const fn: fn & { [key: string]: (...vargs: any[]) => any };

    /**
     * Invokes |vim-function| or |user-function| {func} with arguments {...}.
     * See also |vim.fn|.
     * Equivalent to: 
     * ```lua
     *     vim.fn[func]({...})
     * ```
     */
    function call(func: Function, ...vargs: any): any;

    /**
     * Run diff on strings {a} and {b}. Any indices returned by this function,
     * either directly or via callback arguments, are 1-based.
     * 
     * Examples: 
     * ```lua
     *     vim.diff('a\n', 'b\nc\n')
     *     -- =>
     *     -- @@ -1 +1,2 @@
     *     -- -a
     *     -- +b
     *     -- +c
     * 
     *     vim.diff('a\n', 'b\nc\n', {result_type = 'indices'})
     *     -- =>
     *     -- {
     *     --   {1, 1, 1, 2}
     *     -- }
     * ```
     * Parameters: ~
     *   • {a}      First string to compare
     *   • {b}      Second string to compare
     *   • {opts}   Optional parameters:
     *              • `on_hunk` (callback):
     *                Invoked for each hunk in the diff. Return a negative number
     *                to cancel the callback for any remaining hunks.
     *                Args:
     *                • `start_a` (integer): Start line of hunk in {a}.
     *                • `count_a` (integer): Hunk size in {a}.
     *                • `start_b` (integer): Start line of hunk in {b}.
     *                • `count_b` (integer): Hunk size in {b}.
     *              • `result_type` (string): Form of the returned diff:
     *                • "unified": (default) String in unified format.
     *                • "indices": Array of hunk locations.
     *                Note: This option is ignored if `on_hunk` is used.
     *              • `linematch` (boolean|integer): Run linematch on the resulting hunks
     *                from xdiff. When integer, only hunks upto this size in
     *                lines are run through linematch. Requires `result_type = indices`,
     *                ignored otherwise.
     *              • `algorithm` (string):
     *                Diff algorithm to use. Values:
     *                • "myers"      the default algorithm
     *                • "minimal"    spend extra time to generate the
     *                               smallest possible diff
     *                • "patience"   patience diff algorithm
     *                • "histogram"  histogram diff algorithm
     *              • `ctxlen` (integer): Context length
     *              • `interhunkctxlen` (integer):
     *                Inter hunk context length
     *              • `ignore_whitespace` (boolean):
     *                Ignore whitespace
     *              • `ignore_whitespace_change` (boolean):
     *                Ignore whitespace change
     *              • `ignore_whitespace_change_at_eol` (boolean)
     *                Ignore whitespace change at end-of-line.
     *              • `ignore_cr_at_eol` (boolean)
     *                Ignore carriage return at end-of-line
     *              • `ignore_blank_lines` (boolean)
     *                Ignore blank lines
     *              • `indent_heuristic` (boolean):
     *                Use the indent heuristic for the internal
     *                diff library.
     * 
     * Return: ~
     *     See {opts.result_type}. nil if {opts.on_hunk} is given.
     */
    function diff(a: any, b: any, opts: { [key: string]: any }): any;

    /**
     * The result is a String, which is the text {str} converted from
     * encoding {from} to encoding {to}. When the conversion fails `nil` is
     * returned.  When some characters could not be converted they
     * are replaced with "?".
     * The encoding names are whatever the iconv() library function
     * can accept, see ":Man 3 iconv".
     * 
     * Parameters: ~
     *   • {str}   (string) Text to convert
     *   • {from}  (string) Encoding of {str}
     *   • {to}    (string) Target encoding
     * 
     * Returns: ~
     *     Converted string if conversion succeeds, `nil` otherwise.
     */
    function iconv(str: string, from: number, to: number, opts?: { [key: string]: any }): any;

    /**
     * Returns true if the code is executing as part of a "fast" event handler,
     * where most of the API is disabled. These are low-level events (e.g.
     * |lua-loop-callbacks|) which can be invoked whenever Nvim polls for input.
     * When this is `false` most API functions are callable (but may be subject
     * to other restrictions such as |textlock|).
     */
    function in_fast_event(): any;

    /**
     * Parse the Vim regex {re} and return a regex object. Regexes are "magic"
     * and case-sensitive by default, regardless of 'magic' and 'ignorecase'.
     * They can be controlled with flags, see |/magic| and |/ignorecase|.
     */
    function regex(re: any): any;

    /**
     * Sends {event} to {channel} via |RPC| and returns immediately. If {channel}
     * is 0, the event is broadcast to all channels.
     * 
     * This function also works in a fast callback |lua-loop-callbacks|.
     */
    function rpcnotify(channel: any, method: any, args?: any[], ...vargs: any): any;

    /**
     * Sends a request to {channel} to invoke {method} via |RPC| and blocks until
     * a response is received.
     * 
     * Note: NIL values as part of the return value is represented as |vim.NIL|
     * special value
     */
    function rpcrequest(channel: any, method: any, args?: any[], ...vargs: any): any;

    /**
     * Schedules {callback} to be invoked soon by the main event-loop. Useful
     * to avoid |textlock| or other temporary restrictions.
     */
    function schedule(callback: Function): any;

    /**
     * Convert UTF-32 or UTF-16 {index} to byte index. If {use_utf16} is not
     * supplied, it defaults to false (use UTF-32). Returns the byte index.
     * 
     * Invalid UTF-8 and NUL is treated like by |vim.str_byteindex()|.
     * An {index} in the middle of a UTF-16 sequence is rounded upwards to
     * the end of that sequence.
     */
    function str_byteindex(str: string, index: number, use_utf16?: any): any;

    /**
     * Convert byte index to UTF-32 and UTF-16 indices. If {index} is not
     * supplied, the length of the string is used. All indices are zero-based.
     * Returns two values: the UTF-32 and UTF-16 indices respectively.
     * 
     * Embedded NUL bytes are treated as terminating the string. Invalid UTF-8
     * bytes, and embedded surrogates are counted as one code point each. An
     * {index} in the middle of a UTF-8 sequence is rounded upwards to the end of
     * that sequence.
     */
    function str_utfindex(str: string, index?: number): any;

    /**
     * Compares strings case-insensitively. Returns 0, 1 or -1 if strings are
     * equal, {a} is greater than {b} or {a} is lesser than {b}, respectively.
     */
    function stricmp(a: any, b: any): any;

    /**
     * Attach to ui events, similar to |nvim_ui_attach()| but receive events
     * as lua callback. Can be used to implement screen elements like
     * popupmenu or message handling in lua.
     * 
     * {options} should be a dictionary-like table, where `ext_...` options should
     * be set to true to receive events for the respective external element.
     * 
     * {callback} receives event name plus additional parameters. See |ui-popupmenu|
     * and the sections below for event format for respective events.
     * 
     * WARNING: This api is considered experimental.  Usability will vary for
     * different screen elements. In particular `ext_messages` behavior is subject
     * to further changes and usability improvements.  This is expected to be
     * used to handle messages when setting 'cmdheight' to zero (which is
     * likewise experimental).
     * 
     * Example (stub for a |ui-popupmenu| implementation): 
     * ```lua
     * 
     *   ns = vim.api.nvim_create_namespace('my_fancy_pum')
     * 
     *   vim.ui_attach(ns, {ext_popupmenu=true}, function(event, ...)
     *     if event == "popupmenu_show" then
     *       local items, selected, row, col, grid = ...
     *       print("display pum ", #items)
     *     elseif event == "popupmenu_select" then
     *       local selected = ...
     *       print("selected", selected)
     *     elseif event == "popupmenu_hide" then
     *       print("FIN")
     *     end
     *   end)
     * ```
     */
    function ui_attach(ns: number, options: { [key: string]: any }, callback: Function): any;

    /**
     * Detach a callback previously attached with |vim.ui_attach()| for the
     * given namespace {ns}.
     */
    function ui_detach(ns: number): any;

    /**
     * Wait for {time} in milliseconds until {callback} returns `true`.
     * 
     * Executes {callback} immediately and at approximately {interval}
     * milliseconds (default 200). Nvim still processes other events during
     * this time.
     * 
     * Parameters: ~
     *   • {time}      Number of milliseconds to wait
     *   • {callback}  Optional callback. Waits until {callback} returns true
     *   • {interval}  (Approximate) number of milliseconds to wait between polls
     *   • {fast_only} If true, only |api-fast| events will be processed.
     *                     If called from while in an |api-fast| event, will
     *                     automatically be set to `true`.
     * 
     * Returns: ~
     *     If {callback} returns `true` during the {time}:
     *         `true, nil`
     * 
     *     If {callback} never returns `true` during the {time}:
     *         `false, -1`
     * 
     *     If {callback} is interrupted during the {time}:
     *         `false, -2`
     * 
     *     If {callback} errors, the error is raised.
     * 
     *     Examples: 
     * ```lua
     * 
     * ---
     * -- Wait for 100 ms, allowing other events to process
     * vim.wait(100, function() end)
     * 
     * ---
     * -- Wait for 100 ms or until global variable set.
     * vim.wait(100, function() return vim.g.waiting_for_var end)
     * 
     * ---
     * -- Wait for 1 second or until global variable set, checking every ~500 ms
     * vim.wait(1000, function() return vim.g.waiting_for_var end, 500)
     * 
     * ---
     * -- Schedule a function to set a value in 100ms
     * vim.defer_fn(function() vim.g.timer_result = true end, 100)
     * 
     * -- Would wait ten seconds if results blocked. Actually only waits  100 ms
     * if vim.wait(10000, function() return vim.g.timer_result end) then
     *   print('Only waiting a little bit of time!')
     * end
     * ```
     */
    function wait(time: any, callback?: Function, interval?: any, fast_only?: any): any;

    /** @noSelf **/
    interface go {
        aleph: number

        /**
         * `'allowrevins'`  `'ari'` 	boolean	(default off)
         * 			global
         * 	Allow CTRL-_ in Insert and Command-line mode.  This is default off, to
         * 	avoid that users that accidentally type CTRL-_ instead of SHIFT-_ get
         * 	into reverse Insert mode, and don't know how to get out.  See
         * 	`'revins'` .
         */
        allowrevins: boolean

        /**
         * `'ambiwidth'`  `'ambw'` 	string (default: "single")
         * 			global
         * 	Tells Vim what to do with characters with East Asian Width Class
         * 	Ambiguous (such as Euro, Registered Sign, Copyright Sign, Greek
         * 	letters, Cyrillic letters).
         * 
         * 	There are currently two possible values:
         * 	"single":	Use the same width as characters in US-ASCII.  This is
         * 			expected by most users.
         * 	"double":	Use twice the width of ASCII characters.
         * 
         * 	The value "double" cannot be used if `'listchars'`  or `'fillchars'` 
         * 	contains a character that would be double width.  These errors may
         * 	also be given when calling setcellwidths().
         * 
         * 	The values are overruled for characters specified with
         * 	|setcellwidths()|.
         * 
         * 	There are a number of CJK fonts for which the width of glyphs for
         * 	those characters are solely based on how many octets they take in
         * 	legacy/traditional CJK encodings.  In those encodings, Euro,
         * 	Registered sign, Greek/Cyrillic letters are represented by two octets,
         * 	therefore those fonts have "wide" glyphs for them.  This is also
         * 	true of some line drawing characters used to make tables in text
         * 	file.  Therefore, when a CJK font is used for GUI Vim or
         * 	Vim is running inside a terminal (emulators) that uses a CJK font
         * 	(or Vim is run inside an xterm invoked with "-cjkwidth" option.),
         * 	this option should be set to "double" to match the width perceived
         * 	by Vim with the width of glyphs in the font.  Perhaps it also has
         * 	to be set to "double" under CJK MS-Windows when the system locale is
         * 	set to one of CJK locales.  See Unicode Standard Annex #11
         * 	(https://www.unicode.org/reports/tr11).
         */
        ambiwidth: string

        /**
         * `'arabicshape'`  `'arshape'` 	boolean (default on)
         * 			global
         * 	When on and `'termbidi'`  is off, the required visual character
         * 	corrections that need to take place for displaying the Arabic language
         * 	take effect.  Shaping, in essence, gets enabled; the term is a broad
         * 	one which encompasses:
         * 	  a) the changing/morphing of characters based on their location
         * 	     within a word (initial, medial, final and stand-alone).
         * 	  b) the enabling of the ability to compose characters
         * 	  c) the enabling of the required combining of some characters
         * 	When disabled the display shows each character's true stand-alone
         * 	form.
         * 	Arabic is a complex language which requires other settings, for
         * 	further details see |arabic.txt|.
         */
        arabicshape: boolean

        /**
         * `'autochdir'`  `'acd'` 	boolean (default off)
         * 			global
         * 	When on, Vim will change the current working directory whenever you
         * 	open a file, switch buffers, delete a buffer or open/close a window.
         * 	It will change to the directory containing the file which was opened
         * 	or selected.  When a buffer has no name it also has no directory, thus
         * 	the current directory won't change when navigating to it.
         * 	Note: When this option is on some plugins may not work.
         */
        autochdir: boolean

        /**
         * `'autowrite'`  `'aw'` 	boolean	(default off)
         * 			global
         * 	Write the contents of the file, if it has been modified, on each
         * 	`:next`, `:rewind`, `:last`, `:first`, `:previous`, `:stop`,
         * 	`:suspend`, `:tag`, `:!`, `:make`, CTRL-] and CTRL-^ command; and when
         * 	a `:buffer`, CTRL-O, CTRL-I, '{A-Z0-9}, or `{A-Z0-9} command takes one
         * 	to another file.
         * 	A buffer is not written if it becomes hidden, e.g. when `'bufhidden'`  is
         * 	set to "hide" and `:next` is used.
         * 	Note that for some commands the `'autowrite'`  option is not used, see
         * 	`'autowriteall'`  for that.
         * 	Some buffers will not be written, specifically when `'buftype'`  is
         * 	"nowrite", "nofile", "terminal" or "prompt".
         */
        autowrite: boolean

        /**
         * `'autowriteall'`  `'awa'` 	boolean	(default off)
         * 			global
         * 	Like `'autowrite'` , but also used for commands ":edit", ":enew", ":quit",
         * 	":qall", ":exit", ":xit", ":recover" and closing the Vim window.
         * 	Setting this option also implies that Vim behaves like `'autowrite'`  has
         * 	been set.
         */
        autowriteall: boolean

        /**
         * `'background'`  `'bg'` 	string	(default "dark")
         * 			global
         * 	When set to "dark" or "light", adjusts the default color groups for
         * 	that background type.  The |TUI| or other UI sets this on startup
         * 	(triggering |OptionSet|) if it can detect the background color.
         * 
         * 	This option does NOT change the background color, it tells Nvim what
         * 	the "inherited" (terminal/GUI) background looks like.
         * 	See |:hi-normal| if you want to set the background color explicitly.
         * 
         * 	When a color scheme is loaded (the "g:colors_name" variable is set)
         * 	setting `'background'`  will cause the color scheme to be reloaded.  If
         * 	the color scheme adjusts to the value of `'background'`  this will work.
         * 	However, if the color scheme sets `'background'`  itself the effect may
         * 	be undone.  First delete the "g:colors_name" variable when needed.
         * 
         * 	Normally this option would be set in the vimrc file.  Possibly
         * 	depending on the terminal name.  Example: >
         * 		:if $TERM ==# "xterm"
         * 		:  set background=dark
         * 		:endif
         * <	When this option is set, the default settings for the highlight groups
         * 	will change.  To use other settings, place ":highlight" commands AFTER
         * 	the setting of the `'background'`  option.
         * 	This option is also used in the "$VIMRUNTIME/syntax/syntax.vim" file
         * 	to select the colors for syntax highlighting.  After changing this
         * 	option, you must load syntax.vim again to see the result.  This can be
         * 	done with ":syntax on".
         */
        background: string

        /**
         * `'backspace'`  `'bs'` 	string	(default "indent,eol,start")
         * 			global
         * 	Influences the working of <BS>, <Del>, CTRL-W and CTRL-U in Insert
         * 	mode.  This is a list of items, separated by commas.  Each item allows
         * 	a way to backspace over something:
         * 	value	effect	~
         * 	indent	allow backspacing over autoindent
         * 	eol	allow backspacing over line breaks (join lines)
         * 	start	allow backspacing over the start of insert; CTRL-W and CTRL-U
         * 		stop once at the start of insert.
         * 	nostop	like start, except CTRL-W and CTRL-U do not stop at the start of
         * 		insert.
         * 
         * 	When the value is empty, Vi compatible backspacing is used, none of
         * 	the ways mentioned for the items above are possible.
         * 
         * 	For backwards compatibility with version 5.4 and earlier:
         * 	value	effect	~
         * 	  0	same as ":set backspace=" (Vi compatible)
         * 	  1	same as ":set backspace=indent,eol"
         * 	  2	same as ":set backspace=indent,eol,start"
         * 	  3	same as ":set backspace=indent,eol,nostop"
         */
        backspace: string

        /**
         * `'backup'`  `'bk'` 		boolean	(default off)
         * 			global
         * 	Make a backup before overwriting a file.  Leave it around after the
         * 	file has been successfully written.  If you do not want to keep the
         * 	backup file, but you do want a backup while the file is being
         * 	written, reset this option and set the `'writebackup'`  option (this is
         * 	the default).  If you do not want a backup file at all reset both
         * 	options (use this if your file system is almost full).  See the
         * 	|backup-table| for more explanations.
         * 	When the `'backupskip'`  pattern matches, a backup is not made anyway.
         * 	When `'patchmode'`  is set, the backup may be renamed to become the
         * 	oldest version of a file.
         */
        backup: boolean

        /**
         * `'backupdir'`  `'bdir'` 	string	(default ".,$XDG_STATE_HOME/nvim/backup//")
         * 			global
         * 	List of directories for the backup file, separated with commas.
         * 	- The backup file will be created in the first directory in the list
         * 	  where this is possible.  If none of the directories exist Nvim will
         * 	  attempt to create the last directory in the list.
         * 	- Empty means that no backup file will be created (`'patchmode'`  is
         * 	  impossible!).  Writing may fail because of this.
         * 	- A directory "." means to put the backup file in the same directory
         * 	  as the edited file.
         * 	- A directory starting with "./" (or ".\" for MS-Windows) means to put
         * 	  the backup file relative to where the edited file is.  The leading
         * 	  "." is replaced with the path name of the edited file.
         * 	  ("." inside a directory name has no special meaning).
         * 	- Spaces after the comma are ignored, other spaces are considered part
         * 	  of the directory name.  To have a space at the start of a directory
         * 	  name, precede it with a backslash.
         * 	- To include a comma in a directory name precede it with a backslash.
         * 	- A directory name may end in an `'/'` .
         * 	- For Unix and Win32, if a directory ends in two path separators "//",
         * 	  the swap file name will be built from the complete path to the file
         * 	  with all path separators changed to percent `'%'`  signs. This will
         * 	  ensure file name uniqueness in the backup directory.
         * 	  On Win32, it is also possible to end with "\\".  However, When a
         * 	  separating comma is following, you must use "//", since "\\" will
         * 	  include the comma in the file name. Therefore it is recommended to
         * 	  use `'//'` , instead of `'\\'` .
         * 	- Environment variables are expanded |:set_env|.
         * 	- Careful with `'\'`  characters, type one before a space, type two to
         * 	  get one in the option (see |option-backslash|), for example: >
         * 	    :set bdir=c:\\tmp,\ dir\\,with\\,commas,\\\ dir\ with\ spaces
         * <	- For backwards compatibility with Vim version 3.0 a `'>'`  at the start
         * 	  of the option is removed.
         * 	See also `'backup'`  and `'writebackup'`  options.
         * 	If you want to hide your backup files on Unix, consider this value: >
         * 		:set backupdir=./.backup,~/.backup,.,/tmp
         * <	You must create a ".backup" directory in each directory and in your
         * 	home directory for this to work properly.
         * 	The use of |:set+=| and |:set-=| is preferred when adding or removing
         * 	directories from the list.  This avoids problems when a future version
         * 	uses another default.
         * 	This option cannot be set from a |modeline| or in the |sandbox|, for
         * 	security reasons.
         */
        backupdir: string

        /**
         * `'backupext'`  `'bex'` 	string	(default "~")
         * 			global
         * 	String which is appended to a file name to make the name of the
         * 	backup file.  The default is quite unusual, because this avoids
         * 	accidentally overwriting existing files with a backup file.  You might
         * 	prefer using ".bak", but make sure that you don't have files with
         * 	".bak" that you want to keep.
         * 	Only normal file name characters can be used; "/\*?[|<>" are illegal.
         * 
         * 	If you like to keep a lot of backups, you could use a BufWritePre
         * 	autocommand to change `'backupext'`  just before writing the file to
         * 	include a timestamp. >
         * 		:au BufWritePre * let &bex = `'-'`  .. strftime("%Y%b%d%X") .. `'~'` 
         * <	Use `'backupdir'`  to put the backup in a different directory.
         */
        backupext: string

        /**
         * `'backupskip'`  `'bsk'` 	string	(default: "$TMPDIR/,$TEMP/*"
         * 				 Unix: "/tmp/,$TMP/"
         * 				 Mac: "/private/tmp/,$TMP/")
         * 			global
         * 	A list of file patterns.  When one of the patterns matches with the
         * 	name of the file which is written, no backup file is created.  Both
         * 	the specified file name and the full path name of the file are used.
         * 	The pattern is used like with |:autocmd|, see |autocmd-pattern|.
         * 	Watch out for special characters, see |option-backslash|.
         * 	When $TMPDIR, $TMP or $TEMP is not defined, it is not used for the
         * 	default value.  "/tmp/*" is only used for Unix.
         * 
         * 	WARNING: Not having a backup file means that when Vim fails to write
         * 	your buffer correctly and then, for whatever reason, Vim exits, you
         * 	lose both the original file and what you were writing.  Only disable
         * 	backups if you don't care about losing the file.
         * 
         * 	Note that environment variables are not expanded.  If you want to use
         * 	$HOME you must expand it explicitly, e.g.: >
         * 		:let &backupskip = escape(expand(`'$HOME'` ), `'\'` ) .. `'/tmp/*'` 
         * 
         * <	Note that the default also makes sure that "crontab -e" works (when a
         * 	backup would be made by renaming the original file crontab won't see
         * 	the newly created file).  Also see `'backupcopy'`  and |crontab|.
         */
        backupskip: string

        /**
         * `'belloff'`  `'bo'` 		string	(default "all")
         * 			global
         * 	Specifies for which events the bell will not be rung. It is a comma-
         * 	separated list of items. For each item that is present, the bell
         * 	will be silenced. This is most useful to specify specific events in
         * 	insert mode to be silenced.
         * 
         * 	item	    meaning when present	~
         * 	all	    All events.
         * 	backspace   When hitting <BS> or <Del> and deleting results in an
         * 		    error.
         * 	cursor	    Fail to move around using the cursor keys or
         * 		    <PageUp>/<PageDown> in |Insert-mode|.
         * 	complete    Error occurred when using |i_CTRL-X_CTRL-K| or
         * 		    |i_CTRL-X_CTRL-T|.
         * 	copy	    Cannot copy char from insert mode using |i_CTRL-Y| or
         * 		    |i_CTRL-E|.
         * 	ctrlg	    Unknown Char after <C-G> in Insert mode.
         * 	error	    Other Error occurred (e.g. try to join last line)
         * 		    (mostly used in |Normal-mode| or |Cmdline-mode|).
         * 	esc	    hitting <Esc> in |Normal-mode|.
         * 	hangul	    Ignored.
         * 	lang	    Calling the beep module for Lua/Mzscheme/TCL.
         * 	mess	    No output available for |g<|.
         * 	showmatch   Error occurred for `'showmatch'`  function.
         * 	operator    Empty region error |cpo-E|.
         * 	register    Unknown register after <C-R> in |Insert-mode|.
         * 	shell	    Bell from shell output |:!|.
         * 	spell	    Error happened on spell suggest.
         * 	wildmode    More matches in |cmdline-completion| available
         * 		    (depends on the `'wildmode'`  setting).
         * 
         * 	This is most useful to fine tune when in Insert mode the bell should
         * 	be rung. For Normal mode and Ex commands, the bell is often rung to
         * 	indicate that an error occurred. It can be silenced by adding the
         * 	"error" keyword.
         */
        belloff: string

        /**
         * `'breakat'`  `'brk'` 		string	(default " ^I!@*-+;:,./?")
         * 			global
         * 	This option lets you choose which characters might cause a line
         * 	break if `'linebreak'`  is on.  Only works for ASCII characters.
         */
        breakat: string

        /**
         * `'browsedir'`  `'bsdir'` 	string	(default: "last")
         * 			global
         * 	Which directory to use for the file browser:
         * 	   last		Use same directory as with last file browser, where a
         * 			file was opened or saved.
         * 	   buffer	Use the directory of the related buffer.
         * 	   current	Use the current directory.
         * 	   {path}	Use the specified directory
         */
        browsedir: string

        /**
         * `'casemap'`  `'cmp'` 		string	(default: "internal,keepascii")
         * 			global
         * 	Specifies details about changing the case of letters.  It may contain
         * 	these words, separated by a comma:
         * 	internal	Use internal case mapping functions, the current
         * 			locale does not change the case mapping. When
         * 			"internal" is omitted, the towupper() and towlower()
         * 			system library functions are used when available.
         * 	keepascii	For the ASCII characters (0x00 to 0x7f) use the US
         * 			case mapping, the current locale is not effective.
         * 			This probably only matters for Turkish.
         */
        casemap: string

        /**
         * `'cdhome'`  `'cdh'` 		boolean	(default: off)
         * 			global
         * 	When on, |:cd|, |:tcd| and |:lcd| without an argument changes the
         * 	current working directory to the |$HOME| directory like in Unix.
         * 	When off, those commands just print the current directory name.
         * 	On Unix this option has no effect.
         */
        cdhome: boolean

        /**
         * `'cdpath'`  `'cd'` 		string	(default: equivalent to $CDPATH or ",,")
         * 			global
         * 	This is a list of directories which will be searched when using the
         * 	|:cd|, |:tcd| and |:lcd| commands, provided that the directory being
         * 	searched for has a relative path, not an absolute part starting with
         * 	"/", "./" or "../", the `'cdpath'`  option is not used then.
         * 	The `'cdpath'`  option's value has the same form and semantics as
         * 	|`'path'` |.  Also see |file-searching|.
         * 	The default value is taken from $CDPATH, with a "," prepended to look
         * 	in the current directory first.
         * 	If the default value taken from $CDPATH is not what you want, include
         * 	a modified version of the following command in your vimrc file to
         * 	override it: >
         * 	  :let &cdpath = `','`  .. substitute(substitute($CDPATH, '[, ]', `'\\\0'` , `'g'` ), `':'` , `','` , `'g'` )
         * <	This option cannot be set from a |modeline| or in the |sandbox|, for
         * 	security reasons.
         * 	(parts of `'cdpath'`  can be passed to the shell to expand file names).
         */
        cdpath: string

        /**
         * `'cedit'` 			string	(default: CTRL-F)
         * 			global
         * 	The key used in Command-line Mode to open the command-line window.
         * 	Only non-printable keys are allowed.
         * 	The key can be specified as a single character, but it is difficult to
         * 	type.  The preferred way is to use the <> notation.  Examples: >
         * 		:exe "set cedit=\<C-Y>"
         * 		:exe "set cedit=\<Esc>"
         * <	|Nvi| also has this option, but it only uses the first character.
         * 	See |cmdwin|.
         */
        cedit: string

        /**
         * `'charconvert'`  `'ccv'` 	string (default "")
         * 			global
         * 	An expression that is used for character encoding conversion.  It is
         * 	evaluated when a file that is to be read or has been written has a
         * 	different encoding from what is desired.
         * 	`'charconvert'`  is not used when the internal iconv() function is
         * 	supported and is able to do the conversion.  Using iconv() is
         * 	preferred, because it is much faster.
         * 	`'charconvert'`  is not used when reading stdin |--|, because there is no
         * 	file to convert from.  You will have to save the text in a file first.
         * 	The expression must return zero, false or an empty string for success,
         * 	non-zero or true for failure.
         * 	See |encoding-names| for possible encoding names.
         * 	Additionally, names given in `'fileencodings'`  and `'fileencoding'`  are
         * 	used.
         * 	Conversion between "latin1", "unicode", "ucs-2", "ucs-4" and "utf-8"
         * 	is done internally by Vim, `'charconvert'`  is not used for this.
         * 	Also used for Unicode conversion.
         * 	Example: >
         * 		set charconvert=CharConvert()
         * 		fun CharConvert()
         * 		  system("recode "
         * 			\ .. v:charconvert_from .. ".." .. v:charconvert_to
         * 			\ .. " <" .. v:fname_in .. " >" .. v:fname_out)
         * 		  return v:shell_error
         * 		endfun
         * <	The related Vim variables are:
         * 		v:charconvert_from	name of the current encoding
         * 		v:charconvert_to	name of the desired encoding
         * 		v:fname_in		name of the input file
         * 		v:fname_out		name of the output file
         * 	Note that v:fname_in and v:fname_out will never be the same.
         * 	This option cannot be set from a |modeline| or in the |sandbox|, for
         * 	security reasons.
         */
        charconvert: string

        /**
         * `'clipboard'`  `'cb'` 	string	(default "")
         * 			global
         * 	This option is a list of comma-separated names.
         * 	These names are recognized:
         * 
         * 
         * 	unnamed		When included, Vim will use the clipboard register "*"
         * 			for all yank, delete, change and put operations which
         * 			would normally go to the unnamed register.  When a
         * 			register is explicitly specified, it will always be
         * 			used regardless of whether "unnamed" is in `'clipboard'` 
         * 			or not.  The clipboard register can always be
         * 			explicitly accessed using the "* notation.  Also see
         * 			|clipboard|.
         * 
         * 
         * 	unnamedplus	A variant of the "unnamed" flag which uses the
         * 			clipboard register "+" (|quoteplus|) instead of
         * 			register "*" for all yank, delete, change and put
         * 			operations which would normally go to the unnamed
         * 			register.  When "unnamed" is also included to the
         * 			option, yank and delete operations (but not put)
         * 			will additionally copy the text into register
         * 			`'*'` . See |clipboard|.
         */
        clipboard: string

        /**
         * `'cmdheight'`  `'ch'` 	number	(default 1)
         * 			global or local to tab page
         * 	Number of screen lines to use for the command-line.  Helps avoiding
         * 	|hit-enter| prompts.
         * 	The value of this option is stored with the tab page, so that each tab
         * 	page can have a different value.
         * 
         * 	When `'cmdheight'`  is zero, there is no command-line unless it is being
         * 	used.  The command-line will cover the last line of the screen when
         * 	shown.
         * 
         * 	WARNING: `cmdheight=0` is considered experimental. Expect some
         * 	unwanted behaviour. Some `'shortmess'`  flags and similar
         * 	mechanism might fail to take effect, causing unwanted hit-enter
         * 	prompts.  Some informative messages, both from Nvim itself and
         * 	plugins, will not be displayed.
         */
        cmdheight: number

        /**
         * `'cmdwinheight'`  `'cwh'` 	number	(default 7)
         * 			global
         * 	Number of screen lines to use for the command-line window. |cmdwin|
         */
        cmdwinheight: number

        /**
         * `'columns'`  `'co'` 		number	(default 80 or terminal width)
         * 			global
         * 	Number of columns of the screen.  Normally this is set by the terminal
         * 	initialization and does not have to be set by hand.
         * 	When Vim is running in the GUI or in a resizable window, setting this
         * 	option will cause the window size to be changed.  When you only want
         * 	to use the size for the GUI, put the command in your |ginit.vim| file.
         * 	When you set this option and Vim is unable to change the physical
         * 	number of columns of the display, the display may be messed up.  For
         * 	the GUI it is always possible and Vim limits the number of columns to
         * 	what fits on the screen.  You can use this command to get the widest
         * 	window possible: >
         * 		:set columns=9999
         * <	Minimum value is 12, maximum value is 10000.
         */
        columns: number

        compatible: boolean

        /**
         * `'completeopt'`  `'cot'` 	string	(default: "menu,preview")
         * 			global
         * 	A comma-separated list of options for Insert mode completion
         * 	|ins-completion|.  The supported values are:
         * 
         * 	   menu	    Use a popup menu to show the possible completions.  The
         * 		    menu is only shown when there is more than one match and
         * 		    sufficient colors are available.  |ins-completion-menu|
         * 
         * 	   menuone  Use the popup menu also when there is only one match.
         * 		    Useful when there is additional information about the
         * 		    match, e.g., what file it comes from.
         * 
         * 	   longest  Only insert the longest common text of the matches.  If
         * 		    the menu is displayed you can use CTRL-L to add more
         * 		    characters.  Whether case is ignored depends on the kind
         * 		    of completion.  For buffer text the `'ignorecase'`  option is
         * 		    used.
         * 
         * 	   preview  Show extra information about the currently selected
         * 		    completion in the preview window.  Only works in
         * 		    combination with "menu" or "menuone".
         * 
         * 	  noinsert  Do not insert any text for a match until the user selects
         * 		    a match from the menu. Only works in combination with
         * 		    "menu" or "menuone". No effect if "longest" is present.
         * 
         * 	  noselect  Do not select a match in the menu, force the user to
         * 		    select one from the menu. Only works in combination with
         * 		    "menu" or "menuone".
         */
        completeopt: string

        /**
         * `'completeslash'`  `'csl'` 	string	(default: "")
         * 			local to buffer
         * 			{only for MS-Windows}
         * 	When this option is set it overrules `'shellslash'`  for completion:
         * 	- When this option is set to "slash", a forward slash is used for path
         * 	  completion in insert mode. This is useful when editing HTML tag, or
         * 	  Makefile with `'noshellslash'`  on MS-Windows.
         * 	- When this option is set to "backslash", backslash is used. This is
         * 	  useful when editing a batch file with `'shellslash'`  set on MS-Windows.
         * 	- When this option is empty, same character is used as for
         * 	  `'shellslash'` .
         * 	For Insert mode completion the buffer-local value is used.  For
         * 	command line completion the global value is used.
         */
        completeslash: string

        /**
         * `'confirm'`  `'cf'` 		boolean (default off)
         * 			global
         * 	When `'confirm'`  is on, certain operations that would normally
         * 	fail because of unsaved changes to a buffer, e.g. ":q" and ":e",
         * 	instead raise a dialog asking if you wish to save the current
         * 	file(s).  You can still use a ! to unconditionally |abandon| a buffer.
         * 	If `'confirm'`  is off you can still activate confirmation for one
         * 	command only (this is most useful in mappings) with the |:confirm|
         * 	command.
         * 	Also see the |confirm()| function and the `'v'`  flag in `'guioptions'` .
         */
        confirm: boolean

        /**
         * `'cpoptions'`  `'cpo'` 	string	(default: "aABceFs_")
         * 			global
         * 	A sequence of single character flags.  When a character is present
         * 	this indicates Vi-compatible behavior.  This is used for things where
         * 	not being Vi-compatible is mostly or sometimes preferred.
         * 	`'cpoptions'`  stands for "compatible-options".
         * 	Commas can be added for readability.
         * 	To avoid problems with flags that are added in the future, use the
         * 	"+=" and "-=" feature of ":set" |add-option-flags|.
         * 
         * 	    contains	behavior	~
         * 
         * 		a	When included, a ":read" command with a file name
         * 			argument will set the alternate file name for the
         * 			current window.
         * 
         * 		A	When included, a ":write" command with a file name
         * 			argument will set the alternate file name for the
         * 			current window.
         * 
         * 		b	"\|" in a ":map" command is recognized as the end of
         * 			the map command.  The `'\'`  is included in the mapping,
         * 			the text after the `'|'`  is interpreted as the next
         * 			command.  Use a CTRL-V instead of a backslash to
         * 			include the `'|'`  in the mapping.  Applies to all
         * 			mapping, abbreviation, menu and autocmd commands.
         * 			See also |map_bar|.
         * 
         * 		B	A backslash has no special meaning in mappings,
         * 			abbreviations, user commands and the "to" part of the
         * 			menu commands.  Remove this flag to be able to use a
         * 			backslash like a CTRL-V.  For example, the command
         * 			":map X \<Esc>" results in X being mapped to:
         * 				`'B'`  included:	"\^["	 (^[ is a real <Esc>)
         * 				`'B'`  excluded:	"<Esc>"  (5 characters)
         * 
         * 		c	Searching continues at the end of any match at the
         * 			cursor position, but not further than the start of the
         * 			next line.  When not present searching continues
         * 			one character from the cursor position.  With `'c'` 
         * 			"abababababab" only gets three matches when repeating
         * 			"/abab", without `'c'`  there are five matches.
         * 
         * 		C	Do not concatenate sourced lines that start with a
         * 			backslash.  See |line-continuation|.
         * 
         * 		d	Using "./" in the `'tags'`  option doesn't mean to use
         * 			the tags file relative to the current file, but the
         * 			tags file in the current directory.
         * 
         * 		D	Can't use CTRL-K to enter a digraph after Normal mode
         * 			commands with a character argument, like |r|, |f| and
         * 			|t|.
         * 
         * 		e	When executing a register with ":@r", always add a
         * 			<CR> to the last line, also when the register is not
         * 			linewise.  If this flag is not present, the register
         * 			is not linewise and the last line does not end in a
         * 			<CR>, then the last line is put on the command-line
         * 			and can be edited before hitting <CR>.
         * 
         * 		E	It is an error when using "y", "d", "c", "g~", "gu" or
         * 			"gU" on an Empty region.  The operators only work when
         * 			at least one character is to be operated on.  Example:
         * 			This makes "y0" fail in the first column.
         * 
         * 		f	When included, a ":read" command with a file name
         * 			argument will set the file name for the current buffer,
         * 			if the current buffer doesn't have a file name yet.
         * 
         * 		F	When included, a ":write" command with a file name
         * 			argument will set the file name for the current
         * 			buffer, if the current buffer doesn't have a file name
         * 			yet.  Also see |cpo-P|.
         * 
         * 		i	When included, interrupting the reading of a file will
         * 			leave it modified.
         * 
         * 		I	When moving the cursor up or down just after inserting
         * 			indent for `'autoindent'` , do not delete the indent.
         * 
         * 		J	A |sentence| has to be followed by two spaces after
         * 			the `'.'` , `'!'`  or `'?'` .  A <Tab> is not recognized as
         * 			white space.
         * 
         * 		K	Don't wait for a key code to complete when it is
         * 			halfway through a mapping.  This breaks mapping
         * 			<F1><F1> when only part of the second <F1> has been
         * 			read.  It enables cancelling the mapping by typing
         * 			<F1><Esc>.
         * 
         * 		l	Backslash in a [] range in a search pattern is taken
         * 			literally, only "\]", "\^", "\-" and "\\" are special.
         * 			See |/[]|
         * 			   `'l'`  included: "/[ \t]"  finds <Space>, `'\'`  and `'t'` 
         * 			   `'l'`  excluded: "/[ \t]"  finds <Space> and <Tab>
         * 
         * 		L	When the `'list'`  option is set, `'wrapmargin'` ,
         * 			`'textwidth'` , `'softtabstop'`  and Virtual Replace mode
         * 			(see |gR|) count a <Tab> as two characters, instead of
         * 			the normal behavior of a <Tab>.
         * 
         * 		m	When included, a showmatch will always wait half a
         * 			second.  When not included, a showmatch will wait half
         * 			a second or until a character is typed.  |`'showmatch'` |
         * 
         * 		M	When excluded, "%" matching will take backslashes into
         * 			account.  Thus in "( \( )" and "\( ( \)" the outer
         * 			parenthesis match.  When included "%" ignores
         * 			backslashes, which is Vi compatible.
         * 
         * 		n	When included, the column used for `'number'`  and
         * 			`'relativenumber'`  will also be used for text of wrapped
         * 			lines.
         * 
         * 		o	Line offset to search command is not remembered for
         * 			next search.
         * 
         * 		O	Don't complain if a file is being overwritten, even
         * 			when it didn't exist when editing it.  This is a
         * 			protection against a file unexpectedly created by
         * 			someone else.  Vi didn't complain about this.
         * 
         * 		p	Vi compatible Lisp indenting.  When not present, a
         * 			slightly better algorithm is used.
         * 
         * 		P	When included, a ":write" command that appends to a
         * 			file will set the file name for the current buffer, if
         * 			the current buffer doesn't have a file name yet and
         * 			the `'F'`  flag is also included |cpo-F|.
         * 
         * 		q	When joining multiple lines leave the cursor at the
         * 			position where it would be when joining two lines.
         * 
         * 		r	Redo ("." command) uses "/" to repeat a search
         * 			command, instead of the actually used search string.
         * 
         * 		R	Remove marks from filtered lines.  Without this flag
         * 			marks are kept like |:keepmarks| was used.
         * 
         * 		s	Set buffer options when entering the buffer for the
         * 			first time.  This is like it is in Vim version 3.0.
         * 			And it is the default.  If not present the options are
         * 			set when the buffer is created.
         * 
         * 		S	Set buffer options always when entering a buffer
         * 			(except `'readonly'` , `'fileformat'` , `'filetype'`  and
         * 			`'syntax'` ).  This is the (most) Vi compatible setting.
         * 			The options are set to the values in the current
         * 			buffer.  When you change an option and go to another
         * 			buffer, the value is copied.  Effectively makes the
         * 			buffer options global to all buffers.
         * 
         * 			`'s'`     `'S'`      copy buffer options
         * 			no     no      when buffer created
         * 			yes    no      when buffer first entered (default)
         * 			 X     yes     each time when buffer entered (vi comp.)
         * 
         * 		t	Search pattern for the tag command is remembered for
         * 			"n" command.  Otherwise Vim only puts the pattern in
         * 			the history for search pattern, but doesn't change the
         * 			last used search pattern.
         * 
         * 		u	Undo is Vi compatible.  See |undo-two-ways|.
         * 
         * 		v	Backspaced characters remain visible on the screen in
         * 			Insert mode.  Without this flag the characters are
         * 			erased from the screen right away.  With this flag the
         * 			screen newly typed text overwrites backspaced
         * 			characters.
         * 
         * 		W	Don't overwrite a readonly file.  When omitted, ":w!"
         * 			overwrites a readonly file, if possible.
         * 
         * 		x	<Esc> on the command-line executes the command-line.
         * 			The default in Vim is to abandon the command-line,
         * 			because <Esc> normally aborts a command.  |c_<Esc>|
         * 
         * 		X	When using a count with "R" the replaced text is
         * 			deleted only once.  Also when repeating "R" with "."
         * 			and a count.
         * 
         * 		y	A yank command can be redone with ".".  Think twice if
         * 			you really want to use this, it may break some
         * 			plugins, since most people expect "." to only repeat a
         * 			change.
         * 
         * 		Z	When using "w!" while the `'readonly'`  option is set,
         * 			don't reset `'readonly'` .
         * 
         * 		!	When redoing a filter command, use the last used
         * 			external command, whatever it was.  Otherwise the last
         * 			used -filter- command is used.
         * 
         * 		$	When making a change to one line, don't redisplay the
         * 			line, but put a `'$'`  at the end of the changed text.
         * 			The changed text will be overwritten when you type the
         * 			new text.  The line is redisplayed if you type any
         * 			command that moves the cursor from the insertion
         * 			point.
         * 
         * 		%	Vi-compatible matching is done for the "%" command.
         * 			Does not recognize "#if", "#endif", etc.
         * 			Does not recognize "/*" and "* /".
         * 			Parens inside single and double quotes are also
         * 			counted, causing a string that contains a paren to
         * 			disturb the matching.  For example, in a line like
         * 			"if (strcmp("foo(", s))" the first paren does not
         * 			match the last one.  When this flag is not included,
         * 			parens inside single and double quotes are treated
         * 			specially.  When matching a paren outside of quotes,
         * 			everything inside quotes is ignored.  When matching a
         * 			paren inside quotes, it will find the matching one (if
         * 			there is one).  This works very well for C programs.
         * 			This flag is also used for other features, such as
         * 			C-indenting.
         * 
         * 		+	When included, a ":write file" command will reset the
         * 			`'modified'`  flag of the buffer, even though the buffer
         * 			itself may still be different from its file.
         * 
         * 		>	When appending to a register, put a line break before
         * 			the appended text.
         * 
         * 		;	When using |,| or |;| to repeat the last |t| search
         * 			and the cursor is right in front of the searched
         * 			character, the cursor won't move. When not included,
         * 			the cursor would skip over it and jump to the
         * 			following occurrence.
         * 
         * 		_	When using |cw| on a word, do not include the
         * 			whitespace following the word in the motion.
         */
        cpoptions: string

        /**
         * `'debug'` 			string	(default "")
         * 			global
         * 	These values can be used:
         * 	msg	Error messages that would otherwise be omitted will be given
         * 		anyway.
         * 	throw	Error messages that would otherwise be omitted will be given
         * 		anyway and also throw an exception and set |v:errmsg|.
         * 	beep	A message will be given when otherwise only a beep would be
         * 		produced.
         * 	The values can be combined, separated by a comma.
         * 	"msg" and "throw" are useful for debugging `'foldexpr'` , `'formatexpr'`  or
         * 	`'indentexpr'` .
         */
        debug: string

        /**
         * `'delcombine'`  `'deco'` 	boolean (default off)
         * 			global
         * 	If editing Unicode and this option is set, backspace and Normal mode
         * 	"x" delete each combining character on its own.  When it is off (the
         * 	default) the character along with its combining characters are
         * 	deleted.
         * 	Note: When `'delcombine'`  is set "xx" may work differently from "2x"!
         * 
         * 	This is useful for Arabic, Hebrew and many other languages where one
         * 	may have combining characters overtop of base characters, and want
         * 	to remove only the combining ones.
         */
        delcombine: boolean

        /**
         * `'diffexpr'`  `'dex'` 	string	(default "")
         * 			global
         * 	Expression which is evaluated to obtain a diff file (either ed-style
         * 	or unified-style) from two versions of a file.  See |diff-diffexpr|.
         * 	This option cannot be set from a |modeline| or in the |sandbox|, for
         * 	security reasons.
         */
        diffexpr: string

        /**
         * `'diffopt'`  `'dip'` 		string	(default "internal,filler,closeoff")
         * 			global
         * 	Option settings for diff mode.  It can consist of the following items.
         * 	All are optional.  Items must be separated by a comma.
         * 
         * 		filler		Show filler lines, to keep the text
         * 				synchronized with a window that has inserted
         * 				lines at the same position.  Mostly useful
         * 				when windows are side-by-side and `'scrollbind'` 
         * 				is set.
         * 
         * 		context:{n}	Use a context of {n} lines between a change
         * 				and a fold that contains unchanged lines.
         * 				When omitted a context of six lines is used.
         * 				When using zero the context is actually one,
         * 				since folds require a line in between, also
         * 				for a deleted line.
         * 				See |fold-diff|.
         * 
         * 		iblank		Ignore changes where lines are all blank.  Adds
         * 				the "-B" flag to the "diff" command if
         * 				`'diffexpr'`  is empty.  Check the documentation
         * 				of the "diff" command for what this does
         * 				exactly.
         * 				NOTE: the diff windows will get out of sync,
         * 				because no differences between blank lines are
         * 				taken into account.
         * 
         * 		icase		Ignore changes in case of text.  "a" and "A"
         * 				are considered the same.  Adds the "-i" flag
         * 				to the "diff" command if `'diffexpr'`  is empty.
         * 
         * 		iwhite		Ignore changes in amount of white space.  Adds
         * 				the "-b" flag to the "diff" command if
         * 				`'diffexpr'`  is empty.  Check the documentation
         * 				of the "diff" command for what this does
         * 				exactly.  It should ignore adding trailing
         * 				white space, but not leading white space.
         * 
         * 		iwhiteall	Ignore all white space changes.  Adds
         * 				the "-w" flag to the "diff" command if
         * 				`'diffexpr'`  is empty.  Check the documentation
         * 				of the "diff" command for what this does
         * 				exactly.
         * 
         * 		iwhiteeol	Ignore white space changes at end of line.
         * 				Adds the "-Z" flag to the "diff" command if
         * 				`'diffexpr'`  is empty.  Check the documentation
         * 				of the "diff" command for what this does
         * 				exactly.
         * 
         * 		horizontal	Start diff mode with horizontal splits (unless
         * 				explicitly specified otherwise).
         * 
         * 		vertical	Start diff mode with vertical splits (unless
         * 				explicitly specified otherwise).
         * 
         * 		closeoff	When a window is closed where `'diff'`  is set
         * 				and there is only one window remaining in the
         * 				same tab page with `'diff'`  set, execute
         * 				`:diffoff` in that window.  This undoes a
         * 				`:diffsplit` command.
         * 
         * 		hiddenoff	Do not use diff mode for a buffer when it
         * 				becomes hidden.
         * 
         * 		foldcolumn:{n}	Set the `'foldcolumn'`  option to {n} when
         * 				starting diff mode.  Without this 2 is used.
         * 
         * 		followwrap	Follow the `'wrap'`  option and leave as it is.
         * 
         * 		internal	Use the internal diff library.  This is
         * 				ignored when `'diffexpr'`  is set.
         * 				When running out of memory when writing a
         * 				buffer this item will be ignored for diffs
         * 				involving that buffer.  Set the `'verbose'` 
         * 				option to see when this happens.
         * 
         * 		indent-heuristic
         * 				Use the indent heuristic for the internal
         * 				diff library.
         * 
         * 		linematch:{n}   Enable a second stage diff on each generated
         * 				hunk in order to align lines. When the total
         * 				number of lines in a hunk exceeds {n}, the
         * 				second stage diff will not be performed as
         * 				very large hunks can cause noticeable lag. A
         * 				recommended setting is "linematch:60", as this
         * 				will enable alignment for a 2 buffer diff with
         * 				hunks of up to 30 lines each, or a 3 buffer
         * 				diff with hunks of up to 20 lines each.
         * 
         *                 algorithm:{text} Use the specified diff algorithm with the
         * 				internal diff engine. Currently supported
         * 				algorithms are:
         * 				myers      the default algorithm
         * 				minimal    spend extra time to generate the
         * 					   smallest possible diff
         * 				patience   patience diff algorithm
         * 				histogram  histogram diff algorithm
         * 
         * 	Examples: >
         * 		:set diffopt=internal,filler,context:4
         * 		:set diffopt=
         * 		:set diffopt=internal,filler,foldcolumn:3
         * 		:set diffopt-=internal  " do NOT use the internal diff parser
         * <
         */
        diffopt: string

        /**
         * `'digraph'`  `'dg'` 		boolean	(default off)
         * 			global
         * 	Enable the entering of digraphs in Insert mode with {char1} <BS>
         * 	{char2}.  See |digraphs|.
         */
        digraph: boolean

        /**
         * `'directory'`  `'dir'` 	string	(default "$XDG_STATE_HOME/nvim/swap//")
         * 			global
         * 	List of directory names for the swap file, separated with commas.
         * 
         * 	Possible items:
         * 	- The swap file will be created in the first directory where this is
         * 	  possible.  If it is not possible in any directory, but last
         * 	  directory listed in the option does not exist, it is created.
         * 	- Empty means that no swap file will be used (recovery is
         * 	  impossible!) and no |E303| error will be given.
         * 	- A directory "." means to put the swap file in the same directory as
         * 	  the edited file.  On Unix, a dot is prepended to the file name, so
         * 	  it doesn't show in a directory listing.  On MS-Windows the "hidden"
         * 	  attribute is set and a dot prepended if possible.
         * 	- A directory starting with "./" (or ".\" for MS-Windows) means to put
         * 	  the swap file relative to where the edited file is.  The leading "."
         * 	  is replaced with the path name of the edited file.
         * 	- For Unix and Win32, if a directory ends in two path separators "//",
         * 	  the swap file name will be built from the complete path to the file
         * 	  with all path separators replaced by percent `'%'`  signs (including
         * 	  the colon following the drive letter on Win32). This will ensure
         * 	  file name uniqueness in the preserve directory.
         * 	  On Win32, it is also possible to end with "\\".  However, When a
         * 	  separating comma is following, you must use "//", since "\\" will
         * 	  include the comma in the file name. Therefore it is recommended to
         * 	  use `'//'` , instead of `'\\'` .
         * 	- Spaces after the comma are ignored, other spaces are considered part
         * 	  of the directory name.  To have a space at the start of a directory
         * 	  name, precede it with a backslash.
         * 	- To include a comma in a directory name precede it with a backslash.
         * 	- A directory name may end in an `':'`  or `'/'` .
         * 	- Environment variables are expanded |:set_env|.
         * 	- Careful with `'\'`  characters, type one before a space, type two to
         * 	  get one in the option (see |option-backslash|), for example: >
         * 	    :set dir=c:\\tmp,\ dir\\,with\\,commas,\\\ dir\ with\ spaces
         * <	- For backwards compatibility with Vim version 3.0 a `'>'`  at the start
         * 	  of the option is removed.
         * 	Using "." first in the list is recommended.  This means that editing
         * 	the same file twice will result in a warning.  Using "/tmp" on Unix is
         * 	discouraged: When the system crashes you lose the swap file.
         * 	"/var/tmp" is often not cleared when rebooting, thus is a better
         * 	choice than "/tmp".  But others on the computer may be able to see the
         * 	files, and it can contain a lot of files, your swap files get lost in
         * 	the crowd.  That is why a "tmp" directory in your home directory is
         * 	tried first.
         * 	The use of |:set+=| and |:set-=| is preferred when adding or removing
         * 	directories from the list.  This avoids problems when a future version
         * 	uses another default.
         * 	This option cannot be set from a |modeline| or in the |sandbox|, for
         * 	security reasons.
         */
        directory: string

        /**
         * `'display'`  `'dy'` 		string	(default "lastline")
         * 			global
         * 	Change the way text is displayed.  This is a comma-separated list of
         * 	flags:
         * 	lastline	When included, as much as possible of the last line
         * 			in a window will be displayed.  "@@@" is put in the
         * 			last columns of the last screen line to indicate the
         * 			rest of the line is not displayed.
         * 	truncate	Like "lastline", but "@@@" is displayed in the first
         * 			column of the last screen line.  Overrules "lastline".
         * 	uhex		Show unprintable characters hexadecimal as <xx>
         * 			instead of using ^C and ~C.
         * 	msgsep		Obsolete flag. Allowed but takes no effect. |msgsep|
         * 
         * 	When neither "lastline" nor "truncate" is included, a last line that
         * 	doesn't fit is replaced with "@" lines.
         * 
         * 	The "@" character can be changed by setting the "lastline" item in
         * 	`'fillchars'` .  The character is highlighted with |hl-NonText|.
         */
        display: string

        /**
         * `'eadirection'`  `'ead'` 	string	(default "both")
         * 			global
         * 	Tells when the `'equalalways'`  option applies:
         * 		ver	vertically, width of windows is not affected
         * 		hor	horizontally, height of windows is not affected
         * 		both	width and height of windows is affected
         */
        eadirection: string

        edcompatible: boolean

        /**
         * `'emoji'`  `'emo'` 	boolean (default: on)
         * 			global
         * 	When on all Unicode emoji characters are considered to be full width.
         * 	This excludes "text emoji" characters, which are normally displayed as
         * 	single width.  Unfortunately there is no good specification for this
         * 	and it has been determined on trial-and-error basis.  Use the
         * 	|setcellwidths()| function to change the behavior.
         */
        emoji: boolean

        /**
         * `'encoding'`  `'enc'` 
         * 	String-encoding used internally and for |RPC| communication.
         * 	Always UTF-8.
         * 
         * 	See `'fileencoding'`  to control file-content encoding.
         */
        encoding: string

        /**
         * `'equalalways'`  `'ea'` 	boolean	(default on)
         * 			global
         * 	When on, all the windows are automatically made the same size after
         * 	splitting or closing a window.  This also happens the moment the
         * 	option is switched on.  When off, splitting a window will reduce the
         * 	size of the current window and leave the other windows the same.  When
         * 	closing a window the extra lines are given to the window next to it
         * 	(depending on `'splitbelow'`  and `'splitright'` ).
         * 	When mixing vertically and horizontally split windows, a minimal size
         * 	is computed and some windows may be larger if there is room.  The
         * 	`'eadirection'`  option tells in which direction the size is affected.
         * 	Changing the height and width of a window can be avoided by setting
         * 	`'winfixheight'`  and `'winfixwidth'` , respectively.
         * 	If a window size is specified when creating a new window sizes are
         * 	currently not equalized (it's complicated, but may be implemented in
         * 	the future).
         */
        equalalways: boolean

        /**
         * `'errorbells'`  `'eb'` 	boolean	(default off)
         * 			global
         * 	Ring the bell (beep or screen flash) for error messages.  This only
         * 	makes a difference for error messages, the bell will be used always
         * 	for a lot of errors without a message (e.g., hitting <Esc> in Normal
         * 	mode).  See `'visualbell'`  to make the bell behave like a screen flash
         * 	or do nothing. See `'belloff'`  to finetune when to ring the bell.
         */
        errorbells: boolean

        /**
         * `'errorfile'`  `'ef'` 	string	(default: "errors.err")
         * 			global
         * 	Name of the errorfile for the QuickFix mode (see |:cf|).
         * 	When the "-q" command-line argument is used, `'errorfile'`  is set to the
         * 	following argument.  See |-q|.
         * 	NOT used for the ":make" command.  See `'makeef'`  for that.
         * 	Environment variables are expanded |:set_env|.
         * 	See |option-backslash| about including spaces and backslashes.
         * 	This option cannot be set from a |modeline| or in the |sandbox|, for
         * 	security reasons.
         */
        errorfile: string

        /**
         * `'eventignore'`  `'ei'` 	string	(default "")
         * 			global
         * 	A list of autocommand event names, which are to be ignored.
         * 	When set to "all" or when "all" is one of the items, all autocommand
         * 	events are ignored, autocommands will not be executed.
         * 	Otherwise this is a comma-separated list of event names.  Example: >
         * 	    :set ei=WinEnter,WinLeave
         * <
         */
        eventignore: string

        /**
         * `'exrc'`  `'ex'` 		boolean (default off)
         * 			global
         * 	Automatically execute .nvim.lua, .nvimrc, and .exrc files in the
         * 	current directory, if the file is in the |trust| list. Use |:trust| to
         * 	manage trusted files. See also |vim.secure.read()|.
         * 
         * 	Compare `'exrc'`  to |editorconfig|:
         * 	- `'exrc'`  can execute any code; editorconfig only specifies settings.
         * 	- `'exrc'`  is Nvim-specific; editorconfig works in other editors.
         * 
         * 	This option cannot be set from a |modeline| or in the |sandbox|, for
         * 	security reasons.
         */
        exrc: boolean

        /**
         * `'fileencodings'`  `'fencs'` 	string (default: "ucs-bom,utf-8,default,latin1")
         * 			global
         * 	This is a list of character encodings considered when starting to edit
         * 	an existing file.  When a file is read, Vim tries to use the first
         * 	mentioned character encoding.  If an error is detected, the next one
         * 	in the list is tried.  When an encoding is found that works,
         * 	`'fileencoding'`  is set to it.  If all fail, `'fileencoding'`  is set to
         * 	an empty string, which means that UTF-8 is used.
         * 		WARNING: Conversion can cause loss of information! You can use
         * 		the |++bad| argument to specify what is done with characters
         * 		that can't be converted.
         * 	For an empty file or a file with only ASCII characters most encodings
         * 	will work and the first entry of `'fileencodings'`  will be used (except
         * 	"ucs-bom", which requires the BOM to be present).  If you prefer
         * 	another encoding use an BufReadPost autocommand event to test if your
         * 	preferred encoding is to be used.  Example: >
         * 		au BufReadPost * if search(`'\S'` , `'w'` ) == 0 |
         * 			\ set fenc=iso-2022-jp | endif
         * <	This sets `'fileencoding'`  to "iso-2022-jp" if the file does not contain
         * 	non-blank characters.
         * 	When the |++enc| argument is used then the value of `'fileencodings'`  is
         * 	not used.
         * 	Note that `'fileencodings'`  is not used for a new file, the global value
         * 	of `'fileencoding'`  is used instead.  You can set it with: >
         * 		:setglobal fenc=iso-8859-2
         * <	This means that a non-existing file may get a different encoding than
         * 	an empty file.
         * 	The special value "ucs-bom" can be used to check for a Unicode BOM
         * 	(Byte Order Mark) at the start of the file.  It must not be preceded
         * 	by "utf-8" or another Unicode encoding for this to work properly.
         * 	An entry for an 8-bit encoding (e.g., "latin1") should be the last,
         * 	because Vim cannot detect an error, thus the encoding is always
         * 	accepted.
         * 	The special value "default" can be used for the encoding from the
         * 	environment.  It is useful when your environment uses a non-latin1
         * 	encoding, such as Russian.
         * 	When a file contains an illegal UTF-8 byte sequence it won't be
         * 	recognized as "utf-8".  You can use the |8g8| command to find the
         * 	illegal byte sequence.
         * 	WRONG VALUES:			WHAT'S WRONG:
         * 		latin1,utf-8		"latin1" will always be used
         * 		utf-8,ucs-bom,latin1	BOM won't be recognized in an utf-8
         * 					file
         * 		cp1250,latin1		"cp1250" will always be used
         * 	If `'fileencodings'`  is empty, `'fileencoding'`  is not modified.
         * 	See `'fileencoding'`  for the possible values.
         * 	Setting this option does not have an effect until the next time a file
         * 	is read.
         */
        fileencodings: string

        /**
         * `'fileformats'`  `'ffs'` 	string (default:
         * 				Win32: "dos,unix",
         * 				Unix: "unix,dos")
         * 			global
         * 	This gives the end-of-line (<EOL>) formats that will be tried when
         * 	starting to edit a new buffer and when reading a file into an existing
         * 	buffer:
         * 	- When empty, the format defined with `'fileformat'`  will be used
         * 	  always.  It is not set automatically.
         * 	- When set to one name, that format will be used whenever a new buffer
         * 	  is opened.  `'fileformat'`  is set accordingly for that buffer.  The
         * 	  `'fileformats'`  name will be used when a file is read into an existing
         * 	  buffer, no matter what `'fileformat'`  for that buffer is set to.
         * 	- When more than one name is present, separated by commas, automatic
         * 	  <EOL> detection will be done when reading a file.  When starting to
         * 	  edit a file, a check is done for the <EOL>:
         * 	  1. If all lines end in <CR><NL>, and `'fileformats'`  includes "dos",
         * 	     `'fileformat'`  is set to "dos".
         * 	  2. If a <NL> is found and `'fileformats'`  includes "unix", `'fileformat'` 
         * 	     is set to "unix".  Note that when a <NL> is found without a
         * 	     preceding <CR>, "unix" is preferred over "dos".
         * 	  3. If `'fileformat'`  has not yet been set, and if a <CR> is found, and
         * 	     if `'fileformats'`  includes "mac", `'fileformat'`  is set to "mac".
         * 	     This means that "mac" is only chosen when:
         * 	      "unix" is not present or no <NL> is found in the file, and
         * 	      "dos" is not present or no <CR><NL> is found in the file.
         * 	     Except: if "unix" was chosen, but there is a <CR> before
         * 	     the first <NL>, and there appear to be more <CR>s than <NL>s in
         * 	     the first few lines, "mac" is used.
         * 	  4. If `'fileformat'`  is still not set, the first name from
         * 	     `'fileformats'`  is used.
         * 	  When reading a file into an existing buffer, the same is done, but
         * 	  this happens like `'fileformat'`  has been set appropriately for that
         * 	  file only, the option is not changed.
         * 	When `'binary'`  is set, the value of `'fileformats'`  is not used.
         * 
         * 	When Vim starts up with an empty buffer the first item is used.  You
         * 	can overrule this by setting `'fileformat'`  in your .vimrc.
         * 
         * 	For systems with a Dos-like <EOL> (<CR><NL>), when reading files that
         * 	are ":source"ed and for vimrc files, automatic <EOL> detection may be
         * 	done:
         * 	- When `'fileformats'`  is empty, there is no automatic detection.  Dos
         * 	  format will be used.
         * 	- When `'fileformats'`  is set to one or more names, automatic detection
         * 	  is done.  This is based on the first <NL> in the file: If there is a
         * 	  <CR> in front of it, Dos format is used, otherwise Unix format is
         * 	  used.
         * 	Also see |file-formats|.
         */
        fileformats: string

        /**
         * `'fileignorecase'`  `'fic'` 	boolean	(default on for systems where case in file
         * 				 names is normally ignored)
         * 			global
         * 	When set case is ignored when using file names and directories.
         * 	See `'wildignorecase'`  for only ignoring case when doing completion.
         */
        fileignorecase: boolean

        /**
         * `'foldclose'`  `'fcl'` 	string (default "")
         * 			global
         * 	When set to "all", a fold is closed when the cursor isn't in it and
         * 	its level is higher than `'foldlevel'` .  Useful if you want folds to
         * 	automatically close when moving out of them.
         */
        foldclose: string

        /**
         * `'foldlevelstart'`  `'fdls'` 	number (default: -1)
         * 			global
         * 	Sets `'foldlevel'`  when starting to edit another buffer in a window.
         * 	Useful to always start editing with all folds closed (value zero),
         * 	some folds closed (one) or no folds closed (99).
         * 	This is done before reading any modeline, thus a setting in a modeline
         * 	overrules this option.  Starting to edit a file for |diff-mode| also
         * 	ignores this option and closes all folds.
         * 	It is also done before BufReadPre autocommands, to allow an autocmd to
         * 	overrule the `'foldlevel'`  value for specific files.
         * 	When the value is negative, it is not used.
         */
        foldlevelstart: number

        /**
         * `'foldopen'`  `'fdo'` 	string (default: "block,hor,mark,percent,quickfix,
         * 							     search,tag,undo")
         * 			global
         * 	Specifies for which type of commands folds will be opened, if the
         * 	command moves the cursor into a closed fold.  It is a comma-separated
         * 	list of items.
         * 	NOTE: When the command is part of a mapping this option is not used.
         * 	Add the |zv| command to the mapping to get the same effect.
         * 	(rationale: the mapping may want to control opening folds itself)
         * 
         * 		item		commands ~
         * 		all		any
         * 		block		"(", "{", "[[", "[{", etc.
         * 		hor		horizontal movements: "l", "w", "fx", etc.
         * 		insert		any command in Insert mode
         * 		jump		far jumps: "G", "gg", etc.
         * 		mark		jumping to a mark: "'m", CTRL-O, etc.
         * 		percent		"%"
         * 		quickfix	":cn", ":crew", ":make", etc.
         * 		search		search for a pattern: "/", "n", "*", "gd", etc.
         * 				(not for a search pattern in a ":" command)
         * 				Also for |[s| and |]s|.
         * 		tag		jumping to a tag: ":ta", CTRL-T, etc.
         * 		undo		undo or redo: "u" and CTRL-R
         * 	When a movement command is used for an operator (e.g., "dl" or "y%")
         * 	this option is not used.  This means the operator will include the
         * 	whole closed fold.
         * 	Note that vertical movements are not here, because it would make it
         * 	very difficult to move onto a closed fold.
         * 	In insert mode the folds containing the cursor will always be open
         * 	when text is inserted.
         * 	To close folds you can re-apply `'foldlevel'`  with the |zx| command or
         * 	set the `'foldclose'`  option to "all".
         */
        foldopen: string

        /**
         * `'fsync'`  `'fs'` 		boolean	(default off)
         * 			global
         * 	When on, the OS function fsync() will be called after saving a file
         * 	(|:write|, |writefile()|, …), |swap-file|, |undo-persistence| and |shada-file|.
         * 	This flushes the file to disk, ensuring that it is safely written.
         * 	Slow on some systems: writing buffers, quitting Nvim, and other
         * 	operations may sometimes take a few seconds.
         * 
         * 	Files are ALWAYS flushed (`'fsync'`  is ignored) when:
         * 	- |CursorHold| event is triggered
         * 	- |:preserve| is called
         * 	- system signals low battery life
         * 	- Nvim exits abnormally
         * 
         * 	This option cannot be set from a |modeline| or in the |sandbox|, for
         * 	security reasons.
         */
        fsync: boolean

        /**
         * `'gdefault'`  `'gd'` 		boolean	(default off)
         * 			global
         * 	When on, the ":substitute" flag `'g'`  is default on.  This means that
         * 	all matches in a line are substituted instead of one.  When a `'g'`  flag
         * 	is given to a ":substitute" command, this will toggle the substitution
         * 	of all or one match.  See |complex-change|.
         * 
         * 		command		`'gdefault'`  on	`'gdefault'`  off	~
         * 		:s///		  subst. all	  subst. one
         * 		:s///g		  subst. one	  subst. all
         * 		:s///gg		  subst. all	  subst. one
         * 
         * 	DEPRECATED: Setting this option may break plugins that are not aware
         * 	of this option.  Also, many users get confused that adding the /g flag
         * 	has the opposite effect of that it normally does.
         */
        gdefault: boolean

        /**
         * `'grepformat'`  `'gfm'` 	string	(default "%f:%l:%m,%f:%l%m,%f  %l%m")
         * 			global
         * 	Format to recognize for the ":grep" command output.
         * 	This is a scanf-like string that uses the same format as the
         * 	`'errorformat'`  option: see |errorformat|.
         */
        grepformat: string

        /**
         * `'guicursor'`  `'gcr'` 	string	(default "n-v-c-sm:block,i-ci-ve:ver25,r-cr-o:hor20")
         * 			global
         * 	Configures the cursor style for each mode. Works in the GUI and many
         * 	terminals.  See |tui-cursor-shape|.
         * 
         * 	To disable cursor-styling, reset the option: >
         * 		:set guicursor=
         * 
         * <	To enable mode shapes, "Cursor" highlight, and blinking: >
         * 		:set guicursor=n-v-c:block,i-ci-ve:ver25,r-cr:hor20,o:hor50
         * 		  \,a:blinkwait700-blinkoff400-blinkon250-Cursor/lCursor
         * 		  \,sm:block-blinkwait175-blinkoff150-blinkon175
         * 
         * <	The option is a comma-separated list of parts.  Each part consists of a
         * 	mode-list and an argument-list:
         * 		mode-list:argument-list,mode-list:argument-list,..
         * 	The mode-list is a dash separated list of these modes:
         * 		n	Normal mode
         * 		v	Visual mode
         * 		ve	Visual mode with `'selection'`  "exclusive" (same as `'v'` ,
         * 			if not specified)
         * 		o	Operator-pending mode
         * 		i	Insert mode
         * 		r	Replace mode
         * 		c	Command-line Normal (append) mode
         * 		ci	Command-line Insert mode
         * 		cr	Command-line Replace mode
         * 		sm	showmatch in Insert mode
         * 		a	all modes
         * 	The argument-list is a dash separated list of these arguments:
         * 		hor{N}	horizontal bar, {N} percent of the character height
         * 		ver{N}	vertical bar, {N} percent of the character width
         * 		block	block cursor, fills the whole character
         * 			- Only one of the above three should be present.
         * 			- Default is "block" for each mode.
         * 		blinkwait{N}
         * 		blinkon{N}
         * 		blinkoff{N}
         * 			blink times for cursor: blinkwait is the delay before
         * 			the cursor starts blinking, blinkon is the time that
         * 			the cursor is shown and blinkoff is the time that the
         * 			cursor is not shown.  Times are in msec.  When one of
         * 			the numbers is zero, there is no blinking. E.g.: >
         * 				:set guicursor=n:blinkon0
         * <			- Default is "blinkon0" for each mode.
         * 		{group-name}
         * 			Highlight group that decides the color and font of the
         * 			cursor.
         * 			In the |TUI|:
         * 			- |inverse|/reverse and no group-name are interpreted
         * 			  as "host-terminal default cursor colors" which
         * 			  typically means "inverted bg and fg colors".
         * 			- |ctermfg| and |guifg| are ignored.
         * 		{group-name}/{group-name}
         * 			Two highlight group names, the first is used when
         * 			no language mappings are used, the other when they
         * 			are. |language-mapping|
         * 
         * 	Examples of parts:
         * 	   n-c-v:block-nCursor	In Normal, Command-line and Visual mode, use a
         * 				block cursor with colors from the "nCursor"
         * 				highlight group
         * 	   n-v-c-sm:block,i-ci-ve:ver25-Cursor,r-cr-o:hor20
         * 				In Normal et al. modes, use a block cursor
         * 				with the default colors defined by the host
         * 				terminal.  In Insert-likes modes, use
         * 				a vertical bar cursor with colors from
         * 				"Cursor" highlight group.  In Replace-likes
         * 				modes, use a underline cursor with
         * 				default colors.
         * 	   i-ci:ver30-iCursor-blinkwait300-blinkon200-blinkoff150
         * 				In Insert and Command-line Insert mode, use a
         * 				30% vertical bar cursor with colors from the
         * 				"iCursor" highlight group.  Blink a bit
         * 				faster.
         * 
         * 	The `'a'`  mode is different.  It will set the given argument-list for
         * 	all modes.  It does not reset anything to defaults.  This can be used
         * 	to do a common setting for all modes.  For example, to switch off
         * 	blinking: "a:blinkon0"
         * 
         * 	Examples of cursor highlighting: >
         * 	    :highlight Cursor gui=reverse guifg=NONE guibg=NONE
         * 	    :highlight Cursor gui=NONE guifg=bg guibg=fg
         * <
         */
        guicursor: string

        /**
         * `'guifont'`  `'gfn'` 		string	(default "")
         * 			global
         * 	This is a list of fonts which will be used for the GUI version of Vim.
         * 	In its simplest form the value is just one font name.  When
         * 	the font cannot be found you will get an error message.  To try other
         * 	font names a list can be specified, font names separated with commas.
         * 	The first valid font is used.
         * 
         * 	Spaces after a comma are ignored.  To include a comma in a font name
         * 	precede it with a backslash.  Setting an option requires an extra
         * 	backslash before a space and a backslash.  See also
         * 	|option-backslash|.  For example: >
         * 	    :set guifont=Screen15,\ 7x13,font\\,with\\,commas
         * <	will make Vim try to use the font "Screen15" first, and if it fails it
         * 	will try to use "7x13" and then "font,with,commas" instead.
         * 
         * 	If none of the fonts can be loaded, Vim will keep the current setting.
         * 	If an empty font list is given, Vim will try using other resource
         * 	settings (for X, it will use the Vim.font resource), and finally it
         * 	will try some builtin default which should always be there ("7x13" in
         * 	the case of X).  The font names given should be "normal" fonts.  Vim
         * 	will try to find the related bold and italic fonts.
         * 
         * 	For Win32 and Mac OS: >
         * 	    :set guifont=*
         * <	will bring up a font requester, where you can pick the font you want.
         * 
         * 	The font name depends on the GUI used.
         * 
         * 	For Mac OSX you can use something like this: >
         * 	    :set guifont=Monaco:h10
         * <
         * 	Note that the fonts must be mono-spaced (all characters have the same
         * 	width).
         * 
         * 	To preview a font on X11, you might be able to use the "xfontsel"
         * 	program.  The "xlsfonts" program gives a list of all available fonts.
         * 
         * 	For the Win32 GUI
         * 	- takes these options in the font name:
         * 		hXX - height is XX (points, can be floating-point)
         * 		wXX - width is XX (points, can be floating-point)
         * 		b   - bold
         * 		i   - italic
         * 		u   - underline
         * 		s   - strikeout
         * 		cXX - character set XX.  Valid charsets are: ANSI, ARABIC,
         * 		      BALTIC, CHINESEBIG5, DEFAULT, EASTEUROPE, GB2312, GREEK,
         * 		      HANGEUL, HEBREW, JOHAB, MAC, OEM, RUSSIAN, SHIFTJIS,
         * 		      SYMBOL, THAI, TURKISH, VIETNAMESE ANSI and BALTIC.
         * 		      Normally you would use "cDEFAULT".
         * 
         * 	  Use a `':'`  to separate the options.
         * 	- A `'_'`  can be used in the place of a space, so you don't need to use
         * 	  backslashes to escape the spaces.
         * 	- Examples: >
         * 	    :set guifont=courier_new:h12:w5:b:cRUSSIAN
         * 	    :set guifont=Andale_Mono:h7.5:w4.5
         * <
         */
        guifont: string

        /**
         * `'guifontwide'`  `'gfw'` 	string	(default "")
         * 			global
         * 	Comma-separated list of fonts to be used for double-width characters.
         * 	The first font that can be loaded is used.
         * 	Note: The size of these fonts must be exactly twice as wide as the one
         * 	specified with `'guifont'`  and the same height.
         * 
         * 	When `'guifont'`  has a valid font and `'guifontwide'`  is empty Vim will
         * 	attempt to set `'guifontwide'`  to a matching double-width font.
         */
        guifontwide: string

        /**
         * `'guioptions'`  `'go'` 	string	(default "egmrLT"   (MS-Windows))
         * 			global
         * 	This option only has an effect in the GUI version of Vim.  It is a
         * 	sequence of letters which describes what components and options of the
         * 	GUI should be used.
         * 	To avoid problems with flags that are added in the future, use the
         * 	"+=" and "-=" feature of ":set" |add-option-flags|.
         * 
         * 	Valid letters are as follows:
         * 
         * 	  `'a'` 	Autoselect:  If present, then whenever VISUAL mode is started,
         * 		or the Visual area extended, Vim tries to become the owner of
         * 		the windowing system's global selection.  This means that the
         * 		Visually highlighted text is available for pasting into other
         * 		applications as well as into Vim itself.  When the Visual mode
         * 		ends, possibly due to an operation on the text, or when an
         * 		application wants to paste the selection, the highlighted text
         * 		is automatically yanked into the "* selection register.
         * 		Thus the selection is still available for pasting into other
         * 		applications after the VISUAL mode has ended.
         * 		    If not present, then Vim won't become the owner of the
         * 		windowing system's global selection unless explicitly told to
         * 		by a yank or delete operation for the "* register.
         * 		The same applies to the modeless selection.
         * 
         * 	  `'P'` 	Like autoselect but using the "+ register instead of the "*
         * 		register.
         * 
         * 	  `'A'` 	Autoselect for the modeless selection.  Like `'a'` , but only
         * 		applies to the modeless selection.
         * 
         * 		    `'guioptions'`    autoselect Visual  autoselect modeless ~
         * 			 ""		 -			 -
         * 			 "a"		yes			yes
         * 			 "A"		 -			yes
         * 			 "aA"		yes			yes
         * 
         * 
         * 	  `'c'` 	Use console dialogs instead of popup dialogs for simple
         * 		choices.
         * 
         * 	  `'d'` 	Use dark theme variant if available.
         * 
         * 	  `'e'` 	Add tab pages when indicated with `'showtabline'` .
         * 		`'guitablabel'`  can be used to change the text in the labels.
         * 		When `'e'`  is missing a non-GUI tab pages line may be used.
         * 		The GUI tabs are only supported on some systems, currently
         * 		Mac OS/X and MS-Windows.
         * 
         * 	  `'i'` 	Use a Vim icon.
         * 
         * 	  `'m'` 	Menu bar is present.
         * 
         * 	  `'M'` 	The system menu "$VIMRUNTIME/menu.vim" is not sourced.  Note
         * 		that this flag must be added in the vimrc file, before
         * 		switching on syntax or filetype recognition (when the |gvimrc|
         * 		file is sourced the system menu has already been loaded; the
         * 		`:syntax on` and `:filetype on` commands load the menu too).
         * 
         * 	  `'g'` 	Grey menu items: Make menu items that are not active grey.  If
         * 		`'g'`  is not included inactive menu items are not shown at all.
         * 
         * 	  `'T'` 	Include Toolbar.  Currently only in Win32 GUI.
         * 
         * 	  `'r'` 	Right-hand scrollbar is always present.
         * 
         * 	  `'R'` 	Right-hand scrollbar is present when there is a vertically
         * 		split window.
         * 
         * 	  `'l'` 	Left-hand scrollbar is always present.
         * 
         * 	  `'L'` 	Left-hand scrollbar is present when there is a vertically
         * 		split window.
         * 
         * 	  `'b'` 	Bottom (horizontal) scrollbar is present.  Its size depends on
         * 		the longest visible line, or on the cursor line if the `'h'` 
         * 		flag is included. |gui-horiz-scroll|
         * 
         * 	  `'h'` 	Limit horizontal scrollbar size to the length of the cursor
         * 		line.  Reduces computations. |gui-horiz-scroll|
         * 
         * 	And yes, you may even have scrollbars on the left AND the right if
         * 	you really want to :-).  See |gui-scrollbars| for more information.
         * 
         * 
         * 	  `'v'` 	Use a vertical button layout for dialogs.  When not included,
         * 		a horizontal layout is preferred, but when it doesn't fit a
         * 		vertical layout is used anyway.  Not supported in GTK 3.
         * 
         * 	  `'p'` 	Use Pointer callbacks for X11 GUI.  This is required for some
         * 		window managers.  If the cursor is not blinking or hollow at
         * 		the right moment, try adding this flag.  This must be done
         * 		before starting the GUI.  Set it in your |gvimrc|.  Adding or
         * 		removing it after the GUI has started has no effect.
         * 
         * 	  `'k'` 	Keep the GUI window size when adding/removing a scrollbar, or
         * 		toolbar, tabline, etc.  Instead, the behavior is similar to
         * 		when the window is maximized and will adjust `'lines'`  and
         * 		`'columns'`  to fit to the window.  Without the `'k'`  flag Vim will
         * 		try to keep `'lines'`  and `'columns'`  the same when adding and
         * 		removing GUI components.
         */
        guioptions: string

        /**
         * `'guitablabel'`  `'gtl'` 	string	(default empty)
         * 			global
         * 	When non-empty describes the text to use in a label of the GUI tab
         * 	pages line.  When empty and when the result is empty Vim will use a
         * 	default label.  See |setting-guitablabel| for more info.
         * 
         * 	The format of this option is like that of `'statusline'` .
         * 	`'guitabtooltip'`  is used for the tooltip, see below.
         * 	The expression will be evaluated in the |sandbox| when set from a
         * 	modeline, see |sandbox-option|.
         * 	This option cannot be set in a modeline when `'modelineexpr'`  is off.
         * 
         * 	Only used when the GUI tab pages line is displayed.  `'e'`  must be
         * 	present in `'guioptions'` .  For the non-GUI tab pages line `'tabline'`  is
         * 	used.
         */
        guitablabel: string

        /**
         * `'guitabtooltip'`  `'gtt'` 	string	(default empty)
         * 			global
         * 	When non-empty describes the text to use in a tooltip for the GUI tab
         * 	pages line.  When empty Vim will use a default tooltip.
         * 	This option is otherwise just like `'guitablabel'`  above.
         * 	You can include a line break.  Simplest method is to use |:let|: >
         * 		:let &guitabtooltip = "line one\nline two"
         * <
         */
        guitabtooltip: string

        /**
         * `'helpfile'`  `'hf'` 		string	(default (MS-Windows) "$VIMRUNTIME\doc\help.txt"
         * 					 (others) "$VIMRUNTIME/doc/help.txt")
         * 			global
         * 	Name of the main help file.  All distributed help files should be
         * 	placed together in one directory.  Additionally, all "doc" directories
         * 	in `'runtimepath'`  will be used.
         * 	Environment variables are expanded |:set_env|.  For example:
         * 	"$VIMRUNTIME/doc/help.txt".  If $VIMRUNTIME is not set, $VIM is also
         * 	tried.  Also see |$VIMRUNTIME| and |option-backslash| about including
         * 	spaces and backslashes.
         * 	This option cannot be set from a |modeline| or in the |sandbox|, for
         * 	security reasons.
         */
        helpfile: string

        /**
         * `'helpheight'`  `'hh'` 	number	(default 20)
         * 			global
         * 	Minimal initial height of the help window when it is opened with the
         * 	":help" command.  The initial height of the help window is half of the
         * 	current window, or (when the `'ea'`  option is on) the same as other
         * 	windows.  When the height is less than `'helpheight'` , the height is
         * 	set to `'helpheight'` .  Set to zero to disable.
         */
        helpheight: number

        /**
         * `'helplang'`  `'hlg'` 	string	(default: messages language or empty)
         * 			global
         * 	Comma-separated list of languages.  Vim will use the first language
         * 	for which the desired help can be found.  The English help will always
         * 	be used as a last resort.  You can add "en" to prefer English over
         * 	another language, but that will only find tags that exist in that
         * 	language and not in the English help.
         * 	Example: >
         * 		:set helplang=de,it
         * <	This will first search German, then Italian and finally English help
         * 	files.
         * 	When using |CTRL-]| and ":help!" in a non-English help file Vim will
         * 	try to find the tag in the current language before using this option.
         * 	See |help-translated|.
         */
        helplang: string

        /**
         * `'hidden'`  `'hid'` 		boolean	(default on)
         * 			global
         * 	When off a buffer is unloaded (including loss of undo information)
         * 	when it is |abandon|ed.  When on a buffer becomes hidden when it is
         * 	|abandon|ed.  A buffer displayed in another window does not become
         * 	hidden, of course.
         * 
         * 	Commands that move through the buffer list sometimes hide a buffer
         * 	although the `'hidden'`  option is off when these three are true:
         * 	- the buffer is modified
         * 	- `'autowrite'`  is off or writing is not possible
         * 	- the `'!'`  flag was used
         * 	Also see |windows|.
         * 
         * 	To hide a specific buffer use the `'bufhidden'`  option.
         * 	`'hidden'`  is set for one command with ":hide {command}" |:hide|.
         */
        hidden: boolean

        highlight: string

        /**
         * `'history'`  `'hi'` 		number	(default: 10000)
         * 			global
         * 	A history of ":" commands, and a history of previous search patterns
         * 	is remembered.  This option decides how many entries may be stored in
         * 	each of these histories (see |cmdline-editing|).
         * 	The maximum value is 10000.
         */
        history: number

        hkmap: boolean

        hkmapp: boolean

        /**
         * `'hlsearch'`  `'hls'` 	boolean	(default on)
         * 			global
         * 	When there is a previous search pattern, highlight all its matches.
         * 	The |hl-Search| highlight group determines the highlighting for all
         * 	matches not under the cursor while the |hl-CurSearch| highlight group
         * 	(if defined) determines the highlighting for the match under the
         * 	cursor. If |hl-CurSearch| is not defined, then |hl-Search| is used for
         * 	both. Note that only the matching text is highlighted, any offsets
         * 	are not applied.
         * 	See also: `'incsearch'`  and |:match|.
         * 	When you get bored looking at the highlighted matches, you can turn it
         * 	off with |:nohlsearch|.  This does not change the option value, as
         * 	soon as you use a search command, the highlighting comes back.
         * 	`'redrawtime'`  specifies the maximum time spent on finding matches.
         * 	When the search pattern can match an end-of-line, Vim will try to
         * 	highlight all of the matched text.  However, this depends on where the
         * 	search starts.  This will be the first line in the window or the first
         * 	line below a closed fold.  A match in a previous line which is not
         * 	drawn may not continue in a newly drawn line.
         * 	You can specify whether the highlight status is restored on startup
         * 	with the `'h'`  flag in `'shada'`  |shada-h|.
         */
        hlsearch: boolean

        /**
         * `'icon'` 			boolean	(default off, on when title can be restored)
         * 			global
         * 	When on, the icon text of the window will be set to the value of
         * 	`'iconstring'`  (if it is not empty), or to the name of the file
         * 	currently being edited.  Only the last part of the name is used.
         * 	Overridden by the `'iconstring'`  option.
         * 	Only works if the terminal supports setting window icons.
         */
        icon: boolean

        /**
         * `'iconstring'` 		string	(default "")
         * 			global
         * 	When this option is not empty, it will be used for the icon text of
         * 	the window.  This happens only when the `'icon'`  option is on.
         * 	Only works if the terminal supports setting window icon text
         * 	When this option contains printf-style `'%'`  items, they will be
         * 	expanded according to the rules used for `'statusline'` .  See
         * 	`'titlestring'`  for example settings.
         * 	This option cannot be set in a modeline when `'modelineexpr'`  is off.
         */
        iconstring: string

        /**
         * `'ignorecase'`  `'ic'` 	boolean	(default off)
         * 			global
         * 	Ignore case in search patterns.  Also used when searching in the tags
         * 	file.
         * 	Also see `'smartcase'`  and `'tagcase'` .
         * 	Can be overruled by using "\c" or "\C" in the pattern, see
         * 	|/ignorecase|.
         */
        ignorecase: boolean

        /**
         * `'imcmdline'`  `'imc'` 	boolean (default off)
         * 			global
         * 	When set the Input Method is always on when starting to edit a command
         * 	line, unless entering a search pattern (see `'imsearch'`  for that).
         * 	Setting this option is useful when your input method allows entering
         * 	English characters directly, e.g., when it's used to type accented
         * 	characters with dead keys.
         */
        imcmdline: boolean

        /**
         * `'imdisable'`  `'imd'` 	boolean (default off, on for some systems (SGI))
         * 			global
         * 	When set the Input Method is never used.  This is useful to disable
         * 	the IM when it doesn't work properly.
         * 	Currently this option is on by default for SGI/IRIX machines.  This
         * 	may change in later releases.
         */
        imdisable: boolean

        /**
         * `'inccommand'`  `'icm'` 	string	(default "nosplit")
         * 			global
         * 
         * 	When nonempty, shows the effects of |:substitute|, |:smagic|,
         * 	|:snomagic| and user commands with the |:command-preview| flag as you
         * 	type.
         * 
         * 	Possible values:
         * 		nosplit	Shows the effects of a command incrementally in the
         * 			buffer.
         * 		split	Like "nosplit", but also shows partial off-screen
         * 			results in a preview window.
         * 
         * 	If the preview for built-in commands is too slow (exceeds
         * 	`'redrawtime'` ) then `'inccommand'`  is automatically disabled until
         * 	|Command-line-mode| is done.
         */
        inccommand: string

        /**
         * `'incsearch'`  `'is'` 	boolean	(default on)
         * 			global
         * 	While typing a search command, show where the pattern, as it was typed
         * 	so far, matches.  The matched string is highlighted.  If the pattern
         * 	is invalid or not found, nothing is shown.  The screen will be updated
         * 	often, this is only useful on fast terminals.
         * 	Note that the match will be shown, but the cursor will return to its
         * 	original position when no match is found and when pressing <Esc>.  You
         * 	still need to finish the search command with <Enter> to move the
         * 	cursor to the match.
         * 	You can use the CTRL-G and CTRL-T keys to move to the next and
         * 	previous match. |c_CTRL-G| |c_CTRL-T|
         * 	Vim only searches for about half a second.  With a complicated
         * 	pattern and/or a lot of text the match may not be found.  This is to
         * 	avoid that Vim hangs while you are typing the pattern.
         * 	The |hl-IncSearch| highlight group determines the highlighting.
         * 	When `'hlsearch'`  is on, all matched strings are highlighted too while
         * 	typing a search command. See also: `'hlsearch'` .
         * 	If you don't want to turn `'hlsearch'`  on, but want to highlight all
         * 	matches while searching, you can turn on and off `'hlsearch'`  with
         * 	autocmd.  Example: >
         * 		augroup vimrc-incsearch-highlight
         * 		  autocmd!
         * 		  autocmd CmdlineEnter /,\? :set hlsearch
         * 		  autocmd CmdlineLeave /,\? :set nohlsearch
         * 		augroup END
         * <
         * 	CTRL-L can be used to add one character from after the current match
         * 	to the command line.  If `'ignorecase'`  and `'smartcase'`  are set and the
         * 	command line has no uppercase characters, the added character is
         * 	converted to lowercase.
         * 	CTRL-R CTRL-W can be used to add the word at the end of the current
         * 	match, excluding the characters that were already typed.
         */
        incsearch: boolean

        insertmode: boolean

        /**
         * `'isfname'`  `'isf'` 		string	(default for Windows:
         * 			     "@,48-57,/,\,.,-,_,+,,,#,$,%,{,},[,],:,@-@,!,~,="
         * 			    otherwise: "@,48-57,/,.,-,_,+,,,#,$,%,~,=")
         * 			global
         * 	The characters specified by this option are included in file names and
         * 	path names.  Filenames are used for commands like "gf", "[i" and in
         * 	the tags file.  It is also used for "\f" in a |pattern|.
         * 	Multi-byte characters 256 and above are always included, only the
         * 	characters up to 255 are specified with this option.
         * 	For UTF-8 the characters 0xa0 to 0xff are included as well.
         * 	Think twice before adding white space to this option.  Although a
         * 	space may appear inside a file name, the effect will be that Vim
         * 	doesn't know where a file name starts or ends when doing completion.
         * 	It most likely works better without a space in `'isfname'` .
         * 
         * 	Note that on systems using a backslash as path separator, Vim tries to
         * 	do its best to make it work as you would expect.  That is a bit
         * 	tricky, since Vi originally used the backslash to escape special
         * 	characters.  Vim will not remove a backslash in front of a normal file
         * 	name character on these systems, but it will on Unix and alikes.  The
         * 	`'&'`  and `'^'`  are not included by default, because these are special for
         * 	cmd.exe.
         * 
         * 	The format of this option is a list of parts, separated with commas.
         * 	Each part can be a single character number or a range.  A range is two
         * 	character numbers with `'-'`  in between.  A character number can be a
         * 	decimal number between 0 and 255 or the ASCII character itself (does
         * 	not work for digits).  Example:
         * 		"_,-,128-140,#-43"	(include `'_'`  and `'-'`  and the range
         * 					128 to 140 and `'#'`  to 43)
         * 	If a part starts with `'^'` , the following character number or range
         * 	will be excluded from the option.  The option is interpreted from left
         * 	to right.  Put the excluded character after the range where it is
         * 	included.  To include `'^'`  itself use it as the last character of the
         * 	option or the end of a range.  Example:
         * 		"^a-z,#,^"	(exclude `'a'`  to `'z'` , include `'#'`  and `'^'` )
         * 	If the character is `'@'` , all characters where isalpha() returns TRUE
         * 	are included.  Normally these are the characters a to z and A to Z,
         * 	plus accented characters.  To include `'@'`  itself use "@-@".  Examples:
         * 		"@,^a-z"	All alphabetic characters, excluding lower
         * 				case ASCII letters.
         * 		"a-z,A-Z,@-@"	All letters plus the `'@'`  character.
         * 	A comma can be included by using it where a character number is
         * 	expected.  Example:
         * 		"48-57,,,_"	Digits, comma and underscore.
         * 	A comma can be excluded by prepending a `'^'` .  Example:
         * 		" -~,^,,9"	All characters from space to `'~'` , excluding
         * 				comma, plus <Tab>.
         * 	See |option-backslash| about including spaces and backslashes.
         */
        isfname: string

        /**
         * `'isident'`  `'isi'` 		string	(default for Windows:
         * 					   "@,48-57,_,128-167,224-235"
         * 				otherwise: "@,48-57,_,192-255")
         * 			global
         * 	The characters given by this option are included in identifiers.
         * 	Identifiers are used in recognizing environment variables and after a
         * 	match of the `'define'`  option.  It is also used for "\i" in a
         * 	|pattern|.  See `'isfname'`  for a description of the format of this
         * 	option.  For `'@'`  only characters up to 255 are used.
         * 	Careful: If you change this option, it might break expanding
         * 	environment variables.  E.g., when `'/'`  is included and Vim tries to
         * 	expand "$HOME/.local/state/nvim/shada/main.shada".  Maybe you should
         * 	change `'iskeyword'`  instead.
         */
        isident: string

        /**
         * `'isprint'`  `'isp'` 	string	(default: "@,161-255")
         * 			global
         * 	The characters given by this option are displayed directly on the
         * 	screen.  It is also used for "\p" in a |pattern|.  The characters from
         * 	space (ASCII 32) to `'~'`  (ASCII 126) are always displayed directly,
         * 	even when they are not included in `'isprint'`  or excluded.  See
         * 	`'isfname'`  for a description of the format of this option.
         * 
         * 	Non-printable characters are displayed with two characters:
         * 		  0 -  31	"^@" - "^_"
         * 		 32 - 126	always single characters
         * 		   127		"^?"
         * 		128 - 159	"~@" - "~_"
         * 		160 - 254	"| " - "|~"
         * 		   255		"~?"
         * 	Illegal bytes from 128 to 255 (invalid UTF-8) are
         * 	displayed as <xx>, with the hexadecimal value of the byte.
         * 	When `'display'`  contains "uhex" all unprintable characters are
         * 	displayed as <xx>.
         * 	The SpecialKey highlighting will be used for unprintable characters.
         * 	|hl-SpecialKey|
         * 
         * 	Multi-byte characters 256 and above are always included, only the
         * 	characters up to 255 are specified with this option.  When a character
         * 	is printable but it is not available in the current font, a
         * 	replacement character will be shown.
         * 	Unprintable and zero-width Unicode characters are displayed as <xxxx>.
         * 	There is no option to specify these characters.
         */
        isprint: string

        /**
         * `'joinspaces'`  `'js'` 	boolean	(default off)
         * 			global
         * 	Insert two spaces after a `'.'` , `'?'`  and `'!'`  with a join command.
         * 	Otherwise only one space is inserted.
         */
        joinspaces: boolean

        /**
         * `'jumpoptions'`  `'jop'` 	string	(default "")
         * 			global
         * 	List of words that change the behavior of the |jumplist|.
         * 	  stack         Make the jumplist behave like the tagstack or like a
         * 	                web browser.  Relative location of entries in the
         * 			jumplist is preserved at the cost of discarding
         * 			subsequent entries when navigating backwards in the
         * 			jumplist and then jumping to a location.
         * 			|jumplist-stack|
         * 
         * 	  view          When moving through the jumplist, |changelist|,
         * 			|alternate-file| or using |mark-motions| try to
         * 			restore the |mark-view| in which the action occurred.
         */
        jumpoptions: string

        /**
         * `'keymodel'`  `'km'` 		string	(default "")
         * 			global
         * 	List of comma-separated words, which enable special things that keys
         * 	can do.  These values can be used:
         * 	   startsel	Using a shifted special key starts selection (either
         * 			Select mode or Visual mode, depending on "key" being
         * 			present in `'selectmode'` ).
         * 	   stopsel	Using a not-shifted special key stops selection.
         * 	Special keys in this context are the cursor keys, <End>, <Home>,
         * 	<PageUp> and <PageDown>.
         * 	The `'keymodel'`  option is set by the |:behave| command.
         */
        keymodel: string

        /**
         * `'langmap'`  `'lmap'` 	string	(default "")
         * 			global
         * 	This option allows switching your keyboard into a special language
         * 	mode.  When you are typing text in Insert mode the characters are
         * 	inserted directly.  When in Normal mode the `'langmap'`  option takes
         * 	care of translating these special characters to the original meaning
         * 	of the key.  This means you don't have to change the keyboard mode to
         * 	be able to execute Normal mode commands.
         * 	This is the opposite of the `'keymap'`  option, where characters are
         * 	mapped in Insert mode.
         * 	Also consider setting `'langremap'`  to off, to prevent `'langmap'`  from
         * 	applying to characters resulting from a mapping.
         * 	This option cannot be set from a |modeline| or in the |sandbox|, for
         * 	security reasons.
         * 
         * 	Example (for Greek, in UTF-8):				  >
         * 	    :set langmap=ΑA,ΒB,ΨC,ΔD,ΕE,ΦF,ΓG,ΗH,ΙI,ΞJ,ΚK,ΛL,ΜM,ΝN,ΟO,ΠP,QQ,ΡR,ΣS,ΤT,ΘU,ΩV,WW,ΧX,ΥY,ΖZ,αa,βb,ψc,δd,εe,φf,γg,ηh,ιi,ξj,κk,λl,μm,νn,οo,πp,qq,ρr,σs,τt,θu,ωv,ςw,χx,υy,ζz
         * <	Example (exchanges meaning of z and y for commands): >
         * 	    :set langmap=zy,yz,ZY,YZ
         * <
         * 	The `'langmap'`  option is a list of parts, separated with commas.  Each
         * 	part can be in one of two forms:
         * 	1.  A list of pairs.  Each pair is a "from" character immediately
         * 	    followed by the "to" character.  Examples: "aA", "aAbBcC".
         * 	2.  A list of "from" characters, a semi-colon and a list of "to"
         * 	    characters.  Example: "abc;ABC"
         * 	Example: "aA,fgh;FGH,cCdDeE"
         * 	Special characters need to be preceded with a backslash.  These are
         * 	";", `','` , `'"'` , `'|'`  and backslash itself.
         * 
         * 	This will allow you to activate vim actions without having to switch
         * 	back and forth between the languages.  Your language characters will
         * 	be understood as normal vim English characters (according to the
         * 	langmap mappings) in the following cases:
         * 	 o Normal/Visual mode (commands, buffer/register names, user mappings)
         * 	 o Insert/Replace Mode: Register names after CTRL-R
         * 	 o Insert/Replace Mode: Mappings
         * 	Characters entered in Command-line mode will NOT be affected by
         * 	this option.   Note that this option can be changed at any time
         * 	allowing to switch between mappings for different languages/encodings.
         * 	Use a mapping to avoid having to type it each time!
         */
        langmap: string

        /**
         * `'langmenu'`  `'lm'` 		string	(default "")
         * 			global
         * 	Language to use for menu translation.  Tells which file is loaded
         * 	from the "lang" directory in `'runtimepath'` : >
         * 		"lang/menu_" .. &langmenu .. ".vim"
         * <	(without the spaces).  For example, to always use the Dutch menus, no
         * 	matter what $LANG is set to: >
         * 		:set langmenu=nl_NL.ISO_8859-1
         * <	When `'langmenu'`  is empty, |v:lang| is used.
         * 	Only normal file name characters can be used, "/\*?[|<>" are illegal.
         * 	If your $LANG is set to a non-English language but you do want to use
         * 	the English menus: >
         * 		:set langmenu=none
         * <	This option must be set before loading menus, switching on filetype
         * 	detection or syntax highlighting.  Once the menus are defined setting
         * 	this option has no effect.  But you could do this: >
         * 		:source $VIMRUNTIME/delmenu.vim
         * 		:set langmenu=de_DE.ISO_8859-1
         * 		:source $VIMRUNTIME/menu.vim
         * <	Warning: This deletes all menus that you defined yourself!
         */
        langmenu: string

        langnoremap: boolean

        /**
         * `'langremap'`  `'lrm'` 	boolean (default off)
         * 			global
         * 	When off, setting `'langmap'`  does not apply to characters resulting from
         * 	a mapping.  If setting `'langmap'`  disables some of your mappings, make
         * 	sure this option is off.
         */
        langremap: boolean

        /**
         * `'laststatus'`  `'ls'` 	number	(default 2)
         * 			global
         * 	The value of this option influences when the last window will have a
         * 	status line:
         * 		0: never
         * 		1: only if there are at least two windows
         * 		2: always
         * 		3: always and ONLY the last window
         * 	The screen looks nicer with a status line if you have several
         * 	windows, but it takes another screen line. |status-line|
         */
        laststatus: number

        /**
         * `'lazyredraw'`  `'lz'` 	boolean	(default off)
         * 			global
         * 	When this option is set, the screen will not be redrawn while
         * 	executing macros, registers and other commands that have not been
         * 	typed.  Also, updating the window title is postponed.  To force an
         * 	update use |:redraw|.
         * 	This may occasionally cause display errors.  It is only meant to be set
         * 	temporarily when performing an operation where redrawing may cause
         * 	flickering or cause a slow down.
         */
        lazyredraw: boolean

        /**
         * `'lines'` 			number	(default 24 or terminal height)
         * 			global
         * 	Number of lines of the Vim window.
         * 	Normally you don't need to set this.  It is done automatically by the
         * 	terminal initialization code.
         * 	When Vim is running in the GUI or in a resizable window, setting this
         * 	option will cause the window size to be changed.  When you only want
         * 	to use the size for the GUI, put the command in your |gvimrc| file.
         * 	Vim limits the number of lines to what fits on the screen.  You can
         * 	use this command to get the tallest window possible: >
         * 		:set lines=999
         * <	Minimum value is 2, maximum value is 1000.
         */
        lines: number

        /**
         * `'linespace'`  `'lsp'` 	number	(default 0)
         * 			global
         * 			{only in the GUI}
         * 	Number of pixel lines inserted between characters.  Useful if the font
         * 	uses the full character cell height, making lines touch each other.
         * 	When non-zero there is room for underlining.
         * 	With some fonts there can be too much room between lines (to have
         * 	space for ascents and descents).  Then it makes sense to set
         * 	`'linespace'`  to a negative value.  This may cause display problems
         * 	though!
         */
        linespace: number

        /**
         * `'loadplugins'`  `'lpl'` 	boolean	(default on)
         * 			global
         * 	When on the plugin scripts are loaded when starting up |load-plugins|.
         * 	This option can be reset in your |vimrc| file to disable the loading
         * 	of plugins.
         * 	Note that using the "-u NONE" and "--noplugin" command line arguments
         * 	reset this option. |-u| |--noplugin|
         */
        loadplugins: boolean

        /**
         * `'magic'` 			boolean	(default on)
         * 			global
         * 	Changes the special characters that can be used in search patterns.
         * 	See |pattern|.
         * 	WARNING: Switching this option off most likely breaks plugins!  That
         * 	is because many patterns assume it's on and will fail when it's off.
         * 	Only switch it off when working with old Vi scripts.  In any other
         * 	situation write patterns that work when `'magic'`  is on.  Include "\M"
         * 	when you want to |/\M|.
         */
        magic: boolean

        /**
         * `'makeef'`  `'mef'` 		string	(default: "")
         * 			global
         * 	Name of the errorfile for the |:make| command (see |:make_makeprg|)
         * 	and the |:grep| command.
         * 	When it is empty, an internally generated temp file will be used.
         * 	When "##" is included, it is replaced by a number to make the name
         * 	unique.  This makes sure that the ":make" command doesn't overwrite an
         * 	existing file.
         * 	NOT used for the ":cf" command.  See `'errorfile'`  for that.
         * 	Environment variables are expanded |:set_env|.
         * 	See |option-backslash| about including spaces and backslashes.
         * 	This option cannot be set from a |modeline| or in the |sandbox|, for
         * 	security reasons.
         */
        makeef: string

        /**
         * `'matchtime'`  `'mat'` 	number	(default 5)
         * 			global
         * 	Tenths of a second to show the matching paren, when `'showmatch'`  is
         * 	set.  Note that this is not in milliseconds, like other options that
         * 	set a time.  This is to be compatible with Nvi.
         */
        matchtime: number

        maxcombine: number

        /**
         * `'maxfuncdepth'`  `'mfd'` 	number	(default 100)
         * 			global
         * 	Maximum depth of function calls for user functions.  This normally
         * 	catches endless recursion.  When using a recursive function with
         * 	more depth, set `'maxfuncdepth'`  to a bigger number.  But this will use
         * 	more memory, there is the danger of failing when memory is exhausted.
         * 	Increasing this limit above 200 also changes the maximum for Ex
         * 	command recursion, see |E169|.
         * 	See also |:function|.
         */
        maxfuncdepth: number

        /**
         * `'maxmapdepth'`  `'mmd'` 	number	(default 1000)
         * 			global
         * 	Maximum number of times a mapping is done without resulting in a
         * 	character to be used.  This normally catches endless mappings, like
         * 	":map x y" with ":map y x".  It still does not catch ":map g wg",
         * 	because the `'w'`  is used before the next mapping is done.  See also
         * 	|key-mapping|.
         */
        maxmapdepth: number

        /**
         * `'maxmempattern'`  `'mmp'` 	number	(default 1000)
         * 			global
         * 	Maximum amount of memory (in Kbyte) to use for pattern matching.
         * 	The maximum value is about 2000000.  Use this to work without a limit.
         * 
         * 	When Vim runs into the limit it gives an error message and mostly
         * 	behaves like CTRL-C was typed.
         * 	Running into the limit often means that the pattern is very
         * 	inefficient or too complex.  This may already happen with the pattern
         * 	"\(.\)*" on a very long line.  ".*" works much better.
         * 	Might also happen on redraw, when syntax rules try to match a complex
         * 	text structure.
         * 	Vim may run out of memory before hitting the `'maxmempattern'`  limit, in
         * 	which case you get an "Out of memory" error instead.
         */
        maxmempattern: number

        /**
         * `'menuitems'`  `'mis'` 	number	(default 25)
         * 			global
         * 	Maximum number of items to use in a menu.  Used for menus that are
         * 	generated from a list of items, e.g., the Buffers menu.  Changing this
         * 	option has no direct effect, the menu must be refreshed first.
         */
        menuitems: number

        /**
         * `'mkspellmem'`  `'msm'` 	string	(default "460000,2000,500")
         * 			global
         * 	Parameters for |:mkspell|.  This tunes when to start compressing the
         * 	word tree.  Compression can be slow when there are many words, but
         * 	it's needed to avoid running out of memory.  The amount of memory used
         * 	per word depends very much on how similar the words are, that's why
         * 	this tuning is complicated.
         * 
         * 	There are three numbers, separated by commas:
         * 		{start},{inc},{added}
         * 
         * 	For most languages the uncompressed word tree fits in memory.  {start}
         * 	gives the amount of memory in Kbyte that can be used before any
         * 	compression is done.  It should be a bit smaller than the amount of
         * 	memory that is available to Vim.
         * 
         * 	When going over the {start} limit the {inc} number specifies the
         * 	amount of memory in Kbyte that can be allocated before another
         * 	compression is done.  A low number means compression is done after
         * 	less words are added, which is slow.  A high number means more memory
         * 	will be allocated.
         * 
         * 	After doing compression, {added} times 1024 words can be added before
         * 	the {inc} limit is ignored and compression is done when any extra
         * 	amount of memory is needed.  A low number means there is a smaller
         * 	chance of hitting the {inc} limit, less memory is used but it's
         * 	slower.
         * 
         * 	The languages for which these numbers are important are Italian and
         * 	Hungarian.  The default works for when you have about 512 Mbyte.  If
         * 	you have 1 Gbyte you could use: >
         * 		:set mkspellmem=900000,3000,800
         * <	If you have less than 512 Mbyte |:mkspell| may fail for some
         * 	languages, no matter what you set `'mkspellmem'`  to.
         * 
         * 	This option cannot be set from a |modeline| or in the |sandbox|.
         */
        mkspellmem: string

        /**
         * `'modelineexpr'`  `'mle'` 	boolean (default: off)
         * 			global
         * 	When on allow some options that are an expression to be set in the
         * 	modeline.  Check the option for whether it is affected by
         * 	`'modelineexpr'` .  Also see |modeline|.
         * 	This option cannot be set from a |modeline| or in the |sandbox|, for
         * 	security reasons.
         */
        modelineexpr: boolean

        /**
         * `'modelines'`  `'mls'` 	number	(default 5)
         * 			global
         * 	If `'modeline'`  is on `'modelines'`  gives the number of lines that is
         * 	checked for set commands.  If `'modeline'`  is off or `'modelines'`  is zero
         * 	no lines are checked.  See |modeline|.
         */
        modelines: number

        /**
         * `'more'` 			boolean	(default: on)
         * 			global
         * 	When on, listings pause when the whole screen is filled.  You will get
         * 	the |more-prompt|.  When this option is off there are no pauses, the
         * 	listing continues until finished.
         */
        more: boolean

        /**
         * `'mouse'` 			string	(default "nvi")
         * 			global
         * 
         * 	Enables mouse support. For example, to enable the mouse in Normal mode
         * 	and Visual mode: >
         * 		:set mouse=nv
         * <
         * 	To temporarily disable mouse support, hold the shift key while using
         * 	the mouse.
         * 
         * 	Mouse support can be enabled for different modes:
         * 		n	Normal mode
         * 		v	Visual mode
         * 		i	Insert mode
         * 		c	Command-line mode
         * 		h	all previous modes when editing a help file
         * 		a	all previous modes
         * 		r	for |hit-enter| and |more-prompt| prompt
         * 
         * 	Left-click anywhere in a text buffer to place the cursor there.  This
         * 	works with operators too, e.g. type |d| then left-click to delete text
         * 	from the current cursor position to the position where you clicked.
         * 
         * 	Drag the |status-line| or vertical separator of a window to resize it.
         * 
         * 	If enabled for "v" (Visual mode) then double-click selects word-wise,
         * 	triple-click makes it line-wise, and quadruple-click makes it
         * 	rectangular block-wise.
         * 
         * 	For scrolling with a mouse wheel see |scroll-mouse-wheel|.
         * 
         * 	Note: When enabling the mouse in a terminal, copy/paste will use the
         * 	"* register if possible. See also `'clipboard'` .
         * 
         * 	Related options:
         * 	`'mousefocus'` 	window focus follows mouse pointer
         * 	`'mousemodel'` 	what mouse button does which action
         * 	`'mousehide'` 	hide mouse pointer while typing text
         * 	`'selectmode'` 	whether to start Select mode or Visual mode
         * 
         * 	The :behave command provides some "profiles" for mouse behavior.
         * 
         * 	:be[have] {model}	Set behavior for mouse and selection.  Valid
         * 				arguments are:
         * 				   mswin	MS-Windows behavior
         * 				   xterm	Xterm behavior
         * 
         * 				Using ":behave" changes these options:
         * 				option		mswin			xterm	~
         * 				`'selectmode'` 	"mouse,key"		""
         * 				`'mousemodel'` 	"popup"			"extend"
         * 				`'keymodel'` 	"startsel,stopsel"	""
         * 				`'selection'` 	"exclusive"		"inclusive"
         */
        mouse: string

        /**
         * `'mousefocus'`  `'mousef'` 	boolean	(default off)
         * 			global
         * 	The window that the mouse pointer is on is automatically activated.
         * 	When changing the window layout or window focus in another way, the
         * 	mouse pointer is moved to the window with keyboard focus.  Off is the
         * 	default because it makes using the pull down menus a little goofy, as
         * 	a pointer transit may activate a window unintentionally.
         */
        mousefocus: boolean

        /**
         * `'mousehide'`  `'mh'` 	boolean	(default on)
         * 			global
         * 			{only works in the GUI}
         * 	When on, the mouse pointer is hidden when characters are typed.
         * 	The mouse pointer is restored when the mouse is moved.
         */
        mousehide: boolean

        /**
         * `'mousemodel'`  `'mousem'` 	string	(default "popup_setpos")
         * 			global
         * 	Sets the model to use for the mouse.  The name mostly specifies what
         * 	the right mouse button is used for:
         * 	   extend	Right mouse button extends a selection.  This works
         * 			like in an xterm.
         * 	   popup	Right mouse button pops up a menu.  The shifted left
         * 			mouse button extends a selection.  This works like
         * 			with Microsoft Windows.
         * 	   popup_setpos Like "popup", but the cursor will be moved to the
         * 			position where the mouse was clicked, and thus the
         * 			selected operation will act upon the clicked object.
         * 			If clicking inside a selection, that selection will
         * 			be acted upon, i.e. no cursor move.  This implies of
         * 			course, that right clicking outside a selection will
         * 			end Visual mode.
         * 	Overview of what button does what for each model:
         * 	mouse		    extend		popup(_setpos) ~
         * 	left click	    place cursor	place cursor
         * 	left drag	    start selection	start selection
         * 	shift-left	    search word		extend selection
         * 	right click	    extend selection	popup menu (place cursor)
         * 	right drag	    extend selection	-
         * 	middle click	    paste		paste
         * 
         * 	In the "popup" model the right mouse button produces a pop-up menu.
         * 	Nvim creates a default |popup-menu| but you can redefine it.
         * 
         * 	Note that you can further refine the meaning of buttons with mappings.
         * 	See |mouse-overview|.  But mappings are NOT used for modeless selection.
         * 
         * 	Example: >
         * 	   :map <S-LeftMouse>     <RightMouse>
         * 	   :map <S-LeftDrag>      <RightDrag>
         * 	   :map <S-LeftRelease>   <RightRelease>
         * 	   :map <2-S-LeftMouse>   <2-RightMouse>
         * 	   :map <2-S-LeftDrag>    <2-RightDrag>
         * 	   :map <2-S-LeftRelease> <2-RightRelease>
         * 	   :map <3-S-LeftMouse>   <3-RightMouse>
         * 	   :map <3-S-LeftDrag>    <3-RightDrag>
         * 	   :map <3-S-LeftRelease> <3-RightRelease>
         * 	   :map <4-S-LeftMouse>   <4-RightMouse>
         * 	   :map <4-S-LeftDrag>    <4-RightDrag>
         * 	   :map <4-S-LeftRelease> <4-RightRelease>
         * <
         * 	Mouse commands requiring the CTRL modifier can be simulated by typing
         * 	the "g" key before using the mouse:
         * 	    "g<LeftMouse>"  is "<C-LeftMouse>	(jump to tag under mouse click)
         * 	    "g<RightMouse>" is "<C-RightMouse>	("CTRL-T")
         * 
         * 	The `'mousemodel'`  option is set by the |:behave| command.
         */
        mousemodel: string

        /**
         * `'mousemoveevent'`  `'mousemev'`   boolean	(default off)
         * 			global
         * 	When on, mouse move events are delivered to the input queue and are
         * 	available for mapping. The default, off, avoids the mouse movement
         * 	overhead except when needed.
         * 	Warning: Setting this option can make pending mappings to be aborted
         * 	when the mouse is moved.
         */
        mousemoveevent: boolean

        /**
         * `'mousescroll'` 		string	(default "ver:3,hor:6")
         * 			global
         * 	This option controls the number of lines / columns to scroll by when
         * 	scrolling with a mouse. The option is a comma separated list of parts.
         * 	Each part consists of a direction and a count as follows:
         * 		direction:count,direction:count
         * 	Direction is one of either "hor" or "ver". "hor" controls horizontal
         * 	scrolling and "ver" controls vertical scrolling. Count sets the amount
         * 	to scroll by for the given direction, it should be a non negative
         * 	integer. Each direction should be set at most once. If a direction
         * 	is omitted, a default value is used (6 for horizontal scrolling and 3
         * 	for vertical scrolling). You can disable mouse scrolling by using
         * 	a count of 0.
         * 
         * 	Example: >
         * 		:set mousescroll=ver:5,hor:2
         * <	Will make Nvim scroll 5 lines at a time when scrolling vertically, and
         * 	scroll 2 columns at a time when scrolling horizontally.
         */
        mousescroll: string

        /**
         * `'mouseshape'`  `'mouses'` 	string	(default "i:beam,r:beam,s:updown,sd:cross,
         * 					m:no,ml:up-arrow,v:rightup-arrow")
         * 			global
         * 	This option tells Vim what the mouse pointer should look like in
         * 	different modes.  The option is a comma-separated list of parts, much
         * 	like used for `'guicursor'` .  Each part consist of a mode/location-list
         * 	and an argument-list:
         * 		mode-list:shape,mode-list:shape,..
         * 	The mode-list is a dash separated list of these modes/locations:
         * 			In a normal window: ~
         * 		n	Normal mode
         * 		v	Visual mode
         * 		ve	Visual mode with `'selection'`  "exclusive" (same as `'v'` ,
         * 			if not specified)
         * 		o	Operator-pending mode
         * 		i	Insert mode
         * 		r	Replace mode
         * 
         * 			Others: ~
         * 		c	appending to the command-line
         * 		ci	inserting in the command-line
         * 		cr	replacing in the command-line
         * 		m	at the 'Hit ENTER' or `'More'`  prompts
         * 		ml	idem, but cursor in the last line
         * 		e	any mode, pointer below last window
         * 		s	any mode, pointer on a status line
         * 		sd	any mode, while dragging a status line
         * 		vs	any mode, pointer on a vertical separator line
         * 		vd	any mode, while dragging a vertical separator line
         * 		a	everywhere
         * 
         * 	The shape is one of the following:
         * 	avail	name		looks like ~
         * 	w x	arrow		Normal mouse pointer
         * 	w x	blank		no pointer at all (use with care!)
         * 	w x	beam		I-beam
         * 	w x	updown		up-down sizing arrows
         * 	w x	leftright	left-right sizing arrows
         * 	w x	busy		The system's usual busy pointer
         * 	w x	no		The system's usual "no input" pointer
         * 	  x	udsizing	indicates up-down resizing
         * 	  x	lrsizing	indicates left-right resizing
         * 	  x	crosshair	like a big thin +
         * 	  x	hand1		black hand
         * 	  x	hand2		white hand
         * 	  x	pencil		what you write with
         * 	  x	question	big ?
         * 	  x	rightup-arrow	arrow pointing right-up
         * 	w x	up-arrow	arrow pointing up
         * 	  x	<number>	any X11 pointer number (see X11/cursorfont.h)
         * 
         * 	The "avail" column contains a `'w'`  if the shape is available for Win32,
         * 	x for X11.
         * 	Any modes not specified or shapes not available use the normal mouse
         * 	pointer.
         * 
         * 	Example: >
         * 		:set mouseshape=s:udsizing,m:no
         * <	will make the mouse turn to a sizing arrow over the status lines and
         * 	indicate no input when the hit-enter prompt is displayed (since
         * 	clicking the mouse has no effect in this state.)
         */
        mouseshape: string

        /**
         * `'mousetime'`  `'mouset'` 	number	(default 500)
         * 			global
         * 	Defines the maximum time in msec between two mouse clicks for the
         * 	second click to be recognized as a multi click.
         */
        mousetime: number

        /**
         * `'opendevice'`  `'odev'` 	boolean	(default off)
         * 			global
         * 			{only for Windows}
         * 	Enable reading and writing from devices.  This may get Vim stuck on a
         * 	device that can be opened but doesn't actually do the I/O.  Therefore
         * 	it is off by default.
         * 	Note that on Windows editing "aux.h", "lpt1.txt" and the like also
         * 	result in editing a device.
         */
        opendevice: boolean

        /**
         * `'operatorfunc'`  `'opfunc'` 	string	(default: empty)
         * 			global
         * 	This option specifies a function to be called by the |g@| operator.
         * 	See |:map-operator| for more info and an example.  The value can be
         * 	the name of a function, a |lambda| or a |Funcref|. See
         * 	|option-value-function| for more information.
         * 
         * 	This option cannot be set from a |modeline| or in the |sandbox|, for
         * 	security reasons.
         */
        operatorfunc: string

        /**
         * `'packpath'`  `'pp'` 		string	(default: see `'runtimepath'` )
         * 	Directories used to find packages.  See |packages| and |rtp-packages|.
         */
        packpath: string

        /**
         * `'paragraphs'`  `'para'` 	string	(default "IPLPPPQPP TPHPLIPpLpItpplpipbp")
         * 			global
         * 	Specifies the nroff macros that separate paragraphs.  These are pairs
         * 	of two letters (see |object-motions|).
         */
        paragraphs: string

        paste: boolean

        pastetoggle: string

        /**
         * `'patchexpr'`  `'pex'` 	string	(default "")
         * 			global
         * 	Expression which is evaluated to apply a patch to a file and generate
         * 	the resulting new version of the file.  See |diff-patchexpr|.
         */
        patchexpr: string

        /**
         * `'patchmode'`  `'pm'` 	string	(default "")
         * 			global
         * 	When non-empty the oldest version of a file is kept.  This can be used
         * 	to keep the original version of a file if you are changing files in a
         * 	source distribution.  Only the first time that a file is written a
         * 	copy of the original file will be kept.  The name of the copy is the
         * 	name of the original file with the string in the `'patchmode'`  option
         * 	appended.  This option should start with a dot.  Use a string like
         * 	".orig" or ".org".  `'backupdir'`  must not be empty for this to work
         * 	(Detail: The backup file is renamed to the patchmode file after the
         * 	new file has been successfully written, that's why it must be possible
         * 	to write a backup file).  If there was no file to be backed up, an
         * 	empty file is created.
         * 	When the `'backupskip'`  pattern matches, a patchmode file is not made.
         * 	Using `'patchmode'`  for compressed files appends the extension at the
         * 	end (e.g., "file.gz.orig"), thus the resulting name isn't always
         * 	recognized as a compressed file.
         * 	Only normal file name characters can be used, "/\*?[|<>" are illegal.
         */
        patchmode: string

        /**
         * `'previewheight'`  `'pvh'` 	number (default 12)
         * 			global
         * 	Default height for a preview window.  Used for |:ptag| and associated
         * 	commands.  Used for |CTRL-W_}| when no count is given.
         */
        previewheight: number

        prompt: boolean

        /**
         * `'pumblend'`  `'pb'` 		number	(default 0)
         * 			global
         * 	Enables pseudo-transparency for the |popup-menu|. Valid values are in
         * 	the range of 0 for fully opaque popupmenu (disabled) to 100 for fully
         * 	transparent background. Values between 0-30 are typically most useful.
         * 
         * 	It is possible to override the level for individual highlights within
         * 	the popupmenu using |highlight-blend|. For instance, to enable
         * 	transparency but force the current selected element to be fully opaque: >
         * 
         * 		:set pumblend=15
         * 		:hi PmenuSel blend=0
         * <
         * 	UI-dependent. Works best with RGB colors. `'termguicolors'` 
         */
        pumblend: number

        /**
         * `'pumheight'`  `'ph'` 	number	(default 0)
         * 			global
         * 	Maximum number of items to show in the popup menu
         * 	(|ins-completion-menu|). Zero means "use available screen space".
         */
        pumheight: number

        /**
         * `'pumwidth'`  `'pw'` 		number	(default 15)
         * 			global
         * 	Minimum width for the popup menu (|ins-completion-menu|).  If the
         * 	cursor column + `'pumwidth'`  exceeds screen width, the popup menu is
         * 	nudged to fit on the screen.
         */
        pumwidth: number

        /**
         * `'pyxversion'`  `'pyx'` 	number	(default 3)
         * 			global
         * 	Specifies the python version used for pyx* functions and commands
         * 	|python_x|.  As only Python 3 is supported, this always has the value
         * 	`3`. Setting any other value is an error.
         * 
         * 	This option cannot be set from a |modeline| or in the |sandbox|, for
         * 	security reasons.
         */
        pyxversion: number

        /**
         * `'quickfixtextfunc'`  `'qftf'` 	string (default "")
         * 			global
         * 	This option specifies a function to be used to get the text to display
         * 	in the quickfix and location list windows.  This can be used to
         * 	customize the information displayed in the quickfix or location window
         * 	for each entry in the corresponding quickfix or location list.  See
         * 	|quickfix-window-function| for an explanation of how to write the
         * 	function and an example.  The value can be the name of a function, a
         * 	|lambda| or a |Funcref|. See |option-value-function| for more
         * 	information.
         * 
         * 	This option cannot be set from a |modeline| or in the |sandbox|, for
         * 	security reasons.
         */
        quickfixtextfunc: string

        /**
         * `'redrawdebug'`  `'rdb'` 	string	(default `''` )
         * 			global
         * 	Flags to change the way redrawing works, for debugging purposes.
         * 	Most useful with `'writedelay'`  set to some reasonable value.
         * 	Supports the following flags:
         * 	    compositor	Indicate each redraw event handled by the compositor
         * 			by briefly flashing the redrawn regions in colors
         * 			indicating the redraw type. These are the highlight
         * 			groups used (and their default colors):
         * 		RedrawDebugNormal   gui=reverse   normal redraw passed through
         * 		RedrawDebugClear    guibg=Yellow  clear event passed through
         * 		RedrawDebugComposed guibg=Green   redraw event modified by the
         * 						  compositor (due to
         * 						  overlapping grids, etc)
         * 		RedrawDebugRecompose guibg=Red    redraw generated by the
         * 						  compositor itself, due to a
         * 						  grid being moved or deleted.
         * 	    line	introduce a delay after each line drawn on the screen.
         * 			When using the TUI or another single-grid UI, "compositor"
         * 			gives more information and should be preferred (every
         * 			line is processed as a separate event by the compositor)
         * 	    flush	introduce a delay after each "flush" event.
         * 	    nothrottle	Turn off throttling of the message grid. This is an
         * 			optimization that joins many small scrolls to one
         * 			larger scroll when drawing the message area (with
         * 			`'display'`  msgsep flag active).
         * 	    invalid	Enable stricter checking (abort) of inconsistencies
         * 			of the internal screen state. This is mostly
         * 			useful when running nvim inside a debugger (and
         * 			the test suite).
         * 	    nodelta	Send all internally redrawn cells to the UI, even if
         * 			they are unchanged from the already displayed state.
         */
        redrawdebug: string

        /**
         * `'redrawtime'`  `'rdt'` 	number	(default 2000)
         * 			global
         * 	Time in milliseconds for redrawing the display.  Applies to
         * 	`'hlsearch'` , `'inccommand'` , |:match| highlighting and syntax
         * 	highlighting.
         * 	When redrawing takes more than this many milliseconds no further
         * 	matches will be highlighted.
         * 	For syntax highlighting the time applies per window.  When over the
         * 	limit syntax highlighting is disabled until |CTRL-L| is used.
         * 	This is used to avoid that Vim hangs when using a very complicated
         * 	pattern.
         */
        redrawtime: number

        /**
         * `'regexpengine'`  `'re'` 	number	(default 0)
         * 			global
         * 	This selects the default regexp engine. |two-engines|
         * 	The possible values are:
         * 		0	automatic selection
         * 		1	old engine
         * 		2	NFA engine
         * 	Note that when using the NFA engine and the pattern contains something
         * 	that is not supported the pattern will not match.  This is only useful
         * 	for debugging the regexp engine.
         * 	Using automatic selection enables Vim to switch the engine, if the
         * 	default engine becomes too costly.  E.g., when the NFA engine uses too
         * 	many states.  This should prevent Vim from hanging on a combination of
         * 	a complex pattern with long text.
         */
        regexpengine: number

        remap: boolean

        /**
         * `'report'` 		number	(default 2)
         * 			global
         * 	Threshold for reporting number of lines changed.  When the number of
         * 	changed lines is more than `'report'`  a message will be given for most
         * 	":" commands.  If you want it always, set `'report'`  to 0.
         * 	For the ":substitute" command the number of substitutions is used
         * 	instead of the number of lines.
         */
        report: number

        /**
         * `'revins'`  `'ri'` 		boolean	(default off)
         * 			global
         * 	Inserting characters in Insert mode will work backwards.  See "typing
         * 	backwards" |ins-reverse|.  This option can be toggled with the CTRL-_
         * 	command in Insert mode, when `'allowrevins'`  is set.
         */
        revins: boolean

        /**
         * `'ruler'`  `'ru'` 		boolean	(default on)
         * 			global
         * 	Show the line and column number of the cursor position, separated by a
         * 	comma.  When there is room, the relative position of the displayed
         * 	text in the file is shown on the far right:
         * 		Top	first line is visible
         * 		Bot	last line is visible
         * 		All	first and last line are visible
         * 		45%	relative position in the file
         * 	If `'rulerformat'`  is set, it will determine the contents of the ruler.
         * 	Each window has its own ruler.  If a window has a status line, the
         * 	ruler is shown there.  If a window doesn't have a status line and
         * 	`'cmdheight'`  is zero, the ruler is not shown.  Otherwise it is shown in
         * 	the last line of the screen.  If the statusline is given by
         * 	`'statusline'`  (i.e. not empty), this option takes precedence over
         * 	`'ruler'`  and `'rulerformat'` .
         * 	If the number of characters displayed is different from the number of
         * 	bytes in the text (e.g., for a TAB or a multibyte character), both
         * 	the text column (byte number) and the screen column are shown,
         * 	separated with a dash.
         * 	For an empty line "0-1" is shown.
         * 	For an empty buffer the line number will also be zero: "0,0-1".
         * 	If you don't want to see the ruler all the time but want to know where
         * 	you are, use "g CTRL-G" |g_CTRL-G|.
         */
        ruler: boolean

        /**
         * `'rulerformat'`  `'ruf'` 	string	(default empty)
         * 			global
         * 	When this option is not empty, it determines the content of the ruler
         * 	string, as displayed for the `'ruler'`  option.
         * 	The format of this option is like that of `'statusline'` .
         * 	This option cannot be set in a modeline when `'modelineexpr'`  is off.
         * 
         * 	The default ruler width is 17 characters.  To make the ruler 15
         * 	characters wide, put "%15(" at the start and "%)" at the end.
         * 	Example: >
         * 		:set rulerformat=%15(%c%V\ %p%%%)
         * <
         */
        rulerformat: string

        /**
         * `'runtimepath'`  `'rtp'` 	string	(default:     "$XDG_CONFIG_HOME/nvim,
         * 					       $XDG_CONFIG_DIRS[1]/nvim,
         * 					       $XDG_CONFIG_DIRS[2]/nvim,
         * 					       …
         * 					       $XDG_DATA_HOME/nvim[-data]/site,
         * 					       $XDG_DATA_DIRS[1]/nvim/site,
         * 					       $XDG_DATA_DIRS[2]/nvim/site,
         * 					       …
         * 					       $VIMRUNTIME,
         * 					       …
         * 					       $XDG_DATA_DIRS[2]/nvim/site/after,
         * 					       $XDG_DATA_DIRS[1]/nvim/site/after,
         * 					       $XDG_DATA_HOME/nvim[-data]/site/after,
         * 					       …
         * 					       $XDG_CONFIG_DIRS[2]/nvim/after,
         * 					       $XDG_CONFIG_DIRS[1]/nvim/after,
         * 					       $XDG_CONFIG_HOME/nvim/after")
         * 			global
         * 	List of directories to be searched for these runtime files:
         * 	  filetype.lua	filetypes |new-filetype|
         * 	  autoload/	automatically loaded scripts |autoload-functions|
         * 	  colors/	color scheme files |:colorscheme|
         * 	  compiler/	compiler files |:compiler|
         * 	  doc/		documentation |write-local-help|
         * 	  ftplugin/	filetype plugins |write-filetype-plugin|
         * 	  indent/	indent scripts |indent-expression|
         * 	  keymap/	key mapping files |mbyte-keymap|
         * 	  lang/		menu translations |:menutrans|
         * 	  lua/		|Lua| plugins
         * 	  menu.vim	GUI menus |menu.vim|
         * 	  pack/		packages |:packadd|
         * 	  parser/	|treesitter| syntax parsers
         * 	  plugin/	plugin scripts |write-plugin|
         * 	  queries/	|treesitter| queries
         * 	  rplugin/	|remote-plugin| scripts
         * 	  spell/	spell checking files |spell|
         * 	  syntax/	syntax files |mysyntaxfile|
         * 	  tutor/	tutorial files |:Tutor|
         * 
         * 	And any other file searched for with the |:runtime| command.
         * 
         * 	Defaults are setup to search these locations:
         * 	1. Your home directory, for personal preferences.
         * 	   Given by `stdpath("config")`.  |$XDG_CONFIG_HOME|
         * 	2. Directories which must contain configuration files according to
         * 	   |xdg| ($XDG_CONFIG_DIRS, defaults to /etc/xdg).  This also contains
         * 	   preferences from system administrator.
         * 	3. Data home directory, for plugins installed by user.
         * 	   Given by `stdpath("data")/site`.  |$XDG_DATA_HOME|
         * 	4. nvim/site subdirectories for each directory in $XDG_DATA_DIRS.
         * 	   This is for plugins which were installed by system administrator,
         * 	   but are not part of the Nvim distribution. XDG_DATA_DIRS defaults
         * 	   to /usr/local/share/:/usr/share/, so system administrators are
         * 	   expected to install site plugins to /usr/share/nvim/site.
         * 	5. Session state directory, for state data such as swap, backupdir,
         * 	   viewdir, undodir, etc.
         * 	   Given by `stdpath("state")`.  |$XDG_STATE_HOME|
         * 	6. $VIMRUNTIME, for files distributed with Nvim.
         * 
         * 	7, 8, 9, 10. In after/ subdirectories of 1, 2, 3 and 4, with reverse
         * 	   ordering.  This is for preferences to overrule or add to the
         * 	   distributed defaults or system-wide settings (rarely needed).
         * 
         * 
         * 	"start" packages will also be searched (|runtime-search-path|) for
         * 	runtime files after these, though such packages are not explicitly
         * 	reported in &runtimepath. But "opt" packages are explicitly added to
         * 	&runtimepath by |:packadd|.
         * 
         * 	Note that, unlike `'path'` , no wildcards like "" are allowed.  Normal
         * 	wildcards are allowed, but can significantly slow down searching for
         * 	runtime files.  For speed, use as few items as possible and avoid
         * 	wildcards.
         * 	See |:runtime|.
         * 	Example: >
         * 		:set runtimepath=~/vimruntime,/mygroup/vim,$VIMRUNTIME
         * <	This will use the directory "~/vimruntime" first (containing your
         * 	personal Nvim runtime files), then "/mygroup/vim", and finally
         * 	"$VIMRUNTIME" (the default runtime files).
         * 	You can put a directory before $VIMRUNTIME to find files which replace
         * 	distributed runtime files.  You can put a directory after $VIMRUNTIME
         * 	to find files which add to distributed runtime files.
         * 
         * 	With |--clean| the home directory entries are not included.
         */
        runtimepath: string

        /**
         * `'scrolljump'`  `'sj'` 	number	(default 1)
         * 			global
         * 	Minimal number of lines to scroll when the cursor gets off the
         * 	screen (e.g., with "j").  Not used for scroll commands (e.g., CTRL-E,
         * 	CTRL-D).  Useful if your terminal scrolls very slowly.
         * 	When set to a negative number from -1 to -100 this is used as the
         * 	percentage of the window height.  Thus -50 scrolls half the window
         * 	height.
         */
        scrolljump: number

        /**
         * `'scrollopt'`  `'sbo'` 	string	(default "ver,jump")
         * 			global
         * 	This is a comma-separated list of words that specifies how
         * 	`'scrollbind'`  windows should behave.  `'sbo'`  stands for ScrollBind
         * 	Options.
         * 	The following words are available:
         * 	    ver		Bind vertical scrolling for `'scrollbind'`  windows
         * 	    hor		Bind horizontal scrolling for `'scrollbind'`  windows
         * 	    jump	Applies to the offset between two windows for vertical
         * 			scrolling.  This offset is the difference in the first
         * 			displayed line of the bound windows.  When moving
         * 			around in a window, another `'scrollbind'`  window may
         * 			reach a position before the start or after the end of
         * 			the buffer.  The offset is not changed though, when
         * 			moving back the `'scrollbind'`  window will try to scroll
         * 			to the desired position when possible.
         * 			When now making that window the current one, two
         * 			things can be done with the relative offset:
         * 			1. When "jump" is not included, the relative offset is
         * 			   adjusted for the scroll position in the new current
         * 			   window.  When going back to the other window, the
         * 			   new relative offset will be used.
         * 			2. When "jump" is included, the other windows are
         * 			   scrolled to keep the same relative offset.  When
         * 			   going back to the other window, it still uses the
         * 			   same relative offset.
         * 	Also see |scroll-binding|.
         * 	When `'diff'`  mode is active there always is vertical scroll binding,
         * 	even when "ver" isn't there.
         */
        scrollopt: string

        /**
         * `'sections'`  `'sect'` 	string	(default "SHNHH HUnhsh")
         * 			global
         * 	Specifies the nroff macros that separate sections.  These are pairs of
         * 	two letters (See |object-motions|).  The default makes a section start
         * 	at the nroff macros ".SH", ".NH", ".H", ".HU", ".nh" and ".sh".
         */
        sections: string

        secure: boolean

        /**
         * `'selection'`  `'sel'` 	string	(default "inclusive")
         * 			global
         * 	This option defines the behavior of the selection.  It is only used
         * 	in Visual and Select mode.
         * 	Possible values:
         * 	   value	past line     inclusive ~
         * 	   old		   no		yes
         * 	   inclusive	   yes		yes
         * 	   exclusive	   yes		no
         * 	"past line" means that the cursor is allowed to be positioned one
         * 	character past the line.
         * 	"inclusive" means that the last character of the selection is included
         * 	in an operation.  For example, when "x" is used to delete the
         * 	selection.
         * 	When "old" is used and `'virtualedit'`  allows the cursor to move past
         * 	the end of line the line break still isn't included.
         * 	Note that when "exclusive" is used and selecting from the end
         * 	backwards, you cannot include the last character of a line, when
         * 	starting in Normal mode and `'virtualedit'`  empty.
         * 
         * 	The `'selection'`  option is set by the |:behave| command.
         */
        selection: string

        /**
         * `'selectmode'`  `'slm'` 	string	(default "")
         * 			global
         * 	This is a comma-separated list of words, which specifies when to start
         * 	Select mode instead of Visual mode, when a selection is started.
         * 	Possible values:
         * 	   mouse	when using the mouse
         * 	   key		when using shifted special keys
         * 	   cmd		when using "v", "V" or CTRL-V
         * 	See |Select-mode|.
         * 	The `'selectmode'`  option is set by the |:behave| command.
         */
        selectmode: string

        /**
         * `'sessionoptions'`  `'ssop'` 	string	(default: "blank,buffers,curdir,folds,
         * 					       help,tabpages,winsize,terminal")
         * 			global
         * 	Changes the effect of the |:mksession| command.  It is a comma-
         * 	separated list of words.  Each word enables saving and restoring
         * 	something:
         * 	   word		save and restore ~
         * 	   blank	empty windows
         * 	   buffers	hidden and unloaded buffers, not just those in windows
         * 	   curdir	the current directory
         * 	   folds	manually created folds, opened/closed folds and local
         * 			fold options
         * 	   globals	global variables that start with an uppercase letter
         * 			and contain at least one lowercase letter.  Only
         * 			String and Number types are stored.
         * 	   help		the help window
         * 	   localoptions	options and mappings local to a window or buffer (not
         * 			global values for local options)
         * 	   options	all options and mappings (also global values for local
         * 			options)
         * 	   skiprtp	exclude `'runtimepath'`  and `'packpath'`  from the options
         * 	   resize	size of the Vim window: `'lines'`  and `'columns'` 
         * 	   sesdir	the directory in which the session file is located
         * 			will become the current directory (useful with
         * 			projects accessed over a network from different
         * 			systems)
         * 	   tabpages	all tab pages; without this only the current tab page
         * 			is restored, so that you can make a session for each
         * 			tab page separately
         * 	   terminal	include terminal windows where the command can be
         * 			restored
         * 	   winpos	position of the whole Vim window
         * 	   winsize	window sizes
         * 	   slash	|deprecated| Always enabled. Uses "/" in filenames.
         * 	   unix		|deprecated| Always enabled. Uses "\n" line endings.
         * 
         * 	Don't include both "curdir" and "sesdir". When neither is included
         * 	filenames are stored as absolute paths.
         * 	If you leave out "options" many things won't work well after restoring
         * 	the session.
         */
        sessionoptions: string

        /**
         * `'shada'`  `'sd'` 		string	(default for
         * 				   Win32:  !,'100,<50,s10,h,rA:,rB:
         * 				   others: !,'100,<50,s10,h)
         * 			global
         * 	When non-empty, the shada file is read upon startup and written
         * 	when exiting Vim (see |shada-file|).  The string should be a comma-
         * 	separated list of parameters, each consisting of a single character
         * 	identifying the particular parameter, followed by a number or string
         * 	which specifies the value of that parameter.  If a particular
         * 	character is left out, then the default value is used for that
         * 	parameter.  The following is a list of the identifying characters and
         * 	the effect of their value.
         * 	CHAR	VALUE	~
         * 
         * 	!	When included, save and restore global variables that start
         * 		with an uppercase letter, and don't contain a lowercase
         * 		letter.  Thus "KEEPTHIS and "K_L_M" are stored, but "KeepThis"
         * 		and "_K_L_M" are not.  Nested List and Dict items may not be
         * 		read back correctly, you end up with an empty item.
         * 
         * 	"	Maximum number of lines saved for each register.  Old name of
         * 		the `'<'`  item, with the disadvantage that you need to put a
         * 		backslash before the ", otherwise it will be recognized as the
         * 		start of a comment!
         * 
         * 	%	When included, save and restore the buffer list.  If Vim is
         * 		started with a file name argument, the buffer list is not
         * 		restored.  If Vim is started without a file name argument, the
         * 		buffer list is restored from the shada file.  Quickfix
         * 		(`'buftype'` ), unlisted (`'buflisted'` ), unnamed and buffers on
         * 		removable media (|shada-r|) are not saved.
         * 		When followed by a number, the number specifies the maximum
         * 		number of buffers that are stored.  Without a number all
         * 		buffers are stored.
         * 
         * 	'	Maximum number of previously edited files for which the marks
         * 		are remembered.  This parameter must always be included when
         * 		`'shada'`  is non-empty.
         * 		Including this item also means that the |jumplist| and the
         * 		|changelist| are stored in the shada file.
         * 
         * 	/	Maximum number of items in the search pattern history to be
         * 		saved.  If non-zero, then the previous search and substitute
         * 		patterns are also saved.  When not included, the value of
         * 		`'history'`  is used.
         * 
         * 	:	Maximum number of items in the command-line history to be
         * 		saved.  When not included, the value of `'history'`  is used.
         * 
         * 	<	Maximum number of lines saved for each register.  If zero then
         * 		registers are not saved.  When not included, all lines are
         * 		saved.  `'"'`  is the old name for this item.
         * 		Also see the `'s'`  item below: limit specified in KiB.
         * 
         * 	@	Maximum number of items in the input-line history to be
         * 		saved.  When not included, the value of `'history'`  is used.
         * 
         * 	c	Dummy option, kept for compatibility reasons.  Has no actual
         * 		effect: ShaDa always uses UTF-8 and `'encoding'`  value is fixed
         * 		to UTF-8 as well.
         * 
         * 	f	Whether file marks need to be stored.  If zero, file marks ('0
         * 		to '9, 'A to 'Z) are not stored.  When not present or when
         * 		non-zero, they are all stored.  '0 is used for the current
         * 		cursor position (when exiting or when doing |:wshada|).
         * 
         * 	h	Disable the effect of `'hlsearch'`  when loading the shada
         * 		file.  When not included, it depends on whether ":nohlsearch"
         * 		has been used since the last search command.
         * 
         * 	n	Name of the shada file.  The name must immediately follow
         * 		the `'n'` .  Must be at the end of the option!  If the
         * 		`'shadafile'`  option is set, that file name overrides the one
         * 		given here with `'shada'` .  Environment variables are
         * 		expanded when opening the file, not when setting the option.
         * 
         * 	r	Removable media.  The argument is a string (up to the next
         * 		`','` ).  This parameter can be given several times.  Each
         * 		specifies the start of a path for which no marks will be
         * 		stored.  This is to avoid removable media.  For Windows you
         * 		could use "ra:,rb:".  You can also use it for temp files,
         * 		e.g., for Unix: "r/tmp".  Case is ignored.
         * 
         * 	s	Maximum size of an item contents in KiB.  If zero then nothing
         * 		is saved.  Unlike Vim this applies to all items, except for
         * 		the buffer list and header.  Full item size is off by three
         * 		unsigned integers: with `s10` maximum item size may be 1 byte
         * 		(type: 7-bit integer) + 9 bytes (timestamp: up to 64-bit
         * 		integer) + 3 bytes (item size: up to 16-bit integer because
         * 		2^8 < 10240 < 2^16) + 10240 bytes (requested maximum item
         * 		contents size) = 10253 bytes.
         * 
         * 	Example: >
         * 	    :set shada='50,<1000,s100,:0,n~/nvim/shada
         * <
         * 	'50		Marks will be remembered for the last 50 files you
         * 			edited.
         * 	<1000		Contents of registers (up to 1000 lines each) will be
         * 			remembered.
         * 	s100		Items with contents occupying more then 100 KiB are
         * 			skipped.
         * 	:0		Command-line history will not be saved.
         * 	n~/nvim/shada	The name of the file to use is "~/nvim/shada".
         * 	no /		Since `'/'`  is not specified, the default will be used,
         * 			that is, save all of the search history, and also the
         * 			previous search and substitute patterns.
         * 	no %		The buffer list will not be saved nor read back.
         * 	no h		`'hlsearch'`  highlighting will be restored.
         * 
         * 	When setting `'shada'`  from an empty value you can use |:rshada| to
         * 	load the contents of the file, this is not done automatically.
         * 
         * 	This option cannot be set from a |modeline| or in the |sandbox|, for
         * 	security reasons.
         */
        shada: string

        /**
         * `'shadafile'`  `'sdf'` 	string	(default: "")
         * 			global
         * 	When non-empty, overrides the file name used for |shada| (viminfo).
         * 	When equal to "NONE" no shada file will be read or written.
         * 	This option can be set with the |-i| command line flag.  The |--clean|
         * 	command line flag sets it to "NONE".
         * 	This option cannot be set from a |modeline| or in the |sandbox|, for
         * 	security reasons.
         */
        shadafile: string

        /**
         * `'shell'`  `'sh'` 		string	(default $SHELL or "sh", Win32: "cmd.exe")
         * 			global
         * 	Name of the shell to use for ! and :! commands.  When changing the
         * 	value also check these options: `'shellpipe'` , `'shellslash'` 
         * 	`'shellredir'` , `'shellquote'` , `'shellxquote'`  and `'shellcmdflag'` .
         * 	It is allowed to give an argument to the command, e.g.  "csh -f".
         * 	See |option-backslash| about including spaces and backslashes.
         * 	Environment variables are expanded |:set_env|.
         * 
         * 	If the name of the shell contains a space, you need to enclose it in
         * 	quotes.  Example with quotes: >
         * 		:set shell=\"c:\program\ files\unix\sh.exe\"\ -f
         * <	Note the backslash before each quote (to avoid starting a comment) and
         * 	each space (to avoid ending the option value), so better use |:let-&|
         * 	like this: >
         * 		:let &shell='"C:\Program Files\unix\sh.exe" -f'
         * <	Also note that the "-f" is not inside the quotes, because it is not
         * 	part of the command name.
         * 
         * 	Rules regarding quotes:
         * 	1. Option is split on space and tab characters that are not inside
         * 	   quotes: "abc def" runs shell named "abc" with additional argument
         * 	   "def", '"abc def"' runs shell named "abc def" with no additional
         * 	   arguments (here and below: additional means “additional to
         * 	   `'shellcmdflag'` ”).
         * 	2. Quotes in option may be present in any position and any number:
         * 	   `'"abc"'` , `'"a"bc'` , `'a"b"c'` , `'ab"c"'`  and `'"a"b"c"'`  are all equivalent
         * 	   to just "abc".
         * 	3. Inside quotes backslash preceding backslash means one backslash.
         * 	   Backslash preceding quote means one quote. Backslash preceding
         * 	   anything else means backslash and next character literally:
         * 	   `'"a\\b"'`  is the same as "a\b", `'"a\\"b"'`  runs shell named literally
         * 	   `'a"b'` , `'"a\b"'`  is the same as "a\b" again.
         * 	4. Outside of quotes backslash always means itself, it cannot be used
         * 	   to escape quote: `'a\"b"'`  is the same as "a\b".
         * 	Note that such processing is done after |:set| did its own round of
         * 	unescaping, so to keep yourself sane use |:let-&| like shown above.
         * 
         * 	To use PowerShell: >
         * 		let &shell = executable(`'pwsh'` ) ? `'pwsh'`  : `'powershell'` 
         * 		let &shellcmdflag = '-NoLogo -ExecutionPolicy RemoteSigned -Command [Console]::InputEncoding=[Console]::OutputEncoding=[System.Text.UTF8Encoding]::new();$PSDefaultParameterValues[`''` Out-File:Encoding`''` ]=`''` utf8`''` ;'
         * 		let &shellredir = '2>&1 | %%{ "$_" } | Out-File %s; exit $LastExitCode'
         * 		let &shellpipe  = '2>&1 | %%{ "$_" } | Tee-Object %s; exit $LastExitCode'
         * 		set shellquote= shellxquote=
         * 
         * <	This option cannot be set from a |modeline| or in the |sandbox|, for
         * 	security reasons.
         */
        shell: string

        /**
         * `'shellcmdflag'`  `'shcf'` 	string	(default: "-c"; Windows: "/s /c")
         * 			global
         * 	Flag passed to the shell to execute "!" and ":!" commands; e.g.,
         * 	`bash.exe -c ls` or `cmd.exe /s /c "dir"`.  For MS-Windows, the
         * 	default is set according to the value of `'shell'` , to reduce the need
         * 	to set this option by the user.
         * 	On Unix it can have more than one flag.  Each white space separated
         * 	part is passed as an argument to the shell command.
         * 	See |option-backslash| about including spaces and backslashes.
         * 	See |shell-unquoting| which talks about separating this option into
         * 	multiple arguments.
         * 	This option cannot be set from a |modeline| or in the |sandbox|, for
         * 	security reasons.
         */
        shellcmdflag: string

        /**
         * `'shellpipe'`  `'sp'` 	string	(default ">", "| tee", "|& tee" or "2>&1| tee")
         * 			global
         * 	String to be used to put the output of the ":make" command in the
         * 	error file.  See also |:make_makeprg|.  See |option-backslash| about
         * 	including spaces and backslashes.
         * 	The name of the temporary file can be represented by "%s" if necessary
         * 	(the file name is appended automatically if no %s appears in the value
         * 	of this option).
         * 	For MS-Windows the default is "2>&1| tee".  The stdout and stderr are
         * 	saved in a file and echoed to the screen.
         * 	For Unix the default is "| tee".  The stdout of the compiler is saved
         * 	in a file and echoed to the screen.  If the `'shell'`  option is "csh" or
         * 	"tcsh" after initializations, the default becomes "|& tee".  If the
         * 	`'shell'`  option is "sh", "ksh", "mksh", "pdksh", "zsh", "zsh-beta",
         * 	"bash", "fish", "ash" or "dash" the default becomes "2>&1| tee".  This
         * 	means that stderr is also included.  Before using the `'shell'`  option a
         * 	path is removed, thus "/bin/sh" uses "sh".
         * 	The initialization of this option is done after reading the vimrc
         * 	and the other initializations, so that when the `'shell'`  option is set
         * 	there, the `'shellpipe'`  option changes automatically, unless it was
         * 	explicitly set before.
         * 	When `'shellpipe'`  is set to an empty string, no redirection of the
         * 	":make" output will be done.  This is useful if you use a `'makeprg'` 
         * 	that writes to `'makeef'`  by itself.  If you want no piping, but do
         * 	want to include the `'makeef'` , set `'shellpipe'`  to a single space.
         * 	Don't forget to precede the space with a backslash: ":set sp=\ ".
         * 	In the future pipes may be used for filtering and this option will
         * 	become obsolete (at least for Unix).
         * 	This option cannot be set from a |modeline| or in the |sandbox|, for
         * 	security reasons.
         */
        shellpipe: string

        /**
         * `'shellquote'`  `'shq'` 	string	(default: ""; Windows, when `'shell'` 
         * 					contains "sh" somewhere: "\"")
         * 			global
         * 	Quoting character(s), put around the command passed to the shell, for
         * 	the "!" and ":!" commands.  The redirection is kept outside of the
         * 	quoting.  See `'shellxquote'`  to include the redirection.  It's
         * 	probably not useful to set both options.
         * 	This is an empty string by default.  Only known to be useful for
         * 	third-party shells on Windows systems, such as the MKS Korn Shell
         * 	or bash, where it should be "\"".  The default is adjusted according
         * 	the value of `'shell'` , to reduce the need to set this option by the
         * 	user.
         * 	This option cannot be set from a |modeline| or in the |sandbox|, for
         * 	security reasons.
         */
        shellquote: string

        /**
         * `'shellredir'`  `'srr'` 	string	(default ">", ">&" or ">%s 2>&1")
         * 			global
         * 	String to be used to put the output of a filter command in a temporary
         * 	file.  See also |:!|.  See |option-backslash| about including spaces
         * 	and backslashes.
         * 	The name of the temporary file can be represented by "%s" if necessary
         * 	(the file name is appended automatically if no %s appears in the value
         * 	of this option).
         * 	The default is ">".  For Unix, if the `'shell'`  option is "csh" or
         * 	"tcsh" during initializations, the default becomes ">&".  If the
         * 	`'shell'`  option is "sh", "ksh", "mksh", "pdksh", "zsh", "zsh-beta",
         * 	"bash" or "fish", the default becomes ">%s 2>&1".  This means that
         * 	stderr is also included.  For Win32, the Unix checks are done and
         * 	additionally "cmd" is checked for, which makes the default ">%s 2>&1".
         * 	Also, the same names with ".exe" appended are checked for.
         * 	The initialization of this option is done after reading the vimrc
         * 	and the other initializations, so that when the `'shell'`  option is set
         * 	there, the `'shellredir'`  option changes automatically unless it was
         * 	explicitly set before.
         * 	In the future pipes may be used for filtering and this option will
         * 	become obsolete (at least for Unix).
         * 	This option cannot be set from a |modeline| or in the |sandbox|, for
         * 	security reasons.
         */
        shellredir: string

        /**
         * `'shellslash'`  `'ssl'` 	boolean	(default off)
         * 			global
         * 			{only for MS-Windows}
         * 	When set, a forward slash is used when expanding file names.  This is
         * 	useful when a Unix-like shell is used instead of cmd.exe.  Backward
         * 	slashes can still be typed, but they are changed to forward slashes by
         * 	Vim.
         * 	Note that setting or resetting this option has no effect for some
         * 	existing file names, thus this option needs to be set before opening
         * 	any file for best results.  This might change in the future.
         * 	`'shellslash'`  only works when a backslash can be used as a path
         * 	separator.  To test if this is so use: >
         * 		if exists(`'+shellslash'` )
         * <	Also see `'completeslash'` .
         */
        shellslash: boolean

        /**
         * `'shelltemp'`  `'stmp'` 	boolean	(default on)
         * 			global
         * 	When on, use temp files for shell commands.  When off use a pipe.
         * 	When using a pipe is not possible temp files are used anyway.
         * 	The advantage of using a pipe is that nobody can read the temp file
         * 	and the `'shell'`  command does not need to support redirection.
         * 	The advantage of using a temp file is that the file type and encoding
         * 	can be detected.
         * 	The |FilterReadPre|, |FilterReadPost| and |FilterWritePre|,
         * 	|FilterWritePost| autocommands event are not triggered when
         * 	`'shelltemp'`  is off.
         * 	|system()| does not respect this option, it always uses pipes.
         */
        shelltemp: boolean

        /**
         * `'shellxescape'`  `'sxe'` 	string	(default: "")
         * 			global
         * 	When `'shellxquote'`  is set to "(" then the characters listed in this
         * 	option will be escaped with a `'^'`  character.  This makes it possible
         * 	to execute most external commands with cmd.exe.
         */
        shellxescape: string

        /**
         * `'shellxquote'`  `'sxq'` 	string	(default: "", Windows: "\"")
         * 			global
         * 	Quoting character(s), put around the command passed to the shell, for
         * 	the "!" and ":!" commands.  Includes the redirection.  See
         * 	`'shellquote'`  to exclude the redirection.  It's probably not useful
         * 	to set both options.
         * 	When the value is `'('`  then `')'`  is appended. When the value is `'"('` 
         * 	then `')"'`  is appended.
         * 	When the value is `'('`  then also see `'shellxescape'` .
         * 	This option cannot be set from a |modeline| or in the |sandbox|, for
         * 	security reasons.
         */
        shellxquote: string

        /**
         * `'shiftround'`  `'sr'` 	boolean	(default off)
         * 			global
         * 	Round indent to multiple of `'shiftwidth'` .  Applies to > and <
         * 	commands.  CTRL-T and CTRL-D in Insert mode always round the indent to
         * 	a multiple of `'shiftwidth'`  (this is Vi compatible).
         */
        shiftround: boolean

        /**
         * `'shortmess'`  `'shm'` 	string	(default "filnxtToOF")
         * 			global
         * 	This option helps to avoid all the |hit-enter| prompts caused by file
         * 	messages, for example  with CTRL-G, and to avoid some other messages.
         * 	It is a list of flags:
         * 	 flag	meaning when present	~
         * 	  f	use "(3 of 5)" instead of "(file 3 of 5)"
         * 	  i	use "[noeol]" instead of "[Incomplete last line]"
         * 	  l	use "999L, 888B" instead of "999 lines, 888 bytes"
         * 	  m	use "[+]" instead of "[Modified]"
         * 	  n	use "[New]" instead of "[New File]"
         * 	  r	use "[RO]" instead of "[readonly]"
         * 	  w	use "[w]" instead of "written" for file write message
         * 		and "[a]" instead of "appended" for ':w >> file' command
         * 	  x	use "[dos]" instead of "[dos format]", "[unix]"
         * 		instead of "[unix format]" and "[mac]" instead of "[mac
         * 		format]"
         * 	  a	all of the above abbreviations
         * 
         * 	  o	overwrite message for writing a file with subsequent
         * 		message for reading a file (useful for ":wn" or when
         * 		`'autowrite'`  on)
         * 	  O	message for reading a file overwrites any previous
         * 		message;  also for quickfix message (e.g., ":cn")
         * 	  s	don't give "search hit BOTTOM, continuing at TOP" or
         * 		"search hit TOP, continuing at BOTTOM" messages; when using
         * 		the search count do not show "W" after the count message (see
         * 		S below)
         * 	  t	truncate file message at the start if it is too long
         * 		to fit on the command-line, "<" will appear in the left most
         * 		column; ignored in Ex mode
         * 	  T	truncate other messages in the middle if they are too
         * 		long to fit on the command line; "..." will appear in the
         * 		middle; ignored in Ex mode
         * 	  W	don't give "written" or "[w]" when writing a file
         * 	  A	don't give the "ATTENTION" message when an existing
         * 		swap file is found
         * 	  I	don't give the intro message when starting Vim,
         * 		see |:intro|
         * 	  c	don't give |ins-completion-menu| messages; for
         * 		example, "-- XXX completion (YYY)", "match 1 of 2", "The only
         * 		match", "Pattern not found", "Back at original", etc.
         * 	  C	don't give messages while scanning for ins-completion
         * 		items, for instance "scanning tags"
         * 	  q	use "recording" instead of "recording @a"
         * 	  F	don't give the file info when editing a file, like
         * 		`:silent` was used for the command
         * 	  S	do not show search count message when searching, e.g.
         * 		"[1/5]"
         * 
         * 	This gives you the opportunity to avoid that a change between buffers
         * 	requires you to hit <Enter>, but still gives as useful a message as
         * 	possible for the space available.  To get the whole message that you
         * 	would have got with `'shm'`  empty, use ":file!"
         * 	Useful values:
         * 	    shm=	No abbreviation of message.
         * 	    shm=a	Abbreviation, but no loss of information.
         * 	    shm=at	Abbreviation, and truncate message when necessary.
         */
        shortmess: string

        /**
         * `'showcmd'`  `'sc'` 		boolean	(default: on)
         * 			global
         * 	Show (partial) command in the last line of the screen.  Set this
         * 	option off if your terminal is slow.
         * 	In Visual mode the size of the selected area is shown:
         * 	- When selecting characters within a line, the number of characters.
         * 	  If the number of bytes is different it is also displayed: "2-6"
         * 	  means two characters and six bytes.
         * 	- When selecting more than one line, the number of lines.
         * 	- When selecting a block, the size in screen characters:
         * 	  {lines}x{columns}.
         * 	This information can be displayed in an alternative location using the
         * 	`'showcmdloc'`  option, useful when `'cmdheight'`  is 0.
         */
        showcmd: boolean

        /**
         * `'showcmdloc'`  `'sloc'` 	string	(default "last")
         * 			global
         * 	This option can be used to display the (partially) entered command in
         * 	another location.  Possible values are:
         * 	  last		Last line of the screen (default).
         * 	  statusline	Status line of the current window.
         * 	  tabline	First line of the screen if `'showtabline'`  is enabled.
         * 	Setting this option to "statusline" or "tabline" means that these will
         * 	be redrawn whenever the command changes, which can be on every key
         * 	pressed.
         * 	The %S `'statusline'`  item can be used in `'statusline'`  or `'tabline'`  to
         * 	place the text.  Without a custom `'statusline'`  or `'tabline'`  it will be
         * 	displayed in a convenient location.
         */
        showcmdloc: string

        /**
         * `'showfulltag'`  `'sft'` 	boolean (default off)
         * 			global
         * 	When completing a word in insert mode (see |ins-completion|) from the
         * 	tags file, show both the tag name and a tidied-up form of the search
         * 	pattern (if there is one) as possible matches.  Thus, if you have
         * 	matched a C function, you can see a template for what arguments are
         * 	required (coding style permitting).
         * 	Note that this doesn't work well together with having "longest" in
         * 	`'completeopt'` , because the completion from the search pattern may not
         * 	match the typed text.
         */
        showfulltag: boolean

        /**
         * `'showmatch'`  `'sm'` 	boolean	(default off)
         * 			global
         * 	When a bracket is inserted, briefly jump to the matching one.  The
         * 	jump is only done if the match can be seen on the screen.  The time to
         * 	show the match can be set with `'matchtime'` .
         * 	A Beep is given if there is no match (no matter if the match can be
         * 	seen or not).
         * 	When the `'m'`  flag is not included in `'cpoptions'` , typing a character
         * 	will immediately move the cursor back to where it belongs.
         * 	See the "sm" field in `'guicursor'`  for setting the cursor shape and
         * 	blinking when showing the match.
         * 	The `'matchpairs'`  option can be used to specify the characters to show
         * 	matches for.  `'rightleft'`  and `'revins'`  are used to look for opposite
         * 	matches.
         * 	Also see the matchparen plugin for highlighting the match when moving
         * 	around |pi_paren.txt|.
         * 	Note: Use of the short form is rated PG.
         */
        showmatch: boolean

        /**
         * `'showmode'`  `'smd'` 	boolean	(default: on)
         * 			global
         * 	If in Insert, Replace or Visual mode put a message on the last line.
         * 	The |hl-ModeMsg| highlight group determines the highlighting.
         * 	The option has no effect when `'cmdheight'`  is zero.
         */
        showmode: boolean

        /**
         * `'showtabline'`  `'stal'` 	number	(default 1)
         * 			global
         * 	The value of this option specifies when the line with tab page labels
         * 	will be displayed:
         * 		0: never
         * 		1: only if there are at least two tab pages
         * 		2: always
         * 	This is both for the GUI and non-GUI implementation of the tab pages
         * 	line.
         * 	See |tab-page| for more information about tab pages.
         */
        showtabline: number

        /**
         * `'sidescroll'`  `'ss'` 	number	(default 1)
         * 			global
         * 	The minimal number of columns to scroll horizontally.  Used only when
         * 	the `'wrap'`  option is off and the cursor is moved off of the screen.
         * 	When it is zero the cursor will be put in the middle of the screen.
         * 	When using a slow terminal set it to a large number or 0.  Not used
         * 	for "zh" and "zl" commands.
         */
        sidescroll: number

        /**
         * `'smartcase'`  `'scs'` 	boolean	(default off)
         * 			global
         * 	Override the `'ignorecase'`  option if the search pattern contains upper
         * 	case characters.  Only used when the search pattern is typed and
         * 	`'ignorecase'`  option is on.  Used for the commands "/", "?", "n", "N",
         * 	":g" and ":s".  Not used for "*", "#", "gd", tag search, etc.  After
         * 	"*" and "#" you can make `'smartcase'`  used by doing a "/" command,
         * 	recalling the search pattern from history and hitting <Enter>.
         */
        smartcase: boolean

        /**
         * `'smarttab'`  `'sta'` 	boolean	(default on)
         * 			global
         * 	When on, a <Tab> in front of a line inserts blanks according to
         * 	`'shiftwidth'` .  `'tabstop'`  or `'softtabstop'`  is used in other places.  A
         * 	<BS> will delete a `'shiftwidth'`  worth of space at the start of the
         * 	line.
         * 	When off, a <Tab> always inserts blanks according to `'tabstop'`  or
         * 	`'softtabstop'` .  `'shiftwidth'`  is only used for shifting text left or
         * 	right |shift-left-right|.
         * 	What gets inserted (a <Tab> or spaces) depends on the `'expandtab'` 
         * 	option.  Also see |ins-expandtab|.  When `'expandtab'`  is not set, the
         * 	number of spaces is minimized by using <Tab>s.
         */
        smarttab: boolean

        /**
         * `'spellsuggest'`  `'sps'` 	string	(default "best")
         * 			global
         * 	Methods used for spelling suggestions.  Both for the |z=| command and
         * 	the |spellsuggest()| function.  This is a comma-separated list of
         * 	items:
         * 
         * 	best		Internal method that works best for English.  Finds
         * 			changes like "fast" and uses a bit of sound-a-like
         * 			scoring to improve the ordering.
         * 
         * 	double		Internal method that uses two methods and mixes the
         * 			results.  The first method is "fast", the other method
         * 			computes how much the suggestion sounds like the bad
         * 			word.  That only works when the language specifies
         * 			sound folding.  Can be slow and doesn't always give
         * 			better results.
         * 
         * 	fast		Internal method that only checks for simple changes:
         * 			character inserts/deletes/swaps.  Works well for
         * 			simple typing mistakes.
         * 
         * 	{number}	The maximum number of suggestions listed for |z=|.
         * 			Not used for |spellsuggest()|.  The number of
         * 			suggestions is never more than the value of `'lines'` 
         * 			minus two.
         * 
         * 	timeout:{millisec}   Limit the time searching for suggestions to
         * 			{millisec} milli seconds.  Applies to the following
         * 			methods.  When omitted the limit is 5000. When
         * 			negative there is no limit.
         * 
         * 	file:{filename} Read file {filename}, which must have two columns,
         * 			separated by a slash.  The first column contains the
         * 			bad word, the second column the suggested good word.
         * 			Example:
         * 				theribal/terrible ~
         * 			Use this for common mistakes that do not appear at the
         * 			top of the suggestion list with the internal methods.
         * 			Lines without a slash are ignored, use this for
         * 			comments.
         * 			The word in the second column must be correct,
         * 			otherwise it will not be used.  Add the word to an
         * 			".add" file if it is currently flagged as a spelling
         * 			mistake.
         * 			The file is used for all languages.
         * 
         * 	expr:{expr}	Evaluate expression {expr}.  Use a function to avoid
         * 			trouble with spaces.  |v:val| holds the badly spelled
         * 			word.  The expression must evaluate to a List of
         * 			Lists, each with a suggestion and a score.
         * 			Example:
         * 				[[`'the'` , 33], [`'that'` , 44]] ~
         * 			Set `'verbose'`  and use |z=| to see the scores that the
         * 			internal methods use.  A lower score is better.
         * 			This may invoke |spellsuggest()| if you temporarily
         * 			set `'spellsuggest'`  to exclude the "expr:" part.
         * 			Errors are silently ignored, unless you set the
         * 			`'verbose'`  option to a non-zero value.
         * 
         * 	Only one of "best", "double" or "fast" may be used.  The others may
         * 	appear several times in any order.  Example: >
         * 		:set sps=file:~/.config/nvim/sugg,best,expr:MySuggest()
         * <
         * 	This option cannot be set from a |modeline| or in the |sandbox|, for
         * 	security reasons.
         */
        spellsuggest: string

        /**
         * `'splitbelow'`  `'sb'` 	boolean	(default off)
         * 			global
         * 	When on, splitting a window will put the new window below the current
         * 	one. |:split|
         */
        splitbelow: boolean

        /**
         * `'splitkeep'`  `'spk'` 	string	(default "cursor")
         * 			global
         * 	The value of this option determines the scroll behavior when opening,
         * 	closing or resizing horizontal splits.
         * 
         * 	Possible values are:
         * 	  cursor	Keep the same relative cursor position.
         * 	  screen	Keep the text on the same screen line.
         * 	  topline	Keep the topline the same.
         * 
         * 	For the "screen" and "topline" values, the cursor position will be
         * 	changed when necessary. In this case, the jumplist will be populated
         * 	with the previous cursor position. For "screen", the text cannot always
         * 	be kept on the same screen line when `'wrap'`  is enabled.
         */
        splitkeep: string

        /**
         * `'splitright'`  `'spr'` 	boolean	(default off)
         * 			global
         * 	When on, splitting a window will put the new window right of the
         * 	current one. |:vsplit|
         */
        splitright: boolean

        /**
         * `'startofline'`  `'sol'` 	boolean	(default off)
         * 			global
         * 	When "on" the commands listed below move the cursor to the first
         * 	non-blank of the line.  When off the cursor is kept in the same column
         * 	(if possible).  This applies to the commands: CTRL-D, CTRL-U, CTRL-B,
         * 	CTRL-F, "G", "H", "M", "L", gg, and to the commands "d", "<<" and ">>"
         * 	with a linewise operator, with "%" with a count and to buffer changing
         * 	commands (CTRL-^, :bnext, :bNext, etc.).  Also for an Ex command that
         * 	only has a line number, e.g., ":25" or ":+".
         * 	In case of buffer changing commands the cursor is placed at the column
         * 	where it was the last time the buffer was edited.
         */
        startofline: boolean

        /**
         * `'suffixes'`  `'su'` 		string	(default ".bak,~,.o,.h,.info,.swp,.obj")
         * 			global
         * 	Files with these suffixes get a lower priority when multiple files
         * 	match a wildcard.  See |suffixes|.  Commas can be used to separate the
         * 	suffixes.  Spaces after the comma are ignored.  A dot is also seen as
         * 	the start of a suffix.  To avoid a dot or comma being recognized as a
         * 	separator, precede it with a backslash (see |option-backslash| about
         * 	including spaces and backslashes).
         * 	See `'wildignore'`  for completely ignoring files.
         * 	The use of |:set+=| and |:set-=| is preferred when adding or removing
         * 	suffixes from the list.  This avoids problems when a future version
         * 	uses another default.
         */
        suffixes: string

        /**
         * `'switchbuf'`  `'swb'` 	string	(default "uselast")
         * 			global
         * 	This option controls the behavior when switching between buffers.
         * 	Mostly for |quickfix| commands some values are also used for other
         * 	commands, as mentioned below.
         * 	Possible values (comma-separated list):
         * 	   useopen	If included, jump to the first open window that
         * 			contains the specified buffer (if there is one).
         * 			Otherwise: Do not examine other windows.
         * 			This setting is checked with |quickfix| commands, when
         * 			jumping to errors (":cc", ":cn", "cp", etc.).  It is
         * 			also used in all buffer related split commands, for
         * 			example ":sbuffer", ":sbnext", or ":sbrewind".
         * 	   usetab	Like "useopen", but also consider windows in other tab
         * 			pages.
         * 	   split	If included, split the current window before loading
         * 			a buffer for a |quickfix| command that display errors.
         * 			Otherwise: do not split, use current window (when used
         * 			in the quickfix window: the previously used window or
         * 			split if there is no other window).
         * 	   vsplit	Just like "split" but split vertically.
         * 	   newtab	Like "split", but open a new tab page.  Overrules
         * 			"split" when both are present.
         * 	   uselast	If included, jump to the previously used window when
         * 			jumping to errors with |quickfix| commands.
         */
        switchbuf: string

        /**
         * `'tabline'`  `'tal'` 		string	(default empty)
         * 			global
         * 	When non-empty, this option determines the content of the tab pages
         * 	line at the top of the Vim window.  When empty Vim will use a default
         * 	tab pages line.  See |setting-tabline| for more info.
         * 
         * 	The tab pages line only appears as specified with the `'showtabline'` 
         * 	option and only when there is no GUI tab line.  When `'e'`  is in
         * 	`'guioptions'`  and the GUI supports a tab line `'guitablabel'`  is used
         * 	instead.  Note that the two tab pages lines are very different.
         * 
         * 	The value is evaluated like with `'statusline'` .  You can use
         * 	|tabpagenr()|, |tabpagewinnr()| and |tabpagebuflist()| to figure out
         * 	the text to be displayed.  Use "%1T" for the first label, "%2T" for
         * 	the second one, etc.  Use "%X" items for closing labels.
         * 
         * 	When changing something that is used in `'tabline'`  that does not
         * 	trigger it to be updated, use |:redrawtabline|.
         * 	This option cannot be set in a modeline when `'modelineexpr'`  is off.
         * 
         * 	Keep in mind that only one of the tab pages is the current one, others
         * 	are invisible and you can't jump to their windows.
         */
        tabline: string

        /**
         * `'tabpagemax'`  `'tpm'` 	number	(default 50)
         * 			global
         * 	Maximum number of tab pages to be opened by the |-p| command line
         * 	argument or the ":tab all" command. |tabpage|
         */
        tabpagemax: number

        /**
         * `'tagbsearch'`  `'tbs'` 	boolean	(default on)
         * 			global
         * 	When searching for a tag (e.g., for the |:ta| command), Vim can either
         * 	use a binary search or a linear search in a tags file.  Binary
         * 	searching makes searching for a tag a LOT faster, but a linear search
         * 	will find more tags if the tags file wasn't properly sorted.
         * 	Vim normally assumes that your tags files are sorted, or indicate that
         * 	they are not sorted.  Only when this is not the case does the
         * 	`'tagbsearch'`  option need to be switched off.
         * 
         * 	When `'tagbsearch'`  is on, binary searching is first used in the tags
         * 	files.  In certain situations, Vim will do a linear search instead for
         * 	certain files, or retry all files with a linear search.  When
         * 	`'tagbsearch'`  is off, only a linear search is done.
         * 
         * 	Linear searching is done anyway, for one file, when Vim finds a line
         * 	at the start of the file indicating that it's not sorted: >
         *    !_TAG_FILE_SORTED	0	/some comment/
         * <	[The whitespace before and after the `'0'`  must be a single <Tab>]
         * 
         * 	When a binary search was done and no match was found in any of the
         * 	files listed in `'tags'` , and case is ignored or a pattern is used
         * 	instead of a normal tag name, a retry is done with a linear search.
         * 	Tags in unsorted tags files, and matches with different case will only
         * 	be found in the retry.
         * 
         * 	If a tag file indicates that it is case-fold sorted, the second,
         * 	linear search can be avoided when case is ignored.  Use a value of `'2'` 
         * 	in the "!_TAG_FILE_SORTED" line for this.  A tag file can be case-fold
         * 	sorted with the -f switch to "sort" in most unices, as in the command:
         * 	"sort -f -o tags tags".  For Universal ctags and Exuberant ctags
         * 	version 5.x or higher (at least 5.5) the --sort=foldcase switch can be
         * 	used for this as well.  Note that case must be folded to uppercase for
         * 	this to work.
         * 
         * 	By default, tag searches are case-sensitive.  Case is ignored when
         * 	`'ignorecase'`  is set and `'tagcase'`  is "followic", or when `'tagcase'`  is
         * 	"ignore".
         * 	Also when `'tagcase'`  is "followscs" and `'smartcase'`  is set, or
         * 	`'tagcase'`  is "smart", and the pattern contains only lowercase
         * 	characters.
         * 
         * 	When `'tagbsearch'`  is off, tags searching is slower when a full match
         * 	exists, but faster when no full match exists.  Tags in unsorted tags
         * 	files may only be found with `'tagbsearch'`  off.
         * 	When the tags file is not sorted, or sorted in a wrong way (not on
         * 	ASCII byte value), `'tagbsearch'`  should be off, or the line given above
         * 	must be included in the tags file.
         * 	This option doesn't affect commands that find all matching tags (e.g.,
         * 	command-line completion and ":help").
         */
        tagbsearch: boolean

        /**
         * `'taglength'`  `'tl'` 	number	(default 0)
         * 			global
         * 	If non-zero, tags are significant up to this number of characters.
         */
        taglength: number

        /**
         * `'tagrelative'`  `'tr'` 	boolean	(default: on)
         * 			global
         * 	If on and using a tags file in another directory, file names in that
         * 	tags file are relative to the directory where the tags file is.
         */
        tagrelative: boolean

        /**
         * `'tagstack'`  `'tgst'` 	boolean	(default on)
         * 			global
         * 	When on, the |tagstack| is used normally.  When off, a ":tag" or
         * 	":tselect" command with an argument will not push the tag onto the
         * 	tagstack.  A following ":tag" without an argument, a ":pop" command or
         * 	any other command that uses the tagstack will use the unmodified
         * 	tagstack, but does change the pointer to the active entry.
         * 	Resetting this option is useful when using a ":tag" command in a
         * 	mapping which should not change the tagstack.
         */
        tagstack: boolean

        /**
         * `'termbidi'`  `'tbidi'` 	boolean (default off)
         * 			global
         * 	The terminal is in charge of Bi-directionality of text (as specified
         * 	by Unicode).  The terminal is also expected to do the required shaping
         * 	that some languages (such as Arabic) require.
         * 	Setting this option implies that `'rightleft'`  will not be set when
         * 	`'arabic'`  is set and the value of `'arabicshape'`  will be ignored.
         * 	Note that setting `'termbidi'`  has the immediate effect that
         * 	`'arabicshape'`  is ignored, but `'rightleft'`  isn't changed automatically.
         * 	For further details see |arabic.txt|.
         */
        termbidi: boolean

        termencoding: string

        /**
         * `'termguicolors'`  `'tgc'` 	boolean (default off)
         * 			global
         * 	Enables 24-bit RGB color in the |TUI|.  Uses "gui" |:highlight|
         * 	attributes instead of "cterm" attributes. |guifg|
         * 	Requires an ISO-8613-3 compatible terminal.
         */
        termguicolors: boolean

        /**
         * `'termpastefilter'`  `'tpf'` 	string	(default: "BS,HT,ESC,DEL")
         * 			global
         * 	A comma-separated list of options for specifying control characters
         * 	to be removed from the text pasted into the terminal window. The
         * 	supported values are:
         * 
         * 	   BS	    Backspace
         * 
         * 	   HT	    TAB
         * 
         * 	   FF	    Form feed
         * 
         * 	   ESC	    Escape
         * 
         * 	   DEL	    DEL
         * 
         * 	   C0	    Other control characters, excluding Line feed and
         * 		    Carriage return < ' '
         * 
         * 	   C1	    Control characters 0x80...0x9F
         */
        termpastefilter: string

        terse: boolean

        /**
         * `'tildeop'`  `'top'` 		boolean	(default off)
         * 			global
         * 	When on: The tilde command "~" behaves like an operator.
         */
        tildeop: boolean

        /**
         * `'timeout'`  `'to'` 		boolean (default on)
         * 			global
         * 	This option and `'timeoutlen'`  determine the behavior when part of a
         * 	mapped key sequence has been received. For example, if <c-f> is
         * 	pressed and `'timeout'`  is set, Nvim will wait `'timeoutlen'`  milliseconds
         * 	for any key that can follow <c-f> in a mapping.
         */
        timeout: boolean

        /**
         * `'timeoutlen'`  `'tm'` 	number	(default 1000)
         * 			global
         * 	Time in milliseconds to wait for a mapped sequence to complete.
         */
        timeoutlen: number

        /**
         * `'title'` 			boolean	(default off)
         * 			global
         * 	When on, the title of the window will be set to the value of
         * 	`'titlestring'`  (if it is not empty), or to:
         * 		filename [+=-] (path) - NVIM
         * 	Where:
         * 		filename	the name of the file being edited
         * 		-		indicates the file cannot be modified, `'ma'`  off
         * 		+		indicates the file was modified
         * 		=		indicates the file is read-only
         * 		=+		indicates the file is read-only and modified
         * 		(path)		is the path of the file being edited
         * 		- NVIM		the server name |v:servername| or "NVIM"
         */
        title: boolean

        /**
         * `'titlelen'` 		number	(default 85)
         * 			global
         * 	Gives the percentage of `'columns'`  to use for the length of the window
         * 	title.  When the title is longer, only the end of the path name is
         * 	shown.  A `'<'`  character before the path name is used to indicate this.
         * 	Using a percentage makes this adapt to the width of the window.  But
         * 	it won't work perfectly, because the actual number of characters
         * 	available also depends on the font used and other things in the title
         * 	bar.  When `'titlelen'`  is zero the full path is used.  Otherwise,
         * 	values from 1 to 30000 percent can be used.
         * 	`'titlelen'`  is also used for the `'titlestring'`  option.
         */
        titlelen: number

        /**
         * `'titleold'` 		string	(default "")
         * 			global
         * 	If not empty, this option will be used to set the window title when
         * 	exiting.  Only if `'title'`  is enabled.
         * 	This option cannot be set from a |modeline| or in the |sandbox|, for
         * 	security reasons.
         */
        titleold: string

        /**
         * `'titlestring'` 		string	(default "")
         * 			global
         * 	When this option is not empty, it will be used for the title of the
         * 	window.  This happens only when the `'title'`  option is on.
         * 
         * 	When this option contains printf-style `'%'`  items, they will be
         * 	expanded according to the rules used for `'statusline'` .
         * 	This option cannot be set in a modeline when `'modelineexpr'`  is off.
         * 
         * 	Example: >
         * 	    :auto BufEnter * let &titlestring = hostname() .. "/" .. expand("%:p")
         * 	    :set title titlestring=%<%F%=%l/%L-%P titlelen=70
         * <	The value of `'titlelen'`  is used to align items in the middle or right
         * 	of the available space.
         * 	Some people prefer to have the file name first: >
         * 	    :set titlestring=%t%(\ %M%)%(\ (%{expand(\"%:~:.:h\")})%)%(\ %a%)
         * <	Note the use of "%{ }" and an expression to get the path of the file,
         * 	without the file name.  The "%( %)" constructs are used to add a
         * 	separating space only when needed.
         * 	NOTE: Use of special characters in `'titlestring'`  may cause the display
         * 	to be garbled (e.g., when it contains a CR or NL character).
         */
        titlestring: string

        /**
         * `'ttimeout'` 		boolean (default on)
         * 			global
         * 	This option and `'ttimeoutlen'`  determine the behavior when part of a
         * 	key code sequence has been received by the |TUI|.
         * 
         * 	For example if <Esc> (the \x1b byte) is received and `'ttimeout'`  is
         * 	set, Nvim waits `'ttimeoutlen'`  milliseconds for the terminal to
         * 	complete a key code sequence. If no input arrives before the timeout,
         * 	a single <Esc> is assumed. Many TUI cursor key codes start with <Esc>.
         * 
         * 	On very slow systems this may fail, causing cursor keys not to work
         * 	sometimes.  If you discover this problem you can ":set ttimeoutlen=9999".
         * 	Nvim will wait for the next character to arrive after an <Esc>.
         */
        ttimeout: boolean

        /**
         * `'ttimeoutlen'`  `'ttm'` 	number	(default 50)
         * 			global
         * 	Time in milliseconds to wait for a key code sequence to complete. Also
         * 	used for CTRL-\ CTRL-N and CTRL-\ CTRL-G when part of a command has
         * 	been typed.
         */
        ttimeoutlen: number

        ttyfast: boolean

        /**
         * `'undodir'`  `'udir'` 	string	(default "$XDG_STATE_HOME/nvim/undo//")
         * 			global
         * 	List of directory names for undo files, separated with commas.
         * 	See `'backupdir'`  for details of the format.
         * 	"." means using the directory of the file.  The undo file name for
         * 	"file.txt" is ".file.txt.un~".
         * 	For other directories the file name is the full path of the edited
         * 	file, with path separators replaced with "%".
         * 	When writing: The first directory that exists is used.  "." always
         * 	works, no directories after "." will be used for writing.  If none of
         * 	the directories exist Nvim will attempt to create the last directory in
         * 	the list.
         * 	When reading all entries are tried to find an undo file.  The first
         * 	undo file that exists is used.  When it cannot be read an error is
         * 	given, no further entry is used.
         * 	See |undo-persistence|.
         * 	This option cannot be set from a |modeline| or in the |sandbox|, for
         * 	security reasons.
         * 
         * 	Note that unlike `'directory'`  and `'backupdir'` , `'undodir'`  always acts as
         * 	though the trailing slashes are present (see `'backupdir'`  for what this
         * 	means).
         */
        undodir: string

        /**
         * `'undoreload'`  `'ur'` 	number	(default 10000)
         * 			global
         * 	Save the whole buffer for undo when reloading it.  This applies to the
         * 	":e!" command and reloading for when the buffer changed outside of
         * 	Vim. |FileChangedShell|
         * 	The save only happens when this option is negative or when the number
         * 	of lines is smaller than the value of this option.
         * 	Set this option to zero to disable undo for a reload.
         * 
         * 	When saving undo for a reload, any undo file is not read.
         * 
         * 	Note that this causes the whole buffer to be stored in memory.  Set
         * 	this option to a lower value if you run out of memory.
         */
        undoreload: number

        /**
         * `'updatecount'`  `'uc'` 	number	(default: 200)
         * 			global
         * 	After typing this many characters the swap file will be written to
         * 	disk.  When zero, no swap file will be created at all (see chapter on
         * 	recovery |crash-recovery|).  `'updatecount'`  is set to zero by starting
         * 	Vim with the "-n" option, see |startup|.  When editing in readonly
         * 	mode this option will be initialized to 10000.
         * 	The swapfile can be disabled per buffer with |`'swapfile'` |.
         * 	When `'updatecount'`  is set from zero to non-zero, swap files are
         * 	created for all buffers that have `'swapfile'`  set.  When `'updatecount'` 
         * 	is set to zero, existing swap files are not deleted.
         * 	This option has no meaning in buffers where |`'buftype'` | is "nofile"
         * 	or "nowrite".
         */
        updatecount: number

        /**
         * `'updatetime'`  `'ut'` 	number	(default 4000)
         * 			global
         * 	If this many milliseconds nothing is typed the swap file will be
         * 	written to disk (see |crash-recovery|).  Also used for the
         * 	|CursorHold| autocommand event.
         */
        updatetime: number

        /**
         * `'verbose'`  `'vbs'` 		number	(default 0)
         * 			global
         * 	Sets the verbosity level.  Also set by |-V| and |:verbose|.
         * 
         * 	Tracing of options in Lua scripts is activated at level 1; Lua scripts
         * 	are not traced with verbose=0, for performance.
         * 
         * 	If greater than or equal to a given level, Nvim produces the following
         * 	messages:
         * 
         * 	Level   Messages ~
         * 	----------------------------------------------------------------------
         * 	1	Lua assignments to options, mappings, etc.
         * 	2	When a file is ":source"'ed, or |shada| file is read or written.
         * 	3	UI info, terminal capabilities.
         * 	4	Shell commands.
         * 	5	Every searched tags file and include file.
         * 	8	Files for which a group of autocommands is executed.
         * 	9	Executed autocommands.
         * 	11	Finding items in a path.
         * 	12	Vimscript function calls.
         * 	13	When an exception is thrown, caught, finished, or discarded.
         * 	14	Anything pending in a ":finally" clause.
         * 	15	Ex commands from a script (truncated at 200 characters).
         * 	16	Ex commands.
         * 
         * 	If `'verbosefile'`  is set then the verbose messages are not displayed.
         */
        verbose: number

        /**
         * `'verbosefile'`  `'vfile'` 	string	(default empty)
         * 			global
         * 	When not empty all messages are written in a file with this name.
         * 	When the file exists messages are appended.
         * 	Writing to the file ends when Vim exits or when `'verbosefile'`  is made
         * 	empty.  Writes are buffered, thus may not show up for some time.
         * 	Setting `'verbosefile'`  to a new value is like making it empty first.
         * 	The difference with |:redir| is that verbose messages are not
         * 	displayed when `'verbosefile'`  is set.
         */
        verbosefile: string

        /**
         * `'viewdir'`  `'vdir'` 	string	(default: "$XDG_STATE_HOME/nvim/view//")
         * 			global
         * 	Name of the directory where to store files for |:mkview|.
         * 	This option cannot be set from a |modeline| or in the |sandbox|, for
         * 	security reasons.
         */
        viewdir: string

        /**
         * `'viewoptions'`  `'vop'` 	string	(default: "folds,cursor,curdir")
         * 			global
         * 	Changes the effect of the |:mkview| command.  It is a comma-separated
         * 	list of words.  Each word enables saving and restoring something:
         * 	   word		save and restore ~
         * 	   cursor	cursor position in file and in window
         * 	   curdir	local current directory, if set with |:lcd|
         * 	   folds	manually created folds, opened/closed folds and local
         * 			fold options
         * 	   options	options and mappings local to a window or buffer (not
         * 			global values for local options)
         * 	   localoptions same as "options"
         * 	   slash	|deprecated| Always enabled. Uses "/" in filenames.
         * 	   unix		|deprecated| Always enabled. Uses "\n" line endings.
         */
        viewoptions: string

        viminfo: string

        viminfofile: string

        /**
         * `'visualbell'`  `'vb'` 	boolean	(default off)
         * 			global
         * 	Use visual bell instead of beeping.  Also see `'errorbells'` .
         */
        visualbell: boolean

        /**
         * `'warn'` 			boolean	(default on)
         * 			global
         * 	Give a warning message when a shell command is used while the buffer
         * 	has been changed.
         */
        warn: boolean

        /**
         * `'whichwrap'`  `'ww'` 	string	(default: "b,s")
         * 			global
         * 	Allow specified keys that move the cursor left/right to move to the
         * 	previous/next line when the cursor is on the first/last character in
         * 	the line.  Concatenate characters to allow this for these keys:
         * 		char   key	  mode	~
         * 		 b    <BS>	 Normal and Visual
         * 		 s    <Space>	 Normal and Visual
         * 		 h    "h"	 Normal and Visual (not recommended)
         * 		 l    "l"	 Normal and Visual (not recommended)
         * 		 <    <Left>	 Normal and Visual
         * 		 >    <Right>	 Normal and Visual
         * 		 ~    "~"	 Normal
         * 		 [    <Left>	 Insert and Replace
         * 		 ]    <Right>	 Insert and Replace
         * 	For example: >
         * 		:set ww=<,>,[,]
         * <	allows wrap only when cursor keys are used.
         * 	When the movement keys are used in combination with a delete or change
         * 	operator, the <EOL> also counts for a character.  This makes "3h"
         * 	different from "3dh" when the cursor crosses the end of a line.  This
         * 	is also true for "x" and "X", because they do the same as "dl" and
         * 	"dh".  If you use this, you may also want to use the mapping
         * 	":map <BS> X" to make backspace delete the character in front of the
         * 	cursor.
         * 	When `'l'`  is included and it is used after an operator at the end of a
         * 	line (not an empty line) then it will not move to the next line.  This
         * 	makes "dl", "cl", "yl" etc. work normally.
         */
        whichwrap: string

        /**
         * `'wildchar'`  `'wc'` 		number	(default: <Tab>)
         * 			global
         * 	Character you have to type to start wildcard expansion in the
         * 	command-line, as specified with `'wildmode'` .
         * 	More info here: |cmdline-completion|.
         * 	The character is not recognized when used inside a macro.  See
         * 	`'wildcharm'`  for that.
         * 	Some keys will not work, such as CTRL-C, <CR> and Enter.
         * 	Although `'wc'`  is a number option, you can set it to a special key: >
         * 		:set wc=<Tab>
         * <
         */
        wildchar: number

        /**
         * `'wildcharm'`  `'wcm'` 	number	(default: none (0))
         * 			global
         * 	`'wildcharm'`  works exactly like `'wildchar'` , except that it is
         * 	recognized when used inside a macro.  You can find "spare" command-line
         * 	keys suitable for this option by looking at |ex-edit-index|.  Normally
         * 	you'll never actually type `'wildcharm'` , just use it in mappings that
         * 	automatically invoke completion mode, e.g.: >
         * 		:set wcm=<C-Z>
         * 		:cnoremap ss so $vim/sessions/*.vim<C-Z>
         * <	Then after typing :ss you can use CTRL-P & CTRL-N.
         */
        wildcharm: number

        /**
         * `'wildignore'`  `'wig'` 	string	(default "")
         * 			global
         * 	A list of file patterns.  A file that matches with one of these
         * 	patterns is ignored when expanding |wildcards|, completing file or
         * 	directory names, and influences the result of |expand()|, |glob()| and
         * 	|globpath()| unless a flag is passed to disable this.
         * 	The pattern is used like with |:autocmd|, see |autocmd-pattern|.
         * 	Also see `'suffixes'` .
         * 	Example: >
         * 		:set wildignore=.obj
         * <	The use of |:set+=| and |:set-=| is preferred when adding or removing
         * 	a pattern from the list.  This avoids problems when a future version
         * 	uses another default.
         */
        wildignore: string

        /**
         * `'wildignorecase'`  `'wic'` 	boolean	(default off)
         * 			global
         * 	When set case is ignored when completing file names and directories.
         * 	Has no effect when `'fileignorecase'`  is set.
         * 	Does not apply when the shell is used to expand wildcards, which
         * 	happens when there are special characters.
         */
        wildignorecase: boolean

        /**
         * `'wildmenu'`  `'wmnu'` 	boolean	(default on)
         * 			global
         * 	When `'wildmenu'`  is on, command-line completion operates in an enhanced
         * 	mode.  On pressing `'wildchar'`  (usually <Tab>) to invoke completion,
         * 	the possible matches are shown.
         * 	When `'wildoptions'`  contains "pum", then the completion matches are
         * 	shown in a popup menu.  Otherwise they are displayed just above the
         * 	command line, with the first match highlighted (overwriting the status
         * 	line, if there is one).
         * 	Keys that show the previous/next match, such as <Tab> or
         * 	CTRL-P/CTRL-N, cause the highlight to move to the appropriate match.
         * 	`'wildmode'`  must specify "full": "longest" and "list" do not start
         * 	`'wildmenu'`  mode. You can check the current mode with |wildmenumode()|.
         * 	The menu is cancelled when a key is hit that is not used for selecting
         * 	a completion.
         * 
         * 	While the menu is active these keys have special meanings:
         * 
         * 	CTRL-Y		- accept the currently selected match and stop
         * 			  completion.
         * 	CTRL-E		- end completion, go back to what was there before
         * 			  selecting a match.
         * 	<Left> <Right>	- select previous/next match (like CTRL-P/CTRL-N)
         * 	<Down>		- in filename/menu name completion: move into a
         * 			  subdirectory or submenu.
         * 	<CR>		- in menu completion, when the cursor is just after a
         * 			  dot: move into a submenu.
         * 	<Up>		- in filename/menu name completion: move up into
         * 			  parent directory or parent menu.
         * 
         * 	If you want <Left> and <Right> to move the cursor instead of selecting
         * 	a different match, use this: >
         * 		:cnoremap <Left> <Space><BS><Left>
         * 		:cnoremap <Right> <Space><BS><Right>
         * <
         * 	|hl-WildMenu| highlights the current match.
         */
        wildmenu: boolean

        /**
         * `'wildmode'`  `'wim'` 	string	(default: "full")
         * 			global
         * 	Completion mode that is used for the character specified with
         * 	`'wildchar'` .  It is a comma-separated list of up to four parts.  Each
         * 	part specifies what to do for each consecutive use of `'wildchar'` .  The
         * 	first part specifies the behavior for the first use of `'wildchar'` ,
         * 	The second part for the second use, etc.
         * 
         * 	Each part consists of a colon separated list consisting of the
         * 	following possible values:
         * 	""		Complete only the first match.
         * 	"full"		Complete the next full match.  After the last match,
         * 			the original string is used and then the first match
         * 			again.  Will also start `'wildmenu'`  if it is enabled.
         * 	"longest"	Complete till longest common string.  If this doesn't
         * 			result in a longer string, use the next part.
         * 	"list"		When more than one match, list all matches.
         * 	"lastused"	When completing buffer names and more than one buffer
         * 			matches, sort buffers by time last used (other than
         * 			the current buffer).
         * 	When there is only a single match, it is fully completed in all cases.
         * 
         * 	Examples of useful colon-separated values:
         * 	"longest:full"	Like "longest", but also start `'wildmenu'`  if it is
         * 			enabled.  Will not complete to the next full match.
         * 	"list:full"	When more than one match, list all matches and
         * 			complete first match.
         * 	"list:longest"	When more than one match, list all matches and
         * 			complete till longest common string.
         * 	"list:lastused" When more than one buffer matches, list all matches
         * 			and sort buffers by time last used (other than the
         * 			current buffer).
         * 
         * 	Examples: >
         * 		:set wildmode=full
         * <	Complete first full match, next match, etc.  (the default) >
         * 		:set wildmode=longest,full
         * <	Complete longest common string, then each full match >
         * 		:set wildmode=list:full
         * <	List all matches and complete each full match >
         * 		:set wildmode=list,full
         * <	List all matches without completing, then each full match >
         * 		:set wildmode=longest,list
         * <	Complete longest common string, then list alternatives.
         * 	More info here: |cmdline-completion|.
         */
        wildmode: string

        /**
         * `'wildoptions'`  `'wop'` 	string	(default "pum,tagfile")
         * 			global
         * 	A list of words that change how |cmdline-completion| is done.
         * 	The following values are supported:
         * 	  fuzzy		Use |fuzzy-matching| to find completion matches. When
         * 			this value is specified, wildcard expansion will not
         * 			be used for completion.  The matches will be sorted by
         * 			the "best match" rather than alphabetically sorted.
         * 			This will find more matches than the wildcard
         * 			expansion. Currently fuzzy matching based completion
         * 			is not supported for file and directory names and
         * 			instead wildcard expansion is used.
         * 	  pum		Display the completion matches using the popup menu
         * 			in the same style as the |ins-completion-menu|.
         * 	  tagfile	When using CTRL-D to list matching tags, the kind of
         * 			tag and the file of the tag is listed.	Only one match
         * 			is displayed per line.  Often used tag kinds are:
         * 				d	#define
         * 				f	function
         */
        wildoptions: string

        /**
         * `'winaltkeys'`  `'wak'` 	string	(default "menu")
         * 			global
         * 			{only used in Win32}
         * 	Some GUI versions allow the access to menu entries by using the ALT
         * 	key in combination with a character that appears underlined in the
         * 	menu.  This conflicts with the use of the ALT key for mappings and
         * 	entering special characters.  This option tells what to do:
         * 	  no	Don't use ALT keys for menus.  ALT key combinations can be
         * 		mapped, but there is no automatic handling.
         * 	  yes	ALT key handling is done by the windowing system.  ALT key
         * 		combinations cannot be mapped.
         * 	  menu	Using ALT in combination with a character that is a menu
         * 		shortcut key, will be handled by the windowing system.  Other
         * 		keys can be mapped.
         * 	If the menu is disabled by excluding `'m'`  from `'guioptions'` , the ALT
         * 	key is never used for the menu.
         * 	This option is not used for <F10>; on Win32.
         */
        winaltkeys: string

        /**
         * `'window'`  `'wi'` 		number  (default screen height - 1)
         * 			global
         * 	Window height used for |CTRL-F| and |CTRL-B| when there is only one
         * 	window and the value is smaller than `'lines'`  minus one.  The screen
         * 	will scroll `'window'`  minus two lines, with a minimum of one.
         * 	When `'window'`  is equal to `'lines'`  minus one CTRL-F and CTRL-B scroll
         * 	in a much smarter way, taking care of wrapping lines.
         * 	When resizing the Vim window, the value is smaller than 1 or more than
         * 	or equal to `'lines'`  it will be set to `'lines'`  minus 1.
         * 	Note: Do not confuse this with the height of the Vim window, use
         * 	`'lines'`  for that.
         */
        window: number

        /**
         * `'winheight'`  `'wh'` 	number	(default 1)
         * 			global
         * 	Minimal number of lines for the current window.  This is not a hard
         * 	minimum, Vim will use fewer lines if there is not enough room.  If the
         * 	focus goes to a window that is smaller, its size is increased, at the
         * 	cost of the height of other windows.
         * 	Set `'winheight'`  to a small number for normal editing.
         * 	Set it to 999 to make the current window fill most of the screen.
         * 	Other windows will be only `'winminheight'`  high.  This has the drawback
         * 	that ":all" will create only two windows.  To avoid "vim -o 1 2 3 4"
         * 	to create only two windows, set the option after startup is done,
         * 	using the |VimEnter| event: >
         * 		au VimEnter * set winheight=999
         * <	Minimum value is 1.
         * 	The height is not adjusted after one of the commands that change the
         * 	height of the current window.
         * 	`'winheight'`  applies to the current window.  Use `'winminheight'`  to set
         * 	the minimal height for other windows.
         */
        winheight: number

        /**
         * `'winminheight'`  `'wmh'` 	number	(default 1)
         * 			global
         * 	The minimal height of a window, when it's not the current window.
         * 	This is a hard minimum, windows will never become smaller.
         * 	When set to zero, windows may be "squashed" to zero lines (i.e. just a
         * 	status bar) if necessary.  They will return to at least one line when
         * 	they become active (since the cursor has to have somewhere to go.)
         * 	Use `'winheight'`  to set the minimal height of the current window.
         * 	This option is only checked when making a window smaller.  Don't use a
         * 	large number, it will cause errors when opening more than a few
         * 	windows.  A value of 0 to 3 is reasonable.
         */
        winminheight: number

        /**
         * `'winminwidth'`  `'wmw'` 	number	(default 1)
         * 			global
         * 	The minimal width of a window, when it's not the current window.
         * 	This is a hard minimum, windows will never become smaller.
         * 	When set to zero, windows may be "squashed" to zero columns (i.e. just
         * 	a vertical separator) if necessary.  They will return to at least one
         * 	line when they become active (since the cursor has to have somewhere
         * 	to go.)
         * 	Use `'winwidth'`  to set the minimal width of the current window.
         * 	This option is only checked when making a window smaller.  Don't use a
         * 	large number, it will cause errors when opening more than a few
         * 	windows.  A value of 0 to 12 is reasonable.
         */
        winminwidth: number

        /**
         * `'winwidth'`  `'wiw'` 	number	(default 20)
         * 			global
         * 	Minimal number of columns for the current window.  This is not a hard
         * 	minimum, Vim will use fewer columns if there is not enough room.  If
         * 	the current window is smaller, its size is increased, at the cost of
         * 	the width of other windows.  Set it to 999 to make the current window
         * 	always fill the screen.  Set it to a small number for normal editing.
         * 	The width is not adjusted after one of the commands to change the
         * 	width of the current window.
         * 	`'winwidth'`  applies to the current window.  Use `'winminwidth'`  to set
         * 	the minimal width for other windows.
         */
        winwidth: number

        /**
         * `'wrapscan'`  `'ws'` 		boolean	(default on)
         * 			global
         * 	Searches wrap around the end of the file.  Also applies to |]s| and
         * 	|[s|, searching for spelling mistakes.
         */
        wrapscan: boolean

        /**
         * `'write'` 			boolean	(default on)
         * 			global
         * 	Allows writing files.  When not set, writing a file is not allowed.
         * 	Can be used for a view-only mode, where modifications to the text are
         * 	still allowed.  Can be reset with the |-m| or |-M| command line
         * 	argument.  Filtering text is still possible, even though this requires
         * 	writing a temporary file.
         */
        write: boolean

        /**
         * `'writeany'`  `'wa'` 		boolean	(default off)
         * 			global
         * 	Allows writing to any file with no need for "!" override.
         */
        writeany: boolean

        /**
         * `'writebackup'`  `'wb'` 	boolean	(default on)
         * 			global
         * 	Make a backup before overwriting a file.  The backup is removed after
         * 	the file was successfully written, unless the `'backup'`  option is
         * 	also on.
         * 	WARNING: Switching this option off means that when Vim fails to write
         * 	your buffer correctly and then, for whatever reason, Vim exits, you
         * 	lose both the original file and what you were writing.  Only reset
         * 	this option if your file system is almost full and it makes the write
         * 	fail (and make sure not to exit Vim until the write was successful).
         * 	See |backup-table| for another explanation.
         * 	When the `'backupskip'`  pattern matches, a backup is not made anyway.
         * 	Depending on `'backupcopy'`  the backup is a new file or the original
         * 	file renamed (and a new file is written).
         */
        writebackup: boolean

        writedelay: number
    }

    export const go: go;

    /** @noSelf **/
    interface wo {
        /**
         * `'arabic'`  `'arab'` 		boolean (default off)
         * 			local to window
         * 	This option can be set to start editing Arabic text.
         * 	Setting this option will:
         * 	- Set the `'rightleft'`  option, unless `'termbidi'`  is set.
         * 	- Set the `'arabicshape'`  option, unless `'termbidi'`  is set.
         * 	- Set the `'keymap'`  option to "arabic"; in Insert mode CTRL-^ toggles
         * 	  between typing English and Arabic key mapping.
         * 	- Set the `'delcombine'`  option
         * 
         * 	Resetting this option will:
         * 	- Reset the `'rightleft'`  option.
         * 	- Disable the use of `'keymap'`  (without changing its value).
         * 	Note that `'arabicshape'`  and `'delcombine'`  are not reset (it is a global
         * 	option).
         * 	Also see |arabic.txt|.
         */
        arabic: boolean

        /**
         * `'breakindent'`  `'bri'` 	boolean (default off)
         * 			local to window
         * 	Every wrapped line will continue visually indented (same amount of
         * 	space as the beginning of that line), thus preserving horizontal blocks
         * 	of text.
         */
        breakindent: boolean

        /**
         * `'breakindentopt'`  `'briopt'`  string (default empty)
         * 			local to window
         * 	Settings for `'breakindent'` . It can consist of the following optional
         * 	items and must be separated by a comma:
         * 		min:{n}	    Minimum text width that will be kept after
         * 			    applying `'breakindent'` , even if the resulting
         * 			    text should normally be narrower. This prevents
         * 			    text indented almost to the right window border
         * 			    occupying lot of vertical space when broken.
         * 			    (default: 20)
         * 		shift:{n}   After applying `'breakindent'` , the wrapped line's
         * 			    beginning will be shifted by the given number of
         * 			    characters.  It permits dynamic French paragraph
         * 			    indentation (negative) or emphasizing the line
         * 			    continuation (positive).
         * 			    (default: 0)
         * 		sbr	    Display the `'showbreak'`  value before applying the
         * 			    additional indent.
         * 			    (default: off)
         * 		list:{n}    Adds an additional indent for lines that match a
         * 			    numbered or bulleted list (using the
         * 			    `'formatlistpat'`  setting).
         * 		list:-1	    Uses the length of a match with `'formatlistpat'` 
         * 			    for indentation.
         * 			    (default: 0)
         * 		column:{n}  Indent at column {n}. Will overrule the other
         * 			    sub-options. Note: an additional indent may be
         * 			    added for the `'showbreak'`  setting.
         * 			    (default: off)
         */
        breakindentopt: string

        /**
         * `'colorcolumn'`  `'cc'` 	string	(default "")
         * 			local to window
         * 	`'colorcolumn'`  is a comma-separated list of screen columns that are
         * 	highlighted with ColorColumn |hl-ColorColumn|.  Useful to align
         * 	text.  Will make screen redrawing slower.
         * 	The screen column can be an absolute number, or a number preceded with
         * 	`'+'`  or `'-'` , which is added to or subtracted from `'textwidth'` . >
         * 
         * 		:set cc=+1  " highlight column after `'textwidth'` 
         * 		:set cc=+1,+2,+3  " highlight three columns after `'textwidth'` 
         * 		:hi ColorColumn ctermbg=lightgrey guibg=lightgrey
         * <
         * 	When `'textwidth'`  is zero then the items with `'-'`  and `'+'`  are not used.
         * 	A maximum of 256 columns are highlighted.
         */
        colorcolumn: string

        /**
         * `'concealcursor'`  `'cocu'` 	string (default: "")
         * 			local to window
         * 	Sets the modes in which text in the cursor line can also be concealed.
         * 	When the current mode is listed then concealing happens just like in
         * 	other lines.
         * 	  n		Normal mode
         * 	  v		Visual mode
         * 	  i		Insert mode
         * 	  c		Command line editing, for `'incsearch'` 
         * 
         * 	`'v'`  applies to all lines in the Visual area, not only the cursor.
         * 	A useful value is "nc".  This is used in help files.  So long as you
         * 	are moving around text is concealed, but when starting to insert text
         * 	or selecting a Visual area the concealed text is displayed, so that
         * 	you can see what you are doing.
         * 	Keep in mind that the cursor position is not always where it's
         * 	displayed.  E.g., when moving vertically it may change column.
         */
        concealcursor: string

        /**
         * `'conceallevel'`  `'cole'` 	number (default 0)
         * 			local to window
         * 	Determine how text with the "conceal" syntax attribute |:syn-conceal|
         * 	is shown:
         * 
         * 	Value		Effect ~
         * 	0		Text is shown normally
         * 	1		Each block of concealed text is replaced with one
         * 			character.  If the syntax item does not have a custom
         * 			replacement character defined (see |:syn-cchar|) the
         * 			character defined in `'listchars'`  is used.
         * 			It is highlighted with the "Conceal" highlight group.
         * 	2		Concealed text is completely hidden unless it has a
         * 			custom replacement character defined (see
         * 			|:syn-cchar|).
         * 	3		Concealed text is completely hidden.
         * 
         * 	Note: in the cursor line concealed text is not hidden, so that you can
         * 	edit and copy the text.  This can be changed with the `'concealcursor'` 
         * 	option.
         */
        conceallevel: number

        /**
         * `'cursorbind'`  `'crb'` 	boolean  (default off)
         * 			local to window
         * 	When this option is set, as the cursor in the current
         * 	window moves other cursorbound windows (windows that also have
         * 	this option set) move their cursors to the corresponding line and
         * 	column.  This option is useful for viewing the
         * 	differences between two versions of a file (see `'diff'` ); in diff mode,
         * 	inserted and deleted lines (though not characters within a line) are
         * 	taken into account.
         */
        cursorbind: boolean

        /**
         * `'cursorcolumn'`  `'cuc'` 	boolean	(default off)
         * 			local to window
         * 	Highlight the screen column of the cursor with CursorColumn
         * 	|hl-CursorColumn|.  Useful to align text.  Will make screen redrawing
         * 	slower.
         * 	If you only want the highlighting in the current window you can use
         * 	these autocommands: >
         * 		au WinLeave * set nocursorline nocursorcolumn
         * 		au WinEnter * set cursorline cursorcolumn
         * <
         */
        cursorcolumn: boolean

        /**
         * `'cursorline'`  `'cul'` 	boolean	(default off)
         * 			local to window
         * 	Highlight the text line of the cursor with CursorLine |hl-CursorLine|.
         * 	Useful to easily spot the cursor.  Will make screen redrawing slower.
         * 	When Visual mode is active the highlighting isn't used to make it
         * 	easier to see the selected text.
         */
        cursorline: boolean

        /**
         * `'cursorlineopt'`  `'culopt'`  string (default: "number,line")
         * 			local to window
         * 	Comma-separated list of settings for how `'cursorline'`  is displayed.
         * 	Valid values:
         * 	"line"		Highlight the text line of the cursor with
         * 			CursorLine |hl-CursorLine|.
         * 	"screenline"	Highlight only the screen line of the cursor with
         * 			CursorLine |hl-CursorLine|.
         * 	"number"	Highlight the line number of the cursor with
         * 			CursorLineNr |hl-CursorLineNr|.
         * 
         * 	Special value:
         * 	"both"		Alias for the values "line,number".
         * 
         * 	"line" and "screenline" cannot be used together.
         */
        cursorlineopt: string

        /**
         * `'diff'` 			boolean	(default off)
         * 			local to window
         * 	Join the current window in the group of windows that shows differences
         * 	between files.  See |diff-mode|.
         */
        diff: boolean

        /**
         * `'fillchars'`  `'fcs'` 	string	(default "")
         * 			global or local to window |global-local|
         * 	Characters to fill the statuslines, vertical separators and special
         * 	lines in the window.
         * 	It is a comma-separated list of items.  Each item has a name, a colon
         * 	and the value of that item:
         * 
         * 	  item		default		Used for ~
         * 	  stl		' ' or `'^'` 	statusline of the current window
         * 	  stlnc		' ' or `'='` 	statusline of the non-current windows
         * 	  wbr		' '		window bar
         * 	  horiz		`'─'`  or `'-'` 	horizontal separators |:split|
         * 	  horizup	`'┴'`  or `'-'` 	upwards facing horizontal separator
         * 	  horizdown	`'┬'`  or `'-'` 	downwards facing horizontal separator
         * 	  vert		`'│'`  or `'|'` 	vertical separators |:vsplit|
         * 	  vertleft	`'┤'`  or `'|'` 	left facing vertical separator
         * 	  vertright	`'├'`  or `'|'` 	right facing vertical separator
         * 	  verthoriz	`'┼'`  or `'+'` 	overlapping vertical and horizontal
         * 					separator
         * 	  fold		`'·'`  or `'-'` 	filling `'foldtext'` 
         * 	  foldopen	`'-'` 		mark the beginning of a fold
         * 	  foldclose	`'+'` 		show a closed fold
         * 	  foldsep	`'│'`  or `'|'`       open fold middle marker
         * 	  diff		`'-'` 		deleted lines of the `'diff'`  option
         * 	  msgsep	' '		message separator `'display'` 
         * 	  eob		`'~'` 		empty lines at the end of a buffer
         * 	  lastline	`'@'` 		`'display'`  contains lastline/truncate
         * 
         * 	Any one that is omitted will fall back to the default.  For "stl" and
         * 	"stlnc" the space will be used when there is highlighting, `'^'`  or `'='` 
         * 	otherwise.
         * 
         * 	Note that "horiz", "horizup", "horizdown", "vertleft", "vertright" and
         * 	"verthoriz" are only used when `'laststatus'`  is 3, since only vertical
         * 	window separators are used otherwise.
         * 
         * 	If `'ambiwidth'`  is "double" then "horiz", "horizup", "horizdown",
         * 	"vert", "vertleft", "vertright", "verthoriz", "foldsep" and "fold"
         * 	default to single-byte alternatives.
         * 
         * 	Example: >
         * 	    :set fillchars=stl:^,stlnc:=,vert:│,fold:·,diff:-
         * <	This is similar to the default, except that these characters will also
         * 	be used when there is highlighting.
         * 
         * 	For the "stl", "stlnc", "foldopen", "foldclose" and "foldsep" items
         * 	single-byte and multibyte characters are supported.  But double-width
         * 	characters are not supported.
         * 
         * 	The highlighting used for these items:
         * 	  item		highlight group ~
         * 	  stl		StatusLine		|hl-StatusLine|
         * 	  stlnc		StatusLineNC		|hl-StatusLineNC|
         * 	  wbr		WinBar			|hl-WinBar| or |hl-WinBarNC|
         * 	  horiz		WinSeparator		|hl-WinSeparator|
         * 	  horizup	WinSeparator		|hl-WinSeparator|
         * 	  horizdown	WinSeparator		|hl-WinSeparator|
         * 	  vert		WinSeparator		|hl-WinSeparator|
         * 	  vertleft	WinSeparator		|hl-WinSeparator|
         * 	  vertright	WinSeparator		|hl-WinSeparator|
         * 	  verthoriz	WinSeparator		|hl-WinSeparator|
         * 	  fold		Folded			|hl-Folded|
         * 	  diff		DiffDelete		|hl-DiffDelete|
         * 	  eob		EndOfBuffer		|hl-EndOfBuffer|
         * 	  lastline	NonText			|hl-NonText|
         */
        fillchars: string

        /**
         * `'foldcolumn'`  `'fdc'` 	string (default "0")
         * 			local to window
         * 	When and how to draw the foldcolumn. Valid values are:
         * 	    "auto":       resize to the minimum amount of folds to display.
         * 	    "auto:[1-9]": resize to accommodate multiple folds up to the
         * 			  selected level
         *             0:            to disable foldcolumn
         * 	    "[1-9]":      to display a fixed number of columns
         * 	See |folding|.
         */
        foldcolumn: string

        /**
         * `'foldenable'`  `'fen'` 	boolean (default on)
         * 			local to window
         * 	When off, all folds are open.  This option can be used to quickly
         * 	switch between showing all text unfolded and viewing the text with
         * 	folds (including manually opened or closed folds).  It can be toggled
         * 	with the |zi| command.  The `'foldcolumn'`  will remain blank when
         * 	`'foldenable'`  is off.
         * 	This option is set by commands that create a new fold or close a fold.
         * 	See |folding|.
         */
        foldenable: boolean

        /**
         * `'foldexpr'`  `'fde'` 	string (default: "0")
         * 			local to window
         * 	The expression used for when `'foldmethod'`  is "expr".  It is evaluated
         * 	for each line to obtain its fold level.  See |fold-expr|.
         * 
         * 	The expression will be evaluated in the |sandbox| if set from a
         * 	modeline, see |sandbox-option|.
         * 	This option can't be set from a |modeline| when the `'diff'`  option is
         * 	on or the `'modelineexpr'`  option is off.
         * 
         * 	It is not allowed to change text or jump to another window while
         * 	evaluating `'foldexpr'`  |textlock|.
         */
        foldexpr: string

        /**
         * `'foldignore'`  `'fdi'` 	string (default: "#")
         * 			local to window
         * 	Used only when `'foldmethod'`  is "indent".  Lines starting with
         * 	characters in `'foldignore'`  will get their fold level from surrounding
         * 	lines.  White space is skipped before checking for this character.
         * 	The default "#" works well for C programs.  See |fold-indent|.
         */
        foldignore: string

        /**
         * `'foldlevel'`  `'fdl'` 	number (default: 0)
         * 			local to window
         * 	Sets the fold level: Folds with a higher level will be closed.
         * 	Setting this option to zero will close all folds.  Higher numbers will
         * 	close fewer folds.
         * 	This option is set by commands like |zm|, |zM| and |zR|.
         * 	See |fold-foldlevel|.
         */
        foldlevel: number

        /**
         * `'foldmarker'`  `'fmr'` 	string (default: "{{{,}}}")
         * 			local to window
         * 	The start and end marker used when `'foldmethod'`  is "marker".  There
         * 	must be one comma, which separates the start and end marker.  The
         * 	marker is a literal string (a regular expression would be too slow).
         * 	See |fold-marker|.
         */
        foldmarker: string

        /**
         * `'foldmethod'`  `'fdm'` 	string (default: "manual")
         * 			local to window
         * 	The kind of folding used for the current window.  Possible values:
         * 	|fold-manual|	manual	    Folds are created manually.
         * 	|fold-indent|	indent	    Lines with equal indent form a fold.
         * 	|fold-expr|	expr	    `'foldexpr'`  gives the fold level of a line.
         * 	|fold-marker|	marker	    Markers are used to specify folds.
         * 	|fold-syntax|	syntax	    Syntax highlighting items specify folds.
         * 	|fold-diff|	diff	    Fold text that is not changed.
         */
        foldmethod: string

        /**
         * `'foldminlines'`  `'fml'` 	number (default: 1)
         * 			local to window
         * 	Sets the number of screen lines above which a fold can be displayed
         * 	closed.  Also for manually closed folds.  With the default value of
         * 	one a fold can only be closed if it takes up two or more screen lines.
         * 	Set to zero to be able to close folds of just one screen line.
         * 	Note that this only has an effect on what is displayed.  After using
         * 	"zc" to close a fold, which is displayed open because it's smaller
         * 	than `'foldminlines'` , a following "zc" may close a containing fold.
         */
        foldminlines: number

        /**
         * `'foldnestmax'`  `'fdn'` 	number (default: 20)
         * 			local to window
         * 	Sets the maximum nesting of folds for the "indent" and "syntax"
         * 	methods.  This avoids that too many folds will be created.  Using more
         * 	than 20 doesn't work, because the internal limit is 20.
         */
        foldnestmax: number

        /**
         * `'foldtext'`  `'fdt'` 	string (default: "foldtext()")
         * 			local to window
         * 	An expression which is used to specify the text displayed for a closed
         * 	fold.  See |fold-foldtext|.
         * 
         * 	The expression will be evaluated in the |sandbox| if set from a
         * 	modeline, see |sandbox-option|.
         * 	This option cannot be set in a modeline when `'modelineexpr'`  is off.
         * 
         * 	It is not allowed to change text or jump to another window while
         * 	evaluating `'foldtext'`  |textlock|.
         */
        foldtext: string

        /**
         * `'linebreak'`  `'lbr'` 	boolean	(default off)
         * 			local to window
         * 	If on, Vim will wrap long lines at a character in `'breakat'`  rather
         * 	than at the last character that fits on the screen.  Unlike
         * 	`'wrapmargin'`  and `'textwidth'` , this does not insert <EOL>s in the file,
         * 	it only affects the way the file is displayed, not its contents.
         * 	If `'breakindent'`  is set, line is visually indented. Then, the value
         * 	of `'showbreak'`  is used to put in front of wrapped lines. This option
         * 	is not used when the `'wrap'`  option is off.
         * 	Note that <Tab> characters after an <EOL> are mostly not displayed
         * 	with the right amount of white space.
         */
        linebreak: boolean

        /**
         * `'list'` 			boolean	(default off)
         * 			local to window
         * 	List mode: By default, show tabs as ">", trailing spaces as "-", and
         * 	non-breakable space characters as "+". Useful to see the difference
         * 	between tabs and spaces and for trailing blanks. Further changed by
         * 	the `'listchars'`  option.
         * 
         * 	The cursor is displayed at the start of the space a Tab character
         * 	occupies, not at the end as usual in Normal mode.  To get this cursor
         * 	position while displaying Tabs with spaces, use: >
         * 		:set list lcs=tab:\ \
         * <
         * 	Note that list mode will also affect formatting (set with `'textwidth'` 
         * 	or `'wrapmargin'` ) when `'cpoptions'`  includes `'L'` .  See `'listchars'`  for
         * 	changing the way tabs are displayed.
         */
        list: boolean

        /**
         * `'listchars'`  `'lcs'` 	string	(default: "tab:> ,trail:-,nbsp:+")
         * 			global or local to window |global-local|
         * 	Strings to use in `'list'`  mode and for the |:list| command.  It is a
         * 	comma-separated list of string settings.
         * 
         * 
         * 	  eol:c		Character to show at the end of each line.  When
         * 			omitted, there is no extra character at the end of the
         * 			line.
         * 
         * 	  tab:xy[z]	Two or three characters to be used to show a tab.
         * 			The third character is optional.
         * 
         * 	  tab:xy	The `'x'`  is always used, then `'y'`  as many times as will
         * 			fit.  Thus "tab:>-" displays: >
         * 				>
         * 				>-
         * 				>--
         * 				etc.
         * <
         * 	  tab:xyz	The `'z'`  is always used, then `'x'`  is prepended, and
         * 			then `'y'`  is used as many times as will fit.  Thus
         * 			"tab:<->" displays: >
         * 				>
         * 				<>
         * 				<->
         * 				<-->
         * 				etc.
         * <
         * 			When "tab:" is omitted, a tab is shown as ^I.
         * 
         * 	  space:c	Character to show for a space.  When omitted, spaces
         * 			are left blank.
         * 
         * 	  multispace:c...
         * 			One or more characters to use cyclically to show for
         * 			multiple consecutive spaces.  Overrides the "space"
         * 			setting, except for single spaces.  When omitted, the
         * 			"space" setting is used.  For example,
         * 			`:set listchars=multispace:---+` shows ten consecutive
         * 			spaces as: >
         * 				---+---+--
         * <
         * 
         * 	  lead:c	Character to show for leading spaces.  When omitted,
         * 			leading spaces are blank.  Overrides the "space" and
         * 			"multispace" settings for leading spaces.  You can
         * 			combine it with "tab:", for example: >
         * 				:set listchars+=tab:>-,lead:.
         * <
         * 
         * 	  leadmultispace:c...
         * 			Like the |lcs-multispace| value, but for leading
         * 			spaces only.  Also overrides |lcs-lead| for leading
         * 			multiple spaces.
         * 			`:set listchars=leadmultispace:---+` shows ten
         * 			consecutive leading spaces as: >
         * 				---+---+--XXX
         * <
         * 			Where "XXX" denotes the first non-blank characters in
         * 			the line.
         * 
         * 	  trail:c	Character to show for trailing spaces.  When omitted,
         * 			trailing spaces are blank.  Overrides the "space" and
         * 			"multispace" settings for trailing spaces.
         * 
         * 	  extends:c	Character to show in the last column, when `'wrap'`  is
         * 			off and the line continues beyond the right of the
         * 			screen.
         * 
         * 	  precedes:c	Character to show in the first visible column of the
         * 			physical line, when there is text preceding the
         * 			character visible in the first column.
         * 
         * 	  conceal:c	Character to show in place of concealed text, when
         * 			`'conceallevel'`  is set to 1.  A space when omitted.
         * 
         * 	  nbsp:c	Character to show for a non-breakable space character
         * 			(0xA0 (160 decimal) and U+202F).  Left blank when
         * 			omitted.
         * 
         * 	The characters `':'`  and `','`  should not be used.  UTF-8 characters can
         * 	be used.  All characters must be single width.
         * 
         * 	Each character can be specified as hex: >
         * 		set listchars=eol:\\x24
         * 		set listchars=eol:\\u21b5
         * 		set listchars=eol:\\U000021b5
         * <	Note that a double backslash is used.  The number of hex characters
         * 	must be exactly 2 for \\x, 4 for \\u and 8 for \\U.
         * 
         * 	Examples: >
         * 	    :set lcs=tab:>-,trail:-
         * 	    :set lcs=tab:>-,eol:<,nbsp:%
         * 	    :set lcs=extends:>,precedes:<
         * <	|hl-NonText| highlighting will be used for "eol", "extends" and
         * 	"precedes". |hl-Whitespace| for "nbsp", "space", "tab", "multispace",
         * 	"lead" and "trail".
         */
        listchars: string

        /**
         * `'number'`  `'nu'` 		boolean	(default off)
         * 			local to window
         * 	Print the line number in front of each line.  When the `'n'`  option is
         * 	excluded from `'cpoptions'`  a wrapped line will not use the column of
         * 	line numbers.
         * 	Use the `'numberwidth'`  option to adjust the room for the line number.
         * 	When a long, wrapped line doesn't start with the first character, `'-'` 
         * 	characters are put before the number.
         * 	For highlighting see |hl-LineNr|, |hl-CursorLineNr|, and the
         * 	|:sign-define| "numhl" argument.
         * 
         * 	The `'relativenumber'`  option changes the displayed number to be
         * 	relative to the cursor.  Together with `'number'`  there are these
         * 	four combinations (cursor in line 3):
         * 
         * 		`'nonu'`           `'nu'`             `'nonu'`           `'nu'` 
         * 		`'nornu'`          `'nornu'`          `'rnu'`            `'rnu'` 
         * >
         * 	    |apple          |  1 apple      |  2 apple      |  2 apple
         * 	    |pear           |  2 pear       |  1 pear       |  1 pear
         * 	    |nobody         |  3 nobody     |  0 nobody     |3   nobody
         * 	    |there          |  4 there      |  1 there      |  1 there
         * <
         */
        number: boolean

        /**
         * `'numberwidth'`  `'nuw'` 	number	(default: 4)
         * 			local to window
         * 	Minimal number of columns to use for the line number.  Only relevant
         * 	when the `'number'`  or `'relativenumber'`  option is set or printing lines
         * 	with a line number. Since one space is always between the number and
         * 	the text, there is one less character for the number itself.
         * 	The value is the minimum width.  A bigger width is used when needed to
         * 	fit the highest line number in the buffer respectively the number of
         * 	rows in the window, depending on whether `'number'`  or `'relativenumber'` 
         * 	is set. Thus with the Vim default of 4 there is room for a line number
         * 	up to 999. When the buffer has 1000 lines five columns will be used.
         * 	The minimum value is 1, the maximum value is 20.
         */
        numberwidth: number

        /**
         * `'previewwindow'`  `'pvw'` 	boolean (default off)
         * 			local to window
         * 	Identifies the preview window.  Only one window can have this option
         * 	set.  It's normally not set directly, but by using one of the commands
         * 	|:ptag|, |:pedit|, etc.
         */
        previewwindow: boolean

        /**
         * `'relativenumber'`  `'rnu'` 	boolean	(default off)
         * 			local to window
         * 	Show the line number relative to the line with the cursor in front of
         * 	each line. Relative line numbers help you use the |count| you can
         * 	precede some vertical motion commands (e.g. j k + -) with, without
         * 	having to calculate it yourself. Especially useful in combination with
         * 	other commands (e.g. y d c < > gq gw =).
         * 	When the `'n'`  option is excluded from `'cpoptions'`  a wrapped
         * 	line will not use the column of line numbers.
         * 	The `'numberwidth'`  option can be used to set the room used for the line
         * 	number.
         * 	When a long, wrapped line doesn't start with the first character, `'-'` 
         * 	characters are put before the number.
         * 	See |hl-LineNr|  and |hl-CursorLineNr| for the highlighting used for
         * 	the number.
         * 
         * 	The number in front of the cursor line also depends on the value of
         * 	`'number'` , see |number_relativenumber| for all combinations of the two
         * 	options.
         */
        relativenumber: boolean

        /**
         * `'rightleft'`  `'rl'` 	boolean	(default off)
         * 			local to window
         * 	When on, display orientation becomes right-to-left, i.e., characters
         * 	that are stored in the file appear from the right to the left.
         * 	Using this option, it is possible to edit files for languages that
         * 	are written from the right to the left such as Hebrew and Arabic.
         * 	This option is per window, so it is possible to edit mixed files
         * 	simultaneously, or to view the same file in both ways (this is
         * 	useful whenever you have a mixed text file with both right-to-left
         * 	and left-to-right strings so that both sets are displayed properly
         * 	in different windows).  Also see |rileft.txt|.
         */
        rightleft: boolean

        /**
         * `'rightleftcmd'`  `'rlc'` 	string	(default "search")
         * 			local to window
         * 	Each word in this option enables the command line editing to work in
         * 	right-to-left mode for a group of commands:
         * 
         * 		search		"/" and "?" commands
         * 
         * 	This is useful for languages such as Hebrew, Arabic and Farsi.
         * 	The `'rightleft'`  option must be set for `'rightleftcmd'`  to take effect.
         */
        rightleftcmd: string

        /**
         * `'scroll'`  `'scr'` 		number	(default: half the window height)
         * 			local to window
         * 	Number of lines to scroll with CTRL-U and CTRL-D commands.  Will be
         * 	set to half the number of lines in the window when the window size
         * 	changes.  This may happen when enabling the |status-line| or
         * 	`'tabline'`  option after setting the `'scroll'`  option.
         * 	If you give a count to the CTRL-U or CTRL-D command it will
         * 	be used as the new value for `'scroll'` .  Reset to half the window
         * 	height with ":set scroll=0".
         */
        scroll: number

        /**
         * `'scrollbind'`  `'scb'` 	boolean  (default off)
         * 			local to window
         * 	See also |scroll-binding|.  When this option is set, the current
         * 	window scrolls as other scrollbind windows (windows that also have
         * 	this option set) scroll.  This option is useful for viewing the
         * 	differences between two versions of a file, see `'diff'` .
         * 	See |`'scrollopt'` | for options that determine how this option should be
         * 	interpreted.
         * 	This option is mostly reset when splitting a window to edit another
         * 	file.  This means that ":split | edit file" results in two windows
         * 	with scroll-binding, but ":split file" does not.
         */
        scrollbind: boolean

        /**
         * `'scrolloff'`  `'so'` 	number	(default 0)
         * 			global or local to window |global-local|
         * 	Minimal number of screen lines to keep above and below the cursor.
         * 	This will make some context visible around where you are working.  If
         * 	you set it to a very large value (999) the cursor line will always be
         * 	in the middle of the window (except at the start or end of the file or
         * 	when long lines wrap).
         * 	After using the local value, go back the global value with one of
         * 	these two: >
         * 		setlocal scrolloff<
         * 		setlocal scrolloff=-1
         * <	For scrolling horizontally see `'sidescrolloff'` .
         */
        scrolloff: number

        /**
         * `'showbreak'`  `'sbr'` 	string	(default "")
         * 			global or local to window |global-local|
         * 	String to put at the start of lines that have been wrapped.  Useful
         * 	values are "> " or "+++ ": >
         * 		:set showbreak=>\
         * <	Note the backslash to escape the trailing space.  It's easier like
         * 	this: >
         * 		:let &showbreak = '+++ '
         * <	Only printable single-cell characters are allowed, excluding <Tab> and
         * 	comma (in a future version the comma might be used to separate the
         * 	part that is shown at the end and at the start of a line).
         * 	The |hl-NonText| highlight group determines the highlighting.
         * 	Note that tabs after the showbreak will be displayed differently.
         * 	If you want the `'showbreak'`  to appear in between line numbers, add the
         * 	"n" flag to `'cpoptions'` .
         * 	A window-local value overrules a global value.  If the global value is
         * 	set and you want no value in the current window use NONE: >
         * 		:setlocal showbreak=NONE
         * <
         */
        showbreak: string

        /**
         * `'sidescrolloff'`  `'siso'` 	number (default 0)
         * 			global or local to window |global-local|
         * 	The minimal number of screen columns to keep to the left and to the
         * 	right of the cursor if `'nowrap'`  is set.  Setting this option to a
         * 	value greater than 0 while having |`'sidescroll'` | also at a non-zero
         * 	value makes some context visible in the line you are scrolling in
         * 	horizontally (except at beginning of the line).  Setting this option
         * 	to a large value (like 999) has the effect of keeping the cursor
         * 	horizontally centered in the window, as long as one does not come too
         * 	close to the beginning of the line.
         * 	After using the local value, go back the global value with one of
         * 	these two: >
         * 		setlocal sidescrolloff<
         * 		setlocal sidescrolloff=-1
         * <
         * 	Example: Try this together with `'sidescroll'`  and `'listchars'`  as
         * 		 in the following example to never allow the cursor to move
         * 		 onto the "extends" character: >
         * 
         * 		 :set nowrap sidescroll=1 listchars=extends:>,precedes:<
         * 		 :set sidescrolloff=1
         * <
         */
        sidescrolloff: number

        /**
         * `'signcolumn'`  `'scl'` 	string	(default "auto")
         * 			local to window
         * 	When and how to draw the signcolumn. Valid values are:
         * 	   "auto"	only when there is a sign to display
         * 	   "auto:[1-9]" resize to accommodate multiple signs up to the
         * 	                given number (maximum 9), e.g. "auto:4"
         * 	   "auto:[1-8]-[2-9]"
         * 	                resize to accommodate multiple signs up to the
         * 			given maximum number (maximum 9) while keeping
         * 			at least the given minimum (maximum 8) fixed
         * 			space. The minimum number should always be less
         * 			than the maximum number, e.g. "auto:2-5"
         * 	   "no"		never
         * 	   "yes"	always
         * 	   "yes:[1-9]"  always, with fixed space for signs up to the given
         * 	                number (maximum 9), e.g. "yes:3"
         * 	   "number"	display signs in the `'number'`  column. If the number
         * 			column is not present, then behaves like "auto".
         * 
         * 	Note regarding "orphaned signs": with signcolumn numbers higher than
         * 	1, deleting lines will also remove the associated signs automatically,
         * 	in contrast to the default Vim behavior of keeping and grouping them.
         * 	This is done in order for the signcolumn appearance not appear weird
         * 	during line deletion.
         */
        signcolumn: string

        /**
         * `'spell'` 			boolean	(default off)
         * 			local to window
         * 	When on spell checking will be done.  See |spell|.
         * 	The languages are specified with `'spelllang'` .
         */
        spell: boolean

        /**
         * `'statuscolumn'`  `'stc'` 	string	(default: empty)
         * 			local to window
         * 	EXPERIMENTAL
         * 	When non-empty, this option determines the content of the area to the
         * 	side of a window, normally containing the fold, sign and number columns.
         * 	The format of this option is like that of `'statusline'` .
         * 
         * 	Some of the items from the `'statusline'`  format are different for
         * 	`'statuscolumn'` :
         * 
         * 	%l	line number of currently drawn line
         * 	%r	relative line number of currently drawn line
         * 	%s	sign column for currently drawn line
         * 	%C	fold column for currently drawn line
         * 
         * 	NOTE: To draw the sign and fold columns, their items must be included in
         * 	`'statuscolumn'` . Even when they are not included, the status column width
         * 	will adapt to the `'signcolumn'`  and `'foldcolumn'`  width.
         * 
         * 	The |v:lnum|    variable holds the line number to be drawn.
         * 	The |v:relnum|  variable holds the relative line number to be drawn.
         * 	The |v:virtnum| variable is negative when drawing virtual lines, zero
         * 		      when drawing the actual buffer line, and positive when
         * 		      drawing the wrapped part of a buffer line.
         * 
         * 	NOTE: The %@ click execute function item is supported as well but the
         * 	specified function will be the same for each row in the same column.
         * 	It cannot be switched out through a dynamic `'statuscolumn'`  format, the
         * 	handler should be written with this in mind.
         * 
         * 	Examples: >vim
         * 		" Relative number with bar separator and click handlers:
         * 		:set statuscolumn=%@SignCb@%s%=%T%@NumCb@%r│%T
         * 
         * 		" Right aligned relative cursor line number:
         * 		:let &stc='%=%{v:relnum?v:relnum:v:lnum} '
         * 
         * 		" Line numbers in hexadecimal for non wrapped part of lines:
         * 		:let &stc='%=%{v:virtnum>0?"":printf("%x",v:lnum)} '
         * 
         * 		" Human readable line numbers with thousands separator:
         * 		:let &stc=`'%{substitute(v:lnum,"\\d\\zs\\ze\\'` 
         * 			   . `'%(\\d\\d\\d\\)\\+$",",","g")}'` 
         * 
         * 		" Both relative and absolute line numbers with different
         * 		" highlighting for odd and even relative numbers:
         * 		:let &stc=`'%#NonText#%{&nu?v:lnum:""}'`  .
         * 		 '%=%{&rnu&&(v:lnum%2)?"\ ".v:relnum:""}' .
         * 		 '%#LineNr#%{&rnu&&!(v:lnum%2)?"\ ".v:relnum:""}'
         * 
         * <	WARNING: this expression is evaluated for each screen line so defining
         * 	an expensive expression can negatively affect render performance.
         */
        statuscolumn: string

        /**
         * `'statusline'`  `'stl'` 	string	(default empty)
         * 			global or local to window |global-local|
         * 	When non-empty, this option determines the content of the status line.
         * 	Also see |status-line|.
         * 
         * 	The option consists of printf style `'%'`  items interspersed with
         * 	normal text.  Each status line item is of the form:
         * 	  %-0{minwid}.{maxwid}{item}
         * 	All fields except the {item} are optional.  A single percent sign can
         * 	be given as "%%".
         * 
         * 	When the option starts with "%!" then it is used as an expression,
         * 	evaluated and the result is used as the option value.  Example: >
         * 		:set statusline=%!MyStatusLine()
         * <	The  variable will be set to the |window-ID| of the
         * 	window that the status line belongs to.
         * 	The result can contain %{} items that will be evaluated too.
         * 	Note that the "%!" expression is evaluated in the context of the
         * 	current window and buffer, while %{} items are evaluated in the
         * 	context of the window that the statusline belongs to.
         * 
         * 	When there is error while evaluating the option then it will be made
         * 	empty to avoid further errors.  Otherwise screen updating would loop.
         * 	When the result contains unprintable characters the result is
         * 	unpredictable.
         * 
         * 	Note that the only effect of `'ruler'`  when this option is set (and
         * 	`'laststatus'`  is 2 or 3) is controlling the output of |CTRL-G|.
         * 
         * 	field	    meaning ~
         * 	-	    Left justify the item.  The default is right justified
         * 		    when minwid is larger than the length of the item.
         * 	0	    Leading zeroes in numeric items.  Overridden by "-".
         * 	minwid	    Minimum width of the item, padding as set by "-" & "0".
         * 		    Value must be 50 or less.
         * 	maxwid	    Maximum width of the item.  Truncation occurs with a "<"
         * 		    on the left for text items.  Numeric items will be
         * 		    shifted down to maxwid-2 digits followed by ">"number
         * 		    where number is the amount of missing digits, much like
         * 		    an exponential notation.
         * 	item	    A one letter code as described below.
         * 
         * 	Following is a description of the possible statusline items.  The
         * 	second character in "item" is the type:
         * 		N for number
         * 		S for string
         * 		F for flags as described below
         * 		- not applicable
         * 
         * 	item  meaning ~
         * 	f S   Path to the file in the buffer, as typed or relative to current
         * 	      directory.
         * 	F S   Full path to the file in the buffer.
         * 	t S   File name (tail) of file in the buffer.
         * 	m F   Modified flag, text is "[+]"; "[-]" if `'modifiable'`  is off.
         * 	M F   Modified flag, text is ",+" or ",-".
         * 	r F   Readonly flag, text is "[RO]".
         * 	R F   Readonly flag, text is ",RO".
         * 	h F   Help buffer flag, text is "[help]".
         * 	H F   Help buffer flag, text is ",HLP".
         * 	w F   Preview window flag, text is "[Preview]".
         * 	W F   Preview window flag, text is ",PRV".
         * 	y F   Type of file in the buffer, e.g., "[vim]".  See `'filetype'` .
         * 	Y F   Type of file in the buffer, e.g., ",VIM".  See `'filetype'` .
         * 	q S   "[Quickfix List]", "[Location List]" or empty.
         * 	k S   Value of "b:keymap_name" or `'keymap'`  when |:lmap| mappings are
         * 	      being used: "<keymap>"
         * 	n N   Buffer number.
         * 	b N   Value of character under cursor.
         * 	B N   As above, in hexadecimal.
         * 	o N   Byte number in file of byte under cursor, first byte is 1.
         * 	      Mnemonic: Offset from start of file (with one added)
         * 	O N   As above, in hexadecimal.
         * 	l N   Line number.
         * 	L N   Number of lines in buffer.
         * 	c N   Column number (byte index).
         * 	v N   Virtual column number (screen column).
         * 	V N   Virtual column number as -{num}.  Not displayed if equal to `'c'` .
         * 	p N   Percentage through file in lines as in |CTRL-G|.
         * 	P S   Percentage through file of displayed window.  This is like the
         * 	      percentage described for `'ruler'` .  Always 3 in length, unless
         * 	      translated.
         * 	S S   `'showcmd'`  content, see `'showcmdloc'` .
         * 	a S   Argument list status as in default title.  ({current} of {max})
         * 	      Empty if the argument file count is zero or one.
         * 	{ NF  Evaluate expression between "%{" and "}" and substitute result.
         * 	      Note that there is no "%" before the closing "}".  The
         * 	      expression cannot contain a "}" character, call a function to
         * 	      work around that.  See |stl-%{| below.
         * 	`{%` -  This is almost same as "{" except the result of the expression is
         * 	      re-evaluated as a statusline format string.  Thus if the
         * 	      return value of expr contains "%" items they will get expanded.
         * 	      The expression can contain the "}" character, the end of
         * 	      expression is denoted by "%}".
         * 	      For example: >
         * 		func! Stl_filename() abort
         * 		    return "%t"
         * 		endfunc
         * <	        `stl=%{Stl_filename()}`   results in `"%t"`
         * 	        `stl=%{%Stl_filename()%}` results in `"Name of current file"`
         * 	%} -  End of "{%" expression
         * 	( -   Start of item group.  Can be used for setting the width and
         * 	      alignment of a section.  Must be followed by %) somewhere.
         * 	) -   End of item group.  No width fields allowed.
         * 	T N   For `'tabline'` : start of tab page N label.  Use %T or %X to end
         * 	      the label.  Clicking this label with left mouse button switches
         * 	      to the specified tab page.
         * 	X N   For `'tabline'` : start of close tab N label.  Use %X or %T to end
         * 	      the label, e.g.: %3Xclose%X.  Use %999X for a "close current
         * 	      tab" label.    Clicking this label with left mouse button closes
         * 	      specified tab page.
         * 	@ N   Start of execute function label. Use %X or %T to
         * 	      end the label, e.g.: %10@SwitchBuffer@foo.c%X.  Clicking this
         * 	      label runs specified function: in the example when clicking once
         * 	      using left mouse button on "foo.c" "SwitchBuffer(10, 1, `'l'` ,
         * 	      '    ')" expression will be run.  Function receives the
         * 	      following arguments in order:
         * 	      1. minwid field value or zero if no N was specified
         * 	      2. number of mouse clicks to detect multiple clicks
         * 	      3. mouse button used: "l", "r" or "m" for left, right or middle
         * 	         button respectively; one should not rely on third argument
         * 	         being only "l", "r" or "m": any other non-empty string value
         * 	         that contains only ASCII lower case letters may be expected
         * 	         for other mouse buttons
         * 	      4. modifiers pressed: string which contains "s" if shift
         * 	         modifier was pressed, "c" for control, "a" for alt and "m"
         * 	         for meta; currently if modifier is not pressed string
         * 	         contains space instead, but one should not rely on presence
         * 	         of spaces or specific order of modifiers: use |stridx()| to
         * 	         test whether some modifier is present; string is guaranteed
         * 	         to contain only ASCII letters and spaces, one letter per
         * 	         modifier; "?" modifier may also be present, but its presence
         * 	         is a bug that denotes that new mouse button recognition was
         * 	         added without modifying code that reacts on mouse clicks on
         * 	         this label.
         * 	      Use |getmousepos()|.winid in the specified function to get the
         * 	      corresponding window id of the clicked item.
         * 	< -   Where to truncate line if too long.  Default is at the start.
         * 	      No width fields allowed.
         * 	= -   Separation point between alignment sections.  Each section will
         * 	      be separated by an equal number of spaces.  With one %= what
         * 	      comes after it will be right-aligned.  With two %= there is a
         * 	      middle part, with white space left and right of it.
         * 	      No width fields allowed.
         * 	# -   Set highlight group.  The name must follow and then a # again.
         * 	      Thus use %#HLname# for highlight group HLname.  The same
         * 	      highlighting is used, also for the statusline of non-current
         * 	      windows.
         * 	* -   Set highlight group to User{N}, where {N} is taken from the
         * 	      minwid field, e.g. %1*.  Restore normal highlight with %* or %0*.
         * 	      The difference between User{N} and StatusLine will be applied to
         * 	      StatusLineNC for the statusline of non-current windows.
         * 	      The number N must be between 1 and 9.  See |hl-User1..9|
         * 
         * 	When displaying a flag, Vim removes the leading comma, if any, when
         * 	that flag comes right after plaintext.  This will make a nice display
         * 	when flags are used like in the examples below.
         * 
         * 	When all items in a group becomes an empty string (i.e. flags that are
         * 	not set) and a minwid is not set for the group, the whole group will
         * 	become empty.  This will make a group like the following disappear
         * 	completely from the statusline when none of the flags are set. >
         * 		:set statusline=...%(\ [%M%R%H]%)...
         * <	Beware that an expression is evaluated each and every time the status
         * 	line is displayed.
         * 
         * 	While evaluating %{} the current buffer and current window will be set
         * 	temporarily to that of the window (and buffer) whose statusline is
         * 	currently being drawn.  The expression will evaluate in this context.
         * 	The variable "g:actual_curbuf" is set to the `bufnr()` number of the
         * 	real current buffer and "g:actual_curwin" to the |window-ID| of the
         * 	real current window.  These values are strings.
         * 
         * 	The `'statusline'`  option will be evaluated in the |sandbox| if set from
         * 	a modeline, see |sandbox-option|.
         * 	This option cannot be set in a modeline when `'modelineexpr'`  is off.
         * 
         * 	It is not allowed to change text or jump to another window while
         * 	evaluating `'statusline'`  |textlock|.
         * 
         * 	If the statusline is not updated when you want it (e.g., after setting
         * 	a variable that's used in an expression), you can force an update by
         * 	using `:redrawstatus`.
         * 
         * 	A result of all digits is regarded a number for display purposes.
         * 	Otherwise the result is taken as flag text and applied to the rules
         * 	described above.
         * 
         * 	Watch out for errors in expressions.  They may render Vim unusable!
         * 	If you are stuck, hold down `':'`  or `'Q'`  to get a prompt, then quit and
         * 	edit your vimrc or whatever with "vim --clean" to get it right.
         * 
         * 	Examples:
         * 	Emulate standard status line with `'ruler'`  set >
         * 	  :set statusline=%<%f\ %h%m%r%=%-14.(%l,%c%V%)\ %P
         * <	Similar, but add ASCII value of char under the cursor (like "ga") >
         * 	  :set statusline=%<%f%h%m%r%=%b\ 0x%B\ \ %l,%c%V\ %P
         * <	Display byte count and byte value, modified flag in red. >
         * 	  :set statusline=%<%f%=\ [%1%n%R%H]\ %-19(%3l,%02c%03V%)%O`'%02b'` 
         * 	  :hi User1 term=inverse,bold cterm=inverse,bold ctermfg=red
         * <	Display a ,GZ flag if a compressed file is loaded >
         * 	  :set statusline=...%r%{VarExists(`'b:gzflag'` ,'\ [GZ]')}%h...
         * <	In the |:autocmd|'s: >
         * 	  :let b:gzflag = 1
         * <	And: >
         * 	  :unlet b:gzflag
         * <	And define this function: >
         * 	  :function VarExists(var, val)
         * 	  :    if exists(a:var) | return a:val | else | return `''`  | endif
         * 	  :endfunction
         * <
         */
        statusline: string

        /**
         * `'virtualedit'`  `'ve'` 	string	(default "")
         * 			global or local to window |global-local|
         * 	A comma-separated list of these words:
         * 	    block	Allow virtual editing in Visual block mode.
         * 	    insert	Allow virtual editing in Insert mode.
         * 	    all		Allow virtual editing in all modes.
         * 	    onemore	Allow the cursor to move just past the end of the line
         * 	    none	When used as the local value, do not allow virtual
         * 			editing even when the global value is set.  When used
         * 			as the global value, "none" is the same as "".
         * 	    NONE	Alternative spelling of "none".
         * 
         * 	Virtual editing means that the cursor can be positioned where there is
         * 	no actual character.  This can be halfway into a tab or beyond the end
         * 	of the line.  Useful for selecting a rectangle in Visual mode and
         * 	editing a table.
         * 	"onemore" is not the same, it will only allow moving the cursor just
         * 	after the last character of the line.  This makes some commands more
         * 	consistent.  Previously the cursor was always past the end of the line
         * 	if the line was empty.  But it is far from Vi compatible.  It may also
         * 	break some plugins or Vim scripts.  For example because |l| can move
         * 	the cursor after the last character.  Use with care!
         * 	Using the `$` command will move to the last character in the line, not
         * 	past it.  This may actually move the cursor to the left!
         * 	The `g$` command will move to the end of the screen line.
         * 	It doesn't make sense to combine "all" with "onemore", but you will
         * 	not get a warning for it.
         * 	When combined with other words, "none" is ignored.
         */
        virtualedit: string

        /**
         * `'winbar'`  `'wbr'` 		string (default empty)
         * 			global or local to window |global-local|
         * 	When non-empty, this option enables the window bar and determines its
         * 	contents. The window bar is a bar that's shown at the top of every
         * 	window with it enabled. The value of `'winbar'`  is evaluated like with
         * 	`'statusline'` .
         * 
         * 	When changing something that is used in `'winbar'`  that does not trigger
         * 	it to be updated, use |:redrawstatus|.
         * 
         * 	Floating windows do not use the global value of `'winbar'` . The
         * 	window-local value of `'winbar'`  must be set for a floating window to
         * 	have a window bar.
         * 
         * 	This option cannot be set in a modeline when `'modelineexpr'`  is off.
         */
        winbar: string

        /**
         * `'winblend'`  `'winbl'` 		number	(default 0)
         * 			local to window
         * 	Enables pseudo-transparency for a floating window. Valid values are in
         * 	the range of 0 for fully opaque window (disabled) to 100 for fully
         * 	transparent background. Values between 0-30 are typically most useful.
         * 
         * 	UI-dependent. Works best with RGB colors. `'termguicolors'` 
         */
        winblend: number

        /**
         * `'winfixheight'`  `'wfh'` 	boolean	(default off)
         * 			local to window
         * 	Keep the window height when windows are opened or closed and
         * 	`'equalalways'`  is set.  Also for |CTRL-W_=|.  Set by default for the
         * 	|preview-window| and |quickfix-window|.
         * 	The height may be changed anyway when running out of room.
         */
        winfixheight: boolean

        /**
         * `'winfixwidth'`  `'wfw'` 	boolean	(default off)
         * 			local to window
         * 	Keep the window width when windows are opened or closed and
         * 	`'equalalways'`  is set.  Also for |CTRL-W_=|.
         * 	The width may be changed anyway when running out of room.
         */
        winfixwidth: boolean

        /**
         * `'winhighlight'`  `'winhl'` 	string (default empty)
         * 			local to window
         * 	Window-local highlights.  Comma-delimited list of highlight
         * 	|group-name| pairs "{hl-from}:{hl-to},..." where each {hl-from} is
         * 	a |highlight-groups| item to be overridden by {hl-to} group in
         * 	the window.
         * 
         * 	Note: highlight namespaces take precedence over `'winhighlight'` .
         * 	See |nvim_win_set_hl_ns()| and |nvim_set_hl()|.
         * 
         * 	Highlights of vertical separators are determined by the window to the
         * 	left of the separator.  The `'tabline'`  highlight of a tabpage is
         * 	decided by the last-focused window of the tabpage.  Highlights of
         * 	the popupmenu are determined by the current window.  Highlights in the
         * 	message area cannot be overridden.
         * 
         * 	Example: show a different color for non-current windows: >
         * 		set winhighlight=Normal:MyNormal,NormalNC:MyNormalNC
         * <
         */
        winhighlight: string

        /**
         * `'wrap'` 			boolean	(default on)
         * 			local to window
         * 	This option changes how text is displayed.  It doesn't change the text
         * 	in the buffer, see `'textwidth'`  for that.
         * 	When on, lines longer than the width of the window will wrap and
         * 	displaying continues on the next line.  When off lines will not wrap
         * 	and only part of long lines will be displayed.  When the cursor is
         * 	moved to a part that is not shown, the screen will scroll
         * 	horizontally.
         * 	The line will be broken in the middle of a word if necessary.  See
         * 	`'linebreak'`  to get the break at a word boundary.
         * 	To make scrolling horizontally a bit more useful, try this: >
         * 		:set sidescroll=5
         * 		:set listchars+=precedes:<,extends:>
         * <	See `'sidescroll'` , `'listchars'`  and |wrap-off|.
         * 	This option can't be set from a |modeline| when the `'diff'`  option is
         * 	on.
         */
        wrap: boolean

    }

    export const wo: wo;

    /** @noSelf **/
    interface bo {
        /**
         * `'autoindent'`  `'ai'` 	boolean	(default on)
         * 			local to buffer
         * 	Copy indent from current line when starting a new line (typing <CR>
         * 	in Insert mode or when using the "o" or "O" command).  If you do not
         * 	type anything on the new line except <BS> or CTRL-D and then type
         * 	<Esc>, CTRL-O or <CR>, the indent is deleted again.  Moving the cursor
         * 	to another line has the same effect, unless the `'I'`  flag is included
         * 	in `'cpoptions'` .
         * 	When autoindent is on, formatting (with the "gq" command or when you
         * 	reach `'textwidth'`  in Insert mode) uses the indentation of the first
         * 	line.
         * 	When `'smartindent'`  or `'cindent'`  is on the indent is changed in
         * 	a different way.
         * 	{small difference from Vi: After the indent is deleted when typing
         * 	<Esc> or <CR>, the cursor position when moving up or down is after the
         * 	deleted indent; Vi puts the cursor somewhere in the deleted indent}.
         */
        autoindent: boolean

        /**
         * `'autoread'`  `'ar'` 		boolean	(default on)
         * 			global or local to buffer |global-local|
         * 	When a file has been detected to have been changed outside of Vim and
         * 	it has not been changed inside of Vim, automatically read it again.
         * 	When the file has been deleted this is not done, so you have the text
         * 	from before it was deleted.  When it appears again then it is read.
         * 	|timestamp|
         * 	If this option has a local value, use this command to switch back to
         * 	using the global value: >
         * 		:set autoread<
         * <
         */
        autoread: boolean

        /**
         * `'backupcopy'`  `'bkc'` 	string	(default: "auto")
         * 			global or local to buffer |global-local|
         * 	When writing a file and a backup is made, this option tells how it's
         * 	done.  This is a comma-separated list of words.
         * 
         * 	The main values are:
         * 	"yes"	make a copy of the file and overwrite the original one
         * 	"no"	rename the file and write a new one
         * 	"auto"	one of the previous, what works best
         * 
         * 	Extra values that can be combined with the ones above are:
         * 	"breaksymlink"	always break symlinks when writing
         * 	"breakhardlink"	always break hardlinks when writing
         * 
         * 	Making a copy and overwriting the original file:
         * 	- Takes extra time to copy the file.
         * 	+ When the file has special attributes, is a (hard/symbolic) link or
         * 	  has a resource fork, all this is preserved.
         * 	- When the file is a link the backup will have the name of the link,
         * 	  not of the real file.
         * 
         * 	Renaming the file and writing a new one:
         * 	+ It's fast.
         * 	- Sometimes not all attributes of the file can be copied to the new
         * 	  file.
         * 	- When the file is a link the new file will not be a link.
         * 
         * 	The "auto" value is the middle way: When Vim sees that renaming the
         * 	file is possible without side effects (the attributes can be passed on
         * 	and the file is not a link) that is used.  When problems are expected,
         * 	a copy will be made.
         * 
         * 	The "breaksymlink" and "breakhardlink" values can be used in
         * 	combination with any of "yes", "no" and "auto".  When included, they
         * 	force Vim to always break either symbolic or hard links by doing
         * 	exactly what the "no" option does, renaming the original file to
         * 	become the backup and writing a new file in its place.  This can be
         * 	useful for example in source trees where all the files are symbolic or
         * 	hard links and any changes should stay in the local source tree, not
         * 	be propagated back to the original source.
         * 
         * 	One situation where "no" and "auto" will cause problems: A program
         * 	that opens a file, invokes Vim to edit that file, and then tests if
         * 	the open file was changed (through the file descriptor) will check the
         * 	backup file instead of the newly created file.  "crontab -e" is an
         * 	example.
         * 
         * 	When a copy is made, the original file is truncated and then filled
         * 	with the new text.  This means that protection bits, owner and
         * 	symbolic links of the original file are unmodified.  The backup file,
         * 	however, is a new file, owned by the user who edited the file.  The
         * 	group of the backup is set to the group of the original file.  If this
         * 	fails, the protection bits for the group are made the same as for
         * 	others.
         * 
         * 	When the file is renamed, this is the other way around: The backup has
         * 	the same attributes of the original file, and the newly written file
         * 	is owned by the current user.  When the file was a (hard/symbolic)
         * 	link, the new file will not!  That's why the "auto" value doesn't
         * 	rename when the file is a link.  The owner and group of the newly
         * 	written file will be set to the same ones as the original file, but
         * 	the system may refuse to do this.  In that case the "auto" value will
         * 	again not rename the file.
         */
        backupcopy: string

        /**
         * `'binary'`  `'bin'` 		boolean	(default off)
         * 			local to buffer
         * 	This option should be set before editing a binary file.  You can also
         * 	use the |-b| Vim argument.  When this option is switched on a few
         * 	options will be changed (also when it already was on):
         * 		`'textwidth'`   will be set to 0
         * 		`'wrapmargin'`  will be set to 0
         * 		`'modeline'`    will be off
         * 		`'expandtab'`   will be off
         * 	Also, `'fileformat'`  and `'fileformats'`  options will not be used, the
         * 	file is read and written like `'fileformat'`  was "unix" (a single <NL>
         * 	separates lines).
         * 	The `'fileencoding'`  and `'fileencodings'`  options will not be used, the
         * 	file is read without conversion.
         * 	NOTE: When you start editing a(nother) file while the `'bin'`  option is
         * 	on, settings from autocommands may change the settings again (e.g.,
         * 	`'textwidth'` ), causing trouble when editing.  You might want to set
         * 	`'bin'`  again when the file has been loaded.
         * 	The previous values of these options are remembered and restored when
         * 	`'bin'`  is switched from on to off.  Each buffer has its own set of
         * 	saved option values.
         * 	To edit a file with `'binary'`  set you can use the |++bin| argument.
         * 	This avoids you have to do ":set bin", which would have effect for all
         * 	files you edit.
         * 	When writing a file the <EOL> for the last line is only written if
         * 	there was one in the original file (normally Vim appends an <EOL> to
         * 	the last line if there is none; this would make the file longer).  See
         * 	the `'endofline'`  option.
         */
        binary: boolean

        /**
         * `'bomb'` 			boolean	(default off)
         * 			local to buffer
         * 	When writing a file and the following conditions are met, a BOM (Byte
         * 	Order Mark) is prepended to the file:
         * 	- this option is on
         * 	- the `'binary'`  option is off
         * 	- `'fileencoding'`  is "utf-8", "ucs-2", "ucs-4" or one of the little/big
         * 	  endian variants.
         * 	Some applications use the BOM to recognize the encoding of the file.
         * 	Often used for UCS-2 files on MS-Windows.  For other applications it
         * 	causes trouble, for example: "cat file1 file2" makes the BOM of file2
         * 	appear halfway through the resulting file.  Gcc doesn't accept a BOM.
         * 	When Vim reads a file and `'fileencodings'`  starts with "ucs-bom", a
         * 	check for the presence of the BOM is done and `'bomb'`  set accordingly.
         * 	Unless `'binary'`  is set, it is removed from the first line, so that you
         * 	don't see it when editing.  When you don't change the options, the BOM
         * 	will be restored when writing the file.
         */
        bomb: boolean

        /**
         * `'bufhidden'`  `'bh'` 	string (default: "")
         * 			local to buffer
         * 	This option specifies what happens when a buffer is no longer
         * 	displayed in a window:
         * 	  <empty>	follow the global `'hidden'`  option
         * 	  hide		hide the buffer (don't unload it), even if `'hidden'`  is
         * 			not set
         * 	  unload	unload the buffer, even if `'hidden'`  is set; the
         * 			|:hide| command will also unload the buffer
         * 	  delete	delete the buffer from the buffer list, even if
         * 			`'hidden'`  is set; the |:hide| command will also delete
         * 			the buffer, making it behave like |:bdelete|
         * 	  wipe		wipe the buffer from the buffer list, even if
         * 			`'hidden'`  is set; the |:hide| command will also wipe
         * 			out the buffer, making it behave like |:bwipeout|
         * 
         * 	CAREFUL: when "unload", "delete" or "wipe" is used changes in a buffer
         * 	are lost without a warning.  Also, these values may break autocommands
         * 	that switch between buffers temporarily.
         * 	This option is used together with `'buftype'`  and `'swapfile'`  to specify
         * 	special kinds of buffers.   See |special-buffers|.
         */
        bufhidden: string

        /**
         * `'buflisted'`  `'bl'` 	boolean (default: on)
         * 			local to buffer
         * 	When this option is set, the buffer shows up in the buffer list.  If
         * 	it is reset it is not used for ":bnext", "ls", the Buffers menu, etc.
         * 	This option is reset by Vim for buffers that are only used to remember
         * 	a file name or marks.  Vim sets it when starting to edit a buffer.
         * 	But not when moving to a buffer with ":buffer".
         */
        buflisted: boolean

        /**
         * `'buftype'`  `'bt'` 		string (default: "")
         * 			local to buffer
         * 	The value of this option specifies the type of a buffer:
         * 	  <empty>	normal buffer
         * 	  acwrite	buffer will always be written with |BufWriteCmd|s
         * 	  help		help buffer (do not set this manually)
         * 	  nofile	buffer is not related to a file, will not be written
         * 	  nowrite	buffer will not be written
         * 	  quickfix	list of errors |:cwindow| or locations |:lwindow|
         * 	  terminal	|terminal-emulator| buffer
         * 	  prompt	buffer where only the last line can be edited, meant
         * 			to be used by a plugin, see |prompt-buffer|
         * 
         * 	This option is used together with `'bufhidden'`  and `'swapfile'`  to
         * 	specify special kinds of buffers.   See |special-buffers|.
         * 	Also see |win_gettype()|, which returns the type of the window.
         * 
         * 	Be careful with changing this option, it can have many side effects!
         * 	One such effect is that Vim will not check the timestamp of the file,
         * 	if the file is changed by another program this will not be noticed.
         * 
         * 	A "quickfix" buffer is only used for the error list and the location
         * 	list.  This value is set by the |:cwindow| and |:lwindow| commands and
         * 	you are not supposed to change it.
         * 
         * 	"nofile" and "nowrite" buffers are similar:
         * 	both:		The buffer is not to be written to disk, ":w" doesn't
         * 			work (":w filename" does work though).
         * 	both:		The buffer is never considered to be |`'modified'` |.
         * 			There is no warning when the changes will be lost, for
         * 			example when you quit Vim.
         * 	both:		A swap file is only created when using too much memory
         * 			(when `'swapfile'`  has been reset there is never a swap
         * 			file).
         * 	nofile only:	The buffer name is fixed, it is not handled like a
         * 			file name.  It is not modified in response to a |:cd|
         * 			command.
         * 	both:		When using ":e bufname" and already editing "bufname"
         * 			the buffer is made empty and autocommands are
         * 			triggered as usual for |:edit|.
         * 
         * 	"acwrite" implies that the buffer name is not related to a file, like
         * 	"nofile", but it will be written.  Thus, in contrast to "nofile" and
         * 	"nowrite", ":w" does work and a modified buffer can't be abandoned
         * 	without saving.  For writing there must be matching |BufWriteCmd|,
         * 	|FileWriteCmd| or |FileAppendCmd| autocommands.
         */
        buftype: string

        /**
         * `'channel'` 		number (default: 0)
         * 			local to buffer
         * 	|channel| connected to the buffer, or 0 if no channel is connected.
         * 	In a |:terminal| buffer this is the terminal channel.
         * 	Read-only.
         */
        channel: number

        /**
         * `'cindent'`  `'cin'` 		boolean	(default off)
         * 			local to buffer
         * 	Enables automatic C program indenting.  See `'cinkeys'`  to set the keys
         * 	that trigger reindenting in insert mode and `'cinoptions'`  to set your
         * 	preferred indent style.
         * 	If `'indentexpr'`  is not empty, it overrules `'cindent'` .
         * 	If `'lisp'`  is not on and both `'indentexpr'`  and `'equalprg'`  are empty,
         * 	the "=" operator indents using this algorithm rather than calling an
         * 	external program.
         * 	See |C-indenting|.
         * 	When you don't like the way `'cindent'`  works, try the `'smartindent'` 
         * 	option or `'indentexpr'` .
         */
        cindent: boolean

        /**
         * `'cinkeys'`  `'cink'` 	string	(default "0{,0},0),0],:,0#,!^F,o,O,e")
         * 			local to buffer
         * 	A list of keys that, when typed in Insert mode, cause reindenting of
         * 	the current line.  Only used if `'cindent'`  is on and `'indentexpr'`  is
         * 	empty.
         * 	For the format of this option see |cinkeys-format|.
         * 	See |C-indenting|.
         */
        cinkeys: string

        /**
         * `'cinoptions'`  `'cino'` 	string	(default "")
         * 			local to buffer
         * 	The `'cinoptions'`  affect the way `'cindent'`  reindents lines in a C
         * 	program.  See |cinoptions-values| for the values of this option, and
         * 	|C-indenting| for info on C indenting in general.
         */
        cinoptions: string

        /**
         * `'cinscopedecls'`  `'cinsd'` 	string	(default "public,protected,private")
         * 			local to buffer
         * 	Keywords that are interpreted as a C++ scope declaration by |cino-g|.
         * 	Useful e.g. for working with the Qt framework that defines additional
         * 	scope declarations "signals", "public slots" and "private slots": >
         * 		set cinscopedecls+=signals,public\ slots,private\ slots
         * 
         * <
         */
        cinscopedecls: string

        /**
         * `'cinwords'`  `'cinw'` 	string	(default "if,else,while,do,for,switch")
         * 			local to buffer
         * 	These keywords start an extra indent in the next line when
         * 	`'smartindent'`  or `'cindent'`  is set.  For `'cindent'`  this is only done at
         * 	an appropriate place (inside {}).
         * 	Note that `'ignorecase'`  isn't used for `'cinwords'` .  If case doesn't
         * 	matter, include the keyword both the uppercase and lowercase:
         * 	"if,If,IF".
         */
        cinwords: string

        /**
         * `'comments'`  `'com'` 	string	(default
         * 				"s1:/,ex:* /,://,b:#,:%,:XCOMM,n:>,fb:-")
         * 			local to buffer
         * 	A comma-separated list of strings that can start a comment line.  See
         * 	|format-comments|.  See |option-backslash| about using backslashes to
         * 	insert a space.
         */
        comments: string

        /**
         * `'commentstring'`  `'cms'` 	string	(default "")
         * 			local to buffer
         * 	A template for a comment.  The "%s" in the value is replaced with the
         * 	comment text.  Currently only used to add markers for folding, see
         * 	|fold-marker|.
         */
        commentstring: string

        /**
         * `'complete'`  `'cpt'` 	string	(default: ".,w,b,u,t")
         * 			local to buffer
         * 	This option specifies how keyword completion |ins-completion| works
         * 	when CTRL-P or CTRL-N are used.  It is also used for whole-line
         * 	completion |i_CTRL-X_CTRL-L|.  It indicates the type of completion
         * 	and the places to scan.  It is a comma-separated list of flags:
         * 	.	scan the current buffer (`'wrapscan'`  is ignored)
         * 	w	scan buffers from other windows
         * 	b	scan other loaded buffers that are in the buffer list
         * 	u	scan the unloaded buffers that are in the buffer list
         * 	U	scan the buffers that are not in the buffer list
         * 	k	scan the files given with the `'dictionary'`  option
         * 	kspell  use the currently active spell checking |spell|
         * 	k{dict}	scan the file {dict}.  Several "k" flags can be given,
         * 		patterns are valid too.  For example: >
         * 			:set cpt=k/usr/dict/*,k~/spanish
         * <	s	scan the files given with the `'thesaurus'`  option
         * 	s{tsr}	scan the file {tsr}.  Several "s" flags can be given, patterns
         * 		are valid too.
         * 	i	scan current and included files
         * 	d	scan current and included files for defined name or macro
         * 		|i_CTRL-X_CTRL-D|
         * 	]	tag completion
         * 	t	same as "]"
         * 
         * 	Unloaded buffers are not loaded, thus their autocmds |:autocmd| are
         * 	not executed, this may lead to unexpected completions from some files
         * 	(gzipped files for example).  Unloaded buffers are not scanned for
         * 	whole-line completion.
         * 
         * 	As you can see, CTRL-N and CTRL-P can be used to do any `'iskeyword'` -
         * 	based expansion (e.g., dictionary |i_CTRL-X_CTRL-K|, included patterns
         * 	|i_CTRL-X_CTRL-I|, tags |i_CTRL-X_CTRL-]| and normal expansions).
         */
        complete: string

        /**
         * `'completefunc'`  `'cfu'` 	string	(default: empty)
         * 			local to buffer
         * 	This option specifies a function to be used for Insert mode completion
         * 	with CTRL-X CTRL-U. |i_CTRL-X_CTRL-U|
         * 	See |complete-functions| for an explanation of how the function is
         * 	invoked and what it should return.  The value can be the name of a
         * 	function, a |lambda| or a |Funcref|. See |option-value-function| for
         * 	more information.
         * 	This option cannot be set from a |modeline| or in the |sandbox|, for
         * 	security reasons.
         */
        completefunc: string

        /**
         * `'copyindent'`  `'ci'` 	boolean	(default off)
         * 			local to buffer
         * 	Copy the structure of the existing lines indent when autoindenting a
         * 	new line.  Normally the new indent is reconstructed by a series of
         * 	tabs followed by spaces as required (unless |`'expandtab'` | is enabled,
         * 	in which case only spaces are used).  Enabling this option makes the
         * 	new line copy whatever characters were used for indenting on the
         * 	existing line.  `'expandtab'`  has no effect on these characters, a Tab
         * 	remains a Tab.  If the new indent is greater than on the existing
         * 	line, the remaining space is filled in the normal manner.
         * 	See `'preserveindent'` .
         */
        copyindent: boolean

        /**
         * `'define'`  `'def'` 		string	(default "^\sdefine")
         * 			global or local to buffer |global-local|
         * 	Pattern to be used to find a macro definition.  It is a search
         * 	pattern, just like for the "/" command.  This option is used for the
         * 	commands like "[i" and "[d" |include-search|.  The `'isident'`  option is
         * 	used to recognize the defined name after the match:
         * 		{match with `'define'` }{non-ID chars}{defined name}{non-ID char}
         * 	See |option-backslash| about inserting backslashes to include a space
         * 	or backslash.
         * 	The default value is for C programs.  For C++ this value would be
         * 	useful, to include const type declarations: >
         * 		^\(#\s\s[a-z]*\)
         * <	You can also use "\ze" just before the name and continue the pattern
         * 	to check what is following.  E.g. for Javascript, if a function is
         * 	defined with `func_name = function(args)`: >
         * 		^\s=\s*function(
         * <	If the function is defined with `func_name : function() {...`: >
         * 	        ^\s[:]\sfunction\s*(
         * <	When using the ":set" command, you need to double the backslashes!
         * 	To avoid that use `:let` with a single quote string: >
         * 		let &l:define = `'^\s=\s*function('` 
         * <
         */
        define: string

        /**
         * `'dictionary'`  `'dict'` 	string	(default "")
         * 			global or local to buffer |global-local|
         * 	List of file names, separated by commas, that are used to lookup words
         * 	for keyword completion commands |i_CTRL-X_CTRL-K|.  Each file should
         * 	contain a list of words.  This can be one word per line, or several
         * 	words per line, separated by non-keyword characters (white space is
         * 	preferred).  Maximum line length is 510 bytes.
         * 
         * 	When this option is empty or an entry "spell" is present, and spell
         * 	checking is enabled, words in the word lists for the currently active
         * 	`'spelllang'`  are used. See |spell|.
         * 
         * 	To include a comma in a file name precede it with a backslash.  Spaces
         * 	after a comma are ignored, otherwise spaces are included in the file
         * 	name.  See |option-backslash| about using backslashes.
         * 	This has nothing to do with the |Dictionary| variable type.
         * 	Where to find a list of words?
         * 	- BSD/macOS include the "/usr/share/dict/words" file.
         * 	- Try "apt install spell" to get the "/usr/share/dict/words" file on
         * 	  apt-managed systems (Debian/Ubuntu).
         * 	The use of |:set+=| and |:set-=| is preferred when adding or removing
         * 	directories from the list.  This avoids problems when a future version
         * 	uses another default.
         * 	Backticks cannot be used in this option for security reasons.
         */
        dictionary: string

        /**
         * `'endoffile'`  `'eof'` 	boolean	(default off)
         * 			local to buffer
         * 	Indicates that a CTRL-Z character was found at the end of the file
         * 	when reading it.  Normally only happens when `'fileformat'`  is "dos".
         * 	When writing a file and this option is off and the `'binary'`  option
         * 	is on, or `'fixeol'`  option is off, no CTRL-Z will be written at the
         * 	end of the file.
         * 	See |eol-and-eof| for example settings.
         */
        endoffile: boolean

        /**
         * `'endofline'`  `'eol'` 	boolean	(default on)
         * 			local to buffer
         * 	When writing a file and this option is off and the `'binary'`  option
         * 	is on, or `'fixeol'`  option is off, no <EOL> will be written for the
         * 	last line in the file.  This option is automatically set or reset when
         * 	starting to edit a new file, depending on whether file has an <EOL>
         * 	for the last line in the file.  Normally you don't have to set or
         * 	reset this option.
         * 	When `'binary'`  is off and `'fixeol'`  is on the value is not used when
         * 	writing the file.  When `'binary'`  is on or `'fixeol'`  is off it is used
         * 	to remember the presence of a <EOL> for the last line in the file, so
         * 	that when you write the file the situation from the original file can
         * 	be kept.  But you can change it if you want to.
         * 	See |eol-and-eof| for example settings.
         */
        endofline: boolean

        /**
         * `'equalprg'`  `'ep'` 		string	(default "")
         * 			global or local to buffer |global-local|
         * 	External program to use for "=" command.  When this option is empty
         * 	the internal formatting functions are used; either `'lisp'` , `'cindent'` 
         * 	or `'indentexpr'` .
         * 	Environment variables are expanded |:set_env|.  See |option-backslash|
         * 	about including spaces and backslashes.
         * 	This option cannot be set from a |modeline| or in the |sandbox|, for
         * 	security reasons.
         */
        equalprg: string

        /**
         * `'errorformat'`  `'efm'` 	string	(default is very long)
         * 			global or local to buffer |global-local|
         * 	Scanf-like description of the format for the lines in the error file
         * 	(see |errorformat|).
         */
        errorformat: string

        /**
         * `'expandtab'`  `'et'` 	boolean	(default off)
         * 			local to buffer
         * 	In Insert mode: Use the appropriate number of spaces to insert a
         * 	<Tab>.  Spaces are used in indents with the `'>'`  and `'<'`  commands and
         * 	when `'autoindent'`  is on.  To insert a real tab when `'expandtab'`  is
         * 	on, use CTRL-V<Tab>.  See also |:retab| and |ins-expandtab|.
         */
        expandtab: boolean

        /**
         * `'fileencoding'`  `'fenc'` 	string (default: "")
         * 			local to buffer
         * 	File-content encoding for the current buffer. Conversion is done with
         * 	iconv() or as specified with `'charconvert'` .
         * 
         * 	When `'fileencoding'`  is not UTF-8, conversion will be done when
         * 	writing the file.  For reading see below.
         * 	When `'fileencoding'`  is empty, the file will be saved with UTF-8
         * 	encoding (no conversion when reading or writing a file).
         * 
         * 	WARNING: Conversion to a non-Unicode encoding can cause loss of
         * 	information!
         * 
         * 	See |encoding-names| for the possible values.  Additionally, values may be
         * 	specified that can be handled by the converter, see
         * 	|mbyte-conversion|.
         * 
         * 	When reading a file `'fileencoding'`  will be set from `'fileencodings'` .
         * 	To read a file in a certain encoding it won't work by setting
         * 	`'fileencoding'` , use the |++enc| argument.  One exception: when
         * 	`'fileencodings'`  is empty the value of `'fileencoding'`  is used.
         * 	For a new file the global value of `'fileencoding'`  is used.
         * 
         * 	Prepending "8bit-" and "2byte-" has no meaning here, they are ignored.
         * 	When the option is set, the value is converted to lowercase.  Thus
         * 	you can set it with uppercase values too.  `'_'`  characters are
         * 	replaced with `'-'` .  If a name is recognized from the list at
         * 	|encoding-names|, it is replaced by the standard name.  For example
         * 	"ISO8859-2" becomes "iso-8859-2".
         * 
         * 	When this option is set, after starting to edit a file, the `'modified'` 
         * 	option is set, because the file would be different when written.
         * 
         * 	Keep in mind that changing `'fenc'`  from a modeline happens
         * 	AFTER the text has been read, thus it applies to when the file will be
         * 	written.  If you do set `'fenc'`  in a modeline, you might want to set
         * 	`'nomodified'`  to avoid not being able to ":q".
         * 
         * 	This option cannot be changed when `'modifiable'`  is off.
         */
        fileencoding: string

        /**
         * `'fileformat'`  `'ff'` 	string (Windows default: "dos",
         * 				Unix default: "unix")
         * 			local to buffer
         * 	This gives the <EOL> of the current buffer, which is used for
         * 	reading/writing the buffer from/to a file:
         * 	    dos	    <CR><NL>
         * 	    unix    <NL>
         * 	    mac	    <CR>
         * 	When "dos" is used, CTRL-Z at the end of a file is ignored.
         * 	See |file-formats| and |file-read|.
         * 	For the character encoding of the file see `'fileencoding'` .
         * 	When `'binary'`  is set, the value of `'fileformat'`  is ignored, file I/O
         * 	works like it was set to "unix".
         * 	This option is set automatically when starting to edit a file and
         * 	`'fileformats'`  is not empty and `'binary'`  is off.
         * 	When this option is set, after starting to edit a file, the `'modified'` 
         * 	option is set, because the file would be different when written.
         * 	This option cannot be changed when `'modifiable'`  is off.
         */
        fileformat: string

        /**
         * `'filetype'`  `'ft'` 		string (default: "")
         * 			local to buffer
         * 	When this option is set, the FileType autocommand event is triggered.
         * 	All autocommands that match with the value of this option will be
         * 	executed.  Thus the value of `'filetype'`  is used in place of the file
         * 	name.
         * 	Otherwise this option does not always reflect the current file type.
         * 	This option is normally set when the file type is detected.  To enable
         * 	this use the ":filetype on" command. |:filetype|
         * 	Setting this option to a different value is most useful in a modeline,
         * 	for a file for which the file type is not automatically recognized.
         * 	Example, for in an IDL file: >
         * 		/* vim: set filetype=idl : * /
         * <	|FileType| |filetypes|
         * 	When a dot appears in the value then this separates two filetype
         * 	names.  Example: >
         * 		/* vim: set filetype=c.doxygen : * /
         * <	This will use the "c" filetype first, then the "doxygen" filetype.
         * 	This works both for filetype plugins and for syntax files.  More than
         * 	one dot may appear.
         * 	This option is not copied to another buffer, independent of the `'s'`  or
         * 	`'S'`  flag in `'cpoptions'` .
         * 	Only normal file name characters can be used, "/\*?[|<>" are illegal.
         */
        filetype: string

        /**
         * `'fixendofline'`  `'fixeol'` 	boolean	(default on)
         * 			local to buffer
         * 	When writing a file and this option is on, <EOL> at the end of file
         * 	will be restored if missing.  Turn this option off if you want to
         * 	preserve the situation from the original file.
         * 	When the `'binary'`  option is set the value of this option doesn't
         * 	matter.
         * 	See the `'endofline'`  option.
         * 	See |eol-and-eof| for example settings.
         */
        fixendofline: boolean

        /**
         * `'formatexpr'`  `'fex'` 	string (default "")
         * 			local to buffer
         * 	Expression which is evaluated to format a range of lines for the |gq|
         * 	operator or automatic formatting (see `'formatoptions'` ).  When this
         * 	option is empty `'formatprg'`  is used.
         * 
         * 	The |v:lnum|  variable holds the first line to be formatted.
         * 	The |v:count| variable holds the number of lines to be formatted.
         * 	The |v:char|  variable holds the character that is going to be
         * 		      inserted if the expression is being evaluated due to
         * 		      automatic formatting.  This can be empty.  Don't insert
         * 		      it yet!
         * 
         * 	Example: >
         * 		:set formatexpr=mylang#Format()
         * <	This will invoke the mylang#Format() function in the
         * 	autoload/mylang.vim file in `'runtimepath'` . |autoload|
         * 
         * 	The expression is also evaluated when `'textwidth'`  is set and adding
         * 	text beyond that limit.  This happens under the same conditions as
         * 	when internal formatting is used.  Make sure the cursor is kept in the
         * 	same spot relative to the text then!  The |mode()| function will
         * 	return "i" or "R" in this situation.
         * 
         * 	When the expression evaluates to non-zero Vim will fall back to using
         * 	the internal format mechanism.
         * 
         * 	If the expression starts with s: or |<SID>|, then it is replaced with
         * 	the script ID (|local-function|). Example: >
         * 		set formatexpr=s:MyFormatExpr()
         * 		set formatexpr=<SID>SomeFormatExpr()
         * <
         * 	The expression will be evaluated in the |sandbox| when set from a
         * 	modeline, see |sandbox-option|.  That stops the option from working,
         * 	since changing the buffer text is not allowed.
         * 	This option cannot be set in a modeline when `'modelineexpr'`  is off.
         * 	NOTE: This option is set to "" when `'compatible'`  is set.
         */
        formatexpr: string

        /**
         * `'formatlistpat'`  `'flp'` 	string (default: "^\s*\d\+[\]:.)}\t ]\s*")
         * 			local to buffer
         * 	A pattern that is used to recognize a list header.  This is used for
         * 	the "n" flag in `'formatoptions'` .
         * 	The pattern must match exactly the text that will be the indent for
         * 	the line below it.  You can use |/\ze| to mark the end of the match
         * 	while still checking more characters.  There must be a character
         * 	following the pattern, when it matches the whole line it is handled
         * 	like there is no match.
         * 	The default recognizes a number, followed by an optional punctuation
         * 	character and white space.
         */
        formatlistpat: string

        /**
         * `'formatoptions'`  `'fo'` 	string (default: "tcqj")
         * 			local to buffer
         * 	This is a sequence of letters which describes how automatic
         * 	formatting is to be done.  See |fo-table|.  Commas can be inserted for
         * 	readability.
         * 	To avoid problems with flags that are added in the future, use the
         * 	"+=" and "-=" feature of ":set" |add-option-flags|.
         */
        formatoptions: string

        /**
         * `'formatprg'`  `'fp'` 	string (default "")
         * 			global or local to buffer |global-local|
         * 	The name of an external program that will be used to format the lines
         * 	selected with the |gq| operator.  The program must take the input on
         * 	stdin and produce the output on stdout.  The Unix program "fmt" is
         * 	such a program.
         * 	If the `'formatexpr'`  option is not empty it will be used instead.
         * 	Otherwise, if `'formatprg'`  option is an empty string, the internal
         * 	format function will be used |C-indenting|.
         * 	Environment variables are expanded |:set_env|.  See |option-backslash|
         * 	about including spaces and backslashes.
         * 	This option cannot be set from a |modeline| or in the |sandbox|, for
         * 	security reasons.
         */
        formatprg: string

        /**
         * `'grepprg'`  `'gp'` 		string	(default "grep -n ",
         * 				 Unix: "grep -n $* /dev/null")
         * 			global or local to buffer |global-local|
         * 	Program to use for the |:grep| command.  This option may contain `'%'` 
         * 	and `'#'`  characters, which are expanded like when used in a command-
         * 	line.  The placeholder "$*" is allowed to specify where the arguments
         * 	will be included.  Environment variables are expanded |:set_env|.  See
         * 	|option-backslash| about including spaces and backslashes.
         * 	When your "grep" accepts the "-H" argument, use this to make ":grep"
         * 	also work well with a single file: >
         * 		:set grepprg=grep\ -nH
         * <	Special value: When `'grepprg'`  is set to "internal" the |:grep| command
         * 	works like |:vimgrep|, |:lgrep| like |:lvimgrep|, |:grepadd| like
         * 	|:vimgrepadd| and |:lgrepadd| like |:lvimgrepadd|.
         * 	See also the section |:make_makeprg|, since most of the comments there
         * 	apply equally to `'grepprg'` .
         * 	This option cannot be set from a |modeline| or in the |sandbox|, for
         * 	security reasons.
         */
        grepprg: string

        /**
         * `'iminsert'`  `'imi'` 	number (default 0)
         * 			local to buffer
         * 	Specifies whether :lmap or an Input Method (IM) is to be used in
         * 	Insert mode.  Valid values:
         * 		0	:lmap is off and IM is off
         * 		1	:lmap is ON and IM is off
         * 		2	:lmap is off and IM is ON
         * 	To always reset the option to zero when leaving Insert mode with <Esc>
         * 	this can be used: >
         * 		:inoremap <ESC> <ESC>:set iminsert=0<CR>
         * <	This makes :lmap and IM turn off automatically when leaving Insert
         * 	mode.
         * 	Note that this option changes when using CTRL-^ in Insert mode
         * 	|i_CTRL-^|.
         * 	The value is set to 1 when setting `'keymap'`  to a valid keymap name.
         * 	It is also used for the argument of commands like "r" and "f".
         */
        iminsert: number

        /**
         * `'imsearch'`  `'ims'` 	number (default -1)
         * 			local to buffer
         * 	Specifies whether :lmap or an Input Method (IM) is to be used when
         * 	entering a search pattern.  Valid values:
         * 		-1	the value of `'iminsert'`  is used, makes it look like
         * 			`'iminsert'`  is also used when typing a search pattern
         * 		0	:lmap is off and IM is off
         * 		1	:lmap is ON and IM is off
         * 		2	:lmap is off and IM is ON
         * 	Note that this option changes when using CTRL-^ in Command-line mode
         * 	|c_CTRL-^|.
         * 	The value is set to 1 when it is not -1 and setting the `'keymap'` 
         * 	option to a valid keymap name.
         */
        imsearch: number

        /**
         * `'include'`  `'inc'` 		string	(default "^\sinclude")
         * 			global or local to buffer |global-local|
         * 	Pattern to be used to find an include command.  It is a search
         * 	pattern, just like for the "/" command (See |pattern|).  The default
         * 	value is for C programs.  This option is used for the commands "[i",
         * 	"]I", "[d", etc.
         * 	Normally the `'isfname'`  option is used to recognize the file name that
         * 	comes after the matched pattern.  But if "\zs" appears in the pattern
         * 	then the text matched from "\zs" to the end, or until "\ze" if it
         * 	appears, is used as the file name.  Use this to include characters
         * 	that are not in `'isfname'` , such as a space.  You can then use
         * 	`'includeexpr'`  to process the matched text.
         * 	See |option-backslash| about including spaces and backslashes.
         */
        include: string

        /**
         * `'includeexpr'`  `'inex'` 	string	(default "")
         * 			local to buffer
         * 	Expression to be used to transform the string found with the `'include'` 
         * 	option to a file name.  Mostly useful to change "." to "/" for Java: >
         * 		:setlocal includeexpr=substitute(v:fname,`'\\.'` ,`'/'` ,`'g'` )
         * <	The "v:fname" variable will be set to the file name that was detected.
         * 	Note the double backslash: the `:set` command first halves them, then
         * 	one remains in the value, where "\." matches a dot literally.  For
         * 	simple character replacements `tr()` avoids the need for escaping: >
         * 		:setlocal includeexpr=tr(v:fname,`'.'` ,`'/'` )
         * <
         * 	Also used for the |gf| command if an unmodified file name can't be
         * 	found.  Allows doing "gf" on the name after an `'include'`  statement.
         * 	Also used for |<cfile>|.
         * 
         * 	If the expression starts with s: or |<SID>|, then it is replaced with
         * 	the script ID (|local-function|). Example: >
         * 		set includeexpr=s:MyIncludeExpr(v:fname)
         * 		set includeexpr=<SID>SomeIncludeExpr(v:fname)
         * <
         * 	The expression will be evaluated in the |sandbox| when set from a
         * 	modeline, see |sandbox-option|.
         * 	This option cannot be set in a modeline when `'modelineexpr'`  is off.
         * 
         * 	It is not allowed to change text or jump to another window while
         * 	evaluating `'includeexpr'`  |textlock|.
         */
        includeexpr: string

        /**
         * `'indentexpr'`  `'inde'` 	string	(default "")
         * 			local to buffer
         * 	Expression which is evaluated to obtain the proper indent for a line.
         * 	It is used when a new line is created, for the |=| operator and
         * 	in Insert mode as specified with the `'indentkeys'`  option.
         * 	When this option is not empty, it overrules the `'cindent'`  and
         * 	`'smartindent'`  indenting.  When `'lisp'`  is set, this option is
         * 	is only used when `'lispoptions'`  contains "expr:1".
         * 	The expression is evaluated with |v:lnum| set to the line number for
         * 	which the indent is to be computed.  The cursor is also in this line
         * 	when the expression is evaluated (but it may be moved around).
         * 	If the expression starts with s: or |<SID>|, then it is replaced with
         * 	the script ID (|local-function|). Example: >
         * 		set indentexpr=s:MyIndentExpr()
         * 		set indentexpr=<SID>SomeIndentExpr()
         * <
         * 	The expression must return the number of spaces worth of indent.  It
         * 	can return "-1" to keep the current indent (this means `'autoindent'`  is
         * 	used for the indent).
         * 	Functions useful for computing the indent are |indent()|, |cindent()|
         * 	and |lispindent()|.
         * 	The evaluation of the expression must not have side effects!  It must
         * 	not change the text, jump to another window, etc.  Afterwards the
         * 	cursor position is always restored, thus the cursor may be moved.
         * 	Normally this option would be set to call a function: >
         * 		:set indentexpr=GetMyIndent()
         * <	Error messages will be suppressed, unless the `'debug'`  option contains
         * 	"msg".
         * 	See |indent-expression|.
         * 
         * 	The expression will be evaluated in the |sandbox| when set from a
         * 	modeline, see |sandbox-option|.
         * 	This option cannot be set in a modeline when `'modelineexpr'`  is off.
         * 
         * 	It is not allowed to change text or jump to another window while
         * 	evaluating `'indentexpr'`  |textlock|.
         */
        indentexpr: string

        /**
         * `'indentkeys'`  `'indk'` 	string	(default "0{,0},0),0],:,0#,!^F,o,O,e")
         * 			local to buffer
         * 	A list of keys that, when typed in Insert mode, cause reindenting of
         * 	the current line.  Only happens if `'indentexpr'`  isn't empty.
         * 	The format is identical to `'cinkeys'` , see |indentkeys-format|.
         * 	See |C-indenting| and |indent-expression|.
         */
        indentkeys: string

        /**
         * `'infercase'`  `'inf'` 	boolean	(default off)
         * 			local to buffer
         * 	When doing keyword completion in insert mode |ins-completion|, and
         * 	`'ignorecase'`  is also on, the case of the match is adjusted depending
         * 	on the typed text.  If the typed text contains a lowercase letter
         * 	where the match has an upper case letter, the completed part is made
         * 	lowercase.  If the typed text has no lowercase letters and the match
         * 	has a lowercase letter where the typed text has an uppercase letter,
         * 	and there is a letter before it, the completed part is made uppercase.
         * 	With `'noinfercase'`  the match is used as-is.
         */
        infercase: boolean

        /**
         * `'iskeyword'`  `'isk'` 	string (default: @,48-57,_,192-255)
         * 			local to buffer
         * 	Keywords are used in searching and recognizing with many commands:
         * 	"w", "*", "[i", etc.  It is also used for "\k" in a |pattern|.  See
         * 	`'isfname'`  for a description of the format of this option.  For `'@'` 
         * 	characters above 255 check the "word" character class (any character
         * 	that is not white space or punctuation).
         * 	For C programs you could use "a-z,A-Z,48-57,_,.,-,>".
         * 	For a help file it is set to all non-blank printable characters except
         * 	`'*'` , `'"'`  and `'|'`  (so that CTRL-] on a command finds the help for that
         * 	command).
         * 	When the `'lisp'`  option is on the `'-'`  character is always included.
         * 	This option also influences syntax highlighting, unless the syntax
         * 	uses |:syn-iskeyword|.
         */
        iskeyword: string

        /**
         * `'keymap'`  `'kmp'` 		string	(default "")
         * 			local to buffer
         * 	Name of a keyboard mapping.  See |mbyte-keymap|.
         * 	Setting this option to a valid keymap name has the side effect of
         * 	setting `'iminsert'`  to one, so that the keymap becomes effective.
         * 	`'imsearch'`  is also set to one, unless it was -1
         * 	Only normal file name characters can be used, "/\*?[|<>" are illegal.
         */
        keymap: string

        /**
         * `'keywordprg'`  `'kp'` 	string	(default ":Man", Windows: ":help")
         * 			global or local to buffer |global-local|
         * 	Program to use for the |K| command.  Environment variables are
         * 	expanded |:set_env|.  ":help" may be used to access the Vim internal
         * 	help.  (Note that previously setting the global option to the empty
         * 	value did this, which is now deprecated.)
         * 	When the first character is ":", the command is invoked as a Vim
         * 	Ex command prefixed with [count].
         * 	When "man" or "man -s" is used, Vim will automatically translate
         * 	a [count] for the "K" command to a section number.
         * 	See |option-backslash| about including spaces and backslashes.
         * 	Example: >
         * 		:set keywordprg=man\ -s
         * 		:set keywordprg=:Man
         * <	This option cannot be set from a |modeline| or in the |sandbox|, for
         * 	security reasons.
         */
        keywordprg: string

        /**
         * `'lisp'` 			boolean	(default off)
         * 			local to buffer
         * 	Lisp mode: When <Enter> is typed in insert mode set the indent for
         * 	the next line to Lisp standards (well, sort of).  Also happens with
         * 	"cc" or "S".  `'autoindent'`  must also be on for this to work.  The `'p'` 
         * 	flag in `'cpoptions'`  changes the method of indenting: Vi compatible or
         * 	better.  Also see `'lispwords'` .
         * 	The `'-'`  character is included in keyword characters.  Redefines the
         * 	"=" operator to use this same indentation algorithm rather than
         * 	calling an external program if `'equalprg'`  is empty.
         */
        lisp: boolean

        /**
         * `'lispoptions'`  `'lop'` 	string	(default "")
         * 			local to buffer
         * 	Comma-separated list of items that influence the Lisp indenting when
         * 	enabled with the |`'lisp'` | option.  Currently only one item is
         * 	supported:
         * 		expr:1	use `'indentexpr'`  for Lisp indenting when it is set
         * 		expr:0	do not use `'indentexpr'`  for Lisp indenting (default)
         * 	Note that when using `'indentexpr'`  the `=` operator indents all the
         * 	lines, otherwise the first line is not indented (Vi-compatible).
         */
        lispoptions: string

        /**
         * `'lispwords'`  `'lw'` 	string	(default is very long)
         * 			global or local to buffer |global-local|
         * 	Comma-separated list of words that influence the Lisp indenting when
         * 	enabled with the |`'lisp'` | option.
         */
        lispwords: string

        /**
         * `'makeencoding'`  `'menc'` 	string	(default "")
         * 			global or local to buffer |global-local|
         * 	Encoding used for reading the output of external commands.  When empty,
         * 	encoding is not converted.
         * 	This is used for `:make`, `:lmake`, `:grep`, `:lgrep`, `:grepadd`,
         * 	`:lgrepadd`, `:cfile`, `:cgetfile`, `:caddfile`, `:lfile`, `:lgetfile`,
         * 	and `:laddfile`.
         * 
         * 	This would be mostly useful when you use MS-Windows.  If iconv is
         * 	enabled, setting `'makeencoding'`  to "char" has the same effect as
         * 	setting to the system locale encoding.  Example: >
         * 		:set makeencoding=char	" system locale is used
         * <
         */
        makeencoding: string

        /**
         * `'makeprg'`  `'mp'` 		string	(default "make")
         * 			global or local to buffer |global-local|
         * 	Program to use for the ":make" command.  See |:make_makeprg|.
         * 	This option may contain `'%'`  and `'#'`  characters (see  |:_%| and |:_#|),
         * 	which are expanded to the current and alternate file name.  Use |::S|
         * 	to escape file names in case they contain special characters.
         * 	Environment variables are expanded |:set_env|.  See |option-backslash|
         * 	about including spaces and backslashes.
         * 	Note that a `'|'`  must be escaped twice: once for ":set" and once for
         * 	the interpretation of a command.  When you use a filter called
         * 	"myfilter" do it like this: >
         * 	    :set makeprg=gmake\ \\\|\ myfilter
         * <	The placeholder "$*" can be given (even multiple times) to specify
         * 	where the arguments will be included, for example: >
         * 	    :set makeprg=latex\ \\\\nonstopmode\ \\\\input\\{$*}
         * <	This option cannot be set from a |modeline| or in the |sandbox|, for
         * 	security reasons.
         */
        makeprg: string

        /**
         * `'matchpairs'`  `'mps'` 	string	(default "(:),{:},[:]")
         * 			local to buffer
         * 	Characters that form pairs.  The |%| command jumps from one to the
         * 	other.
         * 	Only character pairs are allowed that are different, thus you cannot
         * 	jump between two double quotes.
         * 	The characters must be separated by a colon.
         * 	The pairs must be separated by a comma.  Example for including `'<'`  and
         * 	`'>'`  (for HTML): >
         * 		:set mps+=<:>
         * 
         * <	A more exotic example, to jump between the `'='`  and `';'`  in an
         * 	assignment, useful for languages like C and Java: >
         * 		:au FileType c,cpp,java set mps+==:;
         * 
         * <	For a more advanced way of using "%", see the matchit.vim plugin in
         * 	the $VIMRUNTIME/plugin directory. |add-local-help|
         */
        matchpairs: string

        /**
         * `'modeline'`  `'ml'` 		boolean	(default: on (off for root))
         * 			local to buffer
         * 	If `'modeline'`  is on `'modelines'`  gives the number of lines that is
         * 	checked for set commands.  If `'modeline'`  is off or `'modelines'`  is zero
         * 	no lines are checked.  See |modeline|.
         */
        modeline: boolean

        /**
         * `'modifiable'`  `'ma'` 	boolean	(default on)
         * 			local to buffer
         * 	When off the buffer contents cannot be changed.  The `'fileformat'`  and
         * 	`'fileencoding'`  options also can't be changed.
         * 	Can be reset on startup with the |-M| command line argument.
         */
        modifiable: boolean

        /**
         * `'modified'`  `'mod'` 	boolean	(default off)
         * 			local to buffer
         * 	When on, the buffer is considered to be modified.  This option is set
         * 	when:
         * 	1. A change was made to the text since it was last written.  Using the
         * 	   |undo| command to go back to the original text will reset the
         * 	   option.  But undoing changes that were made before writing the
         * 	   buffer will set the option again, since the text is different from
         * 	   when it was written.
         * 	2. `'fileformat'`  or `'fileencoding'`  is different from its original
         * 	   value.  The original value is set when the buffer is read or
         * 	   written.  A ":set nomodified" command also resets the original
         * 	   values to the current values and the `'modified'`  option will be
         * 	   reset.
         * 	   Similarly for `'eol'`  and `'bomb'` .
         * 	This option is not set when a change is made to the buffer as the
         * 	result of a BufNewFile, BufRead/BufReadPost, BufWritePost,
         * 	FileAppendPost or VimLeave autocommand event.  See |gzip-example| for
         * 	an explanation.
         * 	When `'buftype'`  is "nowrite" or "nofile" this option may be set, but
         * 	will be ignored.
         * 	Note that the text may actually be the same, e.g. `'modified'`  is set
         * 	when using "rA" on an "A".
         */
        modified: boolean

        /**
         * `'nrformats'`  `'nf'` 	string	(default "bin,hex")
         * 			local to buffer
         * 	This defines what bases Vim will consider for numbers when using the
         * 	CTRL-A and CTRL-X commands for adding to and subtracting from a number
         * 	respectively; see |CTRL-A| for more info on these commands.
         * 	alpha	If included, single alphabetical characters will be
         * 		incremented or decremented.  This is useful for a list with a
         * 		letter index a), b), etc.
         * 	octal	If included, numbers that start with a zero will be considered
         * 		to be octal.  Example: Using CTRL-A on "007" results in "010".
         * 	hex	If included, numbers starting with "0x" or "0X" will be
         * 		considered to be hexadecimal.  Example: Using CTRL-X on
         * 		"0x100" results in "0x0ff".
         * 	bin	If included, numbers starting with "0b" or "0B" will be
         * 		considered to be binary.  Example: Using CTRL-X on
         * 		"0b1000" subtracts one, resulting in "0b0111".
         * 	unsigned    If included, numbers are recognized as unsigned. Thus a
         * 		leading dash or negative sign won't be considered as part of
         * 		the number.  Examples:
         * 		    Using CTRL-X on "2020" in "9-2020" results in "9-2019"
         * 		    (without "unsigned" it would become "9-2021").
         * 		    Using CTRL-A on "2020" in "9-2020" results in "9-2021"
         * 		    (without "unsigned" it would become "9-2019").
         * 		    Using CTRL-X on "0" or CTRL-A on "18446744073709551615"
         * 		    (2^64 - 1) has no effect, overflow is prevented.
         * 	Numbers which simply begin with a digit in the range 1-9 are always
         * 	considered decimal.  This also happens for numbers that are not
         * 	recognized as octal or hex.
         */
        nrformats: string

        /**
         * `'omnifunc'`  `'ofu'` 	string	(default: empty)
         * 			local to buffer
         * 	This option specifies a function to be used for Insert mode omni
         * 	completion with CTRL-X CTRL-O. |i_CTRL-X_CTRL-O|
         * 	See |complete-functions| for an explanation of how the function is
         * 	invoked and what it should return.  The value can be the name of a
         * 	function, a |lambda| or a |Funcref|. See |option-value-function| for
         * 	more information.
         * 	This option is usually set by a filetype plugin:
         * 	|:filetype-plugin-on|
         * 	This option cannot be set from a |modeline| or in the |sandbox|, for
         * 	security reasons.
         */
        omnifunc: string

        /**
         * `'path'`  `'pa'` 		string	(default on Unix: ".,/usr/include,,"
         * 				   other systems: ".,,")
         * 			global or local to buffer |global-local|
         * 	This is a list of directories which will be searched when using the
         * 	|gf|, [f, ]f, ^Wf, |:find|, |:sfind|, |:tabfind| and other commands,
         * 	provided that the file being searched for has a relative path (not
         * 	starting with "/", "./" or "../").  The directories in the `'path'` 
         * 	option may be relative or absolute.
         * 	- Use commas to separate directory names: >
         * 		:set path=.,/usr/local/include,/usr/include
         * <	- Spaces can also be used to separate directory names (for backwards
         * 	  compatibility with version 3.0).  To have a space in a directory
         * 	  name, precede it with an extra backslash, and escape the space: >
         * 		:set path=.,/dir/with\\\ space
         * <	- To include a comma in a directory name precede it with an extra
         * 	  backslash: >
         * 		:set path=.,/dir/with\\,comma
         * <	- To search relative to the directory of the current file, use: >
         * 		:set path=.
         * <	- To search in the current directory use an empty string between two
         * 	  commas: >
         * 		:set path=,,
         * <	- A directory name may end in a `':'`  or `'/'` .
         * 	- Environment variables are expanded |:set_env|.
         * 	- When using |netrw.vim| URLs can be used.  For example, adding
         * 	  "https://www.vim.org" will make ":find index.html" work.
         * 	- Search upwards and downwards in a directory tree using "*", "" and
         * 	  ";".  See |file-searching| for info and syntax.
         * 	- Careful with `'\'`  characters, type two to get one in the option: >
         * 		:set path=.,c:\\include
         * <	  Or just use `'/'`  instead: >
         * 		:set path=.,c:/include
         * <	Don't forget "." or files won't even be found in the same directory as
         * 	the file!
         * 	The maximum length is limited.  How much depends on the system, mostly
         * 	it is something like 256 or 1024 characters.
         * 	You can check if all the include files are found, using the value of
         * 	`'path'` , see |:checkpath|.
         * 	The use of |:set+=| and |:set-=| is preferred when adding or removing
         * 	directories from the list.  This avoids problems when a future version
         * 	uses another default.  To remove the current directory use: >
         * 		:set path-=
         * <	To add the current directory use: >
         * 		:set path+=
         * <	To use an environment variable, you probably need to replace the
         * 	separator.  Here is an example to append $INCL, in which directory
         * 	names are separated with a semi-colon: >
         * 		:let &path = &path .. "," .. substitute($INCL, `';'` , `','` , `'g'` )
         * <	Replace the `';'`  with a `':'`  or whatever separator is used.  Note that
         * 	this doesn't work when $INCL contains a comma or white space.
         */
        path: string

        /**
         * `'preserveindent'`  `'pi'` 	boolean	(default off)
         * 			local to buffer
         * 	When changing the indent of the current line, preserve as much of the
         * 	indent structure as possible.  Normally the indent is replaced by a
         * 	series of tabs followed by spaces as required (unless |`'expandtab'` | is
         * 	enabled, in which case only spaces are used).  Enabling this option
         * 	means the indent will preserve as many existing characters as possible
         * 	for indenting, and only add additional tabs or spaces as required.
         * 	`'expandtab'`  does not apply to the preserved white space, a Tab remains
         * 	a Tab.
         * 	NOTE: When using ">>" multiple times the resulting indent is a mix of
         * 	tabs and spaces.  You might not like this.
         * 	Also see `'copyindent'` .
         * 	Use |:retab| to clean up white space.
         */
        preserveindent: boolean

        /**
         * `'quoteescape'`  `'qe'` 	string	(default "\")
         * 			local to buffer
         * 	The characters that are used to escape quotes in a string.  Used for
         * 	objects like a', a" and a` |a'|.
         * 	When one of the characters in this option is found inside a string,
         * 	the following character will be skipped.  The default value makes the
         * 	text "foo\"bar\\" considered to be one string.
         */
        quoteescape: string

        /**
         * `'readonly'`  `'ro'` 		boolean	(default off)
         * 			local to buffer
         * 	If on, writes fail unless you use a `'!'` .  Protects you from
         * 	accidentally overwriting a file.  Default on when Vim is started
         * 	in read-only mode ("vim -R") or when the executable is called "view".
         * 	When using ":w!" the `'readonly'`  option is reset for the current
         * 	buffer, unless the `'Z'`  flag is in `'cpoptions'` .
         * 	When using the ":view" command the `'readonly'`  option is set for the
         * 	newly edited buffer.
         * 	See `'modifiable'`  for disallowing changes to the buffer.
         */
        readonly: boolean

        /**
         * `'scrollback'`  `'scbk'` 	number	(default: 10000)
         * 			local to buffer
         * 	Maximum number of lines kept beyond the visible screen. Lines at the
         * 	top are deleted if new lines exceed this limit.
         * 	Minimum is 1, maximum is 100000.
         * 	Only in |terminal| buffers.
         */
        scrollback: number

        /**
         * `'shiftwidth'`  `'sw'` 	number	(default 8)
         * 			local to buffer
         * 	Number of spaces to use for each step of (auto)indent.  Used for
         * 	|`'cindent'` |, |>>|, |<<|, etc.
         * 	When zero the `'ts'`  value will be used.  Use the |shiftwidth()|
         * 	function to get the effective shiftwidth value.
         */
        shiftwidth: number

        /**
         * `'smartindent'`  `'si'` 	boolean	(default off)
         * 			local to buffer
         * 	Do smart autoindenting when starting a new line.  Works for C-like
         * 	programs, but can also be used for other languages.  `'cindent'`  does
         * 	something like this, works better in most cases, but is more strict,
         * 	see |C-indenting|.  When `'cindent'`  is on or `'indentexpr'`  is set,
         * 	setting `'si'`  has no effect.  `'indentexpr'`  is a more advanced
         * 	alternative.
         * 	Normally `'autoindent'`  should also be on when using `'smartindent'` .
         * 	An indent is automatically inserted:
         * 	- After a line ending in "{".
         * 	- After a line starting with a keyword from `'cinwords'` .
         * 	- Before a line starting with "}" (only with the "O" command).
         * 	When typing `'}'`  as the first character in a new line, that line is
         * 	given the same indent as the matching "{".
         * 	When typing `'#'`  as the first character in a new line, the indent for
         * 	that line is removed, the `'#'`  is put in the first column.  The indent
         * 	is restored for the next line.  If you don't want this, use this
         * 	mapping: ":inoremap # X^H#", where ^H is entered with CTRL-V CTRL-H.
         * 	When using the ">>" command, lines starting with `'#'`  are not shifted
         * 	right.
         */
        smartindent: boolean

        /**
         * `'softtabstop'`  `'sts'` 	number	(default 0)
         * 			local to buffer
         * 	Number of spaces that a <Tab> counts for while performing editing
         * 	operations, like inserting a <Tab> or using <BS>.  It "feels" like
         * 	<Tab>s are being inserted, while in fact a mix of spaces and <Tab>s is
         * 	used.  This is useful to keep the `'ts'`  setting at its standard value
         * 	of 8, while being able to edit like it is set to `'sts'` .  However,
         * 	commands like "x" still work on the actual characters.
         * 	When `'sts'`  is zero, this feature is off.
         * 	When `'sts'`  is negative, the value of `'shiftwidth'`  is used.
         * 	See also |ins-expandtab|.  When `'expandtab'`  is not set, the number of
         * 	spaces is minimized by using <Tab>s.
         * 	The `'L'`  flag in `'cpoptions'`  changes how tabs are used when `'list'`  is
         * 	set.
         * 
         * 	The value of `'softtabstop'`  will be ignored if |`'varsofttabstop'` | is set
         * 	to anything other than an empty string.
         */
        softtabstop: number

        /**
         * `'spellcapcheck'`  `'spc'` 	string	(default "[.?!]\_[\])'" \t]\+")
         * 			local to buffer
         * 	Pattern to locate the end of a sentence.  The following word will be
         * 	checked to start with a capital letter.  If not then it is highlighted
         * 	with SpellCap |hl-SpellCap| (unless the word is also badly spelled).
         * 	When this check is not wanted make this option empty.
         * 	Only used when `'spell'`  is set.
         * 	Be careful with special characters, see |option-backslash| about
         * 	including spaces and backslashes.
         * 	To set this option automatically depending on the language, see
         * 	|set-spc-auto|.
         */
        spellcapcheck: string

        /**
         * `'spellfile'`  `'spf'` 	string	(default empty)
         * 			local to buffer
         * 	Name of the word list file where words are added for the |zg| and |zw|
         * 	commands.  It must end in ".{encoding}.add".  You need to include the
         * 	path, otherwise the file is placed in the current directory.
         * 	The path may include characters from `'isfname'` , space, comma and `'@'` .
         * 
         * 	It may also be a comma-separated list of names.  A count before the
         * 	|zg| and |zw| commands can be used to access each.  This allows using
         * 	a personal word list file and a project word list file.
         * 	When a word is added while this option is empty Vim will set it for
         * 	you: Using the first directory in `'runtimepath'`  that is writable.  If
         * 	there is no "spell" directory yet it will be created.  For the file
         * 	name the first language name that appears in `'spelllang'`  is used,
         * 	ignoring the region.
         * 	The resulting ".spl" file will be used for spell checking, it does not
         * 	have to appear in `'spelllang'` .
         * 	Normally one file is used for all regions, but you can add the region
         * 	name if you want to.  However, it will then only be used when
         * 	`'spellfile'`  is set to it, for entries in `'spelllang'`  only files
         * 	without region name will be found.
         * 	This option cannot be set from a |modeline| or in the |sandbox|, for
         * 	security reasons.
         */
        spellfile: string

        /**
         * `'spelllang'`  `'spl'` 	string	(default "en")
         * 			local to buffer
         * 	A comma-separated list of word list names.  When the `'spell'`  option is
         * 	on spellchecking will be done for these languages.  Example: >
         * 		set spelllang=en_us,nl,medical
         * <	This means US English, Dutch and medical words are recognized.  Words
         * 	that are not recognized will be highlighted.
         * 	The word list name must consist of alphanumeric characters, a dash or
         * 	an underscore.  It should not include a comma or dot.  Using a dash is
         * 	recommended to separate the two letter language name from a
         * 	specification.  Thus "en-rare" is used for rare English words.
         * 	A region name must come last and have the form "_xx", where "xx" is
         * 	the two-letter, lower case region name.  You can use more than one
         * 	region by listing them: "en_us,en_ca" supports both US and Canadian
         * 	English, but not words specific for Australia, New Zealand or Great
         * 	Britain. (Note: currently en_au and en_nz dictionaries are older than
         * 	en_ca, en_gb and en_us).
         * 	If the name "cjk" is included East Asian characters are excluded from
         * 	spell checking.  This is useful when editing text that also has Asian
         * 	words.
         * 	Note that the "medical" dictionary does not exist, it is just an
         * 	example of a longer name.
         * 
         * 	As a special case the name of a .spl file can be given as-is.  The
         * 	first "_xx" in the name is removed and used as the region name
         * 	(_xx is an underscore, two letters and followed by a non-letter).
         * 	This is mainly for testing purposes.  You must make sure the correct
         * 	encoding is used, Vim doesn't check it.
         * 	How the related spell files are found is explained here: |spell-load|.
         * 
         * 	If the |spellfile.vim| plugin is active and you use a language name
         * 	for which Vim cannot find the .spl file in `'runtimepath'`  the plugin
         * 	will ask you if you want to download the file.
         * 
         * 	After this option has been set successfully, Vim will source the files
         * 	"spell/LANG.vim" in `'runtimepath'` .  "LANG" is the value of `'spelllang'` 
         * 	up to the first character that is not an ASCII letter or number and
         * 	not a dash.  Also see |set-spc-auto|.
         */
        spelllang: string

        /**
         * `'spelloptions'`  `'spo'` 	string	(default "")
         * 			local to buffer
         * 	A comma-separated list of options for spell checking:
         * 	camel		When a word is CamelCased, assume "Cased" is a
         * 			separate word: every upper-case character in a word
         * 			that comes after a lower case character indicates the
         * 			start of a new word.
         * 	noplainbuffer	Only spellcheck a buffer when `'syntax'`  is enabled,
         * 			or when extmarks are set within the buffer. Only
         * 			designated regions of the buffer are spellchecked in
         * 			this case.
         */
        spelloptions: string

        /**
         * `'suffixesadd'`  `'sua'` 	string	(default "")
         * 			local to buffer
         * 	Comma-separated list of suffixes, which are used when searching for a
         * 	file for the "gf", "[I", etc. commands.  Example: >
         * 		:set suffixesadd=.java
         * <
         */
        suffixesadd: string

        /**
         * `'swapfile'`  `'swf'` 	boolean (default on)
         * 			local to buffer
         * 	Use a swapfile for the buffer.  This option can be reset when a
         * 	swapfile is not wanted for a specific buffer.  For example, with
         * 	confidential information that even root must not be able to access.
         * 	Careful: All text will be in memory:
         * 		- Don't use this for big files.
         * 		- Recovery will be impossible!
         * 	A swapfile will only be present when |`'updatecount'` | is non-zero and
         * 	`'swapfile'`  is set.
         * 	When `'swapfile'`  is reset, the swap file for the current buffer is
         * 	immediately deleted.  When `'swapfile'`  is set, and `'updatecount'`  is
         * 	non-zero, a swap file is immediately created.
         * 	Also see |swap-file|.
         * 	If you want to open a new buffer without creating a swap file for it,
         * 	use the |:noswapfile| modifier.
         * 	See `'directory'`  for where the swap file is created.
         * 
         * 	This option is used together with `'bufhidden'`  and `'buftype'`  to
         * 	specify special kinds of buffers.   See |special-buffers|.
         */
        swapfile: boolean

        /**
         * `'synmaxcol'`  `'smc'` 	number	(default 3000)
         * 			local to buffer
         * 	Maximum column in which to search for syntax items.  In long lines the
         * 	text after this column is not highlighted and following lines may not
         * 	be highlighted correctly, because the syntax state is cleared.
         * 	This helps to avoid very slow redrawing for an XML file that is one
         * 	long line.
         * 	Set to zero to remove the limit.
         */
        synmaxcol: number

        /**
         * `'syntax'`  `'syn'` 		string	(default empty)
         * 			local to buffer
         * 	When this option is set, the syntax with this name is loaded, unless
         * 	syntax highlighting has been switched off with ":syntax off".
         * 	Otherwise this option does not always reflect the current syntax (the
         * 	b:current_syntax variable does).
         * 	This option is most useful in a modeline, for a file which syntax is
         * 	not automatically recognized.  Example, in an IDL file: >
         * 		/* vim: set syntax=idl : * /
         * <	When a dot appears in the value then this separates two filetype
         * 	names.  Example: >
         * 		/* vim: set syntax=c.doxygen : * /
         * <	This will use the "c" syntax first, then the "doxygen" syntax.
         * 	Note that the second one must be prepared to be loaded as an addition,
         * 	otherwise it will be skipped.  More than one dot may appear.
         * 	To switch off syntax highlighting for the current file, use: >
         * 		:set syntax=OFF
         * <	To switch syntax highlighting on according to the current value of the
         * 	`'filetype'`  option: >
         * 		:set syntax=ON
         * <	What actually happens when setting the `'syntax'`  option is that the
         * 	Syntax autocommand event is triggered with the value as argument.
         * 	This option is not copied to another buffer, independent of the `'s'`  or
         * 	`'S'`  flag in `'cpoptions'` .
         * 	Only normal file name characters can be used, "/\*?[|<>" are illegal.
         */
        syntax: string

        /**
         * `'tabstop'`  `'ts'` 		number	(default 8)
         * 			local to buffer
         * 	Number of spaces that a <Tab> in the file counts for.  Also see
         * 	the |:retab| command, and the `'softtabstop'`  option.
         * 
         * 	Note: Setting `'tabstop'`  to any other value than 8 can make your file
         * 	appear wrong in many places.
         * 	The value must be more than 0 and less than 10000.
         * 
         * 	There are four main ways to use tabs in Vim:
         * 	1. Always keep `'tabstop'`  at 8, set `'softtabstop'`  and `'shiftwidth'`  to 4
         * 	   (or 3 or whatever you prefer) and use `'noexpandtab'` .  Then Vim
         * 	   will use a mix of tabs and spaces, but typing <Tab> and <BS> will
         * 	   behave like a tab appears every 4 (or 3) characters.
         * 	2. Set `'tabstop'`  and `'shiftwidth'`  to whatever you prefer and use
         * 	   `'expandtab'` .  This way you will always insert spaces.  The
         * 	   formatting will never be messed up when `'tabstop'`  is changed.
         * 	3. Set `'tabstop'`  and `'shiftwidth'`  to whatever you prefer and use a
         * 	   |modeline| to set these values when editing the file again.  Only
         * 	   works when using Vim to edit the file.
         * 	4. Always set `'tabstop'`  and `'shiftwidth'`  to the same value, and
         * 	   `'noexpandtab'` .  This should then work (for initial indents only)
         * 	   for any tabstop setting that people use.  It might be nice to have
         * 	   tabs after the first non-blank inserted as spaces if you do this
         * 	   though.  Otherwise aligned comments will be wrong when `'tabstop'`  is
         * 	   changed.
         * 
         * 	The value of `'tabstop'`  will be ignored if |`'vartabstop'` | is set to
         * 	anything other than an empty string.
         */
        tabstop: number

        /**
         * `'tagcase'`  `'tc'` 		string	(default "followic")
         * 			global or local to buffer |global-local|
         * 	This option specifies how case is handled when searching the tags
         * 	file:
         * 	   followic	Follow the `'ignorecase'`  option
         * 	   followscs    Follow the `'smartcase'`  and `'ignorecase'`  options
         * 	   ignore	Ignore case
         * 	   match	Match case
         * 	   smart	Ignore case unless an upper case letter is used
         */
        tagcase: string

        /**
         * `'tagfunc'`  `'tfu'` 		string	(default: empty)
         * 			local to buffer
         * 	This option specifies a function to be used to perform tag searches.
         * 	The function gets the tag pattern and should return a List of matching
         * 	tags.  See |tag-function| for an explanation of how to write the
         * 	function and an example.  The value can be the name of a function, a
         * 	|lambda| or a |Funcref|. See |option-value-function| for more
         * 	information.
         */
        tagfunc: string

        /**
         * `'tags'`  `'tag'` 		string	(default "./tags;,tags")
         * 			global or local to buffer |global-local|
         * 	Filenames for the tag command, separated by spaces or commas.  To
         * 	include a space or comma in a file name, precede it with a backslash
         * 	(see |option-backslash| about including spaces and backslashes).
         * 	When a file name starts with "./", the `'.'`  is replaced with the path
         * 	of the current file.  But only when the `'d'`  flag is not included in
         * 	`'cpoptions'` .  Environment variables are expanded |:set_env|.  Also see
         * 	|tags-option|.
         * 	"*", "" and other wildcards can be used to search for tags files in
         * 	a directory tree.  See |file-searching|.  E.g., "/lib//tags" will
         * 	find all files named "tags" below "/lib".  The filename itself cannot
         * 	contain wildcards, it is used as-is.  E.g., "/lib//tags?" will find
         * 	files called "tags?".
         * 	The |tagfiles()| function can be used to get a list of the file names
         * 	actually used.
         * 	The use of |:set+=| and |:set-=| is preferred when adding or removing
         * 	file names from the list.  This avoids problems when a future version
         * 	uses another default.
         */
        tags: string

        /**
         * `'textwidth'`  `'tw'` 	number	(default 0)
         * 			local to buffer
         * 	Maximum width of text that is being inserted.  A longer line will be
         * 	broken after white space to get this width.  A zero value disables
         * 	this.
         * 	When `'textwidth'`  is zero, `'wrapmargin'`  may be used.  See also
         * 	`'formatoptions'`  and |ins-textwidth|.
         * 	When `'formatexpr'`  is set it will be used to break the line.
         */
        textwidth: number

        /**
         * `'thesaurus'`  `'tsr'` 	string	(default "")
         * 			global or local to buffer |global-local|
         * 	List of file names, separated by commas, that are used to lookup words
         * 	for thesaurus completion commands |i_CTRL-X_CTRL-T|.  See
         * 	|compl-thesaurus|.
         * 
         * 	This option is not used if `'thesaurusfunc'`  is set, either for the
         * 	buffer or globally.
         * 
         * 	To include a comma in a file name precede it with a backslash.  Spaces
         * 	after a comma are ignored, otherwise spaces are included in the file
         * 	name.  See |option-backslash| about using backslashes.  The use of
         * 	|:set+=| and |:set-=| is preferred when adding or removing directories
         * 	from the list.  This avoids problems when a future version uses
         * 	another default.  Backticks cannot be used in this option for security
         * 	reasons.
         */
        thesaurus: string

        /**
         * `'thesaurusfunc'`  `'tsrfu'` 	string	(default: empty)
         * 			global or local to buffer |global-local|
         * 	This option specifies a function to be used for thesaurus completion
         * 	with CTRL-X CTRL-T. |i_CTRL-X_CTRL-T| See |compl-thesaurusfunc|.
         * 	The value can be the name of a function, a |lambda| or a |Funcref|.
         * 	See |option-value-function| for more information.
         * 
         * 	This option cannot be set from a |modeline| or in the |sandbox|, for
         * 	security reasons.
         */
        thesaurusfunc: string

        /**
         * `'undofile'`  `'udf'` 	boolean	(default off)
         * 			local to buffer
         * 	When on, Vim automatically saves undo history to an undo file when
         * 	writing a buffer to a file, and restores undo history from the same
         * 	file on buffer read.
         * 	The directory where the undo file is stored is specified by `'undodir'` .
         * 	For more information about this feature see |undo-persistence|.
         * 	The undo file is not read when `'undoreload'`  causes the buffer from
         * 	before a reload to be saved for undo.
         * 	When `'undofile'`  is turned off the undo file is NOT deleted.
         */
        undofile: boolean

        /**
         * `'undolevels'`  `'ul'` 	number	(default 1000)
         * 			global or local to buffer |global-local|
         * 	Maximum number of changes that can be undone.  Since undo information
         * 	is kept in memory, higher numbers will cause more memory to be used.
         * 	Nevertheless, a single change can already use a large amount of memory.
         * 	Set to 0 for Vi compatibility: One level of undo and "u" undoes
         * 	itself: >
         * 		set ul=0
         * <	But you can also get Vi compatibility by including the `'u'`  flag in
         * 	`'cpoptions'` , and still be able to use CTRL-R to repeat undo.
         * 	Also see |undo-two-ways|.
         * 	Set to -1 for no undo at all.  You might want to do this only for the
         * 	current buffer: >
         * 		setlocal ul=-1
         * <	This helps when you run out of memory for a single change.
         * 
         * 	The local value is set to -123456 when the global value is to be used.
         * 
         * 	Also see |clear-undo|.
         */
        undolevels: number

        /**
         * `'varsofttabstop'`  `'vsts'` 	string	(default "")
         * 			local to buffer
         * 	A list of the number of spaces that a <Tab> counts for while editing,
         * 	such as inserting a <Tab> or using <BS>.  It "feels" like variable-
         * 	width <Tab>s are being inserted, while in fact a mixture of spaces
         * 	and <Tab>s is used.  Tab widths are separated with commas, with the
         * 	final value applying to all subsequent tabs.
         * 
         * 	For example, when editing assembly language files where statements
         * 	start in the 9th column and comments in the 41st, it may be useful
         * 	to use the following: >
         * 		:set varsofttabstop=8,32,8
         * <	This will set soft tabstops with 8 and 8 + 32 spaces, and 8 more
         * 	for every column thereafter.
         * 
         * 	Note that the value of |`'softtabstop'` | will be ignored while
         * 	`'varsofttabstop'`  is set.
         */
        varsofttabstop: string

        /**
         * `'vartabstop'`  `'vts'` 	string	(default "")
         * 			local to buffer
         * 	A list of the number of spaces that a <Tab> in the file counts for,
         * 	separated by commas.  Each value corresponds to one tab, with the
         * 	final value applying to all subsequent tabs. For example: >
         * 		:set vartabstop=4,20,10,8
         * <	This will make the first tab 4 spaces wide, the second 20 spaces,
         * 	the third 10 spaces, and all following tabs 8 spaces.
         * 
         * 	Note that the value of |`'tabstop'` | will be ignored while `'vartabstop'` 
         * 	is set.
         */
        vartabstop: string

        /**
         * `'wrapmargin'`  `'wm'` 	number	(default 0)
         * 			local to buffer
         * 	Number of characters from the right window border where wrapping
         * 	starts.  When typing text beyond this limit, an <EOL> will be inserted
         * 	and inserting continues on the next line.
         * 	Options that add a margin, such as `'number'`  and `'foldcolumn'` , cause
         * 	the text width to be further reduced.
         * 	When `'textwidth'`  is non-zero, this option is not used.
         * 	See also `'formatoptions'`  and |ins-textwidth|.
         */
        wrapmargin: number

    }

    export const bo: bo;

    type ListOption = {
        prepend: (value: string) => void;
        append: (value: string) => void;
        remove: (value: string) => void;
        get: () => string[];
    } & string[];

    type MapOption = {
        prepend: (values: {[key: string]: string}) => void;
        append: (values: {[key: string]: string}) => void;
        remove: (key: string) => void;
        get: () => {[key: string]: string};
    } & {[key: string]: string};

    type Option<T> = {
        get: () => T;
    } & T;

    interface opt {
        aleph: Option<number>;

        /**
         * `'allowrevins'`  `'ari'` 	boolean	(default off)
         * 			global
         * 	Allow CTRL-_ in Insert and Command-line mode.  This is default off, to
         * 	avoid that users that accidentally type CTRL-_ instead of SHIFT-_ get
         * 	into reverse Insert mode, and don't know how to get out.  See
         * 	`'revins'` .
         */
        allowrevins: Option<boolean>;

        /**
         * `'ambiwidth'`  `'ambw'` 	string (default: "single")
         * 			global
         * 	Tells Vim what to do with characters with East Asian Width Class
         * 	Ambiguous (such as Euro, Registered Sign, Copyright Sign, Greek
         * 	letters, Cyrillic letters).
         * 
         * 	There are currently two possible values:
         * 	"single":	Use the same width as characters in US-ASCII.  This is
         * 			expected by most users.
         * 	"double":	Use twice the width of ASCII characters.
         * 
         * 	The value "double" cannot be used if `'listchars'`  or `'fillchars'` 
         * 	contains a character that would be double width.  These errors may
         * 	also be given when calling setcellwidths().
         * 
         * 	The values are overruled for characters specified with
         * 	|setcellwidths()|.
         * 
         * 	There are a number of CJK fonts for which the width of glyphs for
         * 	those characters are solely based on how many octets they take in
         * 	legacy/traditional CJK encodings.  In those encodings, Euro,
         * 	Registered sign, Greek/Cyrillic letters are represented by two octets,
         * 	therefore those fonts have "wide" glyphs for them.  This is also
         * 	true of some line drawing characters used to make tables in text
         * 	file.  Therefore, when a CJK font is used for GUI Vim or
         * 	Vim is running inside a terminal (emulators) that uses a CJK font
         * 	(or Vim is run inside an xterm invoked with "-cjkwidth" option.),
         * 	this option should be set to "double" to match the width perceived
         * 	by Vim with the width of glyphs in the font.  Perhaps it also has
         * 	to be set to "double" under CJK MS-Windows when the system locale is
         * 	set to one of CJK locales.  See Unicode Standard Annex #11
         * 	(https://www.unicode.org/reports/tr11).
         */
        ambiwidth: Option<string>;

        /**
         * `'arabic'`  `'arab'` 		boolean (default off)
         * 			local to window
         * 	This option can be set to start editing Arabic text.
         * 	Setting this option will:
         * 	- Set the `'rightleft'`  option, unless `'termbidi'`  is set.
         * 	- Set the `'arabicshape'`  option, unless `'termbidi'`  is set.
         * 	- Set the `'keymap'`  option to "arabic"; in Insert mode CTRL-^ toggles
         * 	  between typing English and Arabic key mapping.
         * 	- Set the `'delcombine'`  option
         * 
         * 	Resetting this option will:
         * 	- Reset the `'rightleft'`  option.
         * 	- Disable the use of `'keymap'`  (without changing its value).
         * 	Note that `'arabicshape'`  and `'delcombine'`  are not reset (it is a global
         * 	option).
         * 	Also see |arabic.txt|.
         */
        arabic: Option<boolean>;

        /**
         * `'arabicshape'`  `'arshape'` 	boolean (default on)
         * 			global
         * 	When on and `'termbidi'`  is off, the required visual character
         * 	corrections that need to take place for displaying the Arabic language
         * 	take effect.  Shaping, in essence, gets enabled; the term is a broad
         * 	one which encompasses:
         * 	  a) the changing/morphing of characters based on their location
         * 	     within a word (initial, medial, final and stand-alone).
         * 	  b) the enabling of the ability to compose characters
         * 	  c) the enabling of the required combining of some characters
         * 	When disabled the display shows each character's true stand-alone
         * 	form.
         * 	Arabic is a complex language which requires other settings, for
         * 	further details see |arabic.txt|.
         */
        arabicshape: Option<boolean>;

        /**
         * `'autochdir'`  `'acd'` 	boolean (default off)
         * 			global
         * 	When on, Vim will change the current working directory whenever you
         * 	open a file, switch buffers, delete a buffer or open/close a window.
         * 	It will change to the directory containing the file which was opened
         * 	or selected.  When a buffer has no name it also has no directory, thus
         * 	the current directory won't change when navigating to it.
         * 	Note: When this option is on some plugins may not work.
         */
        autochdir: Option<boolean>;

        /**
         * `'autoindent'`  `'ai'` 	boolean	(default on)
         * 			local to buffer
         * 	Copy indent from current line when starting a new line (typing <CR>
         * 	in Insert mode or when using the "o" or "O" command).  If you do not
         * 	type anything on the new line except <BS> or CTRL-D and then type
         * 	<Esc>, CTRL-O or <CR>, the indent is deleted again.  Moving the cursor
         * 	to another line has the same effect, unless the `'I'`  flag is included
         * 	in `'cpoptions'` .
         * 	When autoindent is on, formatting (with the "gq" command or when you
         * 	reach `'textwidth'`  in Insert mode) uses the indentation of the first
         * 	line.
         * 	When `'smartindent'`  or `'cindent'`  is on the indent is changed in
         * 	a different way.
         * 	{small difference from Vi: After the indent is deleted when typing
         * 	<Esc> or <CR>, the cursor position when moving up or down is after the
         * 	deleted indent; Vi puts the cursor somewhere in the deleted indent}.
         */
        autoindent: Option<boolean>;

        /**
         * `'autoread'`  `'ar'` 		boolean	(default on)
         * 			global or local to buffer |global-local|
         * 	When a file has been detected to have been changed outside of Vim and
         * 	it has not been changed inside of Vim, automatically read it again.
         * 	When the file has been deleted this is not done, so you have the text
         * 	from before it was deleted.  When it appears again then it is read.
         * 	|timestamp|
         * 	If this option has a local value, use this command to switch back to
         * 	using the global value: >
         * 		:set autoread<
         * <
         */
        autoread: Option<boolean>;

        /**
         * `'autowrite'`  `'aw'` 	boolean	(default off)
         * 			global
         * 	Write the contents of the file, if it has been modified, on each
         * 	`:next`, `:rewind`, `:last`, `:first`, `:previous`, `:stop`,
         * 	`:suspend`, `:tag`, `:!`, `:make`, CTRL-] and CTRL-^ command; and when
         * 	a `:buffer`, CTRL-O, CTRL-I, '{A-Z0-9}, or `{A-Z0-9} command takes one
         * 	to another file.
         * 	A buffer is not written if it becomes hidden, e.g. when `'bufhidden'`  is
         * 	set to "hide" and `:next` is used.
         * 	Note that for some commands the `'autowrite'`  option is not used, see
         * 	`'autowriteall'`  for that.
         * 	Some buffers will not be written, specifically when `'buftype'`  is
         * 	"nowrite", "nofile", "terminal" or "prompt".
         */
        autowrite: Option<boolean>;

        /**
         * `'autowriteall'`  `'awa'` 	boolean	(default off)
         * 			global
         * 	Like `'autowrite'` , but also used for commands ":edit", ":enew", ":quit",
         * 	":qall", ":exit", ":xit", ":recover" and closing the Vim window.
         * 	Setting this option also implies that Vim behaves like `'autowrite'`  has
         * 	been set.
         */
        autowriteall: Option<boolean>;

        /**
         * `'background'`  `'bg'` 	string	(default "dark")
         * 			global
         * 	When set to "dark" or "light", adjusts the default color groups for
         * 	that background type.  The |TUI| or other UI sets this on startup
         * 	(triggering |OptionSet|) if it can detect the background color.
         * 
         * 	This option does NOT change the background color, it tells Nvim what
         * 	the "inherited" (terminal/GUI) background looks like.
         * 	See |:hi-normal| if you want to set the background color explicitly.
         * 
         * 	When a color scheme is loaded (the "g:colors_name" variable is set)
         * 	setting `'background'`  will cause the color scheme to be reloaded.  If
         * 	the color scheme adjusts to the value of `'background'`  this will work.
         * 	However, if the color scheme sets `'background'`  itself the effect may
         * 	be undone.  First delete the "g:colors_name" variable when needed.
         * 
         * 	Normally this option would be set in the vimrc file.  Possibly
         * 	depending on the terminal name.  Example: >
         * 		:if $TERM ==# "xterm"
         * 		:  set background=dark
         * 		:endif
         * <	When this option is set, the default settings for the highlight groups
         * 	will change.  To use other settings, place ":highlight" commands AFTER
         * 	the setting of the `'background'`  option.
         * 	This option is also used in the "$VIMRUNTIME/syntax/syntax.vim" file
         * 	to select the colors for syntax highlighting.  After changing this
         * 	option, you must load syntax.vim again to see the result.  This can be
         * 	done with ":syntax on".
         */
        background: Option<string>;

        /**
         * `'backspace'`  `'bs'` 	string	(default "indent,eol,start")
         * 			global
         * 	Influences the working of <BS>, <Del>, CTRL-W and CTRL-U in Insert
         * 	mode.  This is a list of items, separated by commas.  Each item allows
         * 	a way to backspace over something:
         * 	value	effect	~
         * 	indent	allow backspacing over autoindent
         * 	eol	allow backspacing over line breaks (join lines)
         * 	start	allow backspacing over the start of insert; CTRL-W and CTRL-U
         * 		stop once at the start of insert.
         * 	nostop	like start, except CTRL-W and CTRL-U do not stop at the start of
         * 		insert.
         * 
         * 	When the value is empty, Vi compatible backspacing is used, none of
         * 	the ways mentioned for the items above are possible.
         * 
         * 	For backwards compatibility with version 5.4 and earlier:
         * 	value	effect	~
         * 	  0	same as ":set backspace=" (Vi compatible)
         * 	  1	same as ":set backspace=indent,eol"
         * 	  2	same as ":set backspace=indent,eol,start"
         * 	  3	same as ":set backspace=indent,eol,nostop"
         */
        backspace: ListOption;

        /**
         * `'backup'`  `'bk'` 		boolean	(default off)
         * 			global
         * 	Make a backup before overwriting a file.  Leave it around after the
         * 	file has been successfully written.  If you do not want to keep the
         * 	backup file, but you do want a backup while the file is being
         * 	written, reset this option and set the `'writebackup'`  option (this is
         * 	the default).  If you do not want a backup file at all reset both
         * 	options (use this if your file system is almost full).  See the
         * 	|backup-table| for more explanations.
         * 	When the `'backupskip'`  pattern matches, a backup is not made anyway.
         * 	When `'patchmode'`  is set, the backup may be renamed to become the
         * 	oldest version of a file.
         */
        backup: Option<boolean>;

        /**
         * `'backupcopy'`  `'bkc'` 	string	(default: "auto")
         * 			global or local to buffer |global-local|
         * 	When writing a file and a backup is made, this option tells how it's
         * 	done.  This is a comma-separated list of words.
         * 
         * 	The main values are:
         * 	"yes"	make a copy of the file and overwrite the original one
         * 	"no"	rename the file and write a new one
         * 	"auto"	one of the previous, what works best
         * 
         * 	Extra values that can be combined with the ones above are:
         * 	"breaksymlink"	always break symlinks when writing
         * 	"breakhardlink"	always break hardlinks when writing
         * 
         * 	Making a copy and overwriting the original file:
         * 	- Takes extra time to copy the file.
         * 	+ When the file has special attributes, is a (hard/symbolic) link or
         * 	  has a resource fork, all this is preserved.
         * 	- When the file is a link the backup will have the name of the link,
         * 	  not of the real file.
         * 
         * 	Renaming the file and writing a new one:
         * 	+ It's fast.
         * 	- Sometimes not all attributes of the file can be copied to the new
         * 	  file.
         * 	- When the file is a link the new file will not be a link.
         * 
         * 	The "auto" value is the middle way: When Vim sees that renaming the
         * 	file is possible without side effects (the attributes can be passed on
         * 	and the file is not a link) that is used.  When problems are expected,
         * 	a copy will be made.
         * 
         * 	The "breaksymlink" and "breakhardlink" values can be used in
         * 	combination with any of "yes", "no" and "auto".  When included, they
         * 	force Vim to always break either symbolic or hard links by doing
         * 	exactly what the "no" option does, renaming the original file to
         * 	become the backup and writing a new file in its place.  This can be
         * 	useful for example in source trees where all the files are symbolic or
         * 	hard links and any changes should stay in the local source tree, not
         * 	be propagated back to the original source.
         * 
         * 	One situation where "no" and "auto" will cause problems: A program
         * 	that opens a file, invokes Vim to edit that file, and then tests if
         * 	the open file was changed (through the file descriptor) will check the
         * 	backup file instead of the newly created file.  "crontab -e" is an
         * 	example.
         * 
         * 	When a copy is made, the original file is truncated and then filled
         * 	with the new text.  This means that protection bits, owner and
         * 	symbolic links of the original file are unmodified.  The backup file,
         * 	however, is a new file, owned by the user who edited the file.  The
         * 	group of the backup is set to the group of the original file.  If this
         * 	fails, the protection bits for the group are made the same as for
         * 	others.
         * 
         * 	When the file is renamed, this is the other way around: The backup has
         * 	the same attributes of the original file, and the newly written file
         * 	is owned by the current user.  When the file was a (hard/symbolic)
         * 	link, the new file will not!  That's why the "auto" value doesn't
         * 	rename when the file is a link.  The owner and group of the newly
         * 	written file will be set to the same ones as the original file, but
         * 	the system may refuse to do this.  In that case the "auto" value will
         * 	again not rename the file.
         */
        backupcopy: ListOption;

        /**
         * `'backupdir'`  `'bdir'` 	string	(default ".,$XDG_STATE_HOME/nvim/backup//")
         * 			global
         * 	List of directories for the backup file, separated with commas.
         * 	- The backup file will be created in the first directory in the list
         * 	  where this is possible.  If none of the directories exist Nvim will
         * 	  attempt to create the last directory in the list.
         * 	- Empty means that no backup file will be created (`'patchmode'`  is
         * 	  impossible!).  Writing may fail because of this.
         * 	- A directory "." means to put the backup file in the same directory
         * 	  as the edited file.
         * 	- A directory starting with "./" (or ".\" for MS-Windows) means to put
         * 	  the backup file relative to where the edited file is.  The leading
         * 	  "." is replaced with the path name of the edited file.
         * 	  ("." inside a directory name has no special meaning).
         * 	- Spaces after the comma are ignored, other spaces are considered part
         * 	  of the directory name.  To have a space at the start of a directory
         * 	  name, precede it with a backslash.
         * 	- To include a comma in a directory name precede it with a backslash.
         * 	- A directory name may end in an `'/'` .
         * 	- For Unix and Win32, if a directory ends in two path separators "//",
         * 	  the swap file name will be built from the complete path to the file
         * 	  with all path separators changed to percent `'%'`  signs. This will
         * 	  ensure file name uniqueness in the backup directory.
         * 	  On Win32, it is also possible to end with "\\".  However, When a
         * 	  separating comma is following, you must use "//", since "\\" will
         * 	  include the comma in the file name. Therefore it is recommended to
         * 	  use `'//'` , instead of `'\\'` .
         * 	- Environment variables are expanded |:set_env|.
         * 	- Careful with `'\'`  characters, type one before a space, type two to
         * 	  get one in the option (see |option-backslash|), for example: >
         * 	    :set bdir=c:\\tmp,\ dir\\,with\\,commas,\\\ dir\ with\ spaces
         * <	- For backwards compatibility with Vim version 3.0 a `'>'`  at the start
         * 	  of the option is removed.
         * 	See also `'backup'`  and `'writebackup'`  options.
         * 	If you want to hide your backup files on Unix, consider this value: >
         * 		:set backupdir=./.backup,~/.backup,.,/tmp
         * <	You must create a ".backup" directory in each directory and in your
         * 	home directory for this to work properly.
         * 	The use of |:set+=| and |:set-=| is preferred when adding or removing
         * 	directories from the list.  This avoids problems when a future version
         * 	uses another default.
         * 	This option cannot be set from a |modeline| or in the |sandbox|, for
         * 	security reasons.
         */
        backupdir: ListOption;

        /**
         * `'backupext'`  `'bex'` 	string	(default "~")
         * 			global
         * 	String which is appended to a file name to make the name of the
         * 	backup file.  The default is quite unusual, because this avoids
         * 	accidentally overwriting existing files with a backup file.  You might
         * 	prefer using ".bak", but make sure that you don't have files with
         * 	".bak" that you want to keep.
         * 	Only normal file name characters can be used; "/\*?[|<>" are illegal.
         * 
         * 	If you like to keep a lot of backups, you could use a BufWritePre
         * 	autocommand to change `'backupext'`  just before writing the file to
         * 	include a timestamp. >
         * 		:au BufWritePre * let &bex = `'-'`  .. strftime("%Y%b%d%X") .. `'~'` 
         * <	Use `'backupdir'`  to put the backup in a different directory.
         */
        backupext: Option<string>;

        /**
         * `'backupskip'`  `'bsk'` 	string	(default: "$TMPDIR/,$TEMP/*"
         * 				 Unix: "/tmp/,$TMP/"
         * 				 Mac: "/private/tmp/,$TMP/")
         * 			global
         * 	A list of file patterns.  When one of the patterns matches with the
         * 	name of the file which is written, no backup file is created.  Both
         * 	the specified file name and the full path name of the file are used.
         * 	The pattern is used like with |:autocmd|, see |autocmd-pattern|.
         * 	Watch out for special characters, see |option-backslash|.
         * 	When $TMPDIR, $TMP or $TEMP is not defined, it is not used for the
         * 	default value.  "/tmp/*" is only used for Unix.
         * 
         * 	WARNING: Not having a backup file means that when Vim fails to write
         * 	your buffer correctly and then, for whatever reason, Vim exits, you
         * 	lose both the original file and what you were writing.  Only disable
         * 	backups if you don't care about losing the file.
         * 
         * 	Note that environment variables are not expanded.  If you want to use
         * 	$HOME you must expand it explicitly, e.g.: >
         * 		:let &backupskip = escape(expand(`'$HOME'` ), `'\'` ) .. `'/tmp/*'` 
         * 
         * <	Note that the default also makes sure that "crontab -e" works (when a
         * 	backup would be made by renaming the original file crontab won't see
         * 	the newly created file).  Also see `'backupcopy'`  and |crontab|.
         */
        backupskip: ListOption;

        /**
         * `'belloff'`  `'bo'` 		string	(default "all")
         * 			global
         * 	Specifies for which events the bell will not be rung. It is a comma-
         * 	separated list of items. For each item that is present, the bell
         * 	will be silenced. This is most useful to specify specific events in
         * 	insert mode to be silenced.
         * 
         * 	item	    meaning when present	~
         * 	all	    All events.
         * 	backspace   When hitting <BS> or <Del> and deleting results in an
         * 		    error.
         * 	cursor	    Fail to move around using the cursor keys or
         * 		    <PageUp>/<PageDown> in |Insert-mode|.
         * 	complete    Error occurred when using |i_CTRL-X_CTRL-K| or
         * 		    |i_CTRL-X_CTRL-T|.
         * 	copy	    Cannot copy char from insert mode using |i_CTRL-Y| or
         * 		    |i_CTRL-E|.
         * 	ctrlg	    Unknown Char after <C-G> in Insert mode.
         * 	error	    Other Error occurred (e.g. try to join last line)
         * 		    (mostly used in |Normal-mode| or |Cmdline-mode|).
         * 	esc	    hitting <Esc> in |Normal-mode|.
         * 	hangul	    Ignored.
         * 	lang	    Calling the beep module for Lua/Mzscheme/TCL.
         * 	mess	    No output available for |g<|.
         * 	showmatch   Error occurred for `'showmatch'`  function.
         * 	operator    Empty region error |cpo-E|.
         * 	register    Unknown register after <C-R> in |Insert-mode|.
         * 	shell	    Bell from shell output |:!|.
         * 	spell	    Error happened on spell suggest.
         * 	wildmode    More matches in |cmdline-completion| available
         * 		    (depends on the `'wildmode'`  setting).
         * 
         * 	This is most useful to fine tune when in Insert mode the bell should
         * 	be rung. For Normal mode and Ex commands, the bell is often rung to
         * 	indicate that an error occurred. It can be silenced by adding the
         * 	"error" keyword.
         */
        belloff: ListOption;

        /**
         * `'binary'`  `'bin'` 		boolean	(default off)
         * 			local to buffer
         * 	This option should be set before editing a binary file.  You can also
         * 	use the |-b| Vim argument.  When this option is switched on a few
         * 	options will be changed (also when it already was on):
         * 		`'textwidth'`   will be set to 0
         * 		`'wrapmargin'`  will be set to 0
         * 		`'modeline'`    will be off
         * 		`'expandtab'`   will be off
         * 	Also, `'fileformat'`  and `'fileformats'`  options will not be used, the
         * 	file is read and written like `'fileformat'`  was "unix" (a single <NL>
         * 	separates lines).
         * 	The `'fileencoding'`  and `'fileencodings'`  options will not be used, the
         * 	file is read without conversion.
         * 	NOTE: When you start editing a(nother) file while the `'bin'`  option is
         * 	on, settings from autocommands may change the settings again (e.g.,
         * 	`'textwidth'` ), causing trouble when editing.  You might want to set
         * 	`'bin'`  again when the file has been loaded.
         * 	The previous values of these options are remembered and restored when
         * 	`'bin'`  is switched from on to off.  Each buffer has its own set of
         * 	saved option values.
         * 	To edit a file with `'binary'`  set you can use the |++bin| argument.
         * 	This avoids you have to do ":set bin", which would have effect for all
         * 	files you edit.
         * 	When writing a file the <EOL> for the last line is only written if
         * 	there was one in the original file (normally Vim appends an <EOL> to
         * 	the last line if there is none; this would make the file longer).  See
         * 	the `'endofline'`  option.
         */
        binary: Option<boolean>;

        /**
         * `'bomb'` 			boolean	(default off)
         * 			local to buffer
         * 	When writing a file and the following conditions are met, a BOM (Byte
         * 	Order Mark) is prepended to the file:
         * 	- this option is on
         * 	- the `'binary'`  option is off
         * 	- `'fileencoding'`  is "utf-8", "ucs-2", "ucs-4" or one of the little/big
         * 	  endian variants.
         * 	Some applications use the BOM to recognize the encoding of the file.
         * 	Often used for UCS-2 files on MS-Windows.  For other applications it
         * 	causes trouble, for example: "cat file1 file2" makes the BOM of file2
         * 	appear halfway through the resulting file.  Gcc doesn't accept a BOM.
         * 	When Vim reads a file and `'fileencodings'`  starts with "ucs-bom", a
         * 	check for the presence of the BOM is done and `'bomb'`  set accordingly.
         * 	Unless `'binary'`  is set, it is removed from the first line, so that you
         * 	don't see it when editing.  When you don't change the options, the BOM
         * 	will be restored when writing the file.
         */
        bomb: Option<boolean>;

        /**
         * `'breakat'`  `'brk'` 		string	(default " ^I!@*-+;:,./?")
         * 			global
         * 	This option lets you choose which characters might cause a line
         * 	break if `'linebreak'`  is on.  Only works for ASCII characters.
         */
        breakat: ListOption;

        /**
         * `'breakindent'`  `'bri'` 	boolean (default off)
         * 			local to window
         * 	Every wrapped line will continue visually indented (same amount of
         * 	space as the beginning of that line), thus preserving horizontal blocks
         * 	of text.
         */
        breakindent: Option<boolean>;

        /**
         * `'breakindentopt'`  `'briopt'`  string (default empty)
         * 			local to window
         * 	Settings for `'breakindent'` . It can consist of the following optional
         * 	items and must be separated by a comma:
         * 		min:{n}	    Minimum text width that will be kept after
         * 			    applying `'breakindent'` , even if the resulting
         * 			    text should normally be narrower. This prevents
         * 			    text indented almost to the right window border
         * 			    occupying lot of vertical space when broken.
         * 			    (default: 20)
         * 		shift:{n}   After applying `'breakindent'` , the wrapped line's
         * 			    beginning will be shifted by the given number of
         * 			    characters.  It permits dynamic French paragraph
         * 			    indentation (negative) or emphasizing the line
         * 			    continuation (positive).
         * 			    (default: 0)
         * 		sbr	    Display the `'showbreak'`  value before applying the
         * 			    additional indent.
         * 			    (default: off)
         * 		list:{n}    Adds an additional indent for lines that match a
         * 			    numbered or bulleted list (using the
         * 			    `'formatlistpat'`  setting).
         * 		list:-1	    Uses the length of a match with `'formatlistpat'` 
         * 			    for indentation.
         * 			    (default: 0)
         * 		column:{n}  Indent at column {n}. Will overrule the other
         * 			    sub-options. Note: an additional indent may be
         * 			    added for the `'showbreak'`  setting.
         * 			    (default: off)
         */
        breakindentopt: ListOption;

        /**
         * `'browsedir'`  `'bsdir'` 	string	(default: "last")
         * 			global
         * 	Which directory to use for the file browser:
         * 	   last		Use same directory as with last file browser, where a
         * 			file was opened or saved.
         * 	   buffer	Use the directory of the related buffer.
         * 	   current	Use the current directory.
         * 	   {path}	Use the specified directory
         */
        browsedir: Option<string>;

        /**
         * `'bufhidden'`  `'bh'` 	string (default: "")
         * 			local to buffer
         * 	This option specifies what happens when a buffer is no longer
         * 	displayed in a window:
         * 	  <empty>	follow the global `'hidden'`  option
         * 	  hide		hide the buffer (don't unload it), even if `'hidden'`  is
         * 			not set
         * 	  unload	unload the buffer, even if `'hidden'`  is set; the
         * 			|:hide| command will also unload the buffer
         * 	  delete	delete the buffer from the buffer list, even if
         * 			`'hidden'`  is set; the |:hide| command will also delete
         * 			the buffer, making it behave like |:bdelete|
         * 	  wipe		wipe the buffer from the buffer list, even if
         * 			`'hidden'`  is set; the |:hide| command will also wipe
         * 			out the buffer, making it behave like |:bwipeout|
         * 
         * 	CAREFUL: when "unload", "delete" or "wipe" is used changes in a buffer
         * 	are lost without a warning.  Also, these values may break autocommands
         * 	that switch between buffers temporarily.
         * 	This option is used together with `'buftype'`  and `'swapfile'`  to specify
         * 	special kinds of buffers.   See |special-buffers|.
         */
        bufhidden: Option<string>;

        /**
         * `'buflisted'`  `'bl'` 	boolean (default: on)
         * 			local to buffer
         * 	When this option is set, the buffer shows up in the buffer list.  If
         * 	it is reset it is not used for ":bnext", "ls", the Buffers menu, etc.
         * 	This option is reset by Vim for buffers that are only used to remember
         * 	a file name or marks.  Vim sets it when starting to edit a buffer.
         * 	But not when moving to a buffer with ":buffer".
         */
        buflisted: Option<boolean>;

        /**
         * `'buftype'`  `'bt'` 		string (default: "")
         * 			local to buffer
         * 	The value of this option specifies the type of a buffer:
         * 	  <empty>	normal buffer
         * 	  acwrite	buffer will always be written with |BufWriteCmd|s
         * 	  help		help buffer (do not set this manually)
         * 	  nofile	buffer is not related to a file, will not be written
         * 	  nowrite	buffer will not be written
         * 	  quickfix	list of errors |:cwindow| or locations |:lwindow|
         * 	  terminal	|terminal-emulator| buffer
         * 	  prompt	buffer where only the last line can be edited, meant
         * 			to be used by a plugin, see |prompt-buffer|
         * 
         * 	This option is used together with `'bufhidden'`  and `'swapfile'`  to
         * 	specify special kinds of buffers.   See |special-buffers|.
         * 	Also see |win_gettype()|, which returns the type of the window.
         * 
         * 	Be careful with changing this option, it can have many side effects!
         * 	One such effect is that Vim will not check the timestamp of the file,
         * 	if the file is changed by another program this will not be noticed.
         * 
         * 	A "quickfix" buffer is only used for the error list and the location
         * 	list.  This value is set by the |:cwindow| and |:lwindow| commands and
         * 	you are not supposed to change it.
         * 
         * 	"nofile" and "nowrite" buffers are similar:
         * 	both:		The buffer is not to be written to disk, ":w" doesn't
         * 			work (":w filename" does work though).
         * 	both:		The buffer is never considered to be |`'modified'` |.
         * 			There is no warning when the changes will be lost, for
         * 			example when you quit Vim.
         * 	both:		A swap file is only created when using too much memory
         * 			(when `'swapfile'`  has been reset there is never a swap
         * 			file).
         * 	nofile only:	The buffer name is fixed, it is not handled like a
         * 			file name.  It is not modified in response to a |:cd|
         * 			command.
         * 	both:		When using ":e bufname" and already editing "bufname"
         * 			the buffer is made empty and autocommands are
         * 			triggered as usual for |:edit|.
         * 
         * 	"acwrite" implies that the buffer name is not related to a file, like
         * 	"nofile", but it will be written.  Thus, in contrast to "nofile" and
         * 	"nowrite", ":w" does work and a modified buffer can't be abandoned
         * 	without saving.  For writing there must be matching |BufWriteCmd|,
         * 	|FileWriteCmd| or |FileAppendCmd| autocommands.
         */
        buftype: Option<string>;

        /**
         * `'casemap'`  `'cmp'` 		string	(default: "internal,keepascii")
         * 			global
         * 	Specifies details about changing the case of letters.  It may contain
         * 	these words, separated by a comma:
         * 	internal	Use internal case mapping functions, the current
         * 			locale does not change the case mapping. When
         * 			"internal" is omitted, the towupper() and towlower()
         * 			system library functions are used when available.
         * 	keepascii	For the ASCII characters (0x00 to 0x7f) use the US
         * 			case mapping, the current locale is not effective.
         * 			This probably only matters for Turkish.
         */
        casemap: ListOption;

        /**
         * `'cdhome'`  `'cdh'` 		boolean	(default: off)
         * 			global
         * 	When on, |:cd|, |:tcd| and |:lcd| without an argument changes the
         * 	current working directory to the |$HOME| directory like in Unix.
         * 	When off, those commands just print the current directory name.
         * 	On Unix this option has no effect.
         */
        cdhome: Option<boolean>;

        /**
         * `'cdpath'`  `'cd'` 		string	(default: equivalent to $CDPATH or ",,")
         * 			global
         * 	This is a list of directories which will be searched when using the
         * 	|:cd|, |:tcd| and |:lcd| commands, provided that the directory being
         * 	searched for has a relative path, not an absolute part starting with
         * 	"/", "./" or "../", the `'cdpath'`  option is not used then.
         * 	The `'cdpath'`  option's value has the same form and semantics as
         * 	|`'path'` |.  Also see |file-searching|.
         * 	The default value is taken from $CDPATH, with a "," prepended to look
         * 	in the current directory first.
         * 	If the default value taken from $CDPATH is not what you want, include
         * 	a modified version of the following command in your vimrc file to
         * 	override it: >
         * 	  :let &cdpath = `','`  .. substitute(substitute($CDPATH, '[, ]', `'\\\0'` , `'g'` ), `':'` , `','` , `'g'` )
         * <	This option cannot be set from a |modeline| or in the |sandbox|, for
         * 	security reasons.
         * 	(parts of `'cdpath'`  can be passed to the shell to expand file names).
         */
        cdpath: ListOption;

        /**
         * `'cedit'` 			string	(default: CTRL-F)
         * 			global
         * 	The key used in Command-line Mode to open the command-line window.
         * 	Only non-printable keys are allowed.
         * 	The key can be specified as a single character, but it is difficult to
         * 	type.  The preferred way is to use the <> notation.  Examples: >
         * 		:exe "set cedit=\<C-Y>"
         * 		:exe "set cedit=\<Esc>"
         * <	|Nvi| also has this option, but it only uses the first character.
         * 	See |cmdwin|.
         */
        cedit: Option<string>;

        /**
         * `'channel'` 		number (default: 0)
         * 			local to buffer
         * 	|channel| connected to the buffer, or 0 if no channel is connected.
         * 	In a |:terminal| buffer this is the terminal channel.
         * 	Read-only.
         */
        channel: Option<number>;

        /**
         * `'charconvert'`  `'ccv'` 	string (default "")
         * 			global
         * 	An expression that is used for character encoding conversion.  It is
         * 	evaluated when a file that is to be read or has been written has a
         * 	different encoding from what is desired.
         * 	`'charconvert'`  is not used when the internal iconv() function is
         * 	supported and is able to do the conversion.  Using iconv() is
         * 	preferred, because it is much faster.
         * 	`'charconvert'`  is not used when reading stdin |--|, because there is no
         * 	file to convert from.  You will have to save the text in a file first.
         * 	The expression must return zero, false or an empty string for success,
         * 	non-zero or true for failure.
         * 	See |encoding-names| for possible encoding names.
         * 	Additionally, names given in `'fileencodings'`  and `'fileencoding'`  are
         * 	used.
         * 	Conversion between "latin1", "unicode", "ucs-2", "ucs-4" and "utf-8"
         * 	is done internally by Vim, `'charconvert'`  is not used for this.
         * 	Also used for Unicode conversion.
         * 	Example: >
         * 		set charconvert=CharConvert()
         * 		fun CharConvert()
         * 		  system("recode "
         * 			\ .. v:charconvert_from .. ".." .. v:charconvert_to
         * 			\ .. " <" .. v:fname_in .. " >" .. v:fname_out)
         * 		  return v:shell_error
         * 		endfun
         * <	The related Vim variables are:
         * 		v:charconvert_from	name of the current encoding
         * 		v:charconvert_to	name of the desired encoding
         * 		v:fname_in		name of the input file
         * 		v:fname_out		name of the output file
         * 	Note that v:fname_in and v:fname_out will never be the same.
         * 	This option cannot be set from a |modeline| or in the |sandbox|, for
         * 	security reasons.
         */
        charconvert: Option<string>;

        /**
         * `'cindent'`  `'cin'` 		boolean	(default off)
         * 			local to buffer
         * 	Enables automatic C program indenting.  See `'cinkeys'`  to set the keys
         * 	that trigger reindenting in insert mode and `'cinoptions'`  to set your
         * 	preferred indent style.
         * 	If `'indentexpr'`  is not empty, it overrules `'cindent'` .
         * 	If `'lisp'`  is not on and both `'indentexpr'`  and `'equalprg'`  are empty,
         * 	the "=" operator indents using this algorithm rather than calling an
         * 	external program.
         * 	See |C-indenting|.
         * 	When you don't like the way `'cindent'`  works, try the `'smartindent'` 
         * 	option or `'indentexpr'` .
         */
        cindent: Option<boolean>;

        /**
         * `'cinkeys'`  `'cink'` 	string	(default "0{,0},0),0],:,0#,!^F,o,O,e")
         * 			local to buffer
         * 	A list of keys that, when typed in Insert mode, cause reindenting of
         * 	the current line.  Only used if `'cindent'`  is on and `'indentexpr'`  is
         * 	empty.
         * 	For the format of this option see |cinkeys-format|.
         * 	See |C-indenting|.
         */
        cinkeys: ListOption;

        /**
         * `'cinoptions'`  `'cino'` 	string	(default "")
         * 			local to buffer
         * 	The `'cinoptions'`  affect the way `'cindent'`  reindents lines in a C
         * 	program.  See |cinoptions-values| for the values of this option, and
         * 	|C-indenting| for info on C indenting in general.
         */
        cinoptions: ListOption;

        /**
         * `'cinscopedecls'`  `'cinsd'` 	string	(default "public,protected,private")
         * 			local to buffer
         * 	Keywords that are interpreted as a C++ scope declaration by |cino-g|.
         * 	Useful e.g. for working with the Qt framework that defines additional
         * 	scope declarations "signals", "public slots" and "private slots": >
         * 		set cinscopedecls+=signals,public\ slots,private\ slots
         * 
         * <
         */
        cinscopedecls: ListOption;

        /**
         * `'cinwords'`  `'cinw'` 	string	(default "if,else,while,do,for,switch")
         * 			local to buffer
         * 	These keywords start an extra indent in the next line when
         * 	`'smartindent'`  or `'cindent'`  is set.  For `'cindent'`  this is only done at
         * 	an appropriate place (inside {}).
         * 	Note that `'ignorecase'`  isn't used for `'cinwords'` .  If case doesn't
         * 	matter, include the keyword both the uppercase and lowercase:
         * 	"if,If,IF".
         */
        cinwords: ListOption;

        /**
         * `'clipboard'`  `'cb'` 	string	(default "")
         * 			global
         * 	This option is a list of comma-separated names.
         * 	These names are recognized:
         * 
         * 
         * 	unnamed		When included, Vim will use the clipboard register "*"
         * 			for all yank, delete, change and put operations which
         * 			would normally go to the unnamed register.  When a
         * 			register is explicitly specified, it will always be
         * 			used regardless of whether "unnamed" is in `'clipboard'` 
         * 			or not.  The clipboard register can always be
         * 			explicitly accessed using the "* notation.  Also see
         * 			|clipboard|.
         * 
         * 
         * 	unnamedplus	A variant of the "unnamed" flag which uses the
         * 			clipboard register "+" (|quoteplus|) instead of
         * 			register "*" for all yank, delete, change and put
         * 			operations which would normally go to the unnamed
         * 			register.  When "unnamed" is also included to the
         * 			option, yank and delete operations (but not put)
         * 			will additionally copy the text into register
         * 			`'*'` . See |clipboard|.
         */
        clipboard: ListOption;

        /**
         * `'cmdheight'`  `'ch'` 	number	(default 1)
         * 			global or local to tab page
         * 	Number of screen lines to use for the command-line.  Helps avoiding
         * 	|hit-enter| prompts.
         * 	The value of this option is stored with the tab page, so that each tab
         * 	page can have a different value.
         * 
         * 	When `'cmdheight'`  is zero, there is no command-line unless it is being
         * 	used.  The command-line will cover the last line of the screen when
         * 	shown.
         * 
         * 	WARNING: `cmdheight=0` is considered experimental. Expect some
         * 	unwanted behaviour. Some `'shortmess'`  flags and similar
         * 	mechanism might fail to take effect, causing unwanted hit-enter
         * 	prompts.  Some informative messages, both from Nvim itself and
         * 	plugins, will not be displayed.
         */
        cmdheight: Option<number>;

        /**
         * `'cmdwinheight'`  `'cwh'` 	number	(default 7)
         * 			global
         * 	Number of screen lines to use for the command-line window. |cmdwin|
         */
        cmdwinheight: Option<number>;

        /**
         * `'colorcolumn'`  `'cc'` 	string	(default "")
         * 			local to window
         * 	`'colorcolumn'`  is a comma-separated list of screen columns that are
         * 	highlighted with ColorColumn |hl-ColorColumn|.  Useful to align
         * 	text.  Will make screen redrawing slower.
         * 	The screen column can be an absolute number, or a number preceded with
         * 	`'+'`  or `'-'` , which is added to or subtracted from `'textwidth'` . >
         * 
         * 		:set cc=+1  " highlight column after `'textwidth'` 
         * 		:set cc=+1,+2,+3  " highlight three columns after `'textwidth'` 
         * 		:hi ColorColumn ctermbg=lightgrey guibg=lightgrey
         * <
         * 	When `'textwidth'`  is zero then the items with `'-'`  and `'+'`  are not used.
         * 	A maximum of 256 columns are highlighted.
         */
        colorcolumn: ListOption;

        /**
         * `'columns'`  `'co'` 		number	(default 80 or terminal width)
         * 			global
         * 	Number of columns of the screen.  Normally this is set by the terminal
         * 	initialization and does not have to be set by hand.
         * 	When Vim is running in the GUI or in a resizable window, setting this
         * 	option will cause the window size to be changed.  When you only want
         * 	to use the size for the GUI, put the command in your |ginit.vim| file.
         * 	When you set this option and Vim is unable to change the physical
         * 	number of columns of the display, the display may be messed up.  For
         * 	the GUI it is always possible and Vim limits the number of columns to
         * 	what fits on the screen.  You can use this command to get the widest
         * 	window possible: >
         * 		:set columns=9999
         * <	Minimum value is 12, maximum value is 10000.
         */
        columns: Option<number>;

        /**
         * `'comments'`  `'com'` 	string	(default
         * 				"s1:/,ex:* /,://,b:#,:%,:XCOMM,n:>,fb:-")
         * 			local to buffer
         * 	A comma-separated list of strings that can start a comment line.  See
         * 	|format-comments|.  See |option-backslash| about using backslashes to
         * 	insert a space.
         */
        comments: ListOption;

        /**
         * `'commentstring'`  `'cms'` 	string	(default "")
         * 			local to buffer
         * 	A template for a comment.  The "%s" in the value is replaced with the
         * 	comment text.  Currently only used to add markers for folding, see
         * 	|fold-marker|.
         */
        commentstring: Option<string>;

        compatible: Option<boolean>;

        /**
         * `'complete'`  `'cpt'` 	string	(default: ".,w,b,u,t")
         * 			local to buffer
         * 	This option specifies how keyword completion |ins-completion| works
         * 	when CTRL-P or CTRL-N are used.  It is also used for whole-line
         * 	completion |i_CTRL-X_CTRL-L|.  It indicates the type of completion
         * 	and the places to scan.  It is a comma-separated list of flags:
         * 	.	scan the current buffer (`'wrapscan'`  is ignored)
         * 	w	scan buffers from other windows
         * 	b	scan other loaded buffers that are in the buffer list
         * 	u	scan the unloaded buffers that are in the buffer list
         * 	U	scan the buffers that are not in the buffer list
         * 	k	scan the files given with the `'dictionary'`  option
         * 	kspell  use the currently active spell checking |spell|
         * 	k{dict}	scan the file {dict}.  Several "k" flags can be given,
         * 		patterns are valid too.  For example: >
         * 			:set cpt=k/usr/dict/*,k~/spanish
         * <	s	scan the files given with the `'thesaurus'`  option
         * 	s{tsr}	scan the file {tsr}.  Several "s" flags can be given, patterns
         * 		are valid too.
         * 	i	scan current and included files
         * 	d	scan current and included files for defined name or macro
         * 		|i_CTRL-X_CTRL-D|
         * 	]	tag completion
         * 	t	same as "]"
         * 
         * 	Unloaded buffers are not loaded, thus their autocmds |:autocmd| are
         * 	not executed, this may lead to unexpected completions from some files
         * 	(gzipped files for example).  Unloaded buffers are not scanned for
         * 	whole-line completion.
         * 
         * 	As you can see, CTRL-N and CTRL-P can be used to do any `'iskeyword'` -
         * 	based expansion (e.g., dictionary |i_CTRL-X_CTRL-K|, included patterns
         * 	|i_CTRL-X_CTRL-I|, tags |i_CTRL-X_CTRL-]| and normal expansions).
         */
        complete: ListOption;

        /**
         * `'completefunc'`  `'cfu'` 	string	(default: empty)
         * 			local to buffer
         * 	This option specifies a function to be used for Insert mode completion
         * 	with CTRL-X CTRL-U. |i_CTRL-X_CTRL-U|
         * 	See |complete-functions| for an explanation of how the function is
         * 	invoked and what it should return.  The value can be the name of a
         * 	function, a |lambda| or a |Funcref|. See |option-value-function| for
         * 	more information.
         * 	This option cannot be set from a |modeline| or in the |sandbox|, for
         * 	security reasons.
         */
        completefunc: Option<string>;

        /**
         * `'completeopt'`  `'cot'` 	string	(default: "menu,preview")
         * 			global
         * 	A comma-separated list of options for Insert mode completion
         * 	|ins-completion|.  The supported values are:
         * 
         * 	   menu	    Use a popup menu to show the possible completions.  The
         * 		    menu is only shown when there is more than one match and
         * 		    sufficient colors are available.  |ins-completion-menu|
         * 
         * 	   menuone  Use the popup menu also when there is only one match.
         * 		    Useful when there is additional information about the
         * 		    match, e.g., what file it comes from.
         * 
         * 	   longest  Only insert the longest common text of the matches.  If
         * 		    the menu is displayed you can use CTRL-L to add more
         * 		    characters.  Whether case is ignored depends on the kind
         * 		    of completion.  For buffer text the `'ignorecase'`  option is
         * 		    used.
         * 
         * 	   preview  Show extra information about the currently selected
         * 		    completion in the preview window.  Only works in
         * 		    combination with "menu" or "menuone".
         * 
         * 	  noinsert  Do not insert any text for a match until the user selects
         * 		    a match from the menu. Only works in combination with
         * 		    "menu" or "menuone". No effect if "longest" is present.
         * 
         * 	  noselect  Do not select a match in the menu, force the user to
         * 		    select one from the menu. Only works in combination with
         * 		    "menu" or "menuone".
         */
        completeopt: ListOption;

        /**
         * `'completeslash'`  `'csl'` 	string	(default: "")
         * 			local to buffer
         * 			{only for MS-Windows}
         * 	When this option is set it overrules `'shellslash'`  for completion:
         * 	- When this option is set to "slash", a forward slash is used for path
         * 	  completion in insert mode. This is useful when editing HTML tag, or
         * 	  Makefile with `'noshellslash'`  on MS-Windows.
         * 	- When this option is set to "backslash", backslash is used. This is
         * 	  useful when editing a batch file with `'shellslash'`  set on MS-Windows.
         * 	- When this option is empty, same character is used as for
         * 	  `'shellslash'` .
         * 	For Insert mode completion the buffer-local value is used.  For
         * 	command line completion the global value is used.
         */
        completeslash: Option<string>;

        /**
         * `'concealcursor'`  `'cocu'` 	string (default: "")
         * 			local to window
         * 	Sets the modes in which text in the cursor line can also be concealed.
         * 	When the current mode is listed then concealing happens just like in
         * 	other lines.
         * 	  n		Normal mode
         * 	  v		Visual mode
         * 	  i		Insert mode
         * 	  c		Command line editing, for `'incsearch'` 
         * 
         * 	`'v'`  applies to all lines in the Visual area, not only the cursor.
         * 	A useful value is "nc".  This is used in help files.  So long as you
         * 	are moving around text is concealed, but when starting to insert text
         * 	or selecting a Visual area the concealed text is displayed, so that
         * 	you can see what you are doing.
         * 	Keep in mind that the cursor position is not always where it's
         * 	displayed.  E.g., when moving vertically it may change column.
         */
        concealcursor: Option<string>;

        /**
         * `'conceallevel'`  `'cole'` 	number (default 0)
         * 			local to window
         * 	Determine how text with the "conceal" syntax attribute |:syn-conceal|
         * 	is shown:
         * 
         * 	Value		Effect ~
         * 	0		Text is shown normally
         * 	1		Each block of concealed text is replaced with one
         * 			character.  If the syntax item does not have a custom
         * 			replacement character defined (see |:syn-cchar|) the
         * 			character defined in `'listchars'`  is used.
         * 			It is highlighted with the "Conceal" highlight group.
         * 	2		Concealed text is completely hidden unless it has a
         * 			custom replacement character defined (see
         * 			|:syn-cchar|).
         * 	3		Concealed text is completely hidden.
         * 
         * 	Note: in the cursor line concealed text is not hidden, so that you can
         * 	edit and copy the text.  This can be changed with the `'concealcursor'` 
         * 	option.
         */
        conceallevel: Option<number>;

        /**
         * `'confirm'`  `'cf'` 		boolean (default off)
         * 			global
         * 	When `'confirm'`  is on, certain operations that would normally
         * 	fail because of unsaved changes to a buffer, e.g. ":q" and ":e",
         * 	instead raise a dialog asking if you wish to save the current
         * 	file(s).  You can still use a ! to unconditionally |abandon| a buffer.
         * 	If `'confirm'`  is off you can still activate confirmation for one
         * 	command only (this is most useful in mappings) with the |:confirm|
         * 	command.
         * 	Also see the |confirm()| function and the `'v'`  flag in `'guioptions'` .
         */
        confirm: Option<boolean>;

        /**
         * `'copyindent'`  `'ci'` 	boolean	(default off)
         * 			local to buffer
         * 	Copy the structure of the existing lines indent when autoindenting a
         * 	new line.  Normally the new indent is reconstructed by a series of
         * 	tabs followed by spaces as required (unless |`'expandtab'` | is enabled,
         * 	in which case only spaces are used).  Enabling this option makes the
         * 	new line copy whatever characters were used for indenting on the
         * 	existing line.  `'expandtab'`  has no effect on these characters, a Tab
         * 	remains a Tab.  If the new indent is greater than on the existing
         * 	line, the remaining space is filled in the normal manner.
         * 	See `'preserveindent'` .
         */
        copyindent: Option<boolean>;

        /**
         * `'cpoptions'`  `'cpo'` 	string	(default: "aABceFs_")
         * 			global
         * 	A sequence of single character flags.  When a character is present
         * 	this indicates Vi-compatible behavior.  This is used for things where
         * 	not being Vi-compatible is mostly or sometimes preferred.
         * 	`'cpoptions'`  stands for "compatible-options".
         * 	Commas can be added for readability.
         * 	To avoid problems with flags that are added in the future, use the
         * 	"+=" and "-=" feature of ":set" |add-option-flags|.
         * 
         * 	    contains	behavior	~
         * 
         * 		a	When included, a ":read" command with a file name
         * 			argument will set the alternate file name for the
         * 			current window.
         * 
         * 		A	When included, a ":write" command with a file name
         * 			argument will set the alternate file name for the
         * 			current window.
         * 
         * 		b	"\|" in a ":map" command is recognized as the end of
         * 			the map command.  The `'\'`  is included in the mapping,
         * 			the text after the `'|'`  is interpreted as the next
         * 			command.  Use a CTRL-V instead of a backslash to
         * 			include the `'|'`  in the mapping.  Applies to all
         * 			mapping, abbreviation, menu and autocmd commands.
         * 			See also |map_bar|.
         * 
         * 		B	A backslash has no special meaning in mappings,
         * 			abbreviations, user commands and the "to" part of the
         * 			menu commands.  Remove this flag to be able to use a
         * 			backslash like a CTRL-V.  For example, the command
         * 			":map X \<Esc>" results in X being mapped to:
         * 				`'B'`  included:	"\^["	 (^[ is a real <Esc>)
         * 				`'B'`  excluded:	"<Esc>"  (5 characters)
         * 
         * 		c	Searching continues at the end of any match at the
         * 			cursor position, but not further than the start of the
         * 			next line.  When not present searching continues
         * 			one character from the cursor position.  With `'c'` 
         * 			"abababababab" only gets three matches when repeating
         * 			"/abab", without `'c'`  there are five matches.
         * 
         * 		C	Do not concatenate sourced lines that start with a
         * 			backslash.  See |line-continuation|.
         * 
         * 		d	Using "./" in the `'tags'`  option doesn't mean to use
         * 			the tags file relative to the current file, but the
         * 			tags file in the current directory.
         * 
         * 		D	Can't use CTRL-K to enter a digraph after Normal mode
         * 			commands with a character argument, like |r|, |f| and
         * 			|t|.
         * 
         * 		e	When executing a register with ":@r", always add a
         * 			<CR> to the last line, also when the register is not
         * 			linewise.  If this flag is not present, the register
         * 			is not linewise and the last line does not end in a
         * 			<CR>, then the last line is put on the command-line
         * 			and can be edited before hitting <CR>.
         * 
         * 		E	It is an error when using "y", "d", "c", "g~", "gu" or
         * 			"gU" on an Empty region.  The operators only work when
         * 			at least one character is to be operated on.  Example:
         * 			This makes "y0" fail in the first column.
         * 
         * 		f	When included, a ":read" command with a file name
         * 			argument will set the file name for the current buffer,
         * 			if the current buffer doesn't have a file name yet.
         * 
         * 		F	When included, a ":write" command with a file name
         * 			argument will set the file name for the current
         * 			buffer, if the current buffer doesn't have a file name
         * 			yet.  Also see |cpo-P|.
         * 
         * 		i	When included, interrupting the reading of a file will
         * 			leave it modified.
         * 
         * 		I	When moving the cursor up or down just after inserting
         * 			indent for `'autoindent'` , do not delete the indent.
         * 
         * 		J	A |sentence| has to be followed by two spaces after
         * 			the `'.'` , `'!'`  or `'?'` .  A <Tab> is not recognized as
         * 			white space.
         * 
         * 		K	Don't wait for a key code to complete when it is
         * 			halfway through a mapping.  This breaks mapping
         * 			<F1><F1> when only part of the second <F1> has been
         * 			read.  It enables cancelling the mapping by typing
         * 			<F1><Esc>.
         * 
         * 		l	Backslash in a [] range in a search pattern is taken
         * 			literally, only "\]", "\^", "\-" and "\\" are special.
         * 			See |/[]|
         * 			   `'l'`  included: "/[ \t]"  finds <Space>, `'\'`  and `'t'` 
         * 			   `'l'`  excluded: "/[ \t]"  finds <Space> and <Tab>
         * 
         * 		L	When the `'list'`  option is set, `'wrapmargin'` ,
         * 			`'textwidth'` , `'softtabstop'`  and Virtual Replace mode
         * 			(see |gR|) count a <Tab> as two characters, instead of
         * 			the normal behavior of a <Tab>.
         * 
         * 		m	When included, a showmatch will always wait half a
         * 			second.  When not included, a showmatch will wait half
         * 			a second or until a character is typed.  |`'showmatch'` |
         * 
         * 		M	When excluded, "%" matching will take backslashes into
         * 			account.  Thus in "( \( )" and "\( ( \)" the outer
         * 			parenthesis match.  When included "%" ignores
         * 			backslashes, which is Vi compatible.
         * 
         * 		n	When included, the column used for `'number'`  and
         * 			`'relativenumber'`  will also be used for text of wrapped
         * 			lines.
         * 
         * 		o	Line offset to search command is not remembered for
         * 			next search.
         * 
         * 		O	Don't complain if a file is being overwritten, even
         * 			when it didn't exist when editing it.  This is a
         * 			protection against a file unexpectedly created by
         * 			someone else.  Vi didn't complain about this.
         * 
         * 		p	Vi compatible Lisp indenting.  When not present, a
         * 			slightly better algorithm is used.
         * 
         * 		P	When included, a ":write" command that appends to a
         * 			file will set the file name for the current buffer, if
         * 			the current buffer doesn't have a file name yet and
         * 			the `'F'`  flag is also included |cpo-F|.
         * 
         * 		q	When joining multiple lines leave the cursor at the
         * 			position where it would be when joining two lines.
         * 
         * 		r	Redo ("." command) uses "/" to repeat a search
         * 			command, instead of the actually used search string.
         * 
         * 		R	Remove marks from filtered lines.  Without this flag
         * 			marks are kept like |:keepmarks| was used.
         * 
         * 		s	Set buffer options when entering the buffer for the
         * 			first time.  This is like it is in Vim version 3.0.
         * 			And it is the default.  If not present the options are
         * 			set when the buffer is created.
         * 
         * 		S	Set buffer options always when entering a buffer
         * 			(except `'readonly'` , `'fileformat'` , `'filetype'`  and
         * 			`'syntax'` ).  This is the (most) Vi compatible setting.
         * 			The options are set to the values in the current
         * 			buffer.  When you change an option and go to another
         * 			buffer, the value is copied.  Effectively makes the
         * 			buffer options global to all buffers.
         * 
         * 			`'s'`     `'S'`      copy buffer options
         * 			no     no      when buffer created
         * 			yes    no      when buffer first entered (default)
         * 			 X     yes     each time when buffer entered (vi comp.)
         * 
         * 		t	Search pattern for the tag command is remembered for
         * 			"n" command.  Otherwise Vim only puts the pattern in
         * 			the history for search pattern, but doesn't change the
         * 			last used search pattern.
         * 
         * 		u	Undo is Vi compatible.  See |undo-two-ways|.
         * 
         * 		v	Backspaced characters remain visible on the screen in
         * 			Insert mode.  Without this flag the characters are
         * 			erased from the screen right away.  With this flag the
         * 			screen newly typed text overwrites backspaced
         * 			characters.
         * 
         * 		W	Don't overwrite a readonly file.  When omitted, ":w!"
         * 			overwrites a readonly file, if possible.
         * 
         * 		x	<Esc> on the command-line executes the command-line.
         * 			The default in Vim is to abandon the command-line,
         * 			because <Esc> normally aborts a command.  |c_<Esc>|
         * 
         * 		X	When using a count with "R" the replaced text is
         * 			deleted only once.  Also when repeating "R" with "."
         * 			and a count.
         * 
         * 		y	A yank command can be redone with ".".  Think twice if
         * 			you really want to use this, it may break some
         * 			plugins, since most people expect "." to only repeat a
         * 			change.
         * 
         * 		Z	When using "w!" while the `'readonly'`  option is set,
         * 			don't reset `'readonly'` .
         * 
         * 		!	When redoing a filter command, use the last used
         * 			external command, whatever it was.  Otherwise the last
         * 			used -filter- command is used.
         * 
         * 		$	When making a change to one line, don't redisplay the
         * 			line, but put a `'$'`  at the end of the changed text.
         * 			The changed text will be overwritten when you type the
         * 			new text.  The line is redisplayed if you type any
         * 			command that moves the cursor from the insertion
         * 			point.
         * 
         * 		%	Vi-compatible matching is done for the "%" command.
         * 			Does not recognize "#if", "#endif", etc.
         * 			Does not recognize "/*" and "* /".
         * 			Parens inside single and double quotes are also
         * 			counted, causing a string that contains a paren to
         * 			disturb the matching.  For example, in a line like
         * 			"if (strcmp("foo(", s))" the first paren does not
         * 			match the last one.  When this flag is not included,
         * 			parens inside single and double quotes are treated
         * 			specially.  When matching a paren outside of quotes,
         * 			everything inside quotes is ignored.  When matching a
         * 			paren inside quotes, it will find the matching one (if
         * 			there is one).  This works very well for C programs.
         * 			This flag is also used for other features, such as
         * 			C-indenting.
         * 
         * 		+	When included, a ":write file" command will reset the
         * 			`'modified'`  flag of the buffer, even though the buffer
         * 			itself may still be different from its file.
         * 
         * 		>	When appending to a register, put a line break before
         * 			the appended text.
         * 
         * 		;	When using |,| or |;| to repeat the last |t| search
         * 			and the cursor is right in front of the searched
         * 			character, the cursor won't move. When not included,
         * 			the cursor would skip over it and jump to the
         * 			following occurrence.
         * 
         * 		_	When using |cw| on a word, do not include the
         * 			whitespace following the word in the motion.
         */
        cpoptions: ListOption;

        /**
         * `'cursorbind'`  `'crb'` 	boolean  (default off)
         * 			local to window
         * 	When this option is set, as the cursor in the current
         * 	window moves other cursorbound windows (windows that also have
         * 	this option set) move their cursors to the corresponding line and
         * 	column.  This option is useful for viewing the
         * 	differences between two versions of a file (see `'diff'` ); in diff mode,
         * 	inserted and deleted lines (though not characters within a line) are
         * 	taken into account.
         */
        cursorbind: Option<boolean>;

        /**
         * `'cursorcolumn'`  `'cuc'` 	boolean	(default off)
         * 			local to window
         * 	Highlight the screen column of the cursor with CursorColumn
         * 	|hl-CursorColumn|.  Useful to align text.  Will make screen redrawing
         * 	slower.
         * 	If you only want the highlighting in the current window you can use
         * 	these autocommands: >
         * 		au WinLeave * set nocursorline nocursorcolumn
         * 		au WinEnter * set cursorline cursorcolumn
         * <
         */
        cursorcolumn: Option<boolean>;

        /**
         * `'cursorline'`  `'cul'` 	boolean	(default off)
         * 			local to window
         * 	Highlight the text line of the cursor with CursorLine |hl-CursorLine|.
         * 	Useful to easily spot the cursor.  Will make screen redrawing slower.
         * 	When Visual mode is active the highlighting isn't used to make it
         * 	easier to see the selected text.
         */
        cursorline: Option<boolean>;

        /**
         * `'cursorlineopt'`  `'culopt'`  string (default: "number,line")
         * 			local to window
         * 	Comma-separated list of settings for how `'cursorline'`  is displayed.
         * 	Valid values:
         * 	"line"		Highlight the text line of the cursor with
         * 			CursorLine |hl-CursorLine|.
         * 	"screenline"	Highlight only the screen line of the cursor with
         * 			CursorLine |hl-CursorLine|.
         * 	"number"	Highlight the line number of the cursor with
         * 			CursorLineNr |hl-CursorLineNr|.
         * 
         * 	Special value:
         * 	"both"		Alias for the values "line,number".
         * 
         * 	"line" and "screenline" cannot be used together.
         */
        cursorlineopt: ListOption;

        /**
         * `'debug'` 			string	(default "")
         * 			global
         * 	These values can be used:
         * 	msg	Error messages that would otherwise be omitted will be given
         * 		anyway.
         * 	throw	Error messages that would otherwise be omitted will be given
         * 		anyway and also throw an exception and set |v:errmsg|.
         * 	beep	A message will be given when otherwise only a beep would be
         * 		produced.
         * 	The values can be combined, separated by a comma.
         * 	"msg" and "throw" are useful for debugging `'foldexpr'` , `'formatexpr'`  or
         * 	`'indentexpr'` .
         */
        debug: Option<string>;

        /**
         * `'define'`  `'def'` 		string	(default "^\sdefine")
         * 			global or local to buffer |global-local|
         * 	Pattern to be used to find a macro definition.  It is a search
         * 	pattern, just like for the "/" command.  This option is used for the
         * 	commands like "[i" and "[d" |include-search|.  The `'isident'`  option is
         * 	used to recognize the defined name after the match:
         * 		{match with `'define'` }{non-ID chars}{defined name}{non-ID char}
         * 	See |option-backslash| about inserting backslashes to include a space
         * 	or backslash.
         * 	The default value is for C programs.  For C++ this value would be
         * 	useful, to include const type declarations: >
         * 		^\(#\s\s[a-z]*\)
         * <	You can also use "\ze" just before the name and continue the pattern
         * 	to check what is following.  E.g. for Javascript, if a function is
         * 	defined with `func_name = function(args)`: >
         * 		^\s=\s*function(
         * <	If the function is defined with `func_name : function() {...`: >
         * 	        ^\s[:]\sfunction\s*(
         * <	When using the ":set" command, you need to double the backslashes!
         * 	To avoid that use `:let` with a single quote string: >
         * 		let &l:define = `'^\s=\s*function('` 
         * <
         */
        define: Option<string>;

        /**
         * `'delcombine'`  `'deco'` 	boolean (default off)
         * 			global
         * 	If editing Unicode and this option is set, backspace and Normal mode
         * 	"x" delete each combining character on its own.  When it is off (the
         * 	default) the character along with its combining characters are
         * 	deleted.
         * 	Note: When `'delcombine'`  is set "xx" may work differently from "2x"!
         * 
         * 	This is useful for Arabic, Hebrew and many other languages where one
         * 	may have combining characters overtop of base characters, and want
         * 	to remove only the combining ones.
         */
        delcombine: Option<boolean>;

        /**
         * `'dictionary'`  `'dict'` 	string	(default "")
         * 			global or local to buffer |global-local|
         * 	List of file names, separated by commas, that are used to lookup words
         * 	for keyword completion commands |i_CTRL-X_CTRL-K|.  Each file should
         * 	contain a list of words.  This can be one word per line, or several
         * 	words per line, separated by non-keyword characters (white space is
         * 	preferred).  Maximum line length is 510 bytes.
         * 
         * 	When this option is empty or an entry "spell" is present, and spell
         * 	checking is enabled, words in the word lists for the currently active
         * 	`'spelllang'`  are used. See |spell|.
         * 
         * 	To include a comma in a file name precede it with a backslash.  Spaces
         * 	after a comma are ignored, otherwise spaces are included in the file
         * 	name.  See |option-backslash| about using backslashes.
         * 	This has nothing to do with the |Dictionary| variable type.
         * 	Where to find a list of words?
         * 	- BSD/macOS include the "/usr/share/dict/words" file.
         * 	- Try "apt install spell" to get the "/usr/share/dict/words" file on
         * 	  apt-managed systems (Debian/Ubuntu).
         * 	The use of |:set+=| and |:set-=| is preferred when adding or removing
         * 	directories from the list.  This avoids problems when a future version
         * 	uses another default.
         * 	Backticks cannot be used in this option for security reasons.
         */
        dictionary: ListOption;

        /**
         * `'diff'` 			boolean	(default off)
         * 			local to window
         * 	Join the current window in the group of windows that shows differences
         * 	between files.  See |diff-mode|.
         */
        diff: Option<boolean>;

        /**
         * `'diffexpr'`  `'dex'` 	string	(default "")
         * 			global
         * 	Expression which is evaluated to obtain a diff file (either ed-style
         * 	or unified-style) from two versions of a file.  See |diff-diffexpr|.
         * 	This option cannot be set from a |modeline| or in the |sandbox|, for
         * 	security reasons.
         */
        diffexpr: Option<string>;

        /**
         * `'diffopt'`  `'dip'` 		string	(default "internal,filler,closeoff")
         * 			global
         * 	Option settings for diff mode.  It can consist of the following items.
         * 	All are optional.  Items must be separated by a comma.
         * 
         * 		filler		Show filler lines, to keep the text
         * 				synchronized with a window that has inserted
         * 				lines at the same position.  Mostly useful
         * 				when windows are side-by-side and `'scrollbind'` 
         * 				is set.
         * 
         * 		context:{n}	Use a context of {n} lines between a change
         * 				and a fold that contains unchanged lines.
         * 				When omitted a context of six lines is used.
         * 				When using zero the context is actually one,
         * 				since folds require a line in between, also
         * 				for a deleted line.
         * 				See |fold-diff|.
         * 
         * 		iblank		Ignore changes where lines are all blank.  Adds
         * 				the "-B" flag to the "diff" command if
         * 				`'diffexpr'`  is empty.  Check the documentation
         * 				of the "diff" command for what this does
         * 				exactly.
         * 				NOTE: the diff windows will get out of sync,
         * 				because no differences between blank lines are
         * 				taken into account.
         * 
         * 		icase		Ignore changes in case of text.  "a" and "A"
         * 				are considered the same.  Adds the "-i" flag
         * 				to the "diff" command if `'diffexpr'`  is empty.
         * 
         * 		iwhite		Ignore changes in amount of white space.  Adds
         * 				the "-b" flag to the "diff" command if
         * 				`'diffexpr'`  is empty.  Check the documentation
         * 				of the "diff" command for what this does
         * 				exactly.  It should ignore adding trailing
         * 				white space, but not leading white space.
         * 
         * 		iwhiteall	Ignore all white space changes.  Adds
         * 				the "-w" flag to the "diff" command if
         * 				`'diffexpr'`  is empty.  Check the documentation
         * 				of the "diff" command for what this does
         * 				exactly.
         * 
         * 		iwhiteeol	Ignore white space changes at end of line.
         * 				Adds the "-Z" flag to the "diff" command if
         * 				`'diffexpr'`  is empty.  Check the documentation
         * 				of the "diff" command for what this does
         * 				exactly.
         * 
         * 		horizontal	Start diff mode with horizontal splits (unless
         * 				explicitly specified otherwise).
         * 
         * 		vertical	Start diff mode with vertical splits (unless
         * 				explicitly specified otherwise).
         * 
         * 		closeoff	When a window is closed where `'diff'`  is set
         * 				and there is only one window remaining in the
         * 				same tab page with `'diff'`  set, execute
         * 				`:diffoff` in that window.  This undoes a
         * 				`:diffsplit` command.
         * 
         * 		hiddenoff	Do not use diff mode for a buffer when it
         * 				becomes hidden.
         * 
         * 		foldcolumn:{n}	Set the `'foldcolumn'`  option to {n} when
         * 				starting diff mode.  Without this 2 is used.
         * 
         * 		followwrap	Follow the `'wrap'`  option and leave as it is.
         * 
         * 		internal	Use the internal diff library.  This is
         * 				ignored when `'diffexpr'`  is set.
         * 				When running out of memory when writing a
         * 				buffer this item will be ignored for diffs
         * 				involving that buffer.  Set the `'verbose'` 
         * 				option to see when this happens.
         * 
         * 		indent-heuristic
         * 				Use the indent heuristic for the internal
         * 				diff library.
         * 
         * 		linematch:{n}   Enable a second stage diff on each generated
         * 				hunk in order to align lines. When the total
         * 				number of lines in a hunk exceeds {n}, the
         * 				second stage diff will not be performed as
         * 				very large hunks can cause noticeable lag. A
         * 				recommended setting is "linematch:60", as this
         * 				will enable alignment for a 2 buffer diff with
         * 				hunks of up to 30 lines each, or a 3 buffer
         * 				diff with hunks of up to 20 lines each.
         * 
         *                 algorithm:{text} Use the specified diff algorithm with the
         * 				internal diff engine. Currently supported
         * 				algorithms are:
         * 				myers      the default algorithm
         * 				minimal    spend extra time to generate the
         * 					   smallest possible diff
         * 				patience   patience diff algorithm
         * 				histogram  histogram diff algorithm
         * 
         * 	Examples: >
         * 		:set diffopt=internal,filler,context:4
         * 		:set diffopt=
         * 		:set diffopt=internal,filler,foldcolumn:3
         * 		:set diffopt-=internal  " do NOT use the internal diff parser
         * <
         */
        diffopt: ListOption;

        /**
         * `'digraph'`  `'dg'` 		boolean	(default off)
         * 			global
         * 	Enable the entering of digraphs in Insert mode with {char1} <BS>
         * 	{char2}.  See |digraphs|.
         */
        digraph: Option<boolean>;

        /**
         * `'directory'`  `'dir'` 	string	(default "$XDG_STATE_HOME/nvim/swap//")
         * 			global
         * 	List of directory names for the swap file, separated with commas.
         * 
         * 	Possible items:
         * 	- The swap file will be created in the first directory where this is
         * 	  possible.  If it is not possible in any directory, but last
         * 	  directory listed in the option does not exist, it is created.
         * 	- Empty means that no swap file will be used (recovery is
         * 	  impossible!) and no |E303| error will be given.
         * 	- A directory "." means to put the swap file in the same directory as
         * 	  the edited file.  On Unix, a dot is prepended to the file name, so
         * 	  it doesn't show in a directory listing.  On MS-Windows the "hidden"
         * 	  attribute is set and a dot prepended if possible.
         * 	- A directory starting with "./" (or ".\" for MS-Windows) means to put
         * 	  the swap file relative to where the edited file is.  The leading "."
         * 	  is replaced with the path name of the edited file.
         * 	- For Unix and Win32, if a directory ends in two path separators "//",
         * 	  the swap file name will be built from the complete path to the file
         * 	  with all path separators replaced by percent `'%'`  signs (including
         * 	  the colon following the drive letter on Win32). This will ensure
         * 	  file name uniqueness in the preserve directory.
         * 	  On Win32, it is also possible to end with "\\".  However, When a
         * 	  separating comma is following, you must use "//", since "\\" will
         * 	  include the comma in the file name. Therefore it is recommended to
         * 	  use `'//'` , instead of `'\\'` .
         * 	- Spaces after the comma are ignored, other spaces are considered part
         * 	  of the directory name.  To have a space at the start of a directory
         * 	  name, precede it with a backslash.
         * 	- To include a comma in a directory name precede it with a backslash.
         * 	- A directory name may end in an `':'`  or `'/'` .
         * 	- Environment variables are expanded |:set_env|.
         * 	- Careful with `'\'`  characters, type one before a space, type two to
         * 	  get one in the option (see |option-backslash|), for example: >
         * 	    :set dir=c:\\tmp,\ dir\\,with\\,commas,\\\ dir\ with\ spaces
         * <	- For backwards compatibility with Vim version 3.0 a `'>'`  at the start
         * 	  of the option is removed.
         * 	Using "." first in the list is recommended.  This means that editing
         * 	the same file twice will result in a warning.  Using "/tmp" on Unix is
         * 	discouraged: When the system crashes you lose the swap file.
         * 	"/var/tmp" is often not cleared when rebooting, thus is a better
         * 	choice than "/tmp".  But others on the computer may be able to see the
         * 	files, and it can contain a lot of files, your swap files get lost in
         * 	the crowd.  That is why a "tmp" directory in your home directory is
         * 	tried first.
         * 	The use of |:set+=| and |:set-=| is preferred when adding or removing
         * 	directories from the list.  This avoids problems when a future version
         * 	uses another default.
         * 	This option cannot be set from a |modeline| or in the |sandbox|, for
         * 	security reasons.
         */
        directory: ListOption;

        /**
         * `'display'`  `'dy'` 		string	(default "lastline")
         * 			global
         * 	Change the way text is displayed.  This is a comma-separated list of
         * 	flags:
         * 	lastline	When included, as much as possible of the last line
         * 			in a window will be displayed.  "@@@" is put in the
         * 			last columns of the last screen line to indicate the
         * 			rest of the line is not displayed.
         * 	truncate	Like "lastline", but "@@@" is displayed in the first
         * 			column of the last screen line.  Overrules "lastline".
         * 	uhex		Show unprintable characters hexadecimal as <xx>
         * 			instead of using ^C and ~C.
         * 	msgsep		Obsolete flag. Allowed but takes no effect. |msgsep|
         * 
         * 	When neither "lastline" nor "truncate" is included, a last line that
         * 	doesn't fit is replaced with "@" lines.
         * 
         * 	The "@" character can be changed by setting the "lastline" item in
         * 	`'fillchars'` .  The character is highlighted with |hl-NonText|.
         */
        display: ListOption;

        /**
         * `'eadirection'`  `'ead'` 	string	(default "both")
         * 			global
         * 	Tells when the `'equalalways'`  option applies:
         * 		ver	vertically, width of windows is not affected
         * 		hor	horizontally, height of windows is not affected
         * 		both	width and height of windows is affected
         */
        eadirection: Option<string>;

        edcompatible: Option<boolean>;

        /**
         * `'emoji'`  `'emo'` 	boolean (default: on)
         * 			global
         * 	When on all Unicode emoji characters are considered to be full width.
         * 	This excludes "text emoji" characters, which are normally displayed as
         * 	single width.  Unfortunately there is no good specification for this
         * 	and it has been determined on trial-and-error basis.  Use the
         * 	|setcellwidths()| function to change the behavior.
         */
        emoji: Option<boolean>;

        /**
         * `'encoding'`  `'enc'` 
         * 	String-encoding used internally and for |RPC| communication.
         * 	Always UTF-8.
         * 
         * 	See `'fileencoding'`  to control file-content encoding.
         */
        encoding: Option<string>;

        /**
         * `'endoffile'`  `'eof'` 	boolean	(default off)
         * 			local to buffer
         * 	Indicates that a CTRL-Z character was found at the end of the file
         * 	when reading it.  Normally only happens when `'fileformat'`  is "dos".
         * 	When writing a file and this option is off and the `'binary'`  option
         * 	is on, or `'fixeol'`  option is off, no CTRL-Z will be written at the
         * 	end of the file.
         * 	See |eol-and-eof| for example settings.
         */
        endoffile: Option<boolean>;

        /**
         * `'endofline'`  `'eol'` 	boolean	(default on)
         * 			local to buffer
         * 	When writing a file and this option is off and the `'binary'`  option
         * 	is on, or `'fixeol'`  option is off, no <EOL> will be written for the
         * 	last line in the file.  This option is automatically set or reset when
         * 	starting to edit a new file, depending on whether file has an <EOL>
         * 	for the last line in the file.  Normally you don't have to set or
         * 	reset this option.
         * 	When `'binary'`  is off and `'fixeol'`  is on the value is not used when
         * 	writing the file.  When `'binary'`  is on or `'fixeol'`  is off it is used
         * 	to remember the presence of a <EOL> for the last line in the file, so
         * 	that when you write the file the situation from the original file can
         * 	be kept.  But you can change it if you want to.
         * 	See |eol-and-eof| for example settings.
         */
        endofline: Option<boolean>;

        /**
         * `'equalalways'`  `'ea'` 	boolean	(default on)
         * 			global
         * 	When on, all the windows are automatically made the same size after
         * 	splitting or closing a window.  This also happens the moment the
         * 	option is switched on.  When off, splitting a window will reduce the
         * 	size of the current window and leave the other windows the same.  When
         * 	closing a window the extra lines are given to the window next to it
         * 	(depending on `'splitbelow'`  and `'splitright'` ).
         * 	When mixing vertically and horizontally split windows, a minimal size
         * 	is computed and some windows may be larger if there is room.  The
         * 	`'eadirection'`  option tells in which direction the size is affected.
         * 	Changing the height and width of a window can be avoided by setting
         * 	`'winfixheight'`  and `'winfixwidth'` , respectively.
         * 	If a window size is specified when creating a new window sizes are
         * 	currently not equalized (it's complicated, but may be implemented in
         * 	the future).
         */
        equalalways: Option<boolean>;

        /**
         * `'equalprg'`  `'ep'` 		string	(default "")
         * 			global or local to buffer |global-local|
         * 	External program to use for "=" command.  When this option is empty
         * 	the internal formatting functions are used; either `'lisp'` , `'cindent'` 
         * 	or `'indentexpr'` .
         * 	Environment variables are expanded |:set_env|.  See |option-backslash|
         * 	about including spaces and backslashes.
         * 	This option cannot be set from a |modeline| or in the |sandbox|, for
         * 	security reasons.
         */
        equalprg: Option<string>;

        /**
         * `'errorbells'`  `'eb'` 	boolean	(default off)
         * 			global
         * 	Ring the bell (beep or screen flash) for error messages.  This only
         * 	makes a difference for error messages, the bell will be used always
         * 	for a lot of errors without a message (e.g., hitting <Esc> in Normal
         * 	mode).  See `'visualbell'`  to make the bell behave like a screen flash
         * 	or do nothing. See `'belloff'`  to finetune when to ring the bell.
         */
        errorbells: Option<boolean>;

        /**
         * `'errorfile'`  `'ef'` 	string	(default: "errors.err")
         * 			global
         * 	Name of the errorfile for the QuickFix mode (see |:cf|).
         * 	When the "-q" command-line argument is used, `'errorfile'`  is set to the
         * 	following argument.  See |-q|.
         * 	NOT used for the ":make" command.  See `'makeef'`  for that.
         * 	Environment variables are expanded |:set_env|.
         * 	See |option-backslash| about including spaces and backslashes.
         * 	This option cannot be set from a |modeline| or in the |sandbox|, for
         * 	security reasons.
         */
        errorfile: Option<string>;

        /**
         * `'errorformat'`  `'efm'` 	string	(default is very long)
         * 			global or local to buffer |global-local|
         * 	Scanf-like description of the format for the lines in the error file
         * 	(see |errorformat|).
         */
        errorformat: ListOption;

        /**
         * `'eventignore'`  `'ei'` 	string	(default "")
         * 			global
         * 	A list of autocommand event names, which are to be ignored.
         * 	When set to "all" or when "all" is one of the items, all autocommand
         * 	events are ignored, autocommands will not be executed.
         * 	Otherwise this is a comma-separated list of event names.  Example: >
         * 	    :set ei=WinEnter,WinLeave
         * <
         */
        eventignore: ListOption;

        /**
         * `'expandtab'`  `'et'` 	boolean	(default off)
         * 			local to buffer
         * 	In Insert mode: Use the appropriate number of spaces to insert a
         * 	<Tab>.  Spaces are used in indents with the `'>'`  and `'<'`  commands and
         * 	when `'autoindent'`  is on.  To insert a real tab when `'expandtab'`  is
         * 	on, use CTRL-V<Tab>.  See also |:retab| and |ins-expandtab|.
         */
        expandtab: Option<boolean>;

        /**
         * `'exrc'`  `'ex'` 		boolean (default off)
         * 			global
         * 	Automatically execute .nvim.lua, .nvimrc, and .exrc files in the
         * 	current directory, if the file is in the |trust| list. Use |:trust| to
         * 	manage trusted files. See also |vim.secure.read()|.
         * 
         * 	Compare `'exrc'`  to |editorconfig|:
         * 	- `'exrc'`  can execute any code; editorconfig only specifies settings.
         * 	- `'exrc'`  is Nvim-specific; editorconfig works in other editors.
         * 
         * 	This option cannot be set from a |modeline| or in the |sandbox|, for
         * 	security reasons.
         */
        exrc: Option<boolean>;

        /**
         * `'fileencoding'`  `'fenc'` 	string (default: "")
         * 			local to buffer
         * 	File-content encoding for the current buffer. Conversion is done with
         * 	iconv() or as specified with `'charconvert'` .
         * 
         * 	When `'fileencoding'`  is not UTF-8, conversion will be done when
         * 	writing the file.  For reading see below.
         * 	When `'fileencoding'`  is empty, the file will be saved with UTF-8
         * 	encoding (no conversion when reading or writing a file).
         * 
         * 	WARNING: Conversion to a non-Unicode encoding can cause loss of
         * 	information!
         * 
         * 	See |encoding-names| for the possible values.  Additionally, values may be
         * 	specified that can be handled by the converter, see
         * 	|mbyte-conversion|.
         * 
         * 	When reading a file `'fileencoding'`  will be set from `'fileencodings'` .
         * 	To read a file in a certain encoding it won't work by setting
         * 	`'fileencoding'` , use the |++enc| argument.  One exception: when
         * 	`'fileencodings'`  is empty the value of `'fileencoding'`  is used.
         * 	For a new file the global value of `'fileencoding'`  is used.
         * 
         * 	Prepending "8bit-" and "2byte-" has no meaning here, they are ignored.
         * 	When the option is set, the value is converted to lowercase.  Thus
         * 	you can set it with uppercase values too.  `'_'`  characters are
         * 	replaced with `'-'` .  If a name is recognized from the list at
         * 	|encoding-names|, it is replaced by the standard name.  For example
         * 	"ISO8859-2" becomes "iso-8859-2".
         * 
         * 	When this option is set, after starting to edit a file, the `'modified'` 
         * 	option is set, because the file would be different when written.
         * 
         * 	Keep in mind that changing `'fenc'`  from a modeline happens
         * 	AFTER the text has been read, thus it applies to when the file will be
         * 	written.  If you do set `'fenc'`  in a modeline, you might want to set
         * 	`'nomodified'`  to avoid not being able to ":q".
         * 
         * 	This option cannot be changed when `'modifiable'`  is off.
         */
        fileencoding: Option<string>;

        /**
         * `'fileencodings'`  `'fencs'` 	string (default: "ucs-bom,utf-8,default,latin1")
         * 			global
         * 	This is a list of character encodings considered when starting to edit
         * 	an existing file.  When a file is read, Vim tries to use the first
         * 	mentioned character encoding.  If an error is detected, the next one
         * 	in the list is tried.  When an encoding is found that works,
         * 	`'fileencoding'`  is set to it.  If all fail, `'fileencoding'`  is set to
         * 	an empty string, which means that UTF-8 is used.
         * 		WARNING: Conversion can cause loss of information! You can use
         * 		the |++bad| argument to specify what is done with characters
         * 		that can't be converted.
         * 	For an empty file or a file with only ASCII characters most encodings
         * 	will work and the first entry of `'fileencodings'`  will be used (except
         * 	"ucs-bom", which requires the BOM to be present).  If you prefer
         * 	another encoding use an BufReadPost autocommand event to test if your
         * 	preferred encoding is to be used.  Example: >
         * 		au BufReadPost * if search(`'\S'` , `'w'` ) == 0 |
         * 			\ set fenc=iso-2022-jp | endif
         * <	This sets `'fileencoding'`  to "iso-2022-jp" if the file does not contain
         * 	non-blank characters.
         * 	When the |++enc| argument is used then the value of `'fileencodings'`  is
         * 	not used.
         * 	Note that `'fileencodings'`  is not used for a new file, the global value
         * 	of `'fileencoding'`  is used instead.  You can set it with: >
         * 		:setglobal fenc=iso-8859-2
         * <	This means that a non-existing file may get a different encoding than
         * 	an empty file.
         * 	The special value "ucs-bom" can be used to check for a Unicode BOM
         * 	(Byte Order Mark) at the start of the file.  It must not be preceded
         * 	by "utf-8" or another Unicode encoding for this to work properly.
         * 	An entry for an 8-bit encoding (e.g., "latin1") should be the last,
         * 	because Vim cannot detect an error, thus the encoding is always
         * 	accepted.
         * 	The special value "default" can be used for the encoding from the
         * 	environment.  It is useful when your environment uses a non-latin1
         * 	encoding, such as Russian.
         * 	When a file contains an illegal UTF-8 byte sequence it won't be
         * 	recognized as "utf-8".  You can use the |8g8| command to find the
         * 	illegal byte sequence.
         * 	WRONG VALUES:			WHAT'S WRONG:
         * 		latin1,utf-8		"latin1" will always be used
         * 		utf-8,ucs-bom,latin1	BOM won't be recognized in an utf-8
         * 					file
         * 		cp1250,latin1		"cp1250" will always be used
         * 	If `'fileencodings'`  is empty, `'fileencoding'`  is not modified.
         * 	See `'fileencoding'`  for the possible values.
         * 	Setting this option does not have an effect until the next time a file
         * 	is read.
         */
        fileencodings: ListOption;

        /**
         * `'fileformat'`  `'ff'` 	string (Windows default: "dos",
         * 				Unix default: "unix")
         * 			local to buffer
         * 	This gives the <EOL> of the current buffer, which is used for
         * 	reading/writing the buffer from/to a file:
         * 	    dos	    <CR><NL>
         * 	    unix    <NL>
         * 	    mac	    <CR>
         * 	When "dos" is used, CTRL-Z at the end of a file is ignored.
         * 	See |file-formats| and |file-read|.
         * 	For the character encoding of the file see `'fileencoding'` .
         * 	When `'binary'`  is set, the value of `'fileformat'`  is ignored, file I/O
         * 	works like it was set to "unix".
         * 	This option is set automatically when starting to edit a file and
         * 	`'fileformats'`  is not empty and `'binary'`  is off.
         * 	When this option is set, after starting to edit a file, the `'modified'` 
         * 	option is set, because the file would be different when written.
         * 	This option cannot be changed when `'modifiable'`  is off.
         */
        fileformat: Option<string>;

        /**
         * `'fileformats'`  `'ffs'` 	string (default:
         * 				Win32: "dos,unix",
         * 				Unix: "unix,dos")
         * 			global
         * 	This gives the end-of-line (<EOL>) formats that will be tried when
         * 	starting to edit a new buffer and when reading a file into an existing
         * 	buffer:
         * 	- When empty, the format defined with `'fileformat'`  will be used
         * 	  always.  It is not set automatically.
         * 	- When set to one name, that format will be used whenever a new buffer
         * 	  is opened.  `'fileformat'`  is set accordingly for that buffer.  The
         * 	  `'fileformats'`  name will be used when a file is read into an existing
         * 	  buffer, no matter what `'fileformat'`  for that buffer is set to.
         * 	- When more than one name is present, separated by commas, automatic
         * 	  <EOL> detection will be done when reading a file.  When starting to
         * 	  edit a file, a check is done for the <EOL>:
         * 	  1. If all lines end in <CR><NL>, and `'fileformats'`  includes "dos",
         * 	     `'fileformat'`  is set to "dos".
         * 	  2. If a <NL> is found and `'fileformats'`  includes "unix", `'fileformat'` 
         * 	     is set to "unix".  Note that when a <NL> is found without a
         * 	     preceding <CR>, "unix" is preferred over "dos".
         * 	  3. If `'fileformat'`  has not yet been set, and if a <CR> is found, and
         * 	     if `'fileformats'`  includes "mac", `'fileformat'`  is set to "mac".
         * 	     This means that "mac" is only chosen when:
         * 	      "unix" is not present or no <NL> is found in the file, and
         * 	      "dos" is not present or no <CR><NL> is found in the file.
         * 	     Except: if "unix" was chosen, but there is a <CR> before
         * 	     the first <NL>, and there appear to be more <CR>s than <NL>s in
         * 	     the first few lines, "mac" is used.
         * 	  4. If `'fileformat'`  is still not set, the first name from
         * 	     `'fileformats'`  is used.
         * 	  When reading a file into an existing buffer, the same is done, but
         * 	  this happens like `'fileformat'`  has been set appropriately for that
         * 	  file only, the option is not changed.
         * 	When `'binary'`  is set, the value of `'fileformats'`  is not used.
         * 
         * 	When Vim starts up with an empty buffer the first item is used.  You
         * 	can overrule this by setting `'fileformat'`  in your .vimrc.
         * 
         * 	For systems with a Dos-like <EOL> (<CR><NL>), when reading files that
         * 	are ":source"ed and for vimrc files, automatic <EOL> detection may be
         * 	done:
         * 	- When `'fileformats'`  is empty, there is no automatic detection.  Dos
         * 	  format will be used.
         * 	- When `'fileformats'`  is set to one or more names, automatic detection
         * 	  is done.  This is based on the first <NL> in the file: If there is a
         * 	  <CR> in front of it, Dos format is used, otherwise Unix format is
         * 	  used.
         * 	Also see |file-formats|.
         */
        fileformats: ListOption;

        /**
         * `'fileignorecase'`  `'fic'` 	boolean	(default on for systems where case in file
         * 				 names is normally ignored)
         * 			global
         * 	When set case is ignored when using file names and directories.
         * 	See `'wildignorecase'`  for only ignoring case when doing completion.
         */
        fileignorecase: Option<boolean>;

        /**
         * `'filetype'`  `'ft'` 		string (default: "")
         * 			local to buffer
         * 	When this option is set, the FileType autocommand event is triggered.
         * 	All autocommands that match with the value of this option will be
         * 	executed.  Thus the value of `'filetype'`  is used in place of the file
         * 	name.
         * 	Otherwise this option does not always reflect the current file type.
         * 	This option is normally set when the file type is detected.  To enable
         * 	this use the ":filetype on" command. |:filetype|
         * 	Setting this option to a different value is most useful in a modeline,
         * 	for a file for which the file type is not automatically recognized.
         * 	Example, for in an IDL file: >
         * 		/* vim: set filetype=idl : * /
         * <	|FileType| |filetypes|
         * 	When a dot appears in the value then this separates two filetype
         * 	names.  Example: >
         * 		/* vim: set filetype=c.doxygen : * /
         * <	This will use the "c" filetype first, then the "doxygen" filetype.
         * 	This works both for filetype plugins and for syntax files.  More than
         * 	one dot may appear.
         * 	This option is not copied to another buffer, independent of the `'s'`  or
         * 	`'S'`  flag in `'cpoptions'` .
         * 	Only normal file name characters can be used, "/\*?[|<>" are illegal.
         */
        filetype: Option<string>;

        /**
         * `'fillchars'`  `'fcs'` 	string	(default "")
         * 			global or local to window |global-local|
         * 	Characters to fill the statuslines, vertical separators and special
         * 	lines in the window.
         * 	It is a comma-separated list of items.  Each item has a name, a colon
         * 	and the value of that item:
         * 
         * 	  item		default		Used for ~
         * 	  stl		' ' or `'^'` 	statusline of the current window
         * 	  stlnc		' ' or `'='` 	statusline of the non-current windows
         * 	  wbr		' '		window bar
         * 	  horiz		`'─'`  or `'-'` 	horizontal separators |:split|
         * 	  horizup	`'┴'`  or `'-'` 	upwards facing horizontal separator
         * 	  horizdown	`'┬'`  or `'-'` 	downwards facing horizontal separator
         * 	  vert		`'│'`  or `'|'` 	vertical separators |:vsplit|
         * 	  vertleft	`'┤'`  or `'|'` 	left facing vertical separator
         * 	  vertright	`'├'`  or `'|'` 	right facing vertical separator
         * 	  verthoriz	`'┼'`  or `'+'` 	overlapping vertical and horizontal
         * 					separator
         * 	  fold		`'·'`  or `'-'` 	filling `'foldtext'` 
         * 	  foldopen	`'-'` 		mark the beginning of a fold
         * 	  foldclose	`'+'` 		show a closed fold
         * 	  foldsep	`'│'`  or `'|'`       open fold middle marker
         * 	  diff		`'-'` 		deleted lines of the `'diff'`  option
         * 	  msgsep	' '		message separator `'display'` 
         * 	  eob		`'~'` 		empty lines at the end of a buffer
         * 	  lastline	`'@'` 		`'display'`  contains lastline/truncate
         * 
         * 	Any one that is omitted will fall back to the default.  For "stl" and
         * 	"stlnc" the space will be used when there is highlighting, `'^'`  or `'='` 
         * 	otherwise.
         * 
         * 	Note that "horiz", "horizup", "horizdown", "vertleft", "vertright" and
         * 	"verthoriz" are only used when `'laststatus'`  is 3, since only vertical
         * 	window separators are used otherwise.
         * 
         * 	If `'ambiwidth'`  is "double" then "horiz", "horizup", "horizdown",
         * 	"vert", "vertleft", "vertright", "verthoriz", "foldsep" and "fold"
         * 	default to single-byte alternatives.
         * 
         * 	Example: >
         * 	    :set fillchars=stl:^,stlnc:=,vert:│,fold:·,diff:-
         * <	This is similar to the default, except that these characters will also
         * 	be used when there is highlighting.
         * 
         * 	For the "stl", "stlnc", "foldopen", "foldclose" and "foldsep" items
         * 	single-byte and multibyte characters are supported.  But double-width
         * 	characters are not supported.
         * 
         * 	The highlighting used for these items:
         * 	  item		highlight group ~
         * 	  stl		StatusLine		|hl-StatusLine|
         * 	  stlnc		StatusLineNC		|hl-StatusLineNC|
         * 	  wbr		WinBar			|hl-WinBar| or |hl-WinBarNC|
         * 	  horiz		WinSeparator		|hl-WinSeparator|
         * 	  horizup	WinSeparator		|hl-WinSeparator|
         * 	  horizdown	WinSeparator		|hl-WinSeparator|
         * 	  vert		WinSeparator		|hl-WinSeparator|
         * 	  vertleft	WinSeparator		|hl-WinSeparator|
         * 	  vertright	WinSeparator		|hl-WinSeparator|
         * 	  verthoriz	WinSeparator		|hl-WinSeparator|
         * 	  fold		Folded			|hl-Folded|
         * 	  diff		DiffDelete		|hl-DiffDelete|
         * 	  eob		EndOfBuffer		|hl-EndOfBuffer|
         * 	  lastline	NonText			|hl-NonText|
         */
        fillchars: MapOption;

        /**
         * `'fixendofline'`  `'fixeol'` 	boolean	(default on)
         * 			local to buffer
         * 	When writing a file and this option is on, <EOL> at the end of file
         * 	will be restored if missing.  Turn this option off if you want to
         * 	preserve the situation from the original file.
         * 	When the `'binary'`  option is set the value of this option doesn't
         * 	matter.
         * 	See the `'endofline'`  option.
         * 	See |eol-and-eof| for example settings.
         */
        fixendofline: Option<boolean>;

        /**
         * `'foldclose'`  `'fcl'` 	string (default "")
         * 			global
         * 	When set to "all", a fold is closed when the cursor isn't in it and
         * 	its level is higher than `'foldlevel'` .  Useful if you want folds to
         * 	automatically close when moving out of them.
         */
        foldclose: ListOption;

        /**
         * `'foldcolumn'`  `'fdc'` 	string (default "0")
         * 			local to window
         * 	When and how to draw the foldcolumn. Valid values are:
         * 	    "auto":       resize to the minimum amount of folds to display.
         * 	    "auto:[1-9]": resize to accommodate multiple folds up to the
         * 			  selected level
         *             0:            to disable foldcolumn
         * 	    "[1-9]":      to display a fixed number of columns
         * 	See |folding|.
         */
        foldcolumn: Option<string>;

        /**
         * `'foldenable'`  `'fen'` 	boolean (default on)
         * 			local to window
         * 	When off, all folds are open.  This option can be used to quickly
         * 	switch between showing all text unfolded and viewing the text with
         * 	folds (including manually opened or closed folds).  It can be toggled
         * 	with the |zi| command.  The `'foldcolumn'`  will remain blank when
         * 	`'foldenable'`  is off.
         * 	This option is set by commands that create a new fold or close a fold.
         * 	See |folding|.
         */
        foldenable: Option<boolean>;

        /**
         * `'foldexpr'`  `'fde'` 	string (default: "0")
         * 			local to window
         * 	The expression used for when `'foldmethod'`  is "expr".  It is evaluated
         * 	for each line to obtain its fold level.  See |fold-expr|.
         * 
         * 	The expression will be evaluated in the |sandbox| if set from a
         * 	modeline, see |sandbox-option|.
         * 	This option can't be set from a |modeline| when the `'diff'`  option is
         * 	on or the `'modelineexpr'`  option is off.
         * 
         * 	It is not allowed to change text or jump to another window while
         * 	evaluating `'foldexpr'`  |textlock|.
         */
        foldexpr: Option<string>;

        /**
         * `'foldignore'`  `'fdi'` 	string (default: "#")
         * 			local to window
         * 	Used only when `'foldmethod'`  is "indent".  Lines starting with
         * 	characters in `'foldignore'`  will get their fold level from surrounding
         * 	lines.  White space is skipped before checking for this character.
         * 	The default "#" works well for C programs.  See |fold-indent|.
         */
        foldignore: Option<string>;

        /**
         * `'foldlevel'`  `'fdl'` 	number (default: 0)
         * 			local to window
         * 	Sets the fold level: Folds with a higher level will be closed.
         * 	Setting this option to zero will close all folds.  Higher numbers will
         * 	close fewer folds.
         * 	This option is set by commands like |zm|, |zM| and |zR|.
         * 	See |fold-foldlevel|.
         */
        foldlevel: Option<number>;

        /**
         * `'foldlevelstart'`  `'fdls'` 	number (default: -1)
         * 			global
         * 	Sets `'foldlevel'`  when starting to edit another buffer in a window.
         * 	Useful to always start editing with all folds closed (value zero),
         * 	some folds closed (one) or no folds closed (99).
         * 	This is done before reading any modeline, thus a setting in a modeline
         * 	overrules this option.  Starting to edit a file for |diff-mode| also
         * 	ignores this option and closes all folds.
         * 	It is also done before BufReadPre autocommands, to allow an autocmd to
         * 	overrule the `'foldlevel'`  value for specific files.
         * 	When the value is negative, it is not used.
         */
        foldlevelstart: Option<number>;

        /**
         * `'foldmarker'`  `'fmr'` 	string (default: "{{{,}}}")
         * 			local to window
         * 	The start and end marker used when `'foldmethod'`  is "marker".  There
         * 	must be one comma, which separates the start and end marker.  The
         * 	marker is a literal string (a regular expression would be too slow).
         * 	See |fold-marker|.
         */
        foldmarker: ListOption;

        /**
         * `'foldmethod'`  `'fdm'` 	string (default: "manual")
         * 			local to window
         * 	The kind of folding used for the current window.  Possible values:
         * 	|fold-manual|	manual	    Folds are created manually.
         * 	|fold-indent|	indent	    Lines with equal indent form a fold.
         * 	|fold-expr|	expr	    `'foldexpr'`  gives the fold level of a line.
         * 	|fold-marker|	marker	    Markers are used to specify folds.
         * 	|fold-syntax|	syntax	    Syntax highlighting items specify folds.
         * 	|fold-diff|	diff	    Fold text that is not changed.
         */
        foldmethod: Option<string>;

        /**
         * `'foldminlines'`  `'fml'` 	number (default: 1)
         * 			local to window
         * 	Sets the number of screen lines above which a fold can be displayed
         * 	closed.  Also for manually closed folds.  With the default value of
         * 	one a fold can only be closed if it takes up two or more screen lines.
         * 	Set to zero to be able to close folds of just one screen line.
         * 	Note that this only has an effect on what is displayed.  After using
         * 	"zc" to close a fold, which is displayed open because it's smaller
         * 	than `'foldminlines'` , a following "zc" may close a containing fold.
         */
        foldminlines: Option<number>;

        /**
         * `'foldnestmax'`  `'fdn'` 	number (default: 20)
         * 			local to window
         * 	Sets the maximum nesting of folds for the "indent" and "syntax"
         * 	methods.  This avoids that too many folds will be created.  Using more
         * 	than 20 doesn't work, because the internal limit is 20.
         */
        foldnestmax: Option<number>;

        /**
         * `'foldopen'`  `'fdo'` 	string (default: "block,hor,mark,percent,quickfix,
         * 							     search,tag,undo")
         * 			global
         * 	Specifies for which type of commands folds will be opened, if the
         * 	command moves the cursor into a closed fold.  It is a comma-separated
         * 	list of items.
         * 	NOTE: When the command is part of a mapping this option is not used.
         * 	Add the |zv| command to the mapping to get the same effect.
         * 	(rationale: the mapping may want to control opening folds itself)
         * 
         * 		item		commands ~
         * 		all		any
         * 		block		"(", "{", "[[", "[{", etc.
         * 		hor		horizontal movements: "l", "w", "fx", etc.
         * 		insert		any command in Insert mode
         * 		jump		far jumps: "G", "gg", etc.
         * 		mark		jumping to a mark: "'m", CTRL-O, etc.
         * 		percent		"%"
         * 		quickfix	":cn", ":crew", ":make", etc.
         * 		search		search for a pattern: "/", "n", "*", "gd", etc.
         * 				(not for a search pattern in a ":" command)
         * 				Also for |[s| and |]s|.
         * 		tag		jumping to a tag: ":ta", CTRL-T, etc.
         * 		undo		undo or redo: "u" and CTRL-R
         * 	When a movement command is used for an operator (e.g., "dl" or "y%")
         * 	this option is not used.  This means the operator will include the
         * 	whole closed fold.
         * 	Note that vertical movements are not here, because it would make it
         * 	very difficult to move onto a closed fold.
         * 	In insert mode the folds containing the cursor will always be open
         * 	when text is inserted.
         * 	To close folds you can re-apply `'foldlevel'`  with the |zx| command or
         * 	set the `'foldclose'`  option to "all".
         */
        foldopen: ListOption;

        /**
         * `'foldtext'`  `'fdt'` 	string (default: "foldtext()")
         * 			local to window
         * 	An expression which is used to specify the text displayed for a closed
         * 	fold.  See |fold-foldtext|.
         * 
         * 	The expression will be evaluated in the |sandbox| if set from a
         * 	modeline, see |sandbox-option|.
         * 	This option cannot be set in a modeline when `'modelineexpr'`  is off.
         * 
         * 	It is not allowed to change text or jump to another window while
         * 	evaluating `'foldtext'`  |textlock|.
         */
        foldtext: Option<string>;

        /**
         * `'formatexpr'`  `'fex'` 	string (default "")
         * 			local to buffer
         * 	Expression which is evaluated to format a range of lines for the |gq|
         * 	operator or automatic formatting (see `'formatoptions'` ).  When this
         * 	option is empty `'formatprg'`  is used.
         * 
         * 	The |v:lnum|  variable holds the first line to be formatted.
         * 	The |v:count| variable holds the number of lines to be formatted.
         * 	The |v:char|  variable holds the character that is going to be
         * 		      inserted if the expression is being evaluated due to
         * 		      automatic formatting.  This can be empty.  Don't insert
         * 		      it yet!
         * 
         * 	Example: >
         * 		:set formatexpr=mylang#Format()
         * <	This will invoke the mylang#Format() function in the
         * 	autoload/mylang.vim file in `'runtimepath'` . |autoload|
         * 
         * 	The expression is also evaluated when `'textwidth'`  is set and adding
         * 	text beyond that limit.  This happens under the same conditions as
         * 	when internal formatting is used.  Make sure the cursor is kept in the
         * 	same spot relative to the text then!  The |mode()| function will
         * 	return "i" or "R" in this situation.
         * 
         * 	When the expression evaluates to non-zero Vim will fall back to using
         * 	the internal format mechanism.
         * 
         * 	If the expression starts with s: or |<SID>|, then it is replaced with
         * 	the script ID (|local-function|). Example: >
         * 		set formatexpr=s:MyFormatExpr()
         * 		set formatexpr=<SID>SomeFormatExpr()
         * <
         * 	The expression will be evaluated in the |sandbox| when set from a
         * 	modeline, see |sandbox-option|.  That stops the option from working,
         * 	since changing the buffer text is not allowed.
         * 	This option cannot be set in a modeline when `'modelineexpr'`  is off.
         * 	NOTE: This option is set to "" when `'compatible'`  is set.
         */
        formatexpr: Option<string>;

        /**
         * `'formatlistpat'`  `'flp'` 	string (default: "^\s*\d\+[\]:.)}\t ]\s*")
         * 			local to buffer
         * 	A pattern that is used to recognize a list header.  This is used for
         * 	the "n" flag in `'formatoptions'` .
         * 	The pattern must match exactly the text that will be the indent for
         * 	the line below it.  You can use |/\ze| to mark the end of the match
         * 	while still checking more characters.  There must be a character
         * 	following the pattern, when it matches the whole line it is handled
         * 	like there is no match.
         * 	The default recognizes a number, followed by an optional punctuation
         * 	character and white space.
         */
        formatlistpat: Option<string>;

        /**
         * `'formatoptions'`  `'fo'` 	string (default: "tcqj")
         * 			local to buffer
         * 	This is a sequence of letters which describes how automatic
         * 	formatting is to be done.  See |fo-table|.  Commas can be inserted for
         * 	readability.
         * 	To avoid problems with flags that are added in the future, use the
         * 	"+=" and "-=" feature of ":set" |add-option-flags|.
         */
        formatoptions: ListOption;

        /**
         * `'formatprg'`  `'fp'` 	string (default "")
         * 			global or local to buffer |global-local|
         * 	The name of an external program that will be used to format the lines
         * 	selected with the |gq| operator.  The program must take the input on
         * 	stdin and produce the output on stdout.  The Unix program "fmt" is
         * 	such a program.
         * 	If the `'formatexpr'`  option is not empty it will be used instead.
         * 	Otherwise, if `'formatprg'`  option is an empty string, the internal
         * 	format function will be used |C-indenting|.
         * 	Environment variables are expanded |:set_env|.  See |option-backslash|
         * 	about including spaces and backslashes.
         * 	This option cannot be set from a |modeline| or in the |sandbox|, for
         * 	security reasons.
         */
        formatprg: Option<string>;

        /**
         * `'fsync'`  `'fs'` 		boolean	(default off)
         * 			global
         * 	When on, the OS function fsync() will be called after saving a file
         * 	(|:write|, |writefile()|, …), |swap-file|, |undo-persistence| and |shada-file|.
         * 	This flushes the file to disk, ensuring that it is safely written.
         * 	Slow on some systems: writing buffers, quitting Nvim, and other
         * 	operations may sometimes take a few seconds.
         * 
         * 	Files are ALWAYS flushed (`'fsync'`  is ignored) when:
         * 	- |CursorHold| event is triggered
         * 	- |:preserve| is called
         * 	- system signals low battery life
         * 	- Nvim exits abnormally
         * 
         * 	This option cannot be set from a |modeline| or in the |sandbox|, for
         * 	security reasons.
         */
        fsync: Option<boolean>;

        /**
         * `'gdefault'`  `'gd'` 		boolean	(default off)
         * 			global
         * 	When on, the ":substitute" flag `'g'`  is default on.  This means that
         * 	all matches in a line are substituted instead of one.  When a `'g'`  flag
         * 	is given to a ":substitute" command, this will toggle the substitution
         * 	of all or one match.  See |complex-change|.
         * 
         * 		command		`'gdefault'`  on	`'gdefault'`  off	~
         * 		:s///		  subst. all	  subst. one
         * 		:s///g		  subst. one	  subst. all
         * 		:s///gg		  subst. all	  subst. one
         * 
         * 	DEPRECATED: Setting this option may break plugins that are not aware
         * 	of this option.  Also, many users get confused that adding the /g flag
         * 	has the opposite effect of that it normally does.
         */
        gdefault: Option<boolean>;

        /**
         * `'grepformat'`  `'gfm'` 	string	(default "%f:%l:%m,%f:%l%m,%f  %l%m")
         * 			global
         * 	Format to recognize for the ":grep" command output.
         * 	This is a scanf-like string that uses the same format as the
         * 	`'errorformat'`  option: see |errorformat|.
         */
        grepformat: ListOption;

        /**
         * `'grepprg'`  `'gp'` 		string	(default "grep -n ",
         * 				 Unix: "grep -n $* /dev/null")
         * 			global or local to buffer |global-local|
         * 	Program to use for the |:grep| command.  This option may contain `'%'` 
         * 	and `'#'`  characters, which are expanded like when used in a command-
         * 	line.  The placeholder "$*" is allowed to specify where the arguments
         * 	will be included.  Environment variables are expanded |:set_env|.  See
         * 	|option-backslash| about including spaces and backslashes.
         * 	When your "grep" accepts the "-H" argument, use this to make ":grep"
         * 	also work well with a single file: >
         * 		:set grepprg=grep\ -nH
         * <	Special value: When `'grepprg'`  is set to "internal" the |:grep| command
         * 	works like |:vimgrep|, |:lgrep| like |:lvimgrep|, |:grepadd| like
         * 	|:vimgrepadd| and |:lgrepadd| like |:lvimgrepadd|.
         * 	See also the section |:make_makeprg|, since most of the comments there
         * 	apply equally to `'grepprg'` .
         * 	This option cannot be set from a |modeline| or in the |sandbox|, for
         * 	security reasons.
         */
        grepprg: Option<string>;

        /**
         * `'guicursor'`  `'gcr'` 	string	(default "n-v-c-sm:block,i-ci-ve:ver25,r-cr-o:hor20")
         * 			global
         * 	Configures the cursor style for each mode. Works in the GUI and many
         * 	terminals.  See |tui-cursor-shape|.
         * 
         * 	To disable cursor-styling, reset the option: >
         * 		:set guicursor=
         * 
         * <	To enable mode shapes, "Cursor" highlight, and blinking: >
         * 		:set guicursor=n-v-c:block,i-ci-ve:ver25,r-cr:hor20,o:hor50
         * 		  \,a:blinkwait700-blinkoff400-blinkon250-Cursor/lCursor
         * 		  \,sm:block-blinkwait175-blinkoff150-blinkon175
         * 
         * <	The option is a comma-separated list of parts.  Each part consists of a
         * 	mode-list and an argument-list:
         * 		mode-list:argument-list,mode-list:argument-list,..
         * 	The mode-list is a dash separated list of these modes:
         * 		n	Normal mode
         * 		v	Visual mode
         * 		ve	Visual mode with `'selection'`  "exclusive" (same as `'v'` ,
         * 			if not specified)
         * 		o	Operator-pending mode
         * 		i	Insert mode
         * 		r	Replace mode
         * 		c	Command-line Normal (append) mode
         * 		ci	Command-line Insert mode
         * 		cr	Command-line Replace mode
         * 		sm	showmatch in Insert mode
         * 		a	all modes
         * 	The argument-list is a dash separated list of these arguments:
         * 		hor{N}	horizontal bar, {N} percent of the character height
         * 		ver{N}	vertical bar, {N} percent of the character width
         * 		block	block cursor, fills the whole character
         * 			- Only one of the above three should be present.
         * 			- Default is "block" for each mode.
         * 		blinkwait{N}
         * 		blinkon{N}
         * 		blinkoff{N}
         * 			blink times for cursor: blinkwait is the delay before
         * 			the cursor starts blinking, blinkon is the time that
         * 			the cursor is shown and blinkoff is the time that the
         * 			cursor is not shown.  Times are in msec.  When one of
         * 			the numbers is zero, there is no blinking. E.g.: >
         * 				:set guicursor=n:blinkon0
         * <			- Default is "blinkon0" for each mode.
         * 		{group-name}
         * 			Highlight group that decides the color and font of the
         * 			cursor.
         * 			In the |TUI|:
         * 			- |inverse|/reverse and no group-name are interpreted
         * 			  as "host-terminal default cursor colors" which
         * 			  typically means "inverted bg and fg colors".
         * 			- |ctermfg| and |guifg| are ignored.
         * 		{group-name}/{group-name}
         * 			Two highlight group names, the first is used when
         * 			no language mappings are used, the other when they
         * 			are. |language-mapping|
         * 
         * 	Examples of parts:
         * 	   n-c-v:block-nCursor	In Normal, Command-line and Visual mode, use a
         * 				block cursor with colors from the "nCursor"
         * 				highlight group
         * 	   n-v-c-sm:block,i-ci-ve:ver25-Cursor,r-cr-o:hor20
         * 				In Normal et al. modes, use a block cursor
         * 				with the default colors defined by the host
         * 				terminal.  In Insert-likes modes, use
         * 				a vertical bar cursor with colors from
         * 				"Cursor" highlight group.  In Replace-likes
         * 				modes, use a underline cursor with
         * 				default colors.
         * 	   i-ci:ver30-iCursor-blinkwait300-blinkon200-blinkoff150
         * 				In Insert and Command-line Insert mode, use a
         * 				30% vertical bar cursor with colors from the
         * 				"iCursor" highlight group.  Blink a bit
         * 				faster.
         * 
         * 	The `'a'`  mode is different.  It will set the given argument-list for
         * 	all modes.  It does not reset anything to defaults.  This can be used
         * 	to do a common setting for all modes.  For example, to switch off
         * 	blinking: "a:blinkon0"
         * 
         * 	Examples of cursor highlighting: >
         * 	    :highlight Cursor gui=reverse guifg=NONE guibg=NONE
         * 	    :highlight Cursor gui=NONE guifg=bg guibg=fg
         * <
         */
        guicursor: ListOption;

        /**
         * `'guifont'`  `'gfn'` 		string	(default "")
         * 			global
         * 	This is a list of fonts which will be used for the GUI version of Vim.
         * 	In its simplest form the value is just one font name.  When
         * 	the font cannot be found you will get an error message.  To try other
         * 	font names a list can be specified, font names separated with commas.
         * 	The first valid font is used.
         * 
         * 	Spaces after a comma are ignored.  To include a comma in a font name
         * 	precede it with a backslash.  Setting an option requires an extra
         * 	backslash before a space and a backslash.  See also
         * 	|option-backslash|.  For example: >
         * 	    :set guifont=Screen15,\ 7x13,font\\,with\\,commas
         * <	will make Vim try to use the font "Screen15" first, and if it fails it
         * 	will try to use "7x13" and then "font,with,commas" instead.
         * 
         * 	If none of the fonts can be loaded, Vim will keep the current setting.
         * 	If an empty font list is given, Vim will try using other resource
         * 	settings (for X, it will use the Vim.font resource), and finally it
         * 	will try some builtin default which should always be there ("7x13" in
         * 	the case of X).  The font names given should be "normal" fonts.  Vim
         * 	will try to find the related bold and italic fonts.
         * 
         * 	For Win32 and Mac OS: >
         * 	    :set guifont=*
         * <	will bring up a font requester, where you can pick the font you want.
         * 
         * 	The font name depends on the GUI used.
         * 
         * 	For Mac OSX you can use something like this: >
         * 	    :set guifont=Monaco:h10
         * <
         * 	Note that the fonts must be mono-spaced (all characters have the same
         * 	width).
         * 
         * 	To preview a font on X11, you might be able to use the "xfontsel"
         * 	program.  The "xlsfonts" program gives a list of all available fonts.
         * 
         * 	For the Win32 GUI
         * 	- takes these options in the font name:
         * 		hXX - height is XX (points, can be floating-point)
         * 		wXX - width is XX (points, can be floating-point)
         * 		b   - bold
         * 		i   - italic
         * 		u   - underline
         * 		s   - strikeout
         * 		cXX - character set XX.  Valid charsets are: ANSI, ARABIC,
         * 		      BALTIC, CHINESEBIG5, DEFAULT, EASTEUROPE, GB2312, GREEK,
         * 		      HANGEUL, HEBREW, JOHAB, MAC, OEM, RUSSIAN, SHIFTJIS,
         * 		      SYMBOL, THAI, TURKISH, VIETNAMESE ANSI and BALTIC.
         * 		      Normally you would use "cDEFAULT".
         * 
         * 	  Use a `':'`  to separate the options.
         * 	- A `'_'`  can be used in the place of a space, so you don't need to use
         * 	  backslashes to escape the spaces.
         * 	- Examples: >
         * 	    :set guifont=courier_new:h12:w5:b:cRUSSIAN
         * 	    :set guifont=Andale_Mono:h7.5:w4.5
         * <
         */
        guifont: ListOption;

        /**
         * `'guifontwide'`  `'gfw'` 	string	(default "")
         * 			global
         * 	Comma-separated list of fonts to be used for double-width characters.
         * 	The first font that can be loaded is used.
         * 	Note: The size of these fonts must be exactly twice as wide as the one
         * 	specified with `'guifont'`  and the same height.
         * 
         * 	When `'guifont'`  has a valid font and `'guifontwide'`  is empty Vim will
         * 	attempt to set `'guifontwide'`  to a matching double-width font.
         */
        guifontwide: ListOption;

        /**
         * `'guioptions'`  `'go'` 	string	(default "egmrLT"   (MS-Windows))
         * 			global
         * 	This option only has an effect in the GUI version of Vim.  It is a
         * 	sequence of letters which describes what components and options of the
         * 	GUI should be used.
         * 	To avoid problems with flags that are added in the future, use the
         * 	"+=" and "-=" feature of ":set" |add-option-flags|.
         * 
         * 	Valid letters are as follows:
         * 
         * 	  `'a'` 	Autoselect:  If present, then whenever VISUAL mode is started,
         * 		or the Visual area extended, Vim tries to become the owner of
         * 		the windowing system's global selection.  This means that the
         * 		Visually highlighted text is available for pasting into other
         * 		applications as well as into Vim itself.  When the Visual mode
         * 		ends, possibly due to an operation on the text, or when an
         * 		application wants to paste the selection, the highlighted text
         * 		is automatically yanked into the "* selection register.
         * 		Thus the selection is still available for pasting into other
         * 		applications after the VISUAL mode has ended.
         * 		    If not present, then Vim won't become the owner of the
         * 		windowing system's global selection unless explicitly told to
         * 		by a yank or delete operation for the "* register.
         * 		The same applies to the modeless selection.
         * 
         * 	  `'P'` 	Like autoselect but using the "+ register instead of the "*
         * 		register.
         * 
         * 	  `'A'` 	Autoselect for the modeless selection.  Like `'a'` , but only
         * 		applies to the modeless selection.
         * 
         * 		    `'guioptions'`    autoselect Visual  autoselect modeless ~
         * 			 ""		 -			 -
         * 			 "a"		yes			yes
         * 			 "A"		 -			yes
         * 			 "aA"		yes			yes
         * 
         * 
         * 	  `'c'` 	Use console dialogs instead of popup dialogs for simple
         * 		choices.
         * 
         * 	  `'d'` 	Use dark theme variant if available.
         * 
         * 	  `'e'` 	Add tab pages when indicated with `'showtabline'` .
         * 		`'guitablabel'`  can be used to change the text in the labels.
         * 		When `'e'`  is missing a non-GUI tab pages line may be used.
         * 		The GUI tabs are only supported on some systems, currently
         * 		Mac OS/X and MS-Windows.
         * 
         * 	  `'i'` 	Use a Vim icon.
         * 
         * 	  `'m'` 	Menu bar is present.
         * 
         * 	  `'M'` 	The system menu "$VIMRUNTIME/menu.vim" is not sourced.  Note
         * 		that this flag must be added in the vimrc file, before
         * 		switching on syntax or filetype recognition (when the |gvimrc|
         * 		file is sourced the system menu has already been loaded; the
         * 		`:syntax on` and `:filetype on` commands load the menu too).
         * 
         * 	  `'g'` 	Grey menu items: Make menu items that are not active grey.  If
         * 		`'g'`  is not included inactive menu items are not shown at all.
         * 
         * 	  `'T'` 	Include Toolbar.  Currently only in Win32 GUI.
         * 
         * 	  `'r'` 	Right-hand scrollbar is always present.
         * 
         * 	  `'R'` 	Right-hand scrollbar is present when there is a vertically
         * 		split window.
         * 
         * 	  `'l'` 	Left-hand scrollbar is always present.
         * 
         * 	  `'L'` 	Left-hand scrollbar is present when there is a vertically
         * 		split window.
         * 
         * 	  `'b'` 	Bottom (horizontal) scrollbar is present.  Its size depends on
         * 		the longest visible line, or on the cursor line if the `'h'` 
         * 		flag is included. |gui-horiz-scroll|
         * 
         * 	  `'h'` 	Limit horizontal scrollbar size to the length of the cursor
         * 		line.  Reduces computations. |gui-horiz-scroll|
         * 
         * 	And yes, you may even have scrollbars on the left AND the right if
         * 	you really want to :-).  See |gui-scrollbars| for more information.
         * 
         * 
         * 	  `'v'` 	Use a vertical button layout for dialogs.  When not included,
         * 		a horizontal layout is preferred, but when it doesn't fit a
         * 		vertical layout is used anyway.  Not supported in GTK 3.
         * 
         * 	  `'p'` 	Use Pointer callbacks for X11 GUI.  This is required for some
         * 		window managers.  If the cursor is not blinking or hollow at
         * 		the right moment, try adding this flag.  This must be done
         * 		before starting the GUI.  Set it in your |gvimrc|.  Adding or
         * 		removing it after the GUI has started has no effect.
         * 
         * 	  `'k'` 	Keep the GUI window size when adding/removing a scrollbar, or
         * 		toolbar, tabline, etc.  Instead, the behavior is similar to
         * 		when the window is maximized and will adjust `'lines'`  and
         * 		`'columns'`  to fit to the window.  Without the `'k'`  flag Vim will
         * 		try to keep `'lines'`  and `'columns'`  the same when adding and
         * 		removing GUI components.
         */
        guioptions: Option<string>;

        /**
         * `'guitablabel'`  `'gtl'` 	string	(default empty)
         * 			global
         * 	When non-empty describes the text to use in a label of the GUI tab
         * 	pages line.  When empty and when the result is empty Vim will use a
         * 	default label.  See |setting-guitablabel| for more info.
         * 
         * 	The format of this option is like that of `'statusline'` .
         * 	`'guitabtooltip'`  is used for the tooltip, see below.
         * 	The expression will be evaluated in the |sandbox| when set from a
         * 	modeline, see |sandbox-option|.
         * 	This option cannot be set in a modeline when `'modelineexpr'`  is off.
         * 
         * 	Only used when the GUI tab pages line is displayed.  `'e'`  must be
         * 	present in `'guioptions'` .  For the non-GUI tab pages line `'tabline'`  is
         * 	used.
         */
        guitablabel: Option<string>;

        /**
         * `'guitabtooltip'`  `'gtt'` 	string	(default empty)
         * 			global
         * 	When non-empty describes the text to use in a tooltip for the GUI tab
         * 	pages line.  When empty Vim will use a default tooltip.
         * 	This option is otherwise just like `'guitablabel'`  above.
         * 	You can include a line break.  Simplest method is to use |:let|: >
         * 		:let &guitabtooltip = "line one\nline two"
         * <
         */
        guitabtooltip: Option<string>;

        /**
         * `'helpfile'`  `'hf'` 		string	(default (MS-Windows) "$VIMRUNTIME\doc\help.txt"
         * 					 (others) "$VIMRUNTIME/doc/help.txt")
         * 			global
         * 	Name of the main help file.  All distributed help files should be
         * 	placed together in one directory.  Additionally, all "doc" directories
         * 	in `'runtimepath'`  will be used.
         * 	Environment variables are expanded |:set_env|.  For example:
         * 	"$VIMRUNTIME/doc/help.txt".  If $VIMRUNTIME is not set, $VIM is also
         * 	tried.  Also see |$VIMRUNTIME| and |option-backslash| about including
         * 	spaces and backslashes.
         * 	This option cannot be set from a |modeline| or in the |sandbox|, for
         * 	security reasons.
         */
        helpfile: Option<string>;

        /**
         * `'helpheight'`  `'hh'` 	number	(default 20)
         * 			global
         * 	Minimal initial height of the help window when it is opened with the
         * 	":help" command.  The initial height of the help window is half of the
         * 	current window, or (when the `'ea'`  option is on) the same as other
         * 	windows.  When the height is less than `'helpheight'` , the height is
         * 	set to `'helpheight'` .  Set to zero to disable.
         */
        helpheight: Option<number>;

        /**
         * `'helplang'`  `'hlg'` 	string	(default: messages language or empty)
         * 			global
         * 	Comma-separated list of languages.  Vim will use the first language
         * 	for which the desired help can be found.  The English help will always
         * 	be used as a last resort.  You can add "en" to prefer English over
         * 	another language, but that will only find tags that exist in that
         * 	language and not in the English help.
         * 	Example: >
         * 		:set helplang=de,it
         * <	This will first search German, then Italian and finally English help
         * 	files.
         * 	When using |CTRL-]| and ":help!" in a non-English help file Vim will
         * 	try to find the tag in the current language before using this option.
         * 	See |help-translated|.
         */
        helplang: ListOption;

        /**
         * `'hidden'`  `'hid'` 		boolean	(default on)
         * 			global
         * 	When off a buffer is unloaded (including loss of undo information)
         * 	when it is |abandon|ed.  When on a buffer becomes hidden when it is
         * 	|abandon|ed.  A buffer displayed in another window does not become
         * 	hidden, of course.
         * 
         * 	Commands that move through the buffer list sometimes hide a buffer
         * 	although the `'hidden'`  option is off when these three are true:
         * 	- the buffer is modified
         * 	- `'autowrite'`  is off or writing is not possible
         * 	- the `'!'`  flag was used
         * 	Also see |windows|.
         * 
         * 	To hide a specific buffer use the `'bufhidden'`  option.
         * 	`'hidden'`  is set for one command with ":hide {command}" |:hide|.
         */
        hidden: Option<boolean>;

        highlight: ListOption;

        /**
         * `'history'`  `'hi'` 		number	(default: 10000)
         * 			global
         * 	A history of ":" commands, and a history of previous search patterns
         * 	is remembered.  This option decides how many entries may be stored in
         * 	each of these histories (see |cmdline-editing|).
         * 	The maximum value is 10000.
         */
        history: Option<number>;

        hkmap: Option<boolean>;

        hkmapp: Option<boolean>;

        /**
         * `'hlsearch'`  `'hls'` 	boolean	(default on)
         * 			global
         * 	When there is a previous search pattern, highlight all its matches.
         * 	The |hl-Search| highlight group determines the highlighting for all
         * 	matches not under the cursor while the |hl-CurSearch| highlight group
         * 	(if defined) determines the highlighting for the match under the
         * 	cursor. If |hl-CurSearch| is not defined, then |hl-Search| is used for
         * 	both. Note that only the matching text is highlighted, any offsets
         * 	are not applied.
         * 	See also: `'incsearch'`  and |:match|.
         * 	When you get bored looking at the highlighted matches, you can turn it
         * 	off with |:nohlsearch|.  This does not change the option value, as
         * 	soon as you use a search command, the highlighting comes back.
         * 	`'redrawtime'`  specifies the maximum time spent on finding matches.
         * 	When the search pattern can match an end-of-line, Vim will try to
         * 	highlight all of the matched text.  However, this depends on where the
         * 	search starts.  This will be the first line in the window or the first
         * 	line below a closed fold.  A match in a previous line which is not
         * 	drawn may not continue in a newly drawn line.
         * 	You can specify whether the highlight status is restored on startup
         * 	with the `'h'`  flag in `'shada'`  |shada-h|.
         */
        hlsearch: Option<boolean>;

        /**
         * `'icon'` 			boolean	(default off, on when title can be restored)
         * 			global
         * 	When on, the icon text of the window will be set to the value of
         * 	`'iconstring'`  (if it is not empty), or to the name of the file
         * 	currently being edited.  Only the last part of the name is used.
         * 	Overridden by the `'iconstring'`  option.
         * 	Only works if the terminal supports setting window icons.
         */
        icon: Option<boolean>;

        /**
         * `'iconstring'` 		string	(default "")
         * 			global
         * 	When this option is not empty, it will be used for the icon text of
         * 	the window.  This happens only when the `'icon'`  option is on.
         * 	Only works if the terminal supports setting window icon text
         * 	When this option contains printf-style `'%'`  items, they will be
         * 	expanded according to the rules used for `'statusline'` .  See
         * 	`'titlestring'`  for example settings.
         * 	This option cannot be set in a modeline when `'modelineexpr'`  is off.
         */
        iconstring: Option<string>;

        /**
         * `'ignorecase'`  `'ic'` 	boolean	(default off)
         * 			global
         * 	Ignore case in search patterns.  Also used when searching in the tags
         * 	file.
         * 	Also see `'smartcase'`  and `'tagcase'` .
         * 	Can be overruled by using "\c" or "\C" in the pattern, see
         * 	|/ignorecase|.
         */
        ignorecase: Option<boolean>;

        /**
         * `'imcmdline'`  `'imc'` 	boolean (default off)
         * 			global
         * 	When set the Input Method is always on when starting to edit a command
         * 	line, unless entering a search pattern (see `'imsearch'`  for that).
         * 	Setting this option is useful when your input method allows entering
         * 	English characters directly, e.g., when it's used to type accented
         * 	characters with dead keys.
         */
        imcmdline: Option<boolean>;

        /**
         * `'imdisable'`  `'imd'` 	boolean (default off, on for some systems (SGI))
         * 			global
         * 	When set the Input Method is never used.  This is useful to disable
         * 	the IM when it doesn't work properly.
         * 	Currently this option is on by default for SGI/IRIX machines.  This
         * 	may change in later releases.
         */
        imdisable: Option<boolean>;

        /**
         * `'iminsert'`  `'imi'` 	number (default 0)
         * 			local to buffer
         * 	Specifies whether :lmap or an Input Method (IM) is to be used in
         * 	Insert mode.  Valid values:
         * 		0	:lmap is off and IM is off
         * 		1	:lmap is ON and IM is off
         * 		2	:lmap is off and IM is ON
         * 	To always reset the option to zero when leaving Insert mode with <Esc>
         * 	this can be used: >
         * 		:inoremap <ESC> <ESC>:set iminsert=0<CR>
         * <	This makes :lmap and IM turn off automatically when leaving Insert
         * 	mode.
         * 	Note that this option changes when using CTRL-^ in Insert mode
         * 	|i_CTRL-^|.
         * 	The value is set to 1 when setting `'keymap'`  to a valid keymap name.
         * 	It is also used for the argument of commands like "r" and "f".
         */
        iminsert: Option<number>;

        /**
         * `'imsearch'`  `'ims'` 	number (default -1)
         * 			local to buffer
         * 	Specifies whether :lmap or an Input Method (IM) is to be used when
         * 	entering a search pattern.  Valid values:
         * 		-1	the value of `'iminsert'`  is used, makes it look like
         * 			`'iminsert'`  is also used when typing a search pattern
         * 		0	:lmap is off and IM is off
         * 		1	:lmap is ON and IM is off
         * 		2	:lmap is off and IM is ON
         * 	Note that this option changes when using CTRL-^ in Command-line mode
         * 	|c_CTRL-^|.
         * 	The value is set to 1 when it is not -1 and setting the `'keymap'` 
         * 	option to a valid keymap name.
         */
        imsearch: Option<number>;

        /**
         * `'inccommand'`  `'icm'` 	string	(default "nosplit")
         * 			global
         * 
         * 	When nonempty, shows the effects of |:substitute|, |:smagic|,
         * 	|:snomagic| and user commands with the |:command-preview| flag as you
         * 	type.
         * 
         * 	Possible values:
         * 		nosplit	Shows the effects of a command incrementally in the
         * 			buffer.
         * 		split	Like "nosplit", but also shows partial off-screen
         * 			results in a preview window.
         * 
         * 	If the preview for built-in commands is too slow (exceeds
         * 	`'redrawtime'` ) then `'inccommand'`  is automatically disabled until
         * 	|Command-line-mode| is done.
         */
        inccommand: Option<string>;

        /**
         * `'include'`  `'inc'` 		string	(default "^\sinclude")
         * 			global or local to buffer |global-local|
         * 	Pattern to be used to find an include command.  It is a search
         * 	pattern, just like for the "/" command (See |pattern|).  The default
         * 	value is for C programs.  This option is used for the commands "[i",
         * 	"]I", "[d", etc.
         * 	Normally the `'isfname'`  option is used to recognize the file name that
         * 	comes after the matched pattern.  But if "\zs" appears in the pattern
         * 	then the text matched from "\zs" to the end, or until "\ze" if it
         * 	appears, is used as the file name.  Use this to include characters
         * 	that are not in `'isfname'` , such as a space.  You can then use
         * 	`'includeexpr'`  to process the matched text.
         * 	See |option-backslash| about including spaces and backslashes.
         */
        include: Option<string>;

        /**
         * `'includeexpr'`  `'inex'` 	string	(default "")
         * 			local to buffer
         * 	Expression to be used to transform the string found with the `'include'` 
         * 	option to a file name.  Mostly useful to change "." to "/" for Java: >
         * 		:setlocal includeexpr=substitute(v:fname,`'\\.'` ,`'/'` ,`'g'` )
         * <	The "v:fname" variable will be set to the file name that was detected.
         * 	Note the double backslash: the `:set` command first halves them, then
         * 	one remains in the value, where "\." matches a dot literally.  For
         * 	simple character replacements `tr()` avoids the need for escaping: >
         * 		:setlocal includeexpr=tr(v:fname,`'.'` ,`'/'` )
         * <
         * 	Also used for the |gf| command if an unmodified file name can't be
         * 	found.  Allows doing "gf" on the name after an `'include'`  statement.
         * 	Also used for |<cfile>|.
         * 
         * 	If the expression starts with s: or |<SID>|, then it is replaced with
         * 	the script ID (|local-function|). Example: >
         * 		set includeexpr=s:MyIncludeExpr(v:fname)
         * 		set includeexpr=<SID>SomeIncludeExpr(v:fname)
         * <
         * 	The expression will be evaluated in the |sandbox| when set from a
         * 	modeline, see |sandbox-option|.
         * 	This option cannot be set in a modeline when `'modelineexpr'`  is off.
         * 
         * 	It is not allowed to change text or jump to another window while
         * 	evaluating `'includeexpr'`  |textlock|.
         */
        includeexpr: Option<string>;

        /**
         * `'incsearch'`  `'is'` 	boolean	(default on)
         * 			global
         * 	While typing a search command, show where the pattern, as it was typed
         * 	so far, matches.  The matched string is highlighted.  If the pattern
         * 	is invalid or not found, nothing is shown.  The screen will be updated
         * 	often, this is only useful on fast terminals.
         * 	Note that the match will be shown, but the cursor will return to its
         * 	original position when no match is found and when pressing <Esc>.  You
         * 	still need to finish the search command with <Enter> to move the
         * 	cursor to the match.
         * 	You can use the CTRL-G and CTRL-T keys to move to the next and
         * 	previous match. |c_CTRL-G| |c_CTRL-T|
         * 	Vim only searches for about half a second.  With a complicated
         * 	pattern and/or a lot of text the match may not be found.  This is to
         * 	avoid that Vim hangs while you are typing the pattern.
         * 	The |hl-IncSearch| highlight group determines the highlighting.
         * 	When `'hlsearch'`  is on, all matched strings are highlighted too while
         * 	typing a search command. See also: `'hlsearch'` .
         * 	If you don't want to turn `'hlsearch'`  on, but want to highlight all
         * 	matches while searching, you can turn on and off `'hlsearch'`  with
         * 	autocmd.  Example: >
         * 		augroup vimrc-incsearch-highlight
         * 		  autocmd!
         * 		  autocmd CmdlineEnter /,\? :set hlsearch
         * 		  autocmd CmdlineLeave /,\? :set nohlsearch
         * 		augroup END
         * <
         * 	CTRL-L can be used to add one character from after the current match
         * 	to the command line.  If `'ignorecase'`  and `'smartcase'`  are set and the
         * 	command line has no uppercase characters, the added character is
         * 	converted to lowercase.
         * 	CTRL-R CTRL-W can be used to add the word at the end of the current
         * 	match, excluding the characters that were already typed.
         */
        incsearch: Option<boolean>;

        /**
         * `'indentexpr'`  `'inde'` 	string	(default "")
         * 			local to buffer
         * 	Expression which is evaluated to obtain the proper indent for a line.
         * 	It is used when a new line is created, for the |=| operator and
         * 	in Insert mode as specified with the `'indentkeys'`  option.
         * 	When this option is not empty, it overrules the `'cindent'`  and
         * 	`'smartindent'`  indenting.  When `'lisp'`  is set, this option is
         * 	is only used when `'lispoptions'`  contains "expr:1".
         * 	The expression is evaluated with |v:lnum| set to the line number for
         * 	which the indent is to be computed.  The cursor is also in this line
         * 	when the expression is evaluated (but it may be moved around).
         * 	If the expression starts with s: or |<SID>|, then it is replaced with
         * 	the script ID (|local-function|). Example: >
         * 		set indentexpr=s:MyIndentExpr()
         * 		set indentexpr=<SID>SomeIndentExpr()
         * <
         * 	The expression must return the number of spaces worth of indent.  It
         * 	can return "-1" to keep the current indent (this means `'autoindent'`  is
         * 	used for the indent).
         * 	Functions useful for computing the indent are |indent()|, |cindent()|
         * 	and |lispindent()|.
         * 	The evaluation of the expression must not have side effects!  It must
         * 	not change the text, jump to another window, etc.  Afterwards the
         * 	cursor position is always restored, thus the cursor may be moved.
         * 	Normally this option would be set to call a function: >
         * 		:set indentexpr=GetMyIndent()
         * <	Error messages will be suppressed, unless the `'debug'`  option contains
         * 	"msg".
         * 	See |indent-expression|.
         * 
         * 	The expression will be evaluated in the |sandbox| when set from a
         * 	modeline, see |sandbox-option|.
         * 	This option cannot be set in a modeline when `'modelineexpr'`  is off.
         * 
         * 	It is not allowed to change text or jump to another window while
         * 	evaluating `'indentexpr'`  |textlock|.
         */
        indentexpr: Option<string>;

        /**
         * `'indentkeys'`  `'indk'` 	string	(default "0{,0},0),0],:,0#,!^F,o,O,e")
         * 			local to buffer
         * 	A list of keys that, when typed in Insert mode, cause reindenting of
         * 	the current line.  Only happens if `'indentexpr'`  isn't empty.
         * 	The format is identical to `'cinkeys'` , see |indentkeys-format|.
         * 	See |C-indenting| and |indent-expression|.
         */
        indentkeys: ListOption;

        /**
         * `'infercase'`  `'inf'` 	boolean	(default off)
         * 			local to buffer
         * 	When doing keyword completion in insert mode |ins-completion|, and
         * 	`'ignorecase'`  is also on, the case of the match is adjusted depending
         * 	on the typed text.  If the typed text contains a lowercase letter
         * 	where the match has an upper case letter, the completed part is made
         * 	lowercase.  If the typed text has no lowercase letters and the match
         * 	has a lowercase letter where the typed text has an uppercase letter,
         * 	and there is a letter before it, the completed part is made uppercase.
         * 	With `'noinfercase'`  the match is used as-is.
         */
        infercase: Option<boolean>;

        insertmode: Option<boolean>;

        /**
         * `'isfname'`  `'isf'` 		string	(default for Windows:
         * 			     "@,48-57,/,\,.,-,_,+,,,#,$,%,{,},[,],:,@-@,!,~,="
         * 			    otherwise: "@,48-57,/,.,-,_,+,,,#,$,%,~,=")
         * 			global
         * 	The characters specified by this option are included in file names and
         * 	path names.  Filenames are used for commands like "gf", "[i" and in
         * 	the tags file.  It is also used for "\f" in a |pattern|.
         * 	Multi-byte characters 256 and above are always included, only the
         * 	characters up to 255 are specified with this option.
         * 	For UTF-8 the characters 0xa0 to 0xff are included as well.
         * 	Think twice before adding white space to this option.  Although a
         * 	space may appear inside a file name, the effect will be that Vim
         * 	doesn't know where a file name starts or ends when doing completion.
         * 	It most likely works better without a space in `'isfname'` .
         * 
         * 	Note that on systems using a backslash as path separator, Vim tries to
         * 	do its best to make it work as you would expect.  That is a bit
         * 	tricky, since Vi originally used the backslash to escape special
         * 	characters.  Vim will not remove a backslash in front of a normal file
         * 	name character on these systems, but it will on Unix and alikes.  The
         * 	`'&'`  and `'^'`  are not included by default, because these are special for
         * 	cmd.exe.
         * 
         * 	The format of this option is a list of parts, separated with commas.
         * 	Each part can be a single character number or a range.  A range is two
         * 	character numbers with `'-'`  in between.  A character number can be a
         * 	decimal number between 0 and 255 or the ASCII character itself (does
         * 	not work for digits).  Example:
         * 		"_,-,128-140,#-43"	(include `'_'`  and `'-'`  and the range
         * 					128 to 140 and `'#'`  to 43)
         * 	If a part starts with `'^'` , the following character number or range
         * 	will be excluded from the option.  The option is interpreted from left
         * 	to right.  Put the excluded character after the range where it is
         * 	included.  To include `'^'`  itself use it as the last character of the
         * 	option or the end of a range.  Example:
         * 		"^a-z,#,^"	(exclude `'a'`  to `'z'` , include `'#'`  and `'^'` )
         * 	If the character is `'@'` , all characters where isalpha() returns TRUE
         * 	are included.  Normally these are the characters a to z and A to Z,
         * 	plus accented characters.  To include `'@'`  itself use "@-@".  Examples:
         * 		"@,^a-z"	All alphabetic characters, excluding lower
         * 				case ASCII letters.
         * 		"a-z,A-Z,@-@"	All letters plus the `'@'`  character.
         * 	A comma can be included by using it where a character number is
         * 	expected.  Example:
         * 		"48-57,,,_"	Digits, comma and underscore.
         * 	A comma can be excluded by prepending a `'^'` .  Example:
         * 		" -~,^,,9"	All characters from space to `'~'` , excluding
         * 				comma, plus <Tab>.
         * 	See |option-backslash| about including spaces and backslashes.
         */
        isfname: ListOption;

        /**
         * `'isident'`  `'isi'` 		string	(default for Windows:
         * 					   "@,48-57,_,128-167,224-235"
         * 				otherwise: "@,48-57,_,192-255")
         * 			global
         * 	The characters given by this option are included in identifiers.
         * 	Identifiers are used in recognizing environment variables and after a
         * 	match of the `'define'`  option.  It is also used for "\i" in a
         * 	|pattern|.  See `'isfname'`  for a description of the format of this
         * 	option.  For `'@'`  only characters up to 255 are used.
         * 	Careful: If you change this option, it might break expanding
         * 	environment variables.  E.g., when `'/'`  is included and Vim tries to
         * 	expand "$HOME/.local/state/nvim/shada/main.shada".  Maybe you should
         * 	change `'iskeyword'`  instead.
         */
        isident: ListOption;

        /**
         * `'iskeyword'`  `'isk'` 	string (default: @,48-57,_,192-255)
         * 			local to buffer
         * 	Keywords are used in searching and recognizing with many commands:
         * 	"w", "*", "[i", etc.  It is also used for "\k" in a |pattern|.  See
         * 	`'isfname'`  for a description of the format of this option.  For `'@'` 
         * 	characters above 255 check the "word" character class (any character
         * 	that is not white space or punctuation).
         * 	For C programs you could use "a-z,A-Z,48-57,_,.,-,>".
         * 	For a help file it is set to all non-blank printable characters except
         * 	`'*'` , `'"'`  and `'|'`  (so that CTRL-] on a command finds the help for that
         * 	command).
         * 	When the `'lisp'`  option is on the `'-'`  character is always included.
         * 	This option also influences syntax highlighting, unless the syntax
         * 	uses |:syn-iskeyword|.
         */
        iskeyword: ListOption;

        /**
         * `'isprint'`  `'isp'` 	string	(default: "@,161-255")
         * 			global
         * 	The characters given by this option are displayed directly on the
         * 	screen.  It is also used for "\p" in a |pattern|.  The characters from
         * 	space (ASCII 32) to `'~'`  (ASCII 126) are always displayed directly,
         * 	even when they are not included in `'isprint'`  or excluded.  See
         * 	`'isfname'`  for a description of the format of this option.
         * 
         * 	Non-printable characters are displayed with two characters:
         * 		  0 -  31	"^@" - "^_"
         * 		 32 - 126	always single characters
         * 		   127		"^?"
         * 		128 - 159	"~@" - "~_"
         * 		160 - 254	"| " - "|~"
         * 		   255		"~?"
         * 	Illegal bytes from 128 to 255 (invalid UTF-8) are
         * 	displayed as <xx>, with the hexadecimal value of the byte.
         * 	When `'display'`  contains "uhex" all unprintable characters are
         * 	displayed as <xx>.
         * 	The SpecialKey highlighting will be used for unprintable characters.
         * 	|hl-SpecialKey|
         * 
         * 	Multi-byte characters 256 and above are always included, only the
         * 	characters up to 255 are specified with this option.  When a character
         * 	is printable but it is not available in the current font, a
         * 	replacement character will be shown.
         * 	Unprintable and zero-width Unicode characters are displayed as <xxxx>.
         * 	There is no option to specify these characters.
         */
        isprint: ListOption;

        /**
         * `'joinspaces'`  `'js'` 	boolean	(default off)
         * 			global
         * 	Insert two spaces after a `'.'` , `'?'`  and `'!'`  with a join command.
         * 	Otherwise only one space is inserted.
         */
        joinspaces: Option<boolean>;

        /**
         * `'jumpoptions'`  `'jop'` 	string	(default "")
         * 			global
         * 	List of words that change the behavior of the |jumplist|.
         * 	  stack         Make the jumplist behave like the tagstack or like a
         * 	                web browser.  Relative location of entries in the
         * 			jumplist is preserved at the cost of discarding
         * 			subsequent entries when navigating backwards in the
         * 			jumplist and then jumping to a location.
         * 			|jumplist-stack|
         * 
         * 	  view          When moving through the jumplist, |changelist|,
         * 			|alternate-file| or using |mark-motions| try to
         * 			restore the |mark-view| in which the action occurred.
         */
        jumpoptions: ListOption;

        /**
         * `'keymap'`  `'kmp'` 		string	(default "")
         * 			local to buffer
         * 	Name of a keyboard mapping.  See |mbyte-keymap|.
         * 	Setting this option to a valid keymap name has the side effect of
         * 	setting `'iminsert'`  to one, so that the keymap becomes effective.
         * 	`'imsearch'`  is also set to one, unless it was -1
         * 	Only normal file name characters can be used, "/\*?[|<>" are illegal.
         */
        keymap: Option<string>;

        /**
         * `'keymodel'`  `'km'` 		string	(default "")
         * 			global
         * 	List of comma-separated words, which enable special things that keys
         * 	can do.  These values can be used:
         * 	   startsel	Using a shifted special key starts selection (either
         * 			Select mode or Visual mode, depending on "key" being
         * 			present in `'selectmode'` ).
         * 	   stopsel	Using a not-shifted special key stops selection.
         * 	Special keys in this context are the cursor keys, <End>, <Home>,
         * 	<PageUp> and <PageDown>.
         * 	The `'keymodel'`  option is set by the |:behave| command.
         */
        keymodel: ListOption;

        /**
         * `'keywordprg'`  `'kp'` 	string	(default ":Man", Windows: ":help")
         * 			global or local to buffer |global-local|
         * 	Program to use for the |K| command.  Environment variables are
         * 	expanded |:set_env|.  ":help" may be used to access the Vim internal
         * 	help.  (Note that previously setting the global option to the empty
         * 	value did this, which is now deprecated.)
         * 	When the first character is ":", the command is invoked as a Vim
         * 	Ex command prefixed with [count].
         * 	When "man" or "man -s" is used, Vim will automatically translate
         * 	a [count] for the "K" command to a section number.
         * 	See |option-backslash| about including spaces and backslashes.
         * 	Example: >
         * 		:set keywordprg=man\ -s
         * 		:set keywordprg=:Man
         * <	This option cannot be set from a |modeline| or in the |sandbox|, for
         * 	security reasons.
         */
        keywordprg: Option<string>;

        /**
         * `'langmap'`  `'lmap'` 	string	(default "")
         * 			global
         * 	This option allows switching your keyboard into a special language
         * 	mode.  When you are typing text in Insert mode the characters are
         * 	inserted directly.  When in Normal mode the `'langmap'`  option takes
         * 	care of translating these special characters to the original meaning
         * 	of the key.  This means you don't have to change the keyboard mode to
         * 	be able to execute Normal mode commands.
         * 	This is the opposite of the `'keymap'`  option, where characters are
         * 	mapped in Insert mode.
         * 	Also consider setting `'langremap'`  to off, to prevent `'langmap'`  from
         * 	applying to characters resulting from a mapping.
         * 	This option cannot be set from a |modeline| or in the |sandbox|, for
         * 	security reasons.
         * 
         * 	Example (for Greek, in UTF-8):				  >
         * 	    :set langmap=ΑA,ΒB,ΨC,ΔD,ΕE,ΦF,ΓG,ΗH,ΙI,ΞJ,ΚK,ΛL,ΜM,ΝN,ΟO,ΠP,QQ,ΡR,ΣS,ΤT,ΘU,ΩV,WW,ΧX,ΥY,ΖZ,αa,βb,ψc,δd,εe,φf,γg,ηh,ιi,ξj,κk,λl,μm,νn,οo,πp,qq,ρr,σs,τt,θu,ωv,ςw,χx,υy,ζz
         * <	Example (exchanges meaning of z and y for commands): >
         * 	    :set langmap=zy,yz,ZY,YZ
         * <
         * 	The `'langmap'`  option is a list of parts, separated with commas.  Each
         * 	part can be in one of two forms:
         * 	1.  A list of pairs.  Each pair is a "from" character immediately
         * 	    followed by the "to" character.  Examples: "aA", "aAbBcC".
         * 	2.  A list of "from" characters, a semi-colon and a list of "to"
         * 	    characters.  Example: "abc;ABC"
         * 	Example: "aA,fgh;FGH,cCdDeE"
         * 	Special characters need to be preceded with a backslash.  These are
         * 	";", `','` , `'"'` , `'|'`  and backslash itself.
         * 
         * 	This will allow you to activate vim actions without having to switch
         * 	back and forth between the languages.  Your language characters will
         * 	be understood as normal vim English characters (according to the
         * 	langmap mappings) in the following cases:
         * 	 o Normal/Visual mode (commands, buffer/register names, user mappings)
         * 	 o Insert/Replace Mode: Register names after CTRL-R
         * 	 o Insert/Replace Mode: Mappings
         * 	Characters entered in Command-line mode will NOT be affected by
         * 	this option.   Note that this option can be changed at any time
         * 	allowing to switch between mappings for different languages/encodings.
         * 	Use a mapping to avoid having to type it each time!
         */
        langmap: ListOption;

        /**
         * `'langmenu'`  `'lm'` 		string	(default "")
         * 			global
         * 	Language to use for menu translation.  Tells which file is loaded
         * 	from the "lang" directory in `'runtimepath'` : >
         * 		"lang/menu_" .. &langmenu .. ".vim"
         * <	(without the spaces).  For example, to always use the Dutch menus, no
         * 	matter what $LANG is set to: >
         * 		:set langmenu=nl_NL.ISO_8859-1
         * <	When `'langmenu'`  is empty, |v:lang| is used.
         * 	Only normal file name characters can be used, "/\*?[|<>" are illegal.
         * 	If your $LANG is set to a non-English language but you do want to use
         * 	the English menus: >
         * 		:set langmenu=none
         * <	This option must be set before loading menus, switching on filetype
         * 	detection or syntax highlighting.  Once the menus are defined setting
         * 	this option has no effect.  But you could do this: >
         * 		:source $VIMRUNTIME/delmenu.vim
         * 		:set langmenu=de_DE.ISO_8859-1
         * 		:source $VIMRUNTIME/menu.vim
         * <	Warning: This deletes all menus that you defined yourself!
         */
        langmenu: Option<string>;

        langnoremap: Option<boolean>;

        /**
         * `'langremap'`  `'lrm'` 	boolean (default off)
         * 			global
         * 	When off, setting `'langmap'`  does not apply to characters resulting from
         * 	a mapping.  If setting `'langmap'`  disables some of your mappings, make
         * 	sure this option is off.
         */
        langremap: Option<boolean>;

        /**
         * `'laststatus'`  `'ls'` 	number	(default 2)
         * 			global
         * 	The value of this option influences when the last window will have a
         * 	status line:
         * 		0: never
         * 		1: only if there are at least two windows
         * 		2: always
         * 		3: always and ONLY the last window
         * 	The screen looks nicer with a status line if you have several
         * 	windows, but it takes another screen line. |status-line|
         */
        laststatus: Option<number>;

        /**
         * `'lazyredraw'`  `'lz'` 	boolean	(default off)
         * 			global
         * 	When this option is set, the screen will not be redrawn while
         * 	executing macros, registers and other commands that have not been
         * 	typed.  Also, updating the window title is postponed.  To force an
         * 	update use |:redraw|.
         * 	This may occasionally cause display errors.  It is only meant to be set
         * 	temporarily when performing an operation where redrawing may cause
         * 	flickering or cause a slow down.
         */
        lazyredraw: Option<boolean>;

        /**
         * `'linebreak'`  `'lbr'` 	boolean	(default off)
         * 			local to window
         * 	If on, Vim will wrap long lines at a character in `'breakat'`  rather
         * 	than at the last character that fits on the screen.  Unlike
         * 	`'wrapmargin'`  and `'textwidth'` , this does not insert <EOL>s in the file,
         * 	it only affects the way the file is displayed, not its contents.
         * 	If `'breakindent'`  is set, line is visually indented. Then, the value
         * 	of `'showbreak'`  is used to put in front of wrapped lines. This option
         * 	is not used when the `'wrap'`  option is off.
         * 	Note that <Tab> characters after an <EOL> are mostly not displayed
         * 	with the right amount of white space.
         */
        linebreak: Option<boolean>;

        /**
         * `'lines'` 			number	(default 24 or terminal height)
         * 			global
         * 	Number of lines of the Vim window.
         * 	Normally you don't need to set this.  It is done automatically by the
         * 	terminal initialization code.
         * 	When Vim is running in the GUI or in a resizable window, setting this
         * 	option will cause the window size to be changed.  When you only want
         * 	to use the size for the GUI, put the command in your |gvimrc| file.
         * 	Vim limits the number of lines to what fits on the screen.  You can
         * 	use this command to get the tallest window possible: >
         * 		:set lines=999
         * <	Minimum value is 2, maximum value is 1000.
         */
        lines: Option<number>;

        /**
         * `'linespace'`  `'lsp'` 	number	(default 0)
         * 			global
         * 			{only in the GUI}
         * 	Number of pixel lines inserted between characters.  Useful if the font
         * 	uses the full character cell height, making lines touch each other.
         * 	When non-zero there is room for underlining.
         * 	With some fonts there can be too much room between lines (to have
         * 	space for ascents and descents).  Then it makes sense to set
         * 	`'linespace'`  to a negative value.  This may cause display problems
         * 	though!
         */
        linespace: Option<number>;

        /**
         * `'lisp'` 			boolean	(default off)
         * 			local to buffer
         * 	Lisp mode: When <Enter> is typed in insert mode set the indent for
         * 	the next line to Lisp standards (well, sort of).  Also happens with
         * 	"cc" or "S".  `'autoindent'`  must also be on for this to work.  The `'p'` 
         * 	flag in `'cpoptions'`  changes the method of indenting: Vi compatible or
         * 	better.  Also see `'lispwords'` .
         * 	The `'-'`  character is included in keyword characters.  Redefines the
         * 	"=" operator to use this same indentation algorithm rather than
         * 	calling an external program if `'equalprg'`  is empty.
         */
        lisp: Option<boolean>;

        /**
         * `'lispoptions'`  `'lop'` 	string	(default "")
         * 			local to buffer
         * 	Comma-separated list of items that influence the Lisp indenting when
         * 	enabled with the |`'lisp'` | option.  Currently only one item is
         * 	supported:
         * 		expr:1	use `'indentexpr'`  for Lisp indenting when it is set
         * 		expr:0	do not use `'indentexpr'`  for Lisp indenting (default)
         * 	Note that when using `'indentexpr'`  the `=` operator indents all the
         * 	lines, otherwise the first line is not indented (Vi-compatible).
         */
        lispoptions: ListOption;

        /**
         * `'lispwords'`  `'lw'` 	string	(default is very long)
         * 			global or local to buffer |global-local|
         * 	Comma-separated list of words that influence the Lisp indenting when
         * 	enabled with the |`'lisp'` | option.
         */
        lispwords: ListOption;

        /**
         * `'list'` 			boolean	(default off)
         * 			local to window
         * 	List mode: By default, show tabs as ">", trailing spaces as "-", and
         * 	non-breakable space characters as "+". Useful to see the difference
         * 	between tabs and spaces and for trailing blanks. Further changed by
         * 	the `'listchars'`  option.
         * 
         * 	The cursor is displayed at the start of the space a Tab character
         * 	occupies, not at the end as usual in Normal mode.  To get this cursor
         * 	position while displaying Tabs with spaces, use: >
         * 		:set list lcs=tab:\ \
         * <
         * 	Note that list mode will also affect formatting (set with `'textwidth'` 
         * 	or `'wrapmargin'` ) when `'cpoptions'`  includes `'L'` .  See `'listchars'`  for
         * 	changing the way tabs are displayed.
         */
        list: Option<boolean>;

        /**
         * `'listchars'`  `'lcs'` 	string	(default: "tab:> ,trail:-,nbsp:+")
         * 			global or local to window |global-local|
         * 	Strings to use in `'list'`  mode and for the |:list| command.  It is a
         * 	comma-separated list of string settings.
         * 
         * 
         * 	  eol:c		Character to show at the end of each line.  When
         * 			omitted, there is no extra character at the end of the
         * 			line.
         * 
         * 	  tab:xy[z]	Two or three characters to be used to show a tab.
         * 			The third character is optional.
         * 
         * 	  tab:xy	The `'x'`  is always used, then `'y'`  as many times as will
         * 			fit.  Thus "tab:>-" displays: >
         * 				>
         * 				>-
         * 				>--
         * 				etc.
         * <
         * 	  tab:xyz	The `'z'`  is always used, then `'x'`  is prepended, and
         * 			then `'y'`  is used as many times as will fit.  Thus
         * 			"tab:<->" displays: >
         * 				>
         * 				<>
         * 				<->
         * 				<-->
         * 				etc.
         * <
         * 			When "tab:" is omitted, a tab is shown as ^I.
         * 
         * 	  space:c	Character to show for a space.  When omitted, spaces
         * 			are left blank.
         * 
         * 	  multispace:c...
         * 			One or more characters to use cyclically to show for
         * 			multiple consecutive spaces.  Overrides the "space"
         * 			setting, except for single spaces.  When omitted, the
         * 			"space" setting is used.  For example,
         * 			`:set listchars=multispace:---+` shows ten consecutive
         * 			spaces as: >
         * 				---+---+--
         * <
         * 
         * 	  lead:c	Character to show for leading spaces.  When omitted,
         * 			leading spaces are blank.  Overrides the "space" and
         * 			"multispace" settings for leading spaces.  You can
         * 			combine it with "tab:", for example: >
         * 				:set listchars+=tab:>-,lead:.
         * <
         * 
         * 	  leadmultispace:c...
         * 			Like the |lcs-multispace| value, but for leading
         * 			spaces only.  Also overrides |lcs-lead| for leading
         * 			multiple spaces.
         * 			`:set listchars=leadmultispace:---+` shows ten
         * 			consecutive leading spaces as: >
         * 				---+---+--XXX
         * <
         * 			Where "XXX" denotes the first non-blank characters in
         * 			the line.
         * 
         * 	  trail:c	Character to show for trailing spaces.  When omitted,
         * 			trailing spaces are blank.  Overrides the "space" and
         * 			"multispace" settings for trailing spaces.
         * 
         * 	  extends:c	Character to show in the last column, when `'wrap'`  is
         * 			off and the line continues beyond the right of the
         * 			screen.
         * 
         * 	  precedes:c	Character to show in the first visible column of the
         * 			physical line, when there is text preceding the
         * 			character visible in the first column.
         * 
         * 	  conceal:c	Character to show in place of concealed text, when
         * 			`'conceallevel'`  is set to 1.  A space when omitted.
         * 
         * 	  nbsp:c	Character to show for a non-breakable space character
         * 			(0xA0 (160 decimal) and U+202F).  Left blank when
         * 			omitted.
         * 
         * 	The characters `':'`  and `','`  should not be used.  UTF-8 characters can
         * 	be used.  All characters must be single width.
         * 
         * 	Each character can be specified as hex: >
         * 		set listchars=eol:\\x24
         * 		set listchars=eol:\\u21b5
         * 		set listchars=eol:\\U000021b5
         * <	Note that a double backslash is used.  The number of hex characters
         * 	must be exactly 2 for \\x, 4 for \\u and 8 for \\U.
         * 
         * 	Examples: >
         * 	    :set lcs=tab:>-,trail:-
         * 	    :set lcs=tab:>-,eol:<,nbsp:%
         * 	    :set lcs=extends:>,precedes:<
         * <	|hl-NonText| highlighting will be used for "eol", "extends" and
         * 	"precedes". |hl-Whitespace| for "nbsp", "space", "tab", "multispace",
         * 	"lead" and "trail".
         */
        listchars: MapOption;

        /**
         * `'loadplugins'`  `'lpl'` 	boolean	(default on)
         * 			global
         * 	When on the plugin scripts are loaded when starting up |load-plugins|.
         * 	This option can be reset in your |vimrc| file to disable the loading
         * 	of plugins.
         * 	Note that using the "-u NONE" and "--noplugin" command line arguments
         * 	reset this option. |-u| |--noplugin|
         */
        loadplugins: Option<boolean>;

        /**
         * `'magic'` 			boolean	(default on)
         * 			global
         * 	Changes the special characters that can be used in search patterns.
         * 	See |pattern|.
         * 	WARNING: Switching this option off most likely breaks plugins!  That
         * 	is because many patterns assume it's on and will fail when it's off.
         * 	Only switch it off when working with old Vi scripts.  In any other
         * 	situation write patterns that work when `'magic'`  is on.  Include "\M"
         * 	when you want to |/\M|.
         */
        magic: Option<boolean>;

        /**
         * `'makeef'`  `'mef'` 		string	(default: "")
         * 			global
         * 	Name of the errorfile for the |:make| command (see |:make_makeprg|)
         * 	and the |:grep| command.
         * 	When it is empty, an internally generated temp file will be used.
         * 	When "##" is included, it is replaced by a number to make the name
         * 	unique.  This makes sure that the ":make" command doesn't overwrite an
         * 	existing file.
         * 	NOT used for the ":cf" command.  See `'errorfile'`  for that.
         * 	Environment variables are expanded |:set_env|.
         * 	See |option-backslash| about including spaces and backslashes.
         * 	This option cannot be set from a |modeline| or in the |sandbox|, for
         * 	security reasons.
         */
        makeef: Option<string>;

        /**
         * `'makeencoding'`  `'menc'` 	string	(default "")
         * 			global or local to buffer |global-local|
         * 	Encoding used for reading the output of external commands.  When empty,
         * 	encoding is not converted.
         * 	This is used for `:make`, `:lmake`, `:grep`, `:lgrep`, `:grepadd`,
         * 	`:lgrepadd`, `:cfile`, `:cgetfile`, `:caddfile`, `:lfile`, `:lgetfile`,
         * 	and `:laddfile`.
         * 
         * 	This would be mostly useful when you use MS-Windows.  If iconv is
         * 	enabled, setting `'makeencoding'`  to "char" has the same effect as
         * 	setting to the system locale encoding.  Example: >
         * 		:set makeencoding=char	" system locale is used
         * <
         */
        makeencoding: Option<string>;

        /**
         * `'makeprg'`  `'mp'` 		string	(default "make")
         * 			global or local to buffer |global-local|
         * 	Program to use for the ":make" command.  See |:make_makeprg|.
         * 	This option may contain `'%'`  and `'#'`  characters (see  |:_%| and |:_#|),
         * 	which are expanded to the current and alternate file name.  Use |::S|
         * 	to escape file names in case they contain special characters.
         * 	Environment variables are expanded |:set_env|.  See |option-backslash|
         * 	about including spaces and backslashes.
         * 	Note that a `'|'`  must be escaped twice: once for ":set" and once for
         * 	the interpretation of a command.  When you use a filter called
         * 	"myfilter" do it like this: >
         * 	    :set makeprg=gmake\ \\\|\ myfilter
         * <	The placeholder "$*" can be given (even multiple times) to specify
         * 	where the arguments will be included, for example: >
         * 	    :set makeprg=latex\ \\\\nonstopmode\ \\\\input\\{$*}
         * <	This option cannot be set from a |modeline| or in the |sandbox|, for
         * 	security reasons.
         */
        makeprg: Option<string>;

        /**
         * `'matchpairs'`  `'mps'` 	string	(default "(:),{:},[:]")
         * 			local to buffer
         * 	Characters that form pairs.  The |%| command jumps from one to the
         * 	other.
         * 	Only character pairs are allowed that are different, thus you cannot
         * 	jump between two double quotes.
         * 	The characters must be separated by a colon.
         * 	The pairs must be separated by a comma.  Example for including `'<'`  and
         * 	`'>'`  (for HTML): >
         * 		:set mps+=<:>
         * 
         * <	A more exotic example, to jump between the `'='`  and `';'`  in an
         * 	assignment, useful for languages like C and Java: >
         * 		:au FileType c,cpp,java set mps+==:;
         * 
         * <	For a more advanced way of using "%", see the matchit.vim plugin in
         * 	the $VIMRUNTIME/plugin directory. |add-local-help|
         */
        matchpairs: ListOption;

        /**
         * `'matchtime'`  `'mat'` 	number	(default 5)
         * 			global
         * 	Tenths of a second to show the matching paren, when `'showmatch'`  is
         * 	set.  Note that this is not in milliseconds, like other options that
         * 	set a time.  This is to be compatible with Nvi.
         */
        matchtime: Option<number>;

        maxcombine: Option<number>;

        /**
         * `'maxfuncdepth'`  `'mfd'` 	number	(default 100)
         * 			global
         * 	Maximum depth of function calls for user functions.  This normally
         * 	catches endless recursion.  When using a recursive function with
         * 	more depth, set `'maxfuncdepth'`  to a bigger number.  But this will use
         * 	more memory, there is the danger of failing when memory is exhausted.
         * 	Increasing this limit above 200 also changes the maximum for Ex
         * 	command recursion, see |E169|.
         * 	See also |:function|.
         */
        maxfuncdepth: Option<number>;

        /**
         * `'maxmapdepth'`  `'mmd'` 	number	(default 1000)
         * 			global
         * 	Maximum number of times a mapping is done without resulting in a
         * 	character to be used.  This normally catches endless mappings, like
         * 	":map x y" with ":map y x".  It still does not catch ":map g wg",
         * 	because the `'w'`  is used before the next mapping is done.  See also
         * 	|key-mapping|.
         */
        maxmapdepth: Option<number>;

        /**
         * `'maxmempattern'`  `'mmp'` 	number	(default 1000)
         * 			global
         * 	Maximum amount of memory (in Kbyte) to use for pattern matching.
         * 	The maximum value is about 2000000.  Use this to work without a limit.
         * 
         * 	When Vim runs into the limit it gives an error message and mostly
         * 	behaves like CTRL-C was typed.
         * 	Running into the limit often means that the pattern is very
         * 	inefficient or too complex.  This may already happen with the pattern
         * 	"\(.\)*" on a very long line.  ".*" works much better.
         * 	Might also happen on redraw, when syntax rules try to match a complex
         * 	text structure.
         * 	Vim may run out of memory before hitting the `'maxmempattern'`  limit, in
         * 	which case you get an "Out of memory" error instead.
         */
        maxmempattern: Option<number>;

        /**
         * `'menuitems'`  `'mis'` 	number	(default 25)
         * 			global
         * 	Maximum number of items to use in a menu.  Used for menus that are
         * 	generated from a list of items, e.g., the Buffers menu.  Changing this
         * 	option has no direct effect, the menu must be refreshed first.
         */
        menuitems: Option<number>;

        /**
         * `'mkspellmem'`  `'msm'` 	string	(default "460000,2000,500")
         * 			global
         * 	Parameters for |:mkspell|.  This tunes when to start compressing the
         * 	word tree.  Compression can be slow when there are many words, but
         * 	it's needed to avoid running out of memory.  The amount of memory used
         * 	per word depends very much on how similar the words are, that's why
         * 	this tuning is complicated.
         * 
         * 	There are three numbers, separated by commas:
         * 		{start},{inc},{added}
         * 
         * 	For most languages the uncompressed word tree fits in memory.  {start}
         * 	gives the amount of memory in Kbyte that can be used before any
         * 	compression is done.  It should be a bit smaller than the amount of
         * 	memory that is available to Vim.
         * 
         * 	When going over the {start} limit the {inc} number specifies the
         * 	amount of memory in Kbyte that can be allocated before another
         * 	compression is done.  A low number means compression is done after
         * 	less words are added, which is slow.  A high number means more memory
         * 	will be allocated.
         * 
         * 	After doing compression, {added} times 1024 words can be added before
         * 	the {inc} limit is ignored and compression is done when any extra
         * 	amount of memory is needed.  A low number means there is a smaller
         * 	chance of hitting the {inc} limit, less memory is used but it's
         * 	slower.
         * 
         * 	The languages for which these numbers are important are Italian and
         * 	Hungarian.  The default works for when you have about 512 Mbyte.  If
         * 	you have 1 Gbyte you could use: >
         * 		:set mkspellmem=900000,3000,800
         * <	If you have less than 512 Mbyte |:mkspell| may fail for some
         * 	languages, no matter what you set `'mkspellmem'`  to.
         * 
         * 	This option cannot be set from a |modeline| or in the |sandbox|.
         */
        mkspellmem: Option<string>;

        /**
         * `'modeline'`  `'ml'` 		boolean	(default: on (off for root))
         * 			local to buffer
         * 	If `'modeline'`  is on `'modelines'`  gives the number of lines that is
         * 	checked for set commands.  If `'modeline'`  is off or `'modelines'`  is zero
         * 	no lines are checked.  See |modeline|.
         */
        modeline: Option<boolean>;

        /**
         * `'modelineexpr'`  `'mle'` 	boolean (default: off)
         * 			global
         * 	When on allow some options that are an expression to be set in the
         * 	modeline.  Check the option for whether it is affected by
         * 	`'modelineexpr'` .  Also see |modeline|.
         * 	This option cannot be set from a |modeline| or in the |sandbox|, for
         * 	security reasons.
         */
        modelineexpr: Option<boolean>;

        /**
         * `'modelines'`  `'mls'` 	number	(default 5)
         * 			global
         * 	If `'modeline'`  is on `'modelines'`  gives the number of lines that is
         * 	checked for set commands.  If `'modeline'`  is off or `'modelines'`  is zero
         * 	no lines are checked.  See |modeline|.
         */
        modelines: Option<number>;

        /**
         * `'modifiable'`  `'ma'` 	boolean	(default on)
         * 			local to buffer
         * 	When off the buffer contents cannot be changed.  The `'fileformat'`  and
         * 	`'fileencoding'`  options also can't be changed.
         * 	Can be reset on startup with the |-M| command line argument.
         */
        modifiable: Option<boolean>;

        /**
         * `'modified'`  `'mod'` 	boolean	(default off)
         * 			local to buffer
         * 	When on, the buffer is considered to be modified.  This option is set
         * 	when:
         * 	1. A change was made to the text since it was last written.  Using the
         * 	   |undo| command to go back to the original text will reset the
         * 	   option.  But undoing changes that were made before writing the
         * 	   buffer will set the option again, since the text is different from
         * 	   when it was written.
         * 	2. `'fileformat'`  or `'fileencoding'`  is different from its original
         * 	   value.  The original value is set when the buffer is read or
         * 	   written.  A ":set nomodified" command also resets the original
         * 	   values to the current values and the `'modified'`  option will be
         * 	   reset.
         * 	   Similarly for `'eol'`  and `'bomb'` .
         * 	This option is not set when a change is made to the buffer as the
         * 	result of a BufNewFile, BufRead/BufReadPost, BufWritePost,
         * 	FileAppendPost or VimLeave autocommand event.  See |gzip-example| for
         * 	an explanation.
         * 	When `'buftype'`  is "nowrite" or "nofile" this option may be set, but
         * 	will be ignored.
         * 	Note that the text may actually be the same, e.g. `'modified'`  is set
         * 	when using "rA" on an "A".
         */
        modified: Option<boolean>;

        /**
         * `'more'` 			boolean	(default: on)
         * 			global
         * 	When on, listings pause when the whole screen is filled.  You will get
         * 	the |more-prompt|.  When this option is off there are no pauses, the
         * 	listing continues until finished.
         */
        more: Option<boolean>;

        /**
         * `'mouse'` 			string	(default "nvi")
         * 			global
         * 
         * 	Enables mouse support. For example, to enable the mouse in Normal mode
         * 	and Visual mode: >
         * 		:set mouse=nv
         * <
         * 	To temporarily disable mouse support, hold the shift key while using
         * 	the mouse.
         * 
         * 	Mouse support can be enabled for different modes:
         * 		n	Normal mode
         * 		v	Visual mode
         * 		i	Insert mode
         * 		c	Command-line mode
         * 		h	all previous modes when editing a help file
         * 		a	all previous modes
         * 		r	for |hit-enter| and |more-prompt| prompt
         * 
         * 	Left-click anywhere in a text buffer to place the cursor there.  This
         * 	works with operators too, e.g. type |d| then left-click to delete text
         * 	from the current cursor position to the position where you clicked.
         * 
         * 	Drag the |status-line| or vertical separator of a window to resize it.
         * 
         * 	If enabled for "v" (Visual mode) then double-click selects word-wise,
         * 	triple-click makes it line-wise, and quadruple-click makes it
         * 	rectangular block-wise.
         * 
         * 	For scrolling with a mouse wheel see |scroll-mouse-wheel|.
         * 
         * 	Note: When enabling the mouse in a terminal, copy/paste will use the
         * 	"* register if possible. See also `'clipboard'` .
         * 
         * 	Related options:
         * 	`'mousefocus'` 	window focus follows mouse pointer
         * 	`'mousemodel'` 	what mouse button does which action
         * 	`'mousehide'` 	hide mouse pointer while typing text
         * 	`'selectmode'` 	whether to start Select mode or Visual mode
         * 
         * 	The :behave command provides some "profiles" for mouse behavior.
         * 
         * 	:be[have] {model}	Set behavior for mouse and selection.  Valid
         * 				arguments are:
         * 				   mswin	MS-Windows behavior
         * 				   xterm	Xterm behavior
         * 
         * 				Using ":behave" changes these options:
         * 				option		mswin			xterm	~
         * 				`'selectmode'` 	"mouse,key"		""
         * 				`'mousemodel'` 	"popup"			"extend"
         * 				`'keymodel'` 	"startsel,stopsel"	""
         * 				`'selection'` 	"exclusive"		"inclusive"
         */
        mouse: ListOption;

        /**
         * `'mousefocus'`  `'mousef'` 	boolean	(default off)
         * 			global
         * 	The window that the mouse pointer is on is automatically activated.
         * 	When changing the window layout or window focus in another way, the
         * 	mouse pointer is moved to the window with keyboard focus.  Off is the
         * 	default because it makes using the pull down menus a little goofy, as
         * 	a pointer transit may activate a window unintentionally.
         */
        mousefocus: Option<boolean>;

        /**
         * `'mousehide'`  `'mh'` 	boolean	(default on)
         * 			global
         * 			{only works in the GUI}
         * 	When on, the mouse pointer is hidden when characters are typed.
         * 	The mouse pointer is restored when the mouse is moved.
         */
        mousehide: Option<boolean>;

        /**
         * `'mousemodel'`  `'mousem'` 	string	(default "popup_setpos")
         * 			global
         * 	Sets the model to use for the mouse.  The name mostly specifies what
         * 	the right mouse button is used for:
         * 	   extend	Right mouse button extends a selection.  This works
         * 			like in an xterm.
         * 	   popup	Right mouse button pops up a menu.  The shifted left
         * 			mouse button extends a selection.  This works like
         * 			with Microsoft Windows.
         * 	   popup_setpos Like "popup", but the cursor will be moved to the
         * 			position where the mouse was clicked, and thus the
         * 			selected operation will act upon the clicked object.
         * 			If clicking inside a selection, that selection will
         * 			be acted upon, i.e. no cursor move.  This implies of
         * 			course, that right clicking outside a selection will
         * 			end Visual mode.
         * 	Overview of what button does what for each model:
         * 	mouse		    extend		popup(_setpos) ~
         * 	left click	    place cursor	place cursor
         * 	left drag	    start selection	start selection
         * 	shift-left	    search word		extend selection
         * 	right click	    extend selection	popup menu (place cursor)
         * 	right drag	    extend selection	-
         * 	middle click	    paste		paste
         * 
         * 	In the "popup" model the right mouse button produces a pop-up menu.
         * 	Nvim creates a default |popup-menu| but you can redefine it.
         * 
         * 	Note that you can further refine the meaning of buttons with mappings.
         * 	See |mouse-overview|.  But mappings are NOT used for modeless selection.
         * 
         * 	Example: >
         * 	   :map <S-LeftMouse>     <RightMouse>
         * 	   :map <S-LeftDrag>      <RightDrag>
         * 	   :map <S-LeftRelease>   <RightRelease>
         * 	   :map <2-S-LeftMouse>   <2-RightMouse>
         * 	   :map <2-S-LeftDrag>    <2-RightDrag>
         * 	   :map <2-S-LeftRelease> <2-RightRelease>
         * 	   :map <3-S-LeftMouse>   <3-RightMouse>
         * 	   :map <3-S-LeftDrag>    <3-RightDrag>
         * 	   :map <3-S-LeftRelease> <3-RightRelease>
         * 	   :map <4-S-LeftMouse>   <4-RightMouse>
         * 	   :map <4-S-LeftDrag>    <4-RightDrag>
         * 	   :map <4-S-LeftRelease> <4-RightRelease>
         * <
         * 	Mouse commands requiring the CTRL modifier can be simulated by typing
         * 	the "g" key before using the mouse:
         * 	    "g<LeftMouse>"  is "<C-LeftMouse>	(jump to tag under mouse click)
         * 	    "g<RightMouse>" is "<C-RightMouse>	("CTRL-T")
         * 
         * 	The `'mousemodel'`  option is set by the |:behave| command.
         */
        mousemodel: Option<string>;

        /**
         * `'mousemoveevent'`  `'mousemev'`   boolean	(default off)
         * 			global
         * 	When on, mouse move events are delivered to the input queue and are
         * 	available for mapping. The default, off, avoids the mouse movement
         * 	overhead except when needed.
         * 	Warning: Setting this option can make pending mappings to be aborted
         * 	when the mouse is moved.
         */
        mousemoveevent: Option<boolean>;

        /**
         * `'mousescroll'` 		string	(default "ver:3,hor:6")
         * 			global
         * 	This option controls the number of lines / columns to scroll by when
         * 	scrolling with a mouse. The option is a comma separated list of parts.
         * 	Each part consists of a direction and a count as follows:
         * 		direction:count,direction:count
         * 	Direction is one of either "hor" or "ver". "hor" controls horizontal
         * 	scrolling and "ver" controls vertical scrolling. Count sets the amount
         * 	to scroll by for the given direction, it should be a non negative
         * 	integer. Each direction should be set at most once. If a direction
         * 	is omitted, a default value is used (6 for horizontal scrolling and 3
         * 	for vertical scrolling). You can disable mouse scrolling by using
         * 	a count of 0.
         * 
         * 	Example: >
         * 		:set mousescroll=ver:5,hor:2
         * <	Will make Nvim scroll 5 lines at a time when scrolling vertically, and
         * 	scroll 2 columns at a time when scrolling horizontally.
         */
        mousescroll: ListOption;

        /**
         * `'mouseshape'`  `'mouses'` 	string	(default "i:beam,r:beam,s:updown,sd:cross,
         * 					m:no,ml:up-arrow,v:rightup-arrow")
         * 			global
         * 	This option tells Vim what the mouse pointer should look like in
         * 	different modes.  The option is a comma-separated list of parts, much
         * 	like used for `'guicursor'` .  Each part consist of a mode/location-list
         * 	and an argument-list:
         * 		mode-list:shape,mode-list:shape,..
         * 	The mode-list is a dash separated list of these modes/locations:
         * 			In a normal window: ~
         * 		n	Normal mode
         * 		v	Visual mode
         * 		ve	Visual mode with `'selection'`  "exclusive" (same as `'v'` ,
         * 			if not specified)
         * 		o	Operator-pending mode
         * 		i	Insert mode
         * 		r	Replace mode
         * 
         * 			Others: ~
         * 		c	appending to the command-line
         * 		ci	inserting in the command-line
         * 		cr	replacing in the command-line
         * 		m	at the 'Hit ENTER' or `'More'`  prompts
         * 		ml	idem, but cursor in the last line
         * 		e	any mode, pointer below last window
         * 		s	any mode, pointer on a status line
         * 		sd	any mode, while dragging a status line
         * 		vs	any mode, pointer on a vertical separator line
         * 		vd	any mode, while dragging a vertical separator line
         * 		a	everywhere
         * 
         * 	The shape is one of the following:
         * 	avail	name		looks like ~
         * 	w x	arrow		Normal mouse pointer
         * 	w x	blank		no pointer at all (use with care!)
         * 	w x	beam		I-beam
         * 	w x	updown		up-down sizing arrows
         * 	w x	leftright	left-right sizing arrows
         * 	w x	busy		The system's usual busy pointer
         * 	w x	no		The system's usual "no input" pointer
         * 	  x	udsizing	indicates up-down resizing
         * 	  x	lrsizing	indicates left-right resizing
         * 	  x	crosshair	like a big thin +
         * 	  x	hand1		black hand
         * 	  x	hand2		white hand
         * 	  x	pencil		what you write with
         * 	  x	question	big ?
         * 	  x	rightup-arrow	arrow pointing right-up
         * 	w x	up-arrow	arrow pointing up
         * 	  x	<number>	any X11 pointer number (see X11/cursorfont.h)
         * 
         * 	The "avail" column contains a `'w'`  if the shape is available for Win32,
         * 	x for X11.
         * 	Any modes not specified or shapes not available use the normal mouse
         * 	pointer.
         * 
         * 	Example: >
         * 		:set mouseshape=s:udsizing,m:no
         * <	will make the mouse turn to a sizing arrow over the status lines and
         * 	indicate no input when the hit-enter prompt is displayed (since
         * 	clicking the mouse has no effect in this state.)
         */
        mouseshape: Option<string>;

        /**
         * `'mousetime'`  `'mouset'` 	number	(default 500)
         * 			global
         * 	Defines the maximum time in msec between two mouse clicks for the
         * 	second click to be recognized as a multi click.
         */
        mousetime: Option<number>;

        /**
         * `'nrformats'`  `'nf'` 	string	(default "bin,hex")
         * 			local to buffer
         * 	This defines what bases Vim will consider for numbers when using the
         * 	CTRL-A and CTRL-X commands for adding to and subtracting from a number
         * 	respectively; see |CTRL-A| for more info on these commands.
         * 	alpha	If included, single alphabetical characters will be
         * 		incremented or decremented.  This is useful for a list with a
         * 		letter index a), b), etc.
         * 	octal	If included, numbers that start with a zero will be considered
         * 		to be octal.  Example: Using CTRL-A on "007" results in "010".
         * 	hex	If included, numbers starting with "0x" or "0X" will be
         * 		considered to be hexadecimal.  Example: Using CTRL-X on
         * 		"0x100" results in "0x0ff".
         * 	bin	If included, numbers starting with "0b" or "0B" will be
         * 		considered to be binary.  Example: Using CTRL-X on
         * 		"0b1000" subtracts one, resulting in "0b0111".
         * 	unsigned    If included, numbers are recognized as unsigned. Thus a
         * 		leading dash or negative sign won't be considered as part of
         * 		the number.  Examples:
         * 		    Using CTRL-X on "2020" in "9-2020" results in "9-2019"
         * 		    (without "unsigned" it would become "9-2021").
         * 		    Using CTRL-A on "2020" in "9-2020" results in "9-2021"
         * 		    (without "unsigned" it would become "9-2019").
         * 		    Using CTRL-X on "0" or CTRL-A on "18446744073709551615"
         * 		    (2^64 - 1) has no effect, overflow is prevented.
         * 	Numbers which simply begin with a digit in the range 1-9 are always
         * 	considered decimal.  This also happens for numbers that are not
         * 	recognized as octal or hex.
         */
        nrformats: ListOption;

        /**
         * `'number'`  `'nu'` 		boolean	(default off)
         * 			local to window
         * 	Print the line number in front of each line.  When the `'n'`  option is
         * 	excluded from `'cpoptions'`  a wrapped line will not use the column of
         * 	line numbers.
         * 	Use the `'numberwidth'`  option to adjust the room for the line number.
         * 	When a long, wrapped line doesn't start with the first character, `'-'` 
         * 	characters are put before the number.
         * 	For highlighting see |hl-LineNr|, |hl-CursorLineNr|, and the
         * 	|:sign-define| "numhl" argument.
         * 
         * 	The `'relativenumber'`  option changes the displayed number to be
         * 	relative to the cursor.  Together with `'number'`  there are these
         * 	four combinations (cursor in line 3):
         * 
         * 		`'nonu'`           `'nu'`             `'nonu'`           `'nu'` 
         * 		`'nornu'`          `'nornu'`          `'rnu'`            `'rnu'` 
         * >
         * 	    |apple          |  1 apple      |  2 apple      |  2 apple
         * 	    |pear           |  2 pear       |  1 pear       |  1 pear
         * 	    |nobody         |  3 nobody     |  0 nobody     |3   nobody
         * 	    |there          |  4 there      |  1 there      |  1 there
         * <
         */
        number: Option<boolean>;

        /**
         * `'numberwidth'`  `'nuw'` 	number	(default: 4)
         * 			local to window
         * 	Minimal number of columns to use for the line number.  Only relevant
         * 	when the `'number'`  or `'relativenumber'`  option is set or printing lines
         * 	with a line number. Since one space is always between the number and
         * 	the text, there is one less character for the number itself.
         * 	The value is the minimum width.  A bigger width is used when needed to
         * 	fit the highest line number in the buffer respectively the number of
         * 	rows in the window, depending on whether `'number'`  or `'relativenumber'` 
         * 	is set. Thus with the Vim default of 4 there is room for a line number
         * 	up to 999. When the buffer has 1000 lines five columns will be used.
         * 	The minimum value is 1, the maximum value is 20.
         */
        numberwidth: Option<number>;

        /**
         * `'omnifunc'`  `'ofu'` 	string	(default: empty)
         * 			local to buffer
         * 	This option specifies a function to be used for Insert mode omni
         * 	completion with CTRL-X CTRL-O. |i_CTRL-X_CTRL-O|
         * 	See |complete-functions| for an explanation of how the function is
         * 	invoked and what it should return.  The value can be the name of a
         * 	function, a |lambda| or a |Funcref|. See |option-value-function| for
         * 	more information.
         * 	This option is usually set by a filetype plugin:
         * 	|:filetype-plugin-on|
         * 	This option cannot be set from a |modeline| or in the |sandbox|, for
         * 	security reasons.
         */
        omnifunc: Option<string>;

        /**
         * `'opendevice'`  `'odev'` 	boolean	(default off)
         * 			global
         * 			{only for Windows}
         * 	Enable reading and writing from devices.  This may get Vim stuck on a
         * 	device that can be opened but doesn't actually do the I/O.  Therefore
         * 	it is off by default.
         * 	Note that on Windows editing "aux.h", "lpt1.txt" and the like also
         * 	result in editing a device.
         */
        opendevice: Option<boolean>;

        /**
         * `'operatorfunc'`  `'opfunc'` 	string	(default: empty)
         * 			global
         * 	This option specifies a function to be called by the |g@| operator.
         * 	See |:map-operator| for more info and an example.  The value can be
         * 	the name of a function, a |lambda| or a |Funcref|. See
         * 	|option-value-function| for more information.
         * 
         * 	This option cannot be set from a |modeline| or in the |sandbox|, for
         * 	security reasons.
         */
        operatorfunc: Option<string>;

        /**
         * `'packpath'`  `'pp'` 		string	(default: see `'runtimepath'` )
         * 	Directories used to find packages.  See |packages| and |rtp-packages|.
         */
        packpath: ListOption;

        /**
         * `'paragraphs'`  `'para'` 	string	(default "IPLPPPQPP TPHPLIPpLpItpplpipbp")
         * 			global
         * 	Specifies the nroff macros that separate paragraphs.  These are pairs
         * 	of two letters (see |object-motions|).
         */
        paragraphs: Option<string>;

        paste: Option<boolean>;

        pastetoggle: Option<string>;

        /**
         * `'patchexpr'`  `'pex'` 	string	(default "")
         * 			global
         * 	Expression which is evaluated to apply a patch to a file and generate
         * 	the resulting new version of the file.  See |diff-patchexpr|.
         */
        patchexpr: Option<string>;

        /**
         * `'patchmode'`  `'pm'` 	string	(default "")
         * 			global
         * 	When non-empty the oldest version of a file is kept.  This can be used
         * 	to keep the original version of a file if you are changing files in a
         * 	source distribution.  Only the first time that a file is written a
         * 	copy of the original file will be kept.  The name of the copy is the
         * 	name of the original file with the string in the `'patchmode'`  option
         * 	appended.  This option should start with a dot.  Use a string like
         * 	".orig" or ".org".  `'backupdir'`  must not be empty for this to work
         * 	(Detail: The backup file is renamed to the patchmode file after the
         * 	new file has been successfully written, that's why it must be possible
         * 	to write a backup file).  If there was no file to be backed up, an
         * 	empty file is created.
         * 	When the `'backupskip'`  pattern matches, a patchmode file is not made.
         * 	Using `'patchmode'`  for compressed files appends the extension at the
         * 	end (e.g., "file.gz.orig"), thus the resulting name isn't always
         * 	recognized as a compressed file.
         * 	Only normal file name characters can be used, "/\*?[|<>" are illegal.
         */
        patchmode: Option<string>;

        /**
         * `'path'`  `'pa'` 		string	(default on Unix: ".,/usr/include,,"
         * 				   other systems: ".,,")
         * 			global or local to buffer |global-local|
         * 	This is a list of directories which will be searched when using the
         * 	|gf|, [f, ]f, ^Wf, |:find|, |:sfind|, |:tabfind| and other commands,
         * 	provided that the file being searched for has a relative path (not
         * 	starting with "/", "./" or "../").  The directories in the `'path'` 
         * 	option may be relative or absolute.
         * 	- Use commas to separate directory names: >
         * 		:set path=.,/usr/local/include,/usr/include
         * <	- Spaces can also be used to separate directory names (for backwards
         * 	  compatibility with version 3.0).  To have a space in a directory
         * 	  name, precede it with an extra backslash, and escape the space: >
         * 		:set path=.,/dir/with\\\ space
         * <	- To include a comma in a directory name precede it with an extra
         * 	  backslash: >
         * 		:set path=.,/dir/with\\,comma
         * <	- To search relative to the directory of the current file, use: >
         * 		:set path=.
         * <	- To search in the current directory use an empty string between two
         * 	  commas: >
         * 		:set path=,,
         * <	- A directory name may end in a `':'`  or `'/'` .
         * 	- Environment variables are expanded |:set_env|.
         * 	- When using |netrw.vim| URLs can be used.  For example, adding
         * 	  "https://www.vim.org" will make ":find index.html" work.
         * 	- Search upwards and downwards in a directory tree using "*", "" and
         * 	  ";".  See |file-searching| for info and syntax.
         * 	- Careful with `'\'`  characters, type two to get one in the option: >
         * 		:set path=.,c:\\include
         * <	  Or just use `'/'`  instead: >
         * 		:set path=.,c:/include
         * <	Don't forget "." or files won't even be found in the same directory as
         * 	the file!
         * 	The maximum length is limited.  How much depends on the system, mostly
         * 	it is something like 256 or 1024 characters.
         * 	You can check if all the include files are found, using the value of
         * 	`'path'` , see |:checkpath|.
         * 	The use of |:set+=| and |:set-=| is preferred when adding or removing
         * 	directories from the list.  This avoids problems when a future version
         * 	uses another default.  To remove the current directory use: >
         * 		:set path-=
         * <	To add the current directory use: >
         * 		:set path+=
         * <	To use an environment variable, you probably need to replace the
         * 	separator.  Here is an example to append $INCL, in which directory
         * 	names are separated with a semi-colon: >
         * 		:let &path = &path .. "," .. substitute($INCL, `';'` , `','` , `'g'` )
         * <	Replace the `';'`  with a `':'`  or whatever separator is used.  Note that
         * 	this doesn't work when $INCL contains a comma or white space.
         */
        path: ListOption;

        /**
         * `'preserveindent'`  `'pi'` 	boolean	(default off)
         * 			local to buffer
         * 	When changing the indent of the current line, preserve as much of the
         * 	indent structure as possible.  Normally the indent is replaced by a
         * 	series of tabs followed by spaces as required (unless |`'expandtab'` | is
         * 	enabled, in which case only spaces are used).  Enabling this option
         * 	means the indent will preserve as many existing characters as possible
         * 	for indenting, and only add additional tabs or spaces as required.
         * 	`'expandtab'`  does not apply to the preserved white space, a Tab remains
         * 	a Tab.
         * 	NOTE: When using ">>" multiple times the resulting indent is a mix of
         * 	tabs and spaces.  You might not like this.
         * 	Also see `'copyindent'` .
         * 	Use |:retab| to clean up white space.
         */
        preserveindent: Option<boolean>;

        /**
         * `'previewheight'`  `'pvh'` 	number (default 12)
         * 			global
         * 	Default height for a preview window.  Used for |:ptag| and associated
         * 	commands.  Used for |CTRL-W_}| when no count is given.
         */
        previewheight: Option<number>;

        /**
         * `'previewwindow'`  `'pvw'` 	boolean (default off)
         * 			local to window
         * 	Identifies the preview window.  Only one window can have this option
         * 	set.  It's normally not set directly, but by using one of the commands
         * 	|:ptag|, |:pedit|, etc.
         */
        previewwindow: Option<boolean>;

        prompt: Option<boolean>;

        /**
         * `'pumblend'`  `'pb'` 		number	(default 0)
         * 			global
         * 	Enables pseudo-transparency for the |popup-menu|. Valid values are in
         * 	the range of 0 for fully opaque popupmenu (disabled) to 100 for fully
         * 	transparent background. Values between 0-30 are typically most useful.
         * 
         * 	It is possible to override the level for individual highlights within
         * 	the popupmenu using |highlight-blend|. For instance, to enable
         * 	transparency but force the current selected element to be fully opaque: >
         * 
         * 		:set pumblend=15
         * 		:hi PmenuSel blend=0
         * <
         * 	UI-dependent. Works best with RGB colors. `'termguicolors'` 
         */
        pumblend: Option<number>;

        /**
         * `'pumheight'`  `'ph'` 	number	(default 0)
         * 			global
         * 	Maximum number of items to show in the popup menu
         * 	(|ins-completion-menu|). Zero means "use available screen space".
         */
        pumheight: Option<number>;

        /**
         * `'pumwidth'`  `'pw'` 		number	(default 15)
         * 			global
         * 	Minimum width for the popup menu (|ins-completion-menu|).  If the
         * 	cursor column + `'pumwidth'`  exceeds screen width, the popup menu is
         * 	nudged to fit on the screen.
         */
        pumwidth: Option<number>;

        /**
         * `'pyxversion'`  `'pyx'` 	number	(default 3)
         * 			global
         * 	Specifies the python version used for pyx* functions and commands
         * 	|python_x|.  As only Python 3 is supported, this always has the value
         * 	`3`. Setting any other value is an error.
         * 
         * 	This option cannot be set from a |modeline| or in the |sandbox|, for
         * 	security reasons.
         */
        pyxversion: Option<number>;

        /**
         * `'quickfixtextfunc'`  `'qftf'` 	string (default "")
         * 			global
         * 	This option specifies a function to be used to get the text to display
         * 	in the quickfix and location list windows.  This can be used to
         * 	customize the information displayed in the quickfix or location window
         * 	for each entry in the corresponding quickfix or location list.  See
         * 	|quickfix-window-function| for an explanation of how to write the
         * 	function and an example.  The value can be the name of a function, a
         * 	|lambda| or a |Funcref|. See |option-value-function| for more
         * 	information.
         * 
         * 	This option cannot be set from a |modeline| or in the |sandbox|, for
         * 	security reasons.
         */
        quickfixtextfunc: Option<string>;

        /**
         * `'quoteescape'`  `'qe'` 	string	(default "\")
         * 			local to buffer
         * 	The characters that are used to escape quotes in a string.  Used for
         * 	objects like a', a" and a` |a'|.
         * 	When one of the characters in this option is found inside a string,
         * 	the following character will be skipped.  The default value makes the
         * 	text "foo\"bar\\" considered to be one string.
         */
        quoteescape: Option<string>;

        /**
         * `'readonly'`  `'ro'` 		boolean	(default off)
         * 			local to buffer
         * 	If on, writes fail unless you use a `'!'` .  Protects you from
         * 	accidentally overwriting a file.  Default on when Vim is started
         * 	in read-only mode ("vim -R") or when the executable is called "view".
         * 	When using ":w!" the `'readonly'`  option is reset for the current
         * 	buffer, unless the `'Z'`  flag is in `'cpoptions'` .
         * 	When using the ":view" command the `'readonly'`  option is set for the
         * 	newly edited buffer.
         * 	See `'modifiable'`  for disallowing changes to the buffer.
         */
        readonly: Option<boolean>;

        /**
         * `'redrawdebug'`  `'rdb'` 	string	(default `''` )
         * 			global
         * 	Flags to change the way redrawing works, for debugging purposes.
         * 	Most useful with `'writedelay'`  set to some reasonable value.
         * 	Supports the following flags:
         * 	    compositor	Indicate each redraw event handled by the compositor
         * 			by briefly flashing the redrawn regions in colors
         * 			indicating the redraw type. These are the highlight
         * 			groups used (and their default colors):
         * 		RedrawDebugNormal   gui=reverse   normal redraw passed through
         * 		RedrawDebugClear    guibg=Yellow  clear event passed through
         * 		RedrawDebugComposed guibg=Green   redraw event modified by the
         * 						  compositor (due to
         * 						  overlapping grids, etc)
         * 		RedrawDebugRecompose guibg=Red    redraw generated by the
         * 						  compositor itself, due to a
         * 						  grid being moved or deleted.
         * 	    line	introduce a delay after each line drawn on the screen.
         * 			When using the TUI or another single-grid UI, "compositor"
         * 			gives more information and should be preferred (every
         * 			line is processed as a separate event by the compositor)
         * 	    flush	introduce a delay after each "flush" event.
         * 	    nothrottle	Turn off throttling of the message grid. This is an
         * 			optimization that joins many small scrolls to one
         * 			larger scroll when drawing the message area (with
         * 			`'display'`  msgsep flag active).
         * 	    invalid	Enable stricter checking (abort) of inconsistencies
         * 			of the internal screen state. This is mostly
         * 			useful when running nvim inside a debugger (and
         * 			the test suite).
         * 	    nodelta	Send all internally redrawn cells to the UI, even if
         * 			they are unchanged from the already displayed state.
         */
        redrawdebug: ListOption;

        /**
         * `'redrawtime'`  `'rdt'` 	number	(default 2000)
         * 			global
         * 	Time in milliseconds for redrawing the display.  Applies to
         * 	`'hlsearch'` , `'inccommand'` , |:match| highlighting and syntax
         * 	highlighting.
         * 	When redrawing takes more than this many milliseconds no further
         * 	matches will be highlighted.
         * 	For syntax highlighting the time applies per window.  When over the
         * 	limit syntax highlighting is disabled until |CTRL-L| is used.
         * 	This is used to avoid that Vim hangs when using a very complicated
         * 	pattern.
         */
        redrawtime: Option<number>;

        /**
         * `'regexpengine'`  `'re'` 	number	(default 0)
         * 			global
         * 	This selects the default regexp engine. |two-engines|
         * 	The possible values are:
         * 		0	automatic selection
         * 		1	old engine
         * 		2	NFA engine
         * 	Note that when using the NFA engine and the pattern contains something
         * 	that is not supported the pattern will not match.  This is only useful
         * 	for debugging the regexp engine.
         * 	Using automatic selection enables Vim to switch the engine, if the
         * 	default engine becomes too costly.  E.g., when the NFA engine uses too
         * 	many states.  This should prevent Vim from hanging on a combination of
         * 	a complex pattern with long text.
         */
        regexpengine: Option<number>;

        /**
         * `'relativenumber'`  `'rnu'` 	boolean	(default off)
         * 			local to window
         * 	Show the line number relative to the line with the cursor in front of
         * 	each line. Relative line numbers help you use the |count| you can
         * 	precede some vertical motion commands (e.g. j k + -) with, without
         * 	having to calculate it yourself. Especially useful in combination with
         * 	other commands (e.g. y d c < > gq gw =).
         * 	When the `'n'`  option is excluded from `'cpoptions'`  a wrapped
         * 	line will not use the column of line numbers.
         * 	The `'numberwidth'`  option can be used to set the room used for the line
         * 	number.
         * 	When a long, wrapped line doesn't start with the first character, `'-'` 
         * 	characters are put before the number.
         * 	See |hl-LineNr|  and |hl-CursorLineNr| for the highlighting used for
         * 	the number.
         * 
         * 	The number in front of the cursor line also depends on the value of
         * 	`'number'` , see |number_relativenumber| for all combinations of the two
         * 	options.
         */
        relativenumber: Option<boolean>;

        remap: Option<boolean>;

        /**
         * `'report'` 		number	(default 2)
         * 			global
         * 	Threshold for reporting number of lines changed.  When the number of
         * 	changed lines is more than `'report'`  a message will be given for most
         * 	":" commands.  If you want it always, set `'report'`  to 0.
         * 	For the ":substitute" command the number of substitutions is used
         * 	instead of the number of lines.
         */
        report: Option<number>;

        /**
         * `'revins'`  `'ri'` 		boolean	(default off)
         * 			global
         * 	Inserting characters in Insert mode will work backwards.  See "typing
         * 	backwards" |ins-reverse|.  This option can be toggled with the CTRL-_
         * 	command in Insert mode, when `'allowrevins'`  is set.
         */
        revins: Option<boolean>;

        /**
         * `'rightleft'`  `'rl'` 	boolean	(default off)
         * 			local to window
         * 	When on, display orientation becomes right-to-left, i.e., characters
         * 	that are stored in the file appear from the right to the left.
         * 	Using this option, it is possible to edit files for languages that
         * 	are written from the right to the left such as Hebrew and Arabic.
         * 	This option is per window, so it is possible to edit mixed files
         * 	simultaneously, or to view the same file in both ways (this is
         * 	useful whenever you have a mixed text file with both right-to-left
         * 	and left-to-right strings so that both sets are displayed properly
         * 	in different windows).  Also see |rileft.txt|.
         */
        rightleft: Option<boolean>;

        /**
         * `'rightleftcmd'`  `'rlc'` 	string	(default "search")
         * 			local to window
         * 	Each word in this option enables the command line editing to work in
         * 	right-to-left mode for a group of commands:
         * 
         * 		search		"/" and "?" commands
         * 
         * 	This is useful for languages such as Hebrew, Arabic and Farsi.
         * 	The `'rightleft'`  option must be set for `'rightleftcmd'`  to take effect.
         */
        rightleftcmd: Option<string>;

        /**
         * `'ruler'`  `'ru'` 		boolean	(default on)
         * 			global
         * 	Show the line and column number of the cursor position, separated by a
         * 	comma.  When there is room, the relative position of the displayed
         * 	text in the file is shown on the far right:
         * 		Top	first line is visible
         * 		Bot	last line is visible
         * 		All	first and last line are visible
         * 		45%	relative position in the file
         * 	If `'rulerformat'`  is set, it will determine the contents of the ruler.
         * 	Each window has its own ruler.  If a window has a status line, the
         * 	ruler is shown there.  If a window doesn't have a status line and
         * 	`'cmdheight'`  is zero, the ruler is not shown.  Otherwise it is shown in
         * 	the last line of the screen.  If the statusline is given by
         * 	`'statusline'`  (i.e. not empty), this option takes precedence over
         * 	`'ruler'`  and `'rulerformat'` .
         * 	If the number of characters displayed is different from the number of
         * 	bytes in the text (e.g., for a TAB or a multibyte character), both
         * 	the text column (byte number) and the screen column are shown,
         * 	separated with a dash.
         * 	For an empty line "0-1" is shown.
         * 	For an empty buffer the line number will also be zero: "0,0-1".
         * 	If you don't want to see the ruler all the time but want to know where
         * 	you are, use "g CTRL-G" |g_CTRL-G|.
         */
        ruler: Option<boolean>;

        /**
         * `'rulerformat'`  `'ruf'` 	string	(default empty)
         * 			global
         * 	When this option is not empty, it determines the content of the ruler
         * 	string, as displayed for the `'ruler'`  option.
         * 	The format of this option is like that of `'statusline'` .
         * 	This option cannot be set in a modeline when `'modelineexpr'`  is off.
         * 
         * 	The default ruler width is 17 characters.  To make the ruler 15
         * 	characters wide, put "%15(" at the start and "%)" at the end.
         * 	Example: >
         * 		:set rulerformat=%15(%c%V\ %p%%%)
         * <
         */
        rulerformat: Option<string>;

        /**
         * `'runtimepath'`  `'rtp'` 	string (default:
         *      "$XDG_CONFIG_HOME/nvim,
         *      "$XDG_CONFIG_DIRS[1]/nvim,
         *      "$XDG_CONFIG_DIRS[2]/nvim,
         *      …
         *      $XDG_DATA_HOME/nvim[-data]/site,
         *      $XDG_DATA_DIRS[1]/nvim/site,
         *      $XDG_DATA_DIRS[2]/nvim/site,
         *      …
         *      $VIMRUNTIME,
         *      …
         *      $XDG_DATA_DIRS[2]/nvim/site/after,
         *      $XDG_DATA_DIRS[1]/nvim/site/after,
         *      $XDG_DATA_HOME/nvim[-data]/site/after,
         *      …
         *      $XDG_CONFIG_DIRS[2]/nvim/after,
         *      $XDG_CONFIG_DIRS[1]/nvim/after,
         *      $XDG_CONFIG_HOME/nvim/after")
         *
         * 			global
         * 	List of directories to be searched for these runtime files:
         * 	  filetype.lua	filetypes |new-filetype|
         * 	  autoload/	automatically loaded scripts |autoload-functions|
         * 	  colors/	color scheme files |:colorscheme|
         * 	  compiler/	compiler files |:compiler|
         * 	  doc/		documentation |write-local-help|
         * 	  ftplugin/	filetype plugins |write-filetype-plugin|
         * 	  indent/	indent scripts |indent-expression|
         * 	  keymap/	key mapping files |mbyte-keymap|
         * 	  lang/		menu translations |:menutrans|
         * 	  lua/		|Lua| plugins
         * 	  menu.vim	GUI menus |menu.vim|
         * 	  pack/		packages |:packadd|
         * 	  parser/	|treesitter| syntax parsers
         * 	  plugin/	plugin scripts |write-plugin|
         * 	  queries/	|treesitter| queries
         * 	  rplugin/	|remote-plugin| scripts
         * 	  spell/	spell checking files |spell|
         * 	  syntax/	syntax files |mysyntaxfile|
         * 	  tutor/	tutorial files |:Tutor|
         * 
         * 	And any other file searched for with the |:runtime| command.
         * 
         * 	Defaults are setup to search these locations:
         * 	1. Your home directory, for personal preferences.
         * 	   Given by `stdpath("config")`.  |$XDG_CONFIG_HOME|
         * 	2. Directories which must contain configuration files according to
         * 	   |xdg| ($XDG_CONFIG_DIRS, defaults to /etc/xdg).  This also contains
         * 	   preferences from system administrator.
         * 	3. Data home directory, for plugins installed by user.
         * 	   Given by `stdpath("data")/site`.  |$XDG_DATA_HOME|
         * 	4. nvim/site subdirectories for each directory in $XDG_DATA_DIRS.
         * 	   This is for plugins which were installed by system administrator,
         * 	   but are not part of the Nvim distribution. XDG_DATA_DIRS defaults
         * 	   to /usr/local/share/:/usr/share/, so system administrators are
         * 	   expected to install site plugins to /usr/share/nvim/site.
         * 	5. Session state directory, for state data such as swap, backupdir,
         * 	   viewdir, undodir, etc.
         * 	   Given by `stdpath("state")`.  |$XDG_STATE_HOME|
         * 	6. $VIMRUNTIME, for files distributed with Nvim.
         * 
         * 	7, 8, 9, 10. In after/ subdirectories of 1, 2, 3 and 4, with reverse
         * 	   ordering.  This is for preferences to overrule or add to the
         * 	   distributed defaults or system-wide settings (rarely needed).
         * 
         * 
         * 	"start" packages will also be searched (|runtime-search-path|) for
         * 	runtime files after these, though such packages are not explicitly
         * 	reported in &runtimepath. But "opt" packages are explicitly added to
         * 	&runtimepath by |:packadd|.
         * 
         * 	Note that, unlike `'path'` , no wildcards like "" are allowed.  Normal
         * 	wildcards are allowed, but can significantly slow down searching for
         * 	runtime files.  For speed, use as few items as possible and avoid
         * 	wildcards.
         * 	See |:runtime|.
         * 	Example: >
         * 		:set runtimepath=~/vimruntime,/mygroup/vim,$VIMRUNTIME
         * <	This will use the directory "~/vimruntime" first (containing your
         * 	personal Nvim runtime files), then "/mygroup/vim", and finally
         * 	"$VIMRUNTIME" (the default runtime files).
         * 	You can put a directory before $VIMRUNTIME to find files which replace
         * 	distributed runtime files.  You can put a directory after $VIMRUNTIME
         * 	to find files which add to distributed runtime files.
         * 
         * 	With |--clean| the home directory entries are not included.
         */
        runtimepath: ListOption;

        /**
         * `'scroll'`  `'scr'` 		number	(default: half the window height)
         * 			local to window
         * 	Number of lines to scroll with CTRL-U and CTRL-D commands.  Will be
         * 	set to half the number of lines in the window when the window size
         * 	changes.  This may happen when enabling the |status-line| or
         * 	`'tabline'`  option after setting the `'scroll'`  option.
         * 	If you give a count to the CTRL-U or CTRL-D command it will
         * 	be used as the new value for `'scroll'` .  Reset to half the window
         * 	height with ":set scroll=0".
         */
        scroll: Option<number>;

        /**
         * `'scrollback'`  `'scbk'` 	number	(default: 10000)
         * 			local to buffer
         * 	Maximum number of lines kept beyond the visible screen. Lines at the
         * 	top are deleted if new lines exceed this limit.
         * 	Minimum is 1, maximum is 100000.
         * 	Only in |terminal| buffers.
         */
        scrollback: Option<number>;

        /**
         * `'scrollbind'`  `'scb'` 	boolean  (default off)
         * 			local to window
         * 	See also |scroll-binding|.  When this option is set, the current
         * 	window scrolls as other scrollbind windows (windows that also have
         * 	this option set) scroll.  This option is useful for viewing the
         * 	differences between two versions of a file, see `'diff'` .
         * 	See |`'scrollopt'` | for options that determine how this option should be
         * 	interpreted.
         * 	This option is mostly reset when splitting a window to edit another
         * 	file.  This means that ":split | edit file" results in two windows
         * 	with scroll-binding, but ":split file" does not.
         */
        scrollbind: Option<boolean>;

        /**
         * `'scrolljump'`  `'sj'` 	number	(default 1)
         * 			global
         * 	Minimal number of lines to scroll when the cursor gets off the
         * 	screen (e.g., with "j").  Not used for scroll commands (e.g., CTRL-E,
         * 	CTRL-D).  Useful if your terminal scrolls very slowly.
         * 	When set to a negative number from -1 to -100 this is used as the
         * 	percentage of the window height.  Thus -50 scrolls half the window
         * 	height.
         */
        scrolljump: Option<number>;

        /**
         * `'scrolloff'`  `'so'` 	number	(default 0)
         * 			global or local to window |global-local|
         * 	Minimal number of screen lines to keep above and below the cursor.
         * 	This will make some context visible around where you are working.  If
         * 	you set it to a very large value (999) the cursor line will always be
         * 	in the middle of the window (except at the start or end of the file or
         * 	when long lines wrap).
         * 	After using the local value, go back the global value with one of
         * 	these two: >
         * 		setlocal scrolloff<
         * 		setlocal scrolloff=-1
         * <	For scrolling horizontally see `'sidescrolloff'` .
         */
        scrolloff: Option<number>;

        /**
         * `'scrollopt'`  `'sbo'` 	string	(default "ver,jump")
         * 			global
         * 	This is a comma-separated list of words that specifies how
         * 	`'scrollbind'`  windows should behave.  `'sbo'`  stands for ScrollBind
         * 	Options.
         * 	The following words are available:
         * 	    ver		Bind vertical scrolling for `'scrollbind'`  windows
         * 	    hor		Bind horizontal scrolling for `'scrollbind'`  windows
         * 	    jump	Applies to the offset between two windows for vertical
         * 			scrolling.  This offset is the difference in the first
         * 			displayed line of the bound windows.  When moving
         * 			around in a window, another `'scrollbind'`  window may
         * 			reach a position before the start or after the end of
         * 			the buffer.  The offset is not changed though, when
         * 			moving back the `'scrollbind'`  window will try to scroll
         * 			to the desired position when possible.
         * 			When now making that window the current one, two
         * 			things can be done with the relative offset:
         * 			1. When "jump" is not included, the relative offset is
         * 			   adjusted for the scroll position in the new current
         * 			   window.  When going back to the other window, the
         * 			   new relative offset will be used.
         * 			2. When "jump" is included, the other windows are
         * 			   scrolled to keep the same relative offset.  When
         * 			   going back to the other window, it still uses the
         * 			   same relative offset.
         * 	Also see |scroll-binding|.
         * 	When `'diff'`  mode is active there always is vertical scroll binding,
         * 	even when "ver" isn't there.
         */
        scrollopt: ListOption;

        /**
         * `'sections'`  `'sect'` 	string	(default "SHNHH HUnhsh")
         * 			global
         * 	Specifies the nroff macros that separate sections.  These are pairs of
         * 	two letters (See |object-motions|).  The default makes a section start
         * 	at the nroff macros ".SH", ".NH", ".H", ".HU", ".nh" and ".sh".
         */
        sections: Option<string>;

        secure: Option<boolean>;

        /**
         * `'selection'`  `'sel'` 	string	(default "inclusive")
         * 			global
         * 	This option defines the behavior of the selection.  It is only used
         * 	in Visual and Select mode.
         * 	Possible values:
         * 	   value	past line     inclusive ~
         * 	   old		   no		yes
         * 	   inclusive	   yes		yes
         * 	   exclusive	   yes		no
         * 	"past line" means that the cursor is allowed to be positioned one
         * 	character past the line.
         * 	"inclusive" means that the last character of the selection is included
         * 	in an operation.  For example, when "x" is used to delete the
         * 	selection.
         * 	When "old" is used and `'virtualedit'`  allows the cursor to move past
         * 	the end of line the line break still isn't included.
         * 	Note that when "exclusive" is used and selecting from the end
         * 	backwards, you cannot include the last character of a line, when
         * 	starting in Normal mode and `'virtualedit'`  empty.
         * 
         * 	The `'selection'`  option is set by the |:behave| command.
         */
        selection: Option<string>;

        /**
         * `'selectmode'`  `'slm'` 	string	(default "")
         * 			global
         * 	This is a comma-separated list of words, which specifies when to start
         * 	Select mode instead of Visual mode, when a selection is started.
         * 	Possible values:
         * 	   mouse	when using the mouse
         * 	   key		when using shifted special keys
         * 	   cmd		when using "v", "V" or CTRL-V
         * 	See |Select-mode|.
         * 	The `'selectmode'`  option is set by the |:behave| command.
         */
        selectmode: ListOption;

        /**
         * `'sessionoptions'`  `'ssop'` 	string	(default: "blank,buffers,curdir,folds,
         * 					       help,tabpages,winsize,terminal")
         * 			global
         * 	Changes the effect of the |:mksession| command.  It is a comma-
         * 	separated list of words.  Each word enables saving and restoring
         * 	something:
         * 	   word		save and restore ~
         * 	   blank	empty windows
         * 	   buffers	hidden and unloaded buffers, not just those in windows
         * 	   curdir	the current directory
         * 	   folds	manually created folds, opened/closed folds and local
         * 			fold options
         * 	   globals	global variables that start with an uppercase letter
         * 			and contain at least one lowercase letter.  Only
         * 			String and Number types are stored.
         * 	   help		the help window
         * 	   localoptions	options and mappings local to a window or buffer (not
         * 			global values for local options)
         * 	   options	all options and mappings (also global values for local
         * 			options)
         * 	   skiprtp	exclude `'runtimepath'`  and `'packpath'`  from the options
         * 	   resize	size of the Vim window: `'lines'`  and `'columns'` 
         * 	   sesdir	the directory in which the session file is located
         * 			will become the current directory (useful with
         * 			projects accessed over a network from different
         * 			systems)
         * 	   tabpages	all tab pages; without this only the current tab page
         * 			is restored, so that you can make a session for each
         * 			tab page separately
         * 	   terminal	include terminal windows where the command can be
         * 			restored
         * 	   winpos	position of the whole Vim window
         * 	   winsize	window sizes
         * 	   slash	|deprecated| Always enabled. Uses "/" in filenames.
         * 	   unix		|deprecated| Always enabled. Uses "\n" line endings.
         * 
         * 	Don't include both "curdir" and "sesdir". When neither is included
         * 	filenames are stored as absolute paths.
         * 	If you leave out "options" many things won't work well after restoring
         * 	the session.
         */
        sessionoptions: ListOption;

        /**
         * `'shada'`  `'sd'` 		string	(default for
         * 				   Win32:  !,'100,<50,s10,h,rA:,rB:
         * 				   others: !,'100,<50,s10,h)
         * 			global
         * 	When non-empty, the shada file is read upon startup and written
         * 	when exiting Vim (see |shada-file|).  The string should be a comma-
         * 	separated list of parameters, each consisting of a single character
         * 	identifying the particular parameter, followed by a number or string
         * 	which specifies the value of that parameter.  If a particular
         * 	character is left out, then the default value is used for that
         * 	parameter.  The following is a list of the identifying characters and
         * 	the effect of their value.
         * 	CHAR	VALUE	~
         * 
         * 	!	When included, save and restore global variables that start
         * 		with an uppercase letter, and don't contain a lowercase
         * 		letter.  Thus "KEEPTHIS and "K_L_M" are stored, but "KeepThis"
         * 		and "_K_L_M" are not.  Nested List and Dict items may not be
         * 		read back correctly, you end up with an empty item.
         * 
         * 	"	Maximum number of lines saved for each register.  Old name of
         * 		the `'<'`  item, with the disadvantage that you need to put a
         * 		backslash before the ", otherwise it will be recognized as the
         * 		start of a comment!
         * 
         * 	%	When included, save and restore the buffer list.  If Vim is
         * 		started with a file name argument, the buffer list is not
         * 		restored.  If Vim is started without a file name argument, the
         * 		buffer list is restored from the shada file.  Quickfix
         * 		(`'buftype'` ), unlisted (`'buflisted'` ), unnamed and buffers on
         * 		removable media (|shada-r|) are not saved.
         * 		When followed by a number, the number specifies the maximum
         * 		number of buffers that are stored.  Without a number all
         * 		buffers are stored.
         * 
         * 	'	Maximum number of previously edited files for which the marks
         * 		are remembered.  This parameter must always be included when
         * 		`'shada'`  is non-empty.
         * 		Including this item also means that the |jumplist| and the
         * 		|changelist| are stored in the shada file.
         * 
         * 	/	Maximum number of items in the search pattern history to be
         * 		saved.  If non-zero, then the previous search and substitute
         * 		patterns are also saved.  When not included, the value of
         * 		`'history'`  is used.
         * 
         * 	:	Maximum number of items in the command-line history to be
         * 		saved.  When not included, the value of `'history'`  is used.
         * 
         * 	<	Maximum number of lines saved for each register.  If zero then
         * 		registers are not saved.  When not included, all lines are
         * 		saved.  `'"'`  is the old name for this item.
         * 		Also see the `'s'`  item below: limit specified in KiB.
         * 
         * 	@	Maximum number of items in the input-line history to be
         * 		saved.  When not included, the value of `'history'`  is used.
         * 
         * 	c	Dummy option, kept for compatibility reasons.  Has no actual
         * 		effect: ShaDa always uses UTF-8 and `'encoding'`  value is fixed
         * 		to UTF-8 as well.
         * 
         * 	f	Whether file marks need to be stored.  If zero, file marks ('0
         * 		to '9, 'A to 'Z) are not stored.  When not present or when
         * 		non-zero, they are all stored.  '0 is used for the current
         * 		cursor position (when exiting or when doing |:wshada|).
         * 
         * 	h	Disable the effect of `'hlsearch'`  when loading the shada
         * 		file.  When not included, it depends on whether ":nohlsearch"
         * 		has been used since the last search command.
         * 
         * 	n	Name of the shada file.  The name must immediately follow
         * 		the `'n'` .  Must be at the end of the option!  If the
         * 		`'shadafile'`  option is set, that file name overrides the one
         * 		given here with `'shada'` .  Environment variables are
         * 		expanded when opening the file, not when setting the option.
         * 
         * 	r	Removable media.  The argument is a string (up to the next
         * 		`','` ).  This parameter can be given several times.  Each
         * 		specifies the start of a path for which no marks will be
         * 		stored.  This is to avoid removable media.  For Windows you
         * 		could use "ra:,rb:".  You can also use it for temp files,
         * 		e.g., for Unix: "r/tmp".  Case is ignored.
         * 
         * 	s	Maximum size of an item contents in KiB.  If zero then nothing
         * 		is saved.  Unlike Vim this applies to all items, except for
         * 		the buffer list and header.  Full item size is off by three
         * 		unsigned integers: with `s10` maximum item size may be 1 byte
         * 		(type: 7-bit integer) + 9 bytes (timestamp: up to 64-bit
         * 		integer) + 3 bytes (item size: up to 16-bit integer because
         * 		2^8 < 10240 < 2^16) + 10240 bytes (requested maximum item
         * 		contents size) = 10253 bytes.
         * 
         * 	Example: >
         * 	    :set shada='50,<1000,s100,:0,n~/nvim/shada
         * <
         * 	'50		Marks will be remembered for the last 50 files you
         * 			edited.
         * 	<1000		Contents of registers (up to 1000 lines each) will be
         * 			remembered.
         * 	s100		Items with contents occupying more then 100 KiB are
         * 			skipped.
         * 	:0		Command-line history will not be saved.
         * 	n~/nvim/shada	The name of the file to use is "~/nvim/shada".
         * 	no /		Since `'/'`  is not specified, the default will be used,
         * 			that is, save all of the search history, and also the
         * 			previous search and substitute patterns.
         * 	no %		The buffer list will not be saved nor read back.
         * 	no h		`'hlsearch'`  highlighting will be restored.
         * 
         * 	When setting `'shada'`  from an empty value you can use |:rshada| to
         * 	load the contents of the file, this is not done automatically.
         * 
         * 	This option cannot be set from a |modeline| or in the |sandbox|, for
         * 	security reasons.
         */
        shada: ListOption;

        /**
         * `'shadafile'`  `'sdf'` 	string	(default: "")
         * 			global
         * 	When non-empty, overrides the file name used for |shada| (viminfo).
         * 	When equal to "NONE" no shada file will be read or written.
         * 	This option can be set with the |-i| command line flag.  The |--clean|
         * 	command line flag sets it to "NONE".
         * 	This option cannot be set from a |modeline| or in the |sandbox|, for
         * 	security reasons.
         */
        shadafile: ListOption;

        /**
         * `'shell'`  `'sh'` 		string	(default $SHELL or "sh", Win32: "cmd.exe")
         * 			global
         * 	Name of the shell to use for ! and :! commands.  When changing the
         * 	value also check these options: `'shellpipe'` , `'shellslash'` 
         * 	`'shellredir'` , `'shellquote'` , `'shellxquote'`  and `'shellcmdflag'` .
         * 	It is allowed to give an argument to the command, e.g.  "csh -f".
         * 	See |option-backslash| about including spaces and backslashes.
         * 	Environment variables are expanded |:set_env|.
         * 
         * 	If the name of the shell contains a space, you need to enclose it in
         * 	quotes.  Example with quotes: >
         * 		:set shell=\"c:\program\ files\unix\sh.exe\"\ -f
         * <	Note the backslash before each quote (to avoid starting a comment) and
         * 	each space (to avoid ending the option value), so better use |:let-&|
         * 	like this: >
         * 		:let &shell='"C:\Program Files\unix\sh.exe" -f'
         * <	Also note that the "-f" is not inside the quotes, because it is not
         * 	part of the command name.
         * 
         * 	Rules regarding quotes:
         * 	1. Option is split on space and tab characters that are not inside
         * 	   quotes: "abc def" runs shell named "abc" with additional argument
         * 	   "def", '"abc def"' runs shell named "abc def" with no additional
         * 	   arguments (here and below: additional means “additional to
         * 	   `'shellcmdflag'` ”).
         * 	2. Quotes in option may be present in any position and any number:
         * 	   `'"abc"'` , `'"a"bc'` , `'a"b"c'` , `'ab"c"'`  and `'"a"b"c"'`  are all equivalent
         * 	   to just "abc".
         * 	3. Inside quotes backslash preceding backslash means one backslash.
         * 	   Backslash preceding quote means one quote. Backslash preceding
         * 	   anything else means backslash and next character literally:
         * 	   `'"a\\b"'`  is the same as "a\b", `'"a\\"b"'`  runs shell named literally
         * 	   `'a"b'` , `'"a\b"'`  is the same as "a\b" again.
         * 	4. Outside of quotes backslash always means itself, it cannot be used
         * 	   to escape quote: `'a\"b"'`  is the same as "a\b".
         * 	Note that such processing is done after |:set| did its own round of
         * 	unescaping, so to keep yourself sane use |:let-&| like shown above.
         * 
         * 	To use PowerShell: >
         * 		let &shell = executable(`'pwsh'` ) ? `'pwsh'`  : `'powershell'` 
         * 		let &shellcmdflag = '-NoLogo -ExecutionPolicy RemoteSigned -Command [Console]::InputEncoding=[Console]::OutputEncoding=[System.Text.UTF8Encoding]::new();$PSDefaultParameterValues[`''` Out-File:Encoding`''` ]=`''` utf8`''` ;'
         * 		let &shellredir = '2>&1 | %%{ "$_" } | Out-File %s; exit $LastExitCode'
         * 		let &shellpipe  = '2>&1 | %%{ "$_" } | Tee-Object %s; exit $LastExitCode'
         * 		set shellquote= shellxquote=
         * 
         * <	This option cannot be set from a |modeline| or in the |sandbox|, for
         * 	security reasons.
         */
        shell: Option<string>;

        /**
         * `'shellcmdflag'`  `'shcf'` 	string	(default: "-c"; Windows: "/s /c")
         * 			global
         * 	Flag passed to the shell to execute "!" and ":!" commands; e.g.,
         * 	`bash.exe -c ls` or `cmd.exe /s /c "dir"`.  For MS-Windows, the
         * 	default is set according to the value of `'shell'` , to reduce the need
         * 	to set this option by the user.
         * 	On Unix it can have more than one flag.  Each white space separated
         * 	part is passed as an argument to the shell command.
         * 	See |option-backslash| about including spaces and backslashes.
         * 	See |shell-unquoting| which talks about separating this option into
         * 	multiple arguments.
         * 	This option cannot be set from a |modeline| or in the |sandbox|, for
         * 	security reasons.
         */
        shellcmdflag: Option<string>;

        /**
         * `'shellpipe'`  `'sp'` 	string	(default ">", "| tee", "|& tee" or "2>&1| tee")
         * 			global
         * 	String to be used to put the output of the ":make" command in the
         * 	error file.  See also |:make_makeprg|.  See |option-backslash| about
         * 	including spaces and backslashes.
         * 	The name of the temporary file can be represented by "%s" if necessary
         * 	(the file name is appended automatically if no %s appears in the value
         * 	of this option).
         * 	For MS-Windows the default is "2>&1| tee".  The stdout and stderr are
         * 	saved in a file and echoed to the screen.
         * 	For Unix the default is "| tee".  The stdout of the compiler is saved
         * 	in a file and echoed to the screen.  If the `'shell'`  option is "csh" or
         * 	"tcsh" after initializations, the default becomes "|& tee".  If the
         * 	`'shell'`  option is "sh", "ksh", "mksh", "pdksh", "zsh", "zsh-beta",
         * 	"bash", "fish", "ash" or "dash" the default becomes "2>&1| tee".  This
         * 	means that stderr is also included.  Before using the `'shell'`  option a
         * 	path is removed, thus "/bin/sh" uses "sh".
         * 	The initialization of this option is done after reading the vimrc
         * 	and the other initializations, so that when the `'shell'`  option is set
         * 	there, the `'shellpipe'`  option changes automatically, unless it was
         * 	explicitly set before.
         * 	When `'shellpipe'`  is set to an empty string, no redirection of the
         * 	":make" output will be done.  This is useful if you use a `'makeprg'` 
         * 	that writes to `'makeef'`  by itself.  If you want no piping, but do
         * 	want to include the `'makeef'` , set `'shellpipe'`  to a single space.
         * 	Don't forget to precede the space with a backslash: ":set sp=\ ".
         * 	In the future pipes may be used for filtering and this option will
         * 	become obsolete (at least for Unix).
         * 	This option cannot be set from a |modeline| or in the |sandbox|, for
         * 	security reasons.
         */
        shellpipe: Option<string>;

        /**
         * `'shellquote'`  `'shq'` 	string	(default: ""; Windows, when `'shell'` 
         * 					contains "sh" somewhere: "\"")
         * 			global
         * 	Quoting character(s), put around the command passed to the shell, for
         * 	the "!" and ":!" commands.  The redirection is kept outside of the
         * 	quoting.  See `'shellxquote'`  to include the redirection.  It's
         * 	probably not useful to set both options.
         * 	This is an empty string by default.  Only known to be useful for
         * 	third-party shells on Windows systems, such as the MKS Korn Shell
         * 	or bash, where it should be "\"".  The default is adjusted according
         * 	the value of `'shell'` , to reduce the need to set this option by the
         * 	user.
         * 	This option cannot be set from a |modeline| or in the |sandbox|, for
         * 	security reasons.
         */
        shellquote: Option<string>;

        /**
         * `'shellredir'`  `'srr'` 	string	(default ">", ">&" or ">%s 2>&1")
         * 			global
         * 	String to be used to put the output of a filter command in a temporary
         * 	file.  See also |:!|.  See |option-backslash| about including spaces
         * 	and backslashes.
         * 	The name of the temporary file can be represented by "%s" if necessary
         * 	(the file name is appended automatically if no %s appears in the value
         * 	of this option).
         * 	The default is ">".  For Unix, if the `'shell'`  option is "csh" or
         * 	"tcsh" during initializations, the default becomes ">&".  If the
         * 	`'shell'`  option is "sh", "ksh", "mksh", "pdksh", "zsh", "zsh-beta",
         * 	"bash" or "fish", the default becomes ">%s 2>&1".  This means that
         * 	stderr is also included.  For Win32, the Unix checks are done and
         * 	additionally "cmd" is checked for, which makes the default ">%s 2>&1".
         * 	Also, the same names with ".exe" appended are checked for.
         * 	The initialization of this option is done after reading the vimrc
         * 	and the other initializations, so that when the `'shell'`  option is set
         * 	there, the `'shellredir'`  option changes automatically unless it was
         * 	explicitly set before.
         * 	In the future pipes may be used for filtering and this option will
         * 	become obsolete (at least for Unix).
         * 	This option cannot be set from a |modeline| or in the |sandbox|, for
         * 	security reasons.
         */
        shellredir: Option<string>;

        /**
         * `'shellslash'`  `'ssl'` 	boolean	(default off)
         * 			global
         * 			{only for MS-Windows}
         * 	When set, a forward slash is used when expanding file names.  This is
         * 	useful when a Unix-like shell is used instead of cmd.exe.  Backward
         * 	slashes can still be typed, but they are changed to forward slashes by
         * 	Vim.
         * 	Note that setting or resetting this option has no effect for some
         * 	existing file names, thus this option needs to be set before opening
         * 	any file for best results.  This might change in the future.
         * 	`'shellslash'`  only works when a backslash can be used as a path
         * 	separator.  To test if this is so use: >
         * 		if exists(`'+shellslash'` )
         * <	Also see `'completeslash'` .
         */
        shellslash: Option<boolean>;

        /**
         * `'shelltemp'`  `'stmp'` 	boolean	(default on)
         * 			global
         * 	When on, use temp files for shell commands.  When off use a pipe.
         * 	When using a pipe is not possible temp files are used anyway.
         * 	The advantage of using a pipe is that nobody can read the temp file
         * 	and the `'shell'`  command does not need to support redirection.
         * 	The advantage of using a temp file is that the file type and encoding
         * 	can be detected.
         * 	The |FilterReadPre|, |FilterReadPost| and |FilterWritePre|,
         * 	|FilterWritePost| autocommands event are not triggered when
         * 	`'shelltemp'`  is off.
         * 	|system()| does not respect this option, it always uses pipes.
         */
        shelltemp: Option<boolean>;

        /**
         * `'shellxescape'`  `'sxe'` 	string	(default: "")
         * 			global
         * 	When `'shellxquote'`  is set to "(" then the characters listed in this
         * 	option will be escaped with a `'^'`  character.  This makes it possible
         * 	to execute most external commands with cmd.exe.
         */
        shellxescape: Option<string>;

        /**
         * `'shellxquote'`  `'sxq'` 	string	(default: "", Windows: "\"")
         * 			global
         * 	Quoting character(s), put around the command passed to the shell, for
         * 	the "!" and ":!" commands.  Includes the redirection.  See
         * 	`'shellquote'`  to exclude the redirection.  It's probably not useful
         * 	to set both options.
         * 	When the value is `'('`  then `')'`  is appended. When the value is `'"('` 
         * 	then `')"'`  is appended.
         * 	When the value is `'('`  then also see `'shellxescape'` .
         * 	This option cannot be set from a |modeline| or in the |sandbox|, for
         * 	security reasons.
         */
        shellxquote: Option<string>;

        /**
         * `'shiftround'`  `'sr'` 	boolean	(default off)
         * 			global
         * 	Round indent to multiple of `'shiftwidth'` .  Applies to > and <
         * 	commands.  CTRL-T and CTRL-D in Insert mode always round the indent to
         * 	a multiple of `'shiftwidth'`  (this is Vi compatible).
         */
        shiftround: Option<boolean>;

        /**
         * `'shiftwidth'`  `'sw'` 	number	(default 8)
         * 			local to buffer
         * 	Number of spaces to use for each step of (auto)indent.  Used for
         * 	|`'cindent'` |, |>>|, |<<|, etc.
         * 	When zero the `'ts'`  value will be used.  Use the |shiftwidth()|
         * 	function to get the effective shiftwidth value.
         */
        shiftwidth: Option<number>;

        /**
         * `'shortmess'`  `'shm'` 	string	(default "filnxtToOF")
         * 			global
         * 	This option helps to avoid all the |hit-enter| prompts caused by file
         * 	messages, for example  with CTRL-G, and to avoid some other messages.
         * 	It is a list of flags:
         * 	 flag	meaning when present	~
         * 	  f	use "(3 of 5)" instead of "(file 3 of 5)"
         * 	  i	use "[noeol]" instead of "[Incomplete last line]"
         * 	  l	use "999L, 888B" instead of "999 lines, 888 bytes"
         * 	  m	use "[+]" instead of "[Modified]"
         * 	  n	use "[New]" instead of "[New File]"
         * 	  r	use "[RO]" instead of "[readonly]"
         * 	  w	use "[w]" instead of "written" for file write message
         * 		and "[a]" instead of "appended" for ':w >> file' command
         * 	  x	use "[dos]" instead of "[dos format]", "[unix]"
         * 		instead of "[unix format]" and "[mac]" instead of "[mac
         * 		format]"
         * 	  a	all of the above abbreviations
         * 
         * 	  o	overwrite message for writing a file with subsequent
         * 		message for reading a file (useful for ":wn" or when
         * 		`'autowrite'`  on)
         * 	  O	message for reading a file overwrites any previous
         * 		message;  also for quickfix message (e.g., ":cn")
         * 	  s	don't give "search hit BOTTOM, continuing at TOP" or
         * 		"search hit TOP, continuing at BOTTOM" messages; when using
         * 		the search count do not show "W" after the count message (see
         * 		S below)
         * 	  t	truncate file message at the start if it is too long
         * 		to fit on the command-line, "<" will appear in the left most
         * 		column; ignored in Ex mode
         * 	  T	truncate other messages in the middle if they are too
         * 		long to fit on the command line; "..." will appear in the
         * 		middle; ignored in Ex mode
         * 	  W	don't give "written" or "[w]" when writing a file
         * 	  A	don't give the "ATTENTION" message when an existing
         * 		swap file is found
         * 	  I	don't give the intro message when starting Vim,
         * 		see |:intro|
         * 	  c	don't give |ins-completion-menu| messages; for
         * 		example, "-- XXX completion (YYY)", "match 1 of 2", "The only
         * 		match", "Pattern not found", "Back at original", etc.
         * 	  C	don't give messages while scanning for ins-completion
         * 		items, for instance "scanning tags"
         * 	  q	use "recording" instead of "recording @a"
         * 	  F	don't give the file info when editing a file, like
         * 		`:silent` was used for the command
         * 	  S	do not show search count message when searching, e.g.
         * 		"[1/5]"
         * 
         * 	This gives you the opportunity to avoid that a change between buffers
         * 	requires you to hit <Enter>, but still gives as useful a message as
         * 	possible for the space available.  To get the whole message that you
         * 	would have got with `'shm'`  empty, use ":file!"
         * 	Useful values:
         * 	    shm=	No abbreviation of message.
         * 	    shm=a	Abbreviation, but no loss of information.
         * 	    shm=at	Abbreviation, and truncate message when necessary.
         */
        shortmess: ListOption;

        /**
         * `'showbreak'`  `'sbr'` 	string	(default "")
         * 			global or local to window |global-local|
         * 	String to put at the start of lines that have been wrapped.  Useful
         * 	values are "> " or "+++ ": >
         * 		:set showbreak=>\
         * <	Note the backslash to escape the trailing space.  It's easier like
         * 	this: >
         * 		:let &showbreak = '+++ '
         * <	Only printable single-cell characters are allowed, excluding <Tab> and
         * 	comma (in a future version the comma might be used to separate the
         * 	part that is shown at the end and at the start of a line).
         * 	The |hl-NonText| highlight group determines the highlighting.
         * 	Note that tabs after the showbreak will be displayed differently.
         * 	If you want the `'showbreak'`  to appear in between line numbers, add the
         * 	"n" flag to `'cpoptions'` .
         * 	A window-local value overrules a global value.  If the global value is
         * 	set and you want no value in the current window use NONE: >
         * 		:setlocal showbreak=NONE
         * <
         */
        showbreak: Option<string>;

        /**
         * `'showcmd'`  `'sc'` 		boolean	(default: on)
         * 			global
         * 	Show (partial) command in the last line of the screen.  Set this
         * 	option off if your terminal is slow.
         * 	In Visual mode the size of the selected area is shown:
         * 	- When selecting characters within a line, the number of characters.
         * 	  If the number of bytes is different it is also displayed: "2-6"
         * 	  means two characters and six bytes.
         * 	- When selecting more than one line, the number of lines.
         * 	- When selecting a block, the size in screen characters:
         * 	  {lines}x{columns}.
         * 	This information can be displayed in an alternative location using the
         * 	`'showcmdloc'`  option, useful when `'cmdheight'`  is 0.
         */
        showcmd: Option<boolean>;

        /**
         * `'showcmdloc'`  `'sloc'` 	string	(default "last")
         * 			global
         * 	This option can be used to display the (partially) entered command in
         * 	another location.  Possible values are:
         * 	  last		Last line of the screen (default).
         * 	  statusline	Status line of the current window.
         * 	  tabline	First line of the screen if `'showtabline'`  is enabled.
         * 	Setting this option to "statusline" or "tabline" means that these will
         * 	be redrawn whenever the command changes, which can be on every key
         * 	pressed.
         * 	The %S `'statusline'`  item can be used in `'statusline'`  or `'tabline'`  to
         * 	place the text.  Without a custom `'statusline'`  or `'tabline'`  it will be
         * 	displayed in a convenient location.
         */
        showcmdloc: Option<string>;

        /**
         * `'showfulltag'`  `'sft'` 	boolean (default off)
         * 			global
         * 	When completing a word in insert mode (see |ins-completion|) from the
         * 	tags file, show both the tag name and a tidied-up form of the search
         * 	pattern (if there is one) as possible matches.  Thus, if you have
         * 	matched a C function, you can see a template for what arguments are
         * 	required (coding style permitting).
         * 	Note that this doesn't work well together with having "longest" in
         * 	`'completeopt'` , because the completion from the search pattern may not
         * 	match the typed text.
         */
        showfulltag: Option<boolean>;

        /**
         * `'showmatch'`  `'sm'` 	boolean	(default off)
         * 			global
         * 	When a bracket is inserted, briefly jump to the matching one.  The
         * 	jump is only done if the match can be seen on the screen.  The time to
         * 	show the match can be set with `'matchtime'` .
         * 	A Beep is given if there is no match (no matter if the match can be
         * 	seen or not).
         * 	When the `'m'`  flag is not included in `'cpoptions'` , typing a character
         * 	will immediately move the cursor back to where it belongs.
         * 	See the "sm" field in `'guicursor'`  for setting the cursor shape and
         * 	blinking when showing the match.
         * 	The `'matchpairs'`  option can be used to specify the characters to show
         * 	matches for.  `'rightleft'`  and `'revins'`  are used to look for opposite
         * 	matches.
         * 	Also see the matchparen plugin for highlighting the match when moving
         * 	around |pi_paren.txt|.
         * 	Note: Use of the short form is rated PG.
         */
        showmatch: Option<boolean>;

        /**
         * `'showmode'`  `'smd'` 	boolean	(default: on)
         * 			global
         * 	If in Insert, Replace or Visual mode put a message on the last line.
         * 	The |hl-ModeMsg| highlight group determines the highlighting.
         * 	The option has no effect when `'cmdheight'`  is zero.
         */
        showmode: Option<boolean>;

        /**
         * `'showtabline'`  `'stal'` 	number	(default 1)
         * 			global
         * 	The value of this option specifies when the line with tab page labels
         * 	will be displayed:
         * 		0: never
         * 		1: only if there are at least two tab pages
         * 		2: always
         * 	This is both for the GUI and non-GUI implementation of the tab pages
         * 	line.
         * 	See |tab-page| for more information about tab pages.
         */
        showtabline: Option<number>;

        /**
         * `'sidescroll'`  `'ss'` 	number	(default 1)
         * 			global
         * 	The minimal number of columns to scroll horizontally.  Used only when
         * 	the `'wrap'`  option is off and the cursor is moved off of the screen.
         * 	When it is zero the cursor will be put in the middle of the screen.
         * 	When using a slow terminal set it to a large number or 0.  Not used
         * 	for "zh" and "zl" commands.
         */
        sidescroll: Option<number>;

        /**
         * `'sidescrolloff'`  `'siso'` 	number (default 0)
         * 			global or local to window |global-local|
         * 	The minimal number of screen columns to keep to the left and to the
         * 	right of the cursor if `'nowrap'`  is set.  Setting this option to a
         * 	value greater than 0 while having |`'sidescroll'` | also at a non-zero
         * 	value makes some context visible in the line you are scrolling in
         * 	horizontally (except at beginning of the line).  Setting this option
         * 	to a large value (like 999) has the effect of keeping the cursor
         * 	horizontally centered in the window, as long as one does not come too
         * 	close to the beginning of the line.
         * 	After using the local value, go back the global value with one of
         * 	these two: >
         * 		setlocal sidescrolloff<
         * 		setlocal sidescrolloff=-1
         * <
         * 	Example: Try this together with `'sidescroll'`  and `'listchars'`  as
         * 		 in the following example to never allow the cursor to move
         * 		 onto the "extends" character: >
         * 
         * 		 :set nowrap sidescroll=1 listchars=extends:>,precedes:<
         * 		 :set sidescrolloff=1
         * <
         */
        sidescrolloff: Option<number>;

        /**
         * `'signcolumn'`  `'scl'` 	string	(default "auto")
         * 			local to window
         * 	When and how to draw the signcolumn. Valid values are:
         * 	   "auto"	only when there is a sign to display
         * 	   "auto:[1-9]" resize to accommodate multiple signs up to the
         * 	                given number (maximum 9), e.g. "auto:4"
         * 	   "auto:[1-8]-[2-9]"
         * 	                resize to accommodate multiple signs up to the
         * 			given maximum number (maximum 9) while keeping
         * 			at least the given minimum (maximum 8) fixed
         * 			space. The minimum number should always be less
         * 			than the maximum number, e.g. "auto:2-5"
         * 	   "no"		never
         * 	   "yes"	always
         * 	   "yes:[1-9]"  always, with fixed space for signs up to the given
         * 	                number (maximum 9), e.g. "yes:3"
         * 	   "number"	display signs in the `'number'`  column. If the number
         * 			column is not present, then behaves like "auto".
         * 
         * 	Note regarding "orphaned signs": with signcolumn numbers higher than
         * 	1, deleting lines will also remove the associated signs automatically,
         * 	in contrast to the default Vim behavior of keeping and grouping them.
         * 	This is done in order for the signcolumn appearance not appear weird
         * 	during line deletion.
         */
        signcolumn: Option<string>;

        /**
         * `'smartcase'`  `'scs'` 	boolean	(default off)
         * 			global
         * 	Override the `'ignorecase'`  option if the search pattern contains upper
         * 	case characters.  Only used when the search pattern is typed and
         * 	`'ignorecase'`  option is on.  Used for the commands "/", "?", "n", "N",
         * 	":g" and ":s".  Not used for "*", "#", "gd", tag search, etc.  After
         * 	"*" and "#" you can make `'smartcase'`  used by doing a "/" command,
         * 	recalling the search pattern from history and hitting <Enter>.
         */
        smartcase: Option<boolean>;

        /**
         * `'smartindent'`  `'si'` 	boolean	(default off)
         * 			local to buffer
         * 	Do smart autoindenting when starting a new line.  Works for C-like
         * 	programs, but can also be used for other languages.  `'cindent'`  does
         * 	something like this, works better in most cases, but is more strict,
         * 	see |C-indenting|.  When `'cindent'`  is on or `'indentexpr'`  is set,
         * 	setting `'si'`  has no effect.  `'indentexpr'`  is a more advanced
         * 	alternative.
         * 	Normally `'autoindent'`  should also be on when using `'smartindent'` .
         * 	An indent is automatically inserted:
         * 	- After a line ending in "{".
         * 	- After a line starting with a keyword from `'cinwords'` .
         * 	- Before a line starting with "}" (only with the "O" command).
         * 	When typing `'}'`  as the first character in a new line, that line is
         * 	given the same indent as the matching "{".
         * 	When typing `'#'`  as the first character in a new line, the indent for
         * 	that line is removed, the `'#'`  is put in the first column.  The indent
         * 	is restored for the next line.  If you don't want this, use this
         * 	mapping: ":inoremap # X^H#", where ^H is entered with CTRL-V CTRL-H.
         * 	When using the ">>" command, lines starting with `'#'`  are not shifted
         * 	right.
         */
        smartindent: Option<boolean>;

        /**
         * `'smarttab'`  `'sta'` 	boolean	(default on)
         * 			global
         * 	When on, a <Tab> in front of a line inserts blanks according to
         * 	`'shiftwidth'` .  `'tabstop'`  or `'softtabstop'`  is used in other places.  A
         * 	<BS> will delete a `'shiftwidth'`  worth of space at the start of the
         * 	line.
         * 	When off, a <Tab> always inserts blanks according to `'tabstop'`  or
         * 	`'softtabstop'` .  `'shiftwidth'`  is only used for shifting text left or
         * 	right |shift-left-right|.
         * 	What gets inserted (a <Tab> or spaces) depends on the `'expandtab'` 
         * 	option.  Also see |ins-expandtab|.  When `'expandtab'`  is not set, the
         * 	number of spaces is minimized by using <Tab>s.
         */
        smarttab: Option<boolean>;

        /**
         * `'softtabstop'`  `'sts'` 	number	(default 0)
         * 			local to buffer
         * 	Number of spaces that a <Tab> counts for while performing editing
         * 	operations, like inserting a <Tab> or using <BS>.  It "feels" like
         * 	<Tab>s are being inserted, while in fact a mix of spaces and <Tab>s is
         * 	used.  This is useful to keep the `'ts'`  setting at its standard value
         * 	of 8, while being able to edit like it is set to `'sts'` .  However,
         * 	commands like "x" still work on the actual characters.
         * 	When `'sts'`  is zero, this feature is off.
         * 	When `'sts'`  is negative, the value of `'shiftwidth'`  is used.
         * 	See also |ins-expandtab|.  When `'expandtab'`  is not set, the number of
         * 	spaces is minimized by using <Tab>s.
         * 	The `'L'`  flag in `'cpoptions'`  changes how tabs are used when `'list'`  is
         * 	set.
         * 
         * 	The value of `'softtabstop'`  will be ignored if |`'varsofttabstop'` | is set
         * 	to anything other than an empty string.
         */
        softtabstop: Option<number>;

        /**
         * `'spell'` 			boolean	(default off)
         * 			local to window
         * 	When on spell checking will be done.  See |spell|.
         * 	The languages are specified with `'spelllang'` .
         */
        spell: Option<boolean>;

        /**
         * `'spellcapcheck'`  `'spc'` 	string	(default "[.?!]\_[\])'" \t]\+")
         * 			local to buffer
         * 	Pattern to locate the end of a sentence.  The following word will be
         * 	checked to start with a capital letter.  If not then it is highlighted
         * 	with SpellCap |hl-SpellCap| (unless the word is also badly spelled).
         * 	When this check is not wanted make this option empty.
         * 	Only used when `'spell'`  is set.
         * 	Be careful with special characters, see |option-backslash| about
         * 	including spaces and backslashes.
         * 	To set this option automatically depending on the language, see
         * 	|set-spc-auto|.
         */
        spellcapcheck: Option<string>;

        /**
         * `'spellfile'`  `'spf'` 	string	(default empty)
         * 			local to buffer
         * 	Name of the word list file where words are added for the |zg| and |zw|
         * 	commands.  It must end in ".{encoding}.add".  You need to include the
         * 	path, otherwise the file is placed in the current directory.
         * 	The path may include characters from `'isfname'` , space, comma and `'@'` .
         * 
         * 	It may also be a comma-separated list of names.  A count before the
         * 	|zg| and |zw| commands can be used to access each.  This allows using
         * 	a personal word list file and a project word list file.
         * 	When a word is added while this option is empty Vim will set it for
         * 	you: Using the first directory in `'runtimepath'`  that is writable.  If
         * 	there is no "spell" directory yet it will be created.  For the file
         * 	name the first language name that appears in `'spelllang'`  is used,
         * 	ignoring the region.
         * 	The resulting ".spl" file will be used for spell checking, it does not
         * 	have to appear in `'spelllang'` .
         * 	Normally one file is used for all regions, but you can add the region
         * 	name if you want to.  However, it will then only be used when
         * 	`'spellfile'`  is set to it, for entries in `'spelllang'`  only files
         * 	without region name will be found.
         * 	This option cannot be set from a |modeline| or in the |sandbox|, for
         * 	security reasons.
         */
        spellfile: ListOption;

        /**
         * `'spelllang'`  `'spl'` 	string	(default "en")
         * 			local to buffer
         * 	A comma-separated list of word list names.  When the `'spell'`  option is
         * 	on spellchecking will be done for these languages.  Example: >
         * 		set spelllang=en_us,nl,medical
         * <	This means US English, Dutch and medical words are recognized.  Words
         * 	that are not recognized will be highlighted.
         * 	The word list name must consist of alphanumeric characters, a dash or
         * 	an underscore.  It should not include a comma or dot.  Using a dash is
         * 	recommended to separate the two letter language name from a
         * 	specification.  Thus "en-rare" is used for rare English words.
         * 	A region name must come last and have the form "_xx", where "xx" is
         * 	the two-letter, lower case region name.  You can use more than one
         * 	region by listing them: "en_us,en_ca" supports both US and Canadian
         * 	English, but not words specific for Australia, New Zealand or Great
         * 	Britain. (Note: currently en_au and en_nz dictionaries are older than
         * 	en_ca, en_gb and en_us).
         * 	If the name "cjk" is included East Asian characters are excluded from
         * 	spell checking.  This is useful when editing text that also has Asian
         * 	words.
         * 	Note that the "medical" dictionary does not exist, it is just an
         * 	example of a longer name.
         * 
         * 	As a special case the name of a .spl file can be given as-is.  The
         * 	first "_xx" in the name is removed and used as the region name
         * 	(_xx is an underscore, two letters and followed by a non-letter).
         * 	This is mainly for testing purposes.  You must make sure the correct
         * 	encoding is used, Vim doesn't check it.
         * 	How the related spell files are found is explained here: |spell-load|.
         * 
         * 	If the |spellfile.vim| plugin is active and you use a language name
         * 	for which Vim cannot find the .spl file in `'runtimepath'`  the plugin
         * 	will ask you if you want to download the file.
         * 
         * 	After this option has been set successfully, Vim will source the files
         * 	"spell/LANG.vim" in `'runtimepath'` .  "LANG" is the value of `'spelllang'` 
         * 	up to the first character that is not an ASCII letter or number and
         * 	not a dash.  Also see |set-spc-auto|.
         */
        spelllang: ListOption;

        /**
         * `'spelloptions'`  `'spo'` 	string	(default "")
         * 			local to buffer
         * 	A comma-separated list of options for spell checking:
         * 	camel		When a word is CamelCased, assume "Cased" is a
         * 			separate word: every upper-case character in a word
         * 			that comes after a lower case character indicates the
         * 			start of a new word.
         * 	noplainbuffer	Only spellcheck a buffer when `'syntax'`  is enabled,
         * 			or when extmarks are set within the buffer. Only
         * 			designated regions of the buffer are spellchecked in
         * 			this case.
         */
        spelloptions: ListOption;

        /**
         * `'spellsuggest'`  `'sps'` 	string	(default "best")
         * 			global
         * 	Methods used for spelling suggestions.  Both for the |z=| command and
         * 	the |spellsuggest()| function.  This is a comma-separated list of
         * 	items:
         * 
         * 	best		Internal method that works best for English.  Finds
         * 			changes like "fast" and uses a bit of sound-a-like
         * 			scoring to improve the ordering.
         * 
         * 	double		Internal method that uses two methods and mixes the
         * 			results.  The first method is "fast", the other method
         * 			computes how much the suggestion sounds like the bad
         * 			word.  That only works when the language specifies
         * 			sound folding.  Can be slow and doesn't always give
         * 			better results.
         * 
         * 	fast		Internal method that only checks for simple changes:
         * 			character inserts/deletes/swaps.  Works well for
         * 			simple typing mistakes.
         * 
         * 	{number}	The maximum number of suggestions listed for |z=|.
         * 			Not used for |spellsuggest()|.  The number of
         * 			suggestions is never more than the value of `'lines'` 
         * 			minus two.
         * 
         * 	timeout:{millisec}   Limit the time searching for suggestions to
         * 			{millisec} milli seconds.  Applies to the following
         * 			methods.  When omitted the limit is 5000. When
         * 			negative there is no limit.
         * 
         * 	file:{filename} Read file {filename}, which must have two columns,
         * 			separated by a slash.  The first column contains the
         * 			bad word, the second column the suggested good word.
         * 			Example:
         * 				theribal/terrible ~
         * 			Use this for common mistakes that do not appear at the
         * 			top of the suggestion list with the internal methods.
         * 			Lines without a slash are ignored, use this for
         * 			comments.
         * 			The word in the second column must be correct,
         * 			otherwise it will not be used.  Add the word to an
         * 			".add" file if it is currently flagged as a spelling
         * 			mistake.
         * 			The file is used for all languages.
         * 
         * 	expr:{expr}	Evaluate expression {expr}.  Use a function to avoid
         * 			trouble with spaces.  |v:val| holds the badly spelled
         * 			word.  The expression must evaluate to a List of
         * 			Lists, each with a suggestion and a score.
         * 			Example:
         * 				[[`'the'` , 33], [`'that'` , 44]] ~
         * 			Set `'verbose'`  and use |z=| to see the scores that the
         * 			internal methods use.  A lower score is better.
         * 			This may invoke |spellsuggest()| if you temporarily
         * 			set `'spellsuggest'`  to exclude the "expr:" part.
         * 			Errors are silently ignored, unless you set the
         * 			`'verbose'`  option to a non-zero value.
         * 
         * 	Only one of "best", "double" or "fast" may be used.  The others may
         * 	appear several times in any order.  Example: >
         * 		:set sps=file:~/.config/nvim/sugg,best,expr:MySuggest()
         * <
         * 	This option cannot be set from a |modeline| or in the |sandbox|, for
         * 	security reasons.
         */
        spellsuggest: ListOption;

        /**
         * `'splitbelow'`  `'sb'` 	boolean	(default off)
         * 			global
         * 	When on, splitting a window will put the new window below the current
         * 	one. |:split|
         */
        splitbelow: Option<boolean>;

        /**
         * `'splitkeep'`  `'spk'` 	string	(default "cursor")
         * 			global
         * 	The value of this option determines the scroll behavior when opening,
         * 	closing or resizing horizontal splits.
         * 
         * 	Possible values are:
         * 	  cursor	Keep the same relative cursor position.
         * 	  screen	Keep the text on the same screen line.
         * 	  topline	Keep the topline the same.
         * 
         * 	For the "screen" and "topline" values, the cursor position will be
         * 	changed when necessary. In this case, the jumplist will be populated
         * 	with the previous cursor position. For "screen", the text cannot always
         * 	be kept on the same screen line when `'wrap'`  is enabled.
         */
        splitkeep: Option<string>;

        /**
         * `'splitright'`  `'spr'` 	boolean	(default off)
         * 			global
         * 	When on, splitting a window will put the new window right of the
         * 	current one. |:vsplit|
         */
        splitright: Option<boolean>;

        /**
         * `'startofline'`  `'sol'` 	boolean	(default off)
         * 			global
         * 	When "on" the commands listed below move the cursor to the first
         * 	non-blank of the line.  When off the cursor is kept in the same column
         * 	(if possible).  This applies to the commands: CTRL-D, CTRL-U, CTRL-B,
         * 	CTRL-F, "G", "H", "M", "L", gg, and to the commands "d", "<<" and ">>"
         * 	with a linewise operator, with "%" with a count and to buffer changing
         * 	commands (CTRL-^, :bnext, :bNext, etc.).  Also for an Ex command that
         * 	only has a line number, e.g., ":25" or ":+".
         * 	In case of buffer changing commands the cursor is placed at the column
         * 	where it was the last time the buffer was edited.
         */
        startofline: Option<boolean>;

        /**
         * `'statuscolumn'`  `'stc'` 	string	(default: empty)
         * 			local to window
         * 	EXPERIMENTAL
         * 	When non-empty, this option determines the content of the area to the
         * 	side of a window, normally containing the fold, sign and number columns.
         * 	The format of this option is like that of `'statusline'` .
         * 
         * 	Some of the items from the `'statusline'`  format are different for
         * 	`'statuscolumn'` :
         * 
         * 	%l	line number of currently drawn line
         * 	%r	relative line number of currently drawn line
         * 	%s	sign column for currently drawn line
         * 	%C	fold column for currently drawn line
         * 
         * 	NOTE: To draw the sign and fold columns, their items must be included in
         * 	`'statuscolumn'` . Even when they are not included, the status column width
         * 	will adapt to the `'signcolumn'`  and `'foldcolumn'`  width.
         * 
         * 	The |v:lnum|    variable holds the line number to be drawn.
         * 	The |v:relnum|  variable holds the relative line number to be drawn.
         * 	The |v:virtnum| variable is negative when drawing virtual lines, zero
         * 		      when drawing the actual buffer line, and positive when
         * 		      drawing the wrapped part of a buffer line.
         * 
         * 	NOTE: The %@ click execute function item is supported as well but the
         * 	specified function will be the same for each row in the same column.
         * 	It cannot be switched out through a dynamic `'statuscolumn'`  format, the
         * 	handler should be written with this in mind.
         * 
         * 	Examples: >vim
         * 		" Relative number with bar separator and click handlers:
         * 		:set statuscolumn=%@SignCb@%s%=%T%@NumCb@%r│%T
         * 
         * 		" Right aligned relative cursor line number:
         * 		:let &stc='%=%{v:relnum?v:relnum:v:lnum} '
         * 
         * 		" Line numbers in hexadecimal for non wrapped part of lines:
         * 		:let &stc='%=%{v:virtnum>0?"":printf("%x",v:lnum)} '
         * 
         * 		" Human readable line numbers with thousands separator:
         * 		:let &stc=`'%{substitute(v:lnum,"\\d\\zs\\ze\\'` 
         * 			   . `'%(\\d\\d\\d\\)\\+$",",","g")}'` 
         * 
         * 		" Both relative and absolute line numbers with different
         * 		" highlighting for odd and even relative numbers:
         * 		:let &stc=`'%#NonText#%{&nu?v:lnum:""}'`  .
         * 		 '%=%{&rnu&&(v:lnum%2)?"\ ".v:relnum:""}' .
         * 		 '%#LineNr#%{&rnu&&!(v:lnum%2)?"\ ".v:relnum:""}'
         * 
         * <	WARNING: this expression is evaluated for each screen line so defining
         * 	an expensive expression can negatively affect render performance.
         */
        statuscolumn: Option<string>;

        /**
         * `'statusline'`  `'stl'` 	string	(default empty)
         * 			global or local to window |global-local|
         * 	When non-empty, this option determines the content of the status line.
         * 	Also see |status-line|.
         * 
         * 	The option consists of printf style `'%'`  items interspersed with
         * 	normal text.  Each status line item is of the form:
         * 	  %-0{minwid}.{maxwid}{item}
         * 	All fields except the {item} are optional.  A single percent sign can
         * 	be given as "%%".
         * 
         * 	When the option starts with "%!" then it is used as an expression,
         * 	evaluated and the result is used as the option value.  Example: >
         * 		:set statusline=%!MyStatusLine()
         * <	The  variable will be set to the |window-ID| of the
         * 	window that the status line belongs to.
         * 	The result can contain %{} items that will be evaluated too.
         * 	Note that the "%!" expression is evaluated in the context of the
         * 	current window and buffer, while %{} items are evaluated in the
         * 	context of the window that the statusline belongs to.
         * 
         * 	When there is error while evaluating the option then it will be made
         * 	empty to avoid further errors.  Otherwise screen updating would loop.
         * 	When the result contains unprintable characters the result is
         * 	unpredictable.
         * 
         * 	Note that the only effect of `'ruler'`  when this option is set (and
         * 	`'laststatus'`  is 2 or 3) is controlling the output of |CTRL-G|.
         * 
         * 	field	    meaning ~
         * 	-	    Left justify the item.  The default is right justified
         * 		    when minwid is larger than the length of the item.
         * 	0	    Leading zeroes in numeric items.  Overridden by "-".
         * 	minwid	    Minimum width of the item, padding as set by "-" & "0".
         * 		    Value must be 50 or less.
         * 	maxwid	    Maximum width of the item.  Truncation occurs with a "<"
         * 		    on the left for text items.  Numeric items will be
         * 		    shifted down to maxwid-2 digits followed by ">"number
         * 		    where number is the amount of missing digits, much like
         * 		    an exponential notation.
         * 	item	    A one letter code as described below.
         * 
         * 	Following is a description of the possible statusline items.  The
         * 	second character in "item" is the type:
         * 		N for number
         * 		S for string
         * 		F for flags as described below
         * 		- not applicable
         * 
         * 	item  meaning ~
         * 	f S   Path to the file in the buffer, as typed or relative to current
         * 	      directory.
         * 	F S   Full path to the file in the buffer.
         * 	t S   File name (tail) of file in the buffer.
         * 	m F   Modified flag, text is "[+]"; "[-]" if `'modifiable'`  is off.
         * 	M F   Modified flag, text is ",+" or ",-".
         * 	r F   Readonly flag, text is "[RO]".
         * 	R F   Readonly flag, text is ",RO".
         * 	h F   Help buffer flag, text is "[help]".
         * 	H F   Help buffer flag, text is ",HLP".
         * 	w F   Preview window flag, text is "[Preview]".
         * 	W F   Preview window flag, text is ",PRV".
         * 	y F   Type of file in the buffer, e.g., "[vim]".  See `'filetype'` .
         * 	Y F   Type of file in the buffer, e.g., ",VIM".  See `'filetype'` .
         * 	q S   "[Quickfix List]", "[Location List]" or empty.
         * 	k S   Value of "b:keymap_name" or `'keymap'`  when |:lmap| mappings are
         * 	      being used: "<keymap>"
         * 	n N   Buffer number.
         * 	b N   Value of character under cursor.
         * 	B N   As above, in hexadecimal.
         * 	o N   Byte number in file of byte under cursor, first byte is 1.
         * 	      Mnemonic: Offset from start of file (with one added)
         * 	O N   As above, in hexadecimal.
         * 	l N   Line number.
         * 	L N   Number of lines in buffer.
         * 	c N   Column number (byte index).
         * 	v N   Virtual column number (screen column).
         * 	V N   Virtual column number as -{num}.  Not displayed if equal to `'c'` .
         * 	p N   Percentage through file in lines as in |CTRL-G|.
         * 	P S   Percentage through file of displayed window.  This is like the
         * 	      percentage described for `'ruler'` .  Always 3 in length, unless
         * 	      translated.
         * 	S S   `'showcmd'`  content, see `'showcmdloc'` .
         * 	a S   Argument list status as in default title.  ({current} of {max})
         * 	      Empty if the argument file count is zero or one.
         * 	{ NF  Evaluate expression between "%{" and "}" and substitute result.
         * 	      Note that there is no "%" before the closing "}".  The
         * 	      expression cannot contain a "}" character, call a function to
         * 	      work around that.  See |stl-%{| below.
         * 	`{%` -  This is almost same as "{" except the result of the expression is
         * 	      re-evaluated as a statusline format string.  Thus if the
         * 	      return value of expr contains "%" items they will get expanded.
         * 	      The expression can contain the "}" character, the end of
         * 	      expression is denoted by "%}".
         * 	      For example: >
         * 		func! Stl_filename() abort
         * 		    return "%t"
         * 		endfunc
         * <	        `stl=%{Stl_filename()}`   results in `"%t"`
         * 	        `stl=%{%Stl_filename()%}` results in `"Name of current file"`
         * 	%} -  End of "{%" expression
         * 	( -   Start of item group.  Can be used for setting the width and
         * 	      alignment of a section.  Must be followed by %) somewhere.
         * 	) -   End of item group.  No width fields allowed.
         * 	T N   For `'tabline'` : start of tab page N label.  Use %T or %X to end
         * 	      the label.  Clicking this label with left mouse button switches
         * 	      to the specified tab page.
         * 	X N   For `'tabline'` : start of close tab N label.  Use %X or %T to end
         * 	      the label, e.g.: %3Xclose%X.  Use %999X for a "close current
         * 	      tab" label.    Clicking this label with left mouse button closes
         * 	      specified tab page.
         * 	@ N   Start of execute function label. Use %X or %T to
         * 	      end the label, e.g.: %10@SwitchBuffer@foo.c%X.  Clicking this
         * 	      label runs specified function: in the example when clicking once
         * 	      using left mouse button on "foo.c" "SwitchBuffer(10, 1, `'l'` ,
         * 	      '    ')" expression will be run.  Function receives the
         * 	      following arguments in order:
         * 	      1. minwid field value or zero if no N was specified
         * 	      2. number of mouse clicks to detect multiple clicks
         * 	      3. mouse button used: "l", "r" or "m" for left, right or middle
         * 	         button respectively; one should not rely on third argument
         * 	         being only "l", "r" or "m": any other non-empty string value
         * 	         that contains only ASCII lower case letters may be expected
         * 	         for other mouse buttons
         * 	      4. modifiers pressed: string which contains "s" if shift
         * 	         modifier was pressed, "c" for control, "a" for alt and "m"
         * 	         for meta; currently if modifier is not pressed string
         * 	         contains space instead, but one should not rely on presence
         * 	         of spaces or specific order of modifiers: use |stridx()| to
         * 	         test whether some modifier is present; string is guaranteed
         * 	         to contain only ASCII letters and spaces, one letter per
         * 	         modifier; "?" modifier may also be present, but its presence
         * 	         is a bug that denotes that new mouse button recognition was
         * 	         added without modifying code that reacts on mouse clicks on
         * 	         this label.
         * 	      Use |getmousepos()|.winid in the specified function to get the
         * 	      corresponding window id of the clicked item.
         * 	< -   Where to truncate line if too long.  Default is at the start.
         * 	      No width fields allowed.
         * 	= -   Separation point between alignment sections.  Each section will
         * 	      be separated by an equal number of spaces.  With one %= what
         * 	      comes after it will be right-aligned.  With two %= there is a
         * 	      middle part, with white space left and right of it.
         * 	      No width fields allowed.
         * 	# -   Set highlight group.  The name must follow and then a # again.
         * 	      Thus use %#HLname# for highlight group HLname.  The same
         * 	      highlighting is used, also for the statusline of non-current
         * 	      windows.
         * 	* -   Set highlight group to User{N}, where {N} is taken from the
         * 	      minwid field, e.g. %1*.  Restore normal highlight with %* or %0*.
         * 	      The difference between User{N} and StatusLine will be applied to
         * 	      StatusLineNC for the statusline of non-current windows.
         * 	      The number N must be between 1 and 9.  See |hl-User1..9|
         * 
         * 	When displaying a flag, Vim removes the leading comma, if any, when
         * 	that flag comes right after plaintext.  This will make a nice display
         * 	when flags are used like in the examples below.
         * 
         * 	When all items in a group becomes an empty string (i.e. flags that are
         * 	not set) and a minwid is not set for the group, the whole group will
         * 	become empty.  This will make a group like the following disappear
         * 	completely from the statusline when none of the flags are set. >
         * 		:set statusline=...%(\ [%M%R%H]%)...
         * <	Beware that an expression is evaluated each and every time the status
         * 	line is displayed.
         * 
         * 	While evaluating %{} the current buffer and current window will be set
         * 	temporarily to that of the window (and buffer) whose statusline is
         * 	currently being drawn.  The expression will evaluate in this context.
         * 	The variable "g:actual_curbuf" is set to the `bufnr()` number of the
         * 	real current buffer and "g:actual_curwin" to the |window-ID| of the
         * 	real current window.  These values are strings.
         * 
         * 	The `'statusline'`  option will be evaluated in the |sandbox| if set from
         * 	a modeline, see |sandbox-option|.
         * 	This option cannot be set in a modeline when `'modelineexpr'`  is off.
         * 
         * 	It is not allowed to change text or jump to another window while
         * 	evaluating `'statusline'`  |textlock|.
         * 
         * 	If the statusline is not updated when you want it (e.g., after setting
         * 	a variable that's used in an expression), you can force an update by
         * 	using `:redrawstatus`.
         * 
         * 	A result of all digits is regarded a number for display purposes.
         * 	Otherwise the result is taken as flag text and applied to the rules
         * 	described above.
         * 
         * 	Watch out for errors in expressions.  They may render Vim unusable!
         * 	If you are stuck, hold down `':'`  or `'Q'`  to get a prompt, then quit and
         * 	edit your vimrc or whatever with "vim --clean" to get it right.
         * 
         * 	Examples:
         * 	Emulate standard status line with `'ruler'`  set >
         * 	  :set statusline=%<%f\ %h%m%r%=%-14.(%l,%c%V%)\ %P
         * <	Similar, but add ASCII value of char under the cursor (like "ga") >
         * 	  :set statusline=%<%f%h%m%r%=%b\ 0x%B\ \ %l,%c%V\ %P
         * <	Display byte count and byte value, modified flag in red. >
         * 	  :set statusline=%<%f%=\ [%1%n%R%H]\ %-19(%3l,%02c%03V%)%O`'%02b'` 
         * 	  :hi User1 term=inverse,bold cterm=inverse,bold ctermfg=red
         * <	Display a ,GZ flag if a compressed file is loaded >
         * 	  :set statusline=...%r%{VarExists(`'b:gzflag'` ,'\ [GZ]')}%h...
         * <	In the |:autocmd|'s: >
         * 	  :let b:gzflag = 1
         * <	And: >
         * 	  :unlet b:gzflag
         * <	And define this function: >
         * 	  :function VarExists(var, val)
         * 	  :    if exists(a:var) | return a:val | else | return `''`  | endif
         * 	  :endfunction
         * <
         */
        statusline: Option<string>;

        /**
         * `'suffixes'`  `'su'` 		string	(default ".bak,~,.o,.h,.info,.swp,.obj")
         * 			global
         * 	Files with these suffixes get a lower priority when multiple files
         * 	match a wildcard.  See |suffixes|.  Commas can be used to separate the
         * 	suffixes.  Spaces after the comma are ignored.  A dot is also seen as
         * 	the start of a suffix.  To avoid a dot or comma being recognized as a
         * 	separator, precede it with a backslash (see |option-backslash| about
         * 	including spaces and backslashes).
         * 	See `'wildignore'`  for completely ignoring files.
         * 	The use of |:set+=| and |:set-=| is preferred when adding or removing
         * 	suffixes from the list.  This avoids problems when a future version
         * 	uses another default.
         */
        suffixes: ListOption;

        /**
         * `'suffixesadd'`  `'sua'` 	string	(default "")
         * 			local to buffer
         * 	Comma-separated list of suffixes, which are used when searching for a
         * 	file for the "gf", "[I", etc. commands.  Example: >
         * 		:set suffixesadd=.java
         * <
         */
        suffixesadd: ListOption;

        /**
         * `'swapfile'`  `'swf'` 	boolean (default on)
         * 			local to buffer
         * 	Use a swapfile for the buffer.  This option can be reset when a
         * 	swapfile is not wanted for a specific buffer.  For example, with
         * 	confidential information that even root must not be able to access.
         * 	Careful: All text will be in memory:
         * 		- Don't use this for big files.
         * 		- Recovery will be impossible!
         * 	A swapfile will only be present when |`'updatecount'` | is non-zero and
         * 	`'swapfile'`  is set.
         * 	When `'swapfile'`  is reset, the swap file for the current buffer is
         * 	immediately deleted.  When `'swapfile'`  is set, and `'updatecount'`  is
         * 	non-zero, a swap file is immediately created.
         * 	Also see |swap-file|.
         * 	If you want to open a new buffer without creating a swap file for it,
         * 	use the |:noswapfile| modifier.
         * 	See `'directory'`  for where the swap file is created.
         * 
         * 	This option is used together with `'bufhidden'`  and `'buftype'`  to
         * 	specify special kinds of buffers.   See |special-buffers|.
         */
        swapfile: Option<boolean>;

        /**
         * `'switchbuf'`  `'swb'` 	string	(default "uselast")
         * 			global
         * 	This option controls the behavior when switching between buffers.
         * 	Mostly for |quickfix| commands some values are also used for other
         * 	commands, as mentioned below.
         * 	Possible values (comma-separated list):
         * 	   useopen	If included, jump to the first open window that
         * 			contains the specified buffer (if there is one).
         * 			Otherwise: Do not examine other windows.
         * 			This setting is checked with |quickfix| commands, when
         * 			jumping to errors (":cc", ":cn", "cp", etc.).  It is
         * 			also used in all buffer related split commands, for
         * 			example ":sbuffer", ":sbnext", or ":sbrewind".
         * 	   usetab	Like "useopen", but also consider windows in other tab
         * 			pages.
         * 	   split	If included, split the current window before loading
         * 			a buffer for a |quickfix| command that display errors.
         * 			Otherwise: do not split, use current window (when used
         * 			in the quickfix window: the previously used window or
         * 			split if there is no other window).
         * 	   vsplit	Just like "split" but split vertically.
         * 	   newtab	Like "split", but open a new tab page.  Overrules
         * 			"split" when both are present.
         * 	   uselast	If included, jump to the previously used window when
         * 			jumping to errors with |quickfix| commands.
         */
        switchbuf: ListOption;

        /**
         * `'synmaxcol'`  `'smc'` 	number	(default 3000)
         * 			local to buffer
         * 	Maximum column in which to search for syntax items.  In long lines the
         * 	text after this column is not highlighted and following lines may not
         * 	be highlighted correctly, because the syntax state is cleared.
         * 	This helps to avoid very slow redrawing for an XML file that is one
         * 	long line.
         * 	Set to zero to remove the limit.
         */
        synmaxcol: Option<number>;

        /**
         * `'syntax'`  `'syn'` 		string	(default empty)
         * 			local to buffer
         * 	When this option is set, the syntax with this name is loaded, unless
         * 	syntax highlighting has been switched off with ":syntax off".
         * 	Otherwise this option does not always reflect the current syntax (the
         * 	b:current_syntax variable does).
         * 	This option is most useful in a modeline, for a file which syntax is
         * 	not automatically recognized.  Example, in an IDL file: >
         * 		/* vim: set syntax=idl : * /
         * <	When a dot appears in the value then this separates two filetype
         * 	names.  Example: >
         * 		/* vim: set syntax=c.doxygen : * /
         * <	This will use the "c" syntax first, then the "doxygen" syntax.
         * 	Note that the second one must be prepared to be loaded as an addition,
         * 	otherwise it will be skipped.  More than one dot may appear.
         * 	To switch off syntax highlighting for the current file, use: >
         * 		:set syntax=OFF
         * <	To switch syntax highlighting on according to the current value of the
         * 	`'filetype'`  option: >
         * 		:set syntax=ON
         * <	What actually happens when setting the `'syntax'`  option is that the
         * 	Syntax autocommand event is triggered with the value as argument.
         * 	This option is not copied to another buffer, independent of the `'s'`  or
         * 	`'S'`  flag in `'cpoptions'` .
         * 	Only normal file name characters can be used, "/\*?[|<>" are illegal.
         */
        syntax: Option<string>;

        /**
         * `'tabline'`  `'tal'` 		string	(default empty)
         * 			global
         * 	When non-empty, this option determines the content of the tab pages
         * 	line at the top of the Vim window.  When empty Vim will use a default
         * 	tab pages line.  See |setting-tabline| for more info.
         * 
         * 	The tab pages line only appears as specified with the `'showtabline'` 
         * 	option and only when there is no GUI tab line.  When `'e'`  is in
         * 	`'guioptions'`  and the GUI supports a tab line `'guitablabel'`  is used
         * 	instead.  Note that the two tab pages lines are very different.
         * 
         * 	The value is evaluated like with `'statusline'` .  You can use
         * 	|tabpagenr()|, |tabpagewinnr()| and |tabpagebuflist()| to figure out
         * 	the text to be displayed.  Use "%1T" for the first label, "%2T" for
         * 	the second one, etc.  Use "%X" items for closing labels.
         * 
         * 	When changing something that is used in `'tabline'`  that does not
         * 	trigger it to be updated, use |:redrawtabline|.
         * 	This option cannot be set in a modeline when `'modelineexpr'`  is off.
         * 
         * 	Keep in mind that only one of the tab pages is the current one, others
         * 	are invisible and you can't jump to their windows.
         */
        tabline: Option<string>;

        /**
         * `'tabpagemax'`  `'tpm'` 	number	(default 50)
         * 			global
         * 	Maximum number of tab pages to be opened by the |-p| command line
         * 	argument or the ":tab all" command. |tabpage|
         */
        tabpagemax: Option<number>;

        /**
         * `'tabstop'`  `'ts'` 		number	(default 8)
         * 			local to buffer
         * 	Number of spaces that a <Tab> in the file counts for.  Also see
         * 	the |:retab| command, and the `'softtabstop'`  option.
         * 
         * 	Note: Setting `'tabstop'`  to any other value than 8 can make your file
         * 	appear wrong in many places.
         * 	The value must be more than 0 and less than 10000.
         * 
         * 	There are four main ways to use tabs in Vim:
         * 	1. Always keep `'tabstop'`  at 8, set `'softtabstop'`  and `'shiftwidth'`  to 4
         * 	   (or 3 or whatever you prefer) and use `'noexpandtab'` .  Then Vim
         * 	   will use a mix of tabs and spaces, but typing <Tab> and <BS> will
         * 	   behave like a tab appears every 4 (or 3) characters.
         * 	2. Set `'tabstop'`  and `'shiftwidth'`  to whatever you prefer and use
         * 	   `'expandtab'` .  This way you will always insert spaces.  The
         * 	   formatting will never be messed up when `'tabstop'`  is changed.
         * 	3. Set `'tabstop'`  and `'shiftwidth'`  to whatever you prefer and use a
         * 	   |modeline| to set these values when editing the file again.  Only
         * 	   works when using Vim to edit the file.
         * 	4. Always set `'tabstop'`  and `'shiftwidth'`  to the same value, and
         * 	   `'noexpandtab'` .  This should then work (for initial indents only)
         * 	   for any tabstop setting that people use.  It might be nice to have
         * 	   tabs after the first non-blank inserted as spaces if you do this
         * 	   though.  Otherwise aligned comments will be wrong when `'tabstop'`  is
         * 	   changed.
         * 
         * 	The value of `'tabstop'`  will be ignored if |`'vartabstop'` | is set to
         * 	anything other than an empty string.
         */
        tabstop: Option<number>;

        /**
         * `'tagbsearch'`  `'tbs'` 	boolean	(default on)
         * 			global
         * 	When searching for a tag (e.g., for the |:ta| command), Vim can either
         * 	use a binary search or a linear search in a tags file.  Binary
         * 	searching makes searching for a tag a LOT faster, but a linear search
         * 	will find more tags if the tags file wasn't properly sorted.
         * 	Vim normally assumes that your tags files are sorted, or indicate that
         * 	they are not sorted.  Only when this is not the case does the
         * 	`'tagbsearch'`  option need to be switched off.
         * 
         * 	When `'tagbsearch'`  is on, binary searching is first used in the tags
         * 	files.  In certain situations, Vim will do a linear search instead for
         * 	certain files, or retry all files with a linear search.  When
         * 	`'tagbsearch'`  is off, only a linear search is done.
         * 
         * 	Linear searching is done anyway, for one file, when Vim finds a line
         * 	at the start of the file indicating that it's not sorted: >
         *    !_TAG_FILE_SORTED	0	/some comment/
         * <	[The whitespace before and after the `'0'`  must be a single <Tab>]
         * 
         * 	When a binary search was done and no match was found in any of the
         * 	files listed in `'tags'` , and case is ignored or a pattern is used
         * 	instead of a normal tag name, a retry is done with a linear search.
         * 	Tags in unsorted tags files, and matches with different case will only
         * 	be found in the retry.
         * 
         * 	If a tag file indicates that it is case-fold sorted, the second,
         * 	linear search can be avoided when case is ignored.  Use a value of `'2'` 
         * 	in the "!_TAG_FILE_SORTED" line for this.  A tag file can be case-fold
         * 	sorted with the -f switch to "sort" in most unices, as in the command:
         * 	"sort -f -o tags tags".  For Universal ctags and Exuberant ctags
         * 	version 5.x or higher (at least 5.5) the --sort=foldcase switch can be
         * 	used for this as well.  Note that case must be folded to uppercase for
         * 	this to work.
         * 
         * 	By default, tag searches are case-sensitive.  Case is ignored when
         * 	`'ignorecase'`  is set and `'tagcase'`  is "followic", or when `'tagcase'`  is
         * 	"ignore".
         * 	Also when `'tagcase'`  is "followscs" and `'smartcase'`  is set, or
         * 	`'tagcase'`  is "smart", and the pattern contains only lowercase
         * 	characters.
         * 
         * 	When `'tagbsearch'`  is off, tags searching is slower when a full match
         * 	exists, but faster when no full match exists.  Tags in unsorted tags
         * 	files may only be found with `'tagbsearch'`  off.
         * 	When the tags file is not sorted, or sorted in a wrong way (not on
         * 	ASCII byte value), `'tagbsearch'`  should be off, or the line given above
         * 	must be included in the tags file.
         * 	This option doesn't affect commands that find all matching tags (e.g.,
         * 	command-line completion and ":help").
         */
        tagbsearch: Option<boolean>;

        /**
         * `'tagcase'`  `'tc'` 		string	(default "followic")
         * 			global or local to buffer |global-local|
         * 	This option specifies how case is handled when searching the tags
         * 	file:
         * 	   followic	Follow the `'ignorecase'`  option
         * 	   followscs    Follow the `'smartcase'`  and `'ignorecase'`  options
         * 	   ignore	Ignore case
         * 	   match	Match case
         * 	   smart	Ignore case unless an upper case letter is used
         */
        tagcase: Option<string>;

        /**
         * `'tagfunc'`  `'tfu'` 		string	(default: empty)
         * 			local to buffer
         * 	This option specifies a function to be used to perform tag searches.
         * 	The function gets the tag pattern and should return a List of matching
         * 	tags.  See |tag-function| for an explanation of how to write the
         * 	function and an example.  The value can be the name of a function, a
         * 	|lambda| or a |Funcref|. See |option-value-function| for more
         * 	information.
         */
        tagfunc: Option<string>;

        /**
         * `'taglength'`  `'tl'` 	number	(default 0)
         * 			global
         * 	If non-zero, tags are significant up to this number of characters.
         */
        taglength: Option<number>;

        /**
         * `'tagrelative'`  `'tr'` 	boolean	(default: on)
         * 			global
         * 	If on and using a tags file in another directory, file names in that
         * 	tags file are relative to the directory where the tags file is.
         */
        tagrelative: Option<boolean>;

        /**
         * `'tags'`  `'tag'` 		string	(default "./tags;,tags")
         * 			global or local to buffer |global-local|
         * 	Filenames for the tag command, separated by spaces or commas.  To
         * 	include a space or comma in a file name, precede it with a backslash
         * 	(see |option-backslash| about including spaces and backslashes).
         * 	When a file name starts with "./", the `'.'`  is replaced with the path
         * 	of the current file.  But only when the `'d'`  flag is not included in
         * 	`'cpoptions'` .  Environment variables are expanded |:set_env|.  Also see
         * 	|tags-option|.
         * 	"*", "" and other wildcards can be used to search for tags files in
         * 	a directory tree.  See |file-searching|.  E.g., "/lib//tags" will
         * 	find all files named "tags" below "/lib".  The filename itself cannot
         * 	contain wildcards, it is used as-is.  E.g., "/lib//tags?" will find
         * 	files called "tags?".
         * 	The |tagfiles()| function can be used to get a list of the file names
         * 	actually used.
         * 	The use of |:set+=| and |:set-=| is preferred when adding or removing
         * 	file names from the list.  This avoids problems when a future version
         * 	uses another default.
         */
        tags: ListOption;

        /**
         * `'tagstack'`  `'tgst'` 	boolean	(default on)
         * 			global
         * 	When on, the |tagstack| is used normally.  When off, a ":tag" or
         * 	":tselect" command with an argument will not push the tag onto the
         * 	tagstack.  A following ":tag" without an argument, a ":pop" command or
         * 	any other command that uses the tagstack will use the unmodified
         * 	tagstack, but does change the pointer to the active entry.
         * 	Resetting this option is useful when using a ":tag" command in a
         * 	mapping which should not change the tagstack.
         */
        tagstack: Option<boolean>;

        /**
         * `'termbidi'`  `'tbidi'` 	boolean (default off)
         * 			global
         * 	The terminal is in charge of Bi-directionality of text (as specified
         * 	by Unicode).  The terminal is also expected to do the required shaping
         * 	that some languages (such as Arabic) require.
         * 	Setting this option implies that `'rightleft'`  will not be set when
         * 	`'arabic'`  is set and the value of `'arabicshape'`  will be ignored.
         * 	Note that setting `'termbidi'`  has the immediate effect that
         * 	`'arabicshape'`  is ignored, but `'rightleft'`  isn't changed automatically.
         * 	For further details see |arabic.txt|.
         */
        termbidi: Option<boolean>;

        termencoding: Option<string>;

        /**
         * `'termguicolors'`  `'tgc'` 	boolean (default off)
         * 			global
         * 	Enables 24-bit RGB color in the |TUI|.  Uses "gui" |:highlight|
         * 	attributes instead of "cterm" attributes. |guifg|
         * 	Requires an ISO-8613-3 compatible terminal.
         */
        termguicolors: Option<boolean>;

        /**
         * `'termpastefilter'`  `'tpf'` 	string	(default: "BS,HT,ESC,DEL")
         * 			global
         * 	A comma-separated list of options for specifying control characters
         * 	to be removed from the text pasted into the terminal window. The
         * 	supported values are:
         * 
         * 	   BS	    Backspace
         * 
         * 	   HT	    TAB
         * 
         * 	   FF	    Form feed
         * 
         * 	   ESC	    Escape
         * 
         * 	   DEL	    DEL
         * 
         * 	   C0	    Other control characters, excluding Line feed and
         * 		    Carriage return < ' '
         * 
         * 	   C1	    Control characters 0x80...0x9F
         */
        termpastefilter: ListOption;

        terse: Option<boolean>;

        /**
         * `'textwidth'`  `'tw'` 	number	(default 0)
         * 			local to buffer
         * 	Maximum width of text that is being inserted.  A longer line will be
         * 	broken after white space to get this width.  A zero value disables
         * 	this.
         * 	When `'textwidth'`  is zero, `'wrapmargin'`  may be used.  See also
         * 	`'formatoptions'`  and |ins-textwidth|.
         * 	When `'formatexpr'`  is set it will be used to break the line.
         */
        textwidth: Option<number>;

        /**
         * `'thesaurus'`  `'tsr'` 	string	(default "")
         * 			global or local to buffer |global-local|
         * 	List of file names, separated by commas, that are used to lookup words
         * 	for thesaurus completion commands |i_CTRL-X_CTRL-T|.  See
         * 	|compl-thesaurus|.
         * 
         * 	This option is not used if `'thesaurusfunc'`  is set, either for the
         * 	buffer or globally.
         * 
         * 	To include a comma in a file name precede it with a backslash.  Spaces
         * 	after a comma are ignored, otherwise spaces are included in the file
         * 	name.  See |option-backslash| about using backslashes.  The use of
         * 	|:set+=| and |:set-=| is preferred when adding or removing directories
         * 	from the list.  This avoids problems when a future version uses
         * 	another default.  Backticks cannot be used in this option for security
         * 	reasons.
         */
        thesaurus: ListOption;

        /**
         * `'thesaurusfunc'`  `'tsrfu'` 	string	(default: empty)
         * 			global or local to buffer |global-local|
         * 	This option specifies a function to be used for thesaurus completion
         * 	with CTRL-X CTRL-T. |i_CTRL-X_CTRL-T| See |compl-thesaurusfunc|.
         * 	The value can be the name of a function, a |lambda| or a |Funcref|.
         * 	See |option-value-function| for more information.
         * 
         * 	This option cannot be set from a |modeline| or in the |sandbox|, for
         * 	security reasons.
         */
        thesaurusfunc: Option<string>;

        /**
         * `'tildeop'`  `'top'` 		boolean	(default off)
         * 			global
         * 	When on: The tilde command "~" behaves like an operator.
         */
        tildeop: Option<boolean>;

        /**
         * `'timeout'`  `'to'` 		boolean (default on)
         * 			global
         * 	This option and `'timeoutlen'`  determine the behavior when part of a
         * 	mapped key sequence has been received. For example, if <c-f> is
         * 	pressed and `'timeout'`  is set, Nvim will wait `'timeoutlen'`  milliseconds
         * 	for any key that can follow <c-f> in a mapping.
         */
        timeout: Option<boolean>;

        /**
         * `'timeoutlen'`  `'tm'` 	number	(default 1000)
         * 			global
         * 	Time in milliseconds to wait for a mapped sequence to complete.
         */
        timeoutlen: Option<number>;

        /**
         * `'title'` 			boolean	(default off)
         * 			global
         * 	When on, the title of the window will be set to the value of
         * 	`'titlestring'`  (if it is not empty), or to:
         * 		filename [+=-] (path) - NVIM
         * 	Where:
         * 		filename	the name of the file being edited
         * 		-		indicates the file cannot be modified, `'ma'`  off
         * 		+		indicates the file was modified
         * 		=		indicates the file is read-only
         * 		=+		indicates the file is read-only and modified
         * 		(path)		is the path of the file being edited
         * 		- NVIM		the server name |v:servername| or "NVIM"
         */
        title: Option<boolean>;

        /**
         * `'titlelen'` 		number	(default 85)
         * 			global
         * 	Gives the percentage of `'columns'`  to use for the length of the window
         * 	title.  When the title is longer, only the end of the path name is
         * 	shown.  A `'<'`  character before the path name is used to indicate this.
         * 	Using a percentage makes this adapt to the width of the window.  But
         * 	it won't work perfectly, because the actual number of characters
         * 	available also depends on the font used and other things in the title
         * 	bar.  When `'titlelen'`  is zero the full path is used.  Otherwise,
         * 	values from 1 to 30000 percent can be used.
         * 	`'titlelen'`  is also used for the `'titlestring'`  option.
         */
        titlelen: Option<number>;

        /**
         * `'titleold'` 		string	(default "")
         * 			global
         * 	If not empty, this option will be used to set the window title when
         * 	exiting.  Only if `'title'`  is enabled.
         * 	This option cannot be set from a |modeline| or in the |sandbox|, for
         * 	security reasons.
         */
        titleold: Option<string>;

        /**
         * `'titlestring'` 		string	(default "")
         * 			global
         * 	When this option is not empty, it will be used for the title of the
         * 	window.  This happens only when the `'title'`  option is on.
         * 
         * 	When this option contains printf-style `'%'`  items, they will be
         * 	expanded according to the rules used for `'statusline'` .
         * 	This option cannot be set in a modeline when `'modelineexpr'`  is off.
         * 
         * 	Example: >
         * 	    :auto BufEnter * let &titlestring = hostname() .. "/" .. expand("%:p")
         * 	    :set title titlestring=%<%F%=%l/%L-%P titlelen=70
         * <	The value of `'titlelen'`  is used to align items in the middle or right
         * 	of the available space.
         * 	Some people prefer to have the file name first: >
         * 	    :set titlestring=%t%(\ %M%)%(\ (%{expand(\"%:~:.:h\")})%)%(\ %a%)
         * <	Note the use of "%{ }" and an expression to get the path of the file,
         * 	without the file name.  The "%( %)" constructs are used to add a
         * 	separating space only when needed.
         * 	NOTE: Use of special characters in `'titlestring'`  may cause the display
         * 	to be garbled (e.g., when it contains a CR or NL character).
         */
        titlestring: Option<string>;

        /**
         * `'ttimeout'` 		boolean (default on)
         * 			global
         * 	This option and `'ttimeoutlen'`  determine the behavior when part of a
         * 	key code sequence has been received by the |TUI|.
         * 
         * 	For example if <Esc> (the \x1b byte) is received and `'ttimeout'`  is
         * 	set, Nvim waits `'ttimeoutlen'`  milliseconds for the terminal to
         * 	complete a key code sequence. If no input arrives before the timeout,
         * 	a single <Esc> is assumed. Many TUI cursor key codes start with <Esc>.
         * 
         * 	On very slow systems this may fail, causing cursor keys not to work
         * 	sometimes.  If you discover this problem you can ":set ttimeoutlen=9999".
         * 	Nvim will wait for the next character to arrive after an <Esc>.
         */
        ttimeout: Option<boolean>;

        /**
         * `'ttimeoutlen'`  `'ttm'` 	number	(default 50)
         * 			global
         * 	Time in milliseconds to wait for a key code sequence to complete. Also
         * 	used for CTRL-\ CTRL-N and CTRL-\ CTRL-G when part of a command has
         * 	been typed.
         */
        ttimeoutlen: Option<number>;

        ttyfast: Option<boolean>;

        /**
         * `'undodir'`  `'udir'` 	string	(default "$XDG_STATE_HOME/nvim/undo//")
         * 			global
         * 	List of directory names for undo files, separated with commas.
         * 	See `'backupdir'`  for details of the format.
         * 	"." means using the directory of the file.  The undo file name for
         * 	"file.txt" is ".file.txt.un~".
         * 	For other directories the file name is the full path of the edited
         * 	file, with path separators replaced with "%".
         * 	When writing: The first directory that exists is used.  "." always
         * 	works, no directories after "." will be used for writing.  If none of
         * 	the directories exist Nvim will attempt to create the last directory in
         * 	the list.
         * 	When reading all entries are tried to find an undo file.  The first
         * 	undo file that exists is used.  When it cannot be read an error is
         * 	given, no further entry is used.
         * 	See |undo-persistence|.
         * 	This option cannot be set from a |modeline| or in the |sandbox|, for
         * 	security reasons.
         * 
         * 	Note that unlike `'directory'`  and `'backupdir'` , `'undodir'`  always acts as
         * 	though the trailing slashes are present (see `'backupdir'`  for what this
         * 	means).
         */
        undodir: ListOption;

        /**
         * `'undofile'`  `'udf'` 	boolean	(default off)
         * 			local to buffer
         * 	When on, Vim automatically saves undo history to an undo file when
         * 	writing a buffer to a file, and restores undo history from the same
         * 	file on buffer read.
         * 	The directory where the undo file is stored is specified by `'undodir'` .
         * 	For more information about this feature see |undo-persistence|.
         * 	The undo file is not read when `'undoreload'`  causes the buffer from
         * 	before a reload to be saved for undo.
         * 	When `'undofile'`  is turned off the undo file is NOT deleted.
         */
        undofile: Option<boolean>;

        /**
         * `'undolevels'`  `'ul'` 	number	(default 1000)
         * 			global or local to buffer |global-local|
         * 	Maximum number of changes that can be undone.  Since undo information
         * 	is kept in memory, higher numbers will cause more memory to be used.
         * 	Nevertheless, a single change can already use a large amount of memory.
         * 	Set to 0 for Vi compatibility: One level of undo and "u" undoes
         * 	itself: >
         * 		set ul=0
         * <	But you can also get Vi compatibility by including the `'u'`  flag in
         * 	`'cpoptions'` , and still be able to use CTRL-R to repeat undo.
         * 	Also see |undo-two-ways|.
         * 	Set to -1 for no undo at all.  You might want to do this only for the
         * 	current buffer: >
         * 		setlocal ul=-1
         * <	This helps when you run out of memory for a single change.
         * 
         * 	The local value is set to -123456 when the global value is to be used.
         * 
         * 	Also see |clear-undo|.
         */
        undolevels: Option<number>;

        /**
         * `'undoreload'`  `'ur'` 	number	(default 10000)
         * 			global
         * 	Save the whole buffer for undo when reloading it.  This applies to the
         * 	":e!" command and reloading for when the buffer changed outside of
         * 	Vim. |FileChangedShell|
         * 	The save only happens when this option is negative or when the number
         * 	of lines is smaller than the value of this option.
         * 	Set this option to zero to disable undo for a reload.
         * 
         * 	When saving undo for a reload, any undo file is not read.
         * 
         * 	Note that this causes the whole buffer to be stored in memory.  Set
         * 	this option to a lower value if you run out of memory.
         */
        undoreload: Option<number>;

        /**
         * `'updatecount'`  `'uc'` 	number	(default: 200)
         * 			global
         * 	After typing this many characters the swap file will be written to
         * 	disk.  When zero, no swap file will be created at all (see chapter on
         * 	recovery |crash-recovery|).  `'updatecount'`  is set to zero by starting
         * 	Vim with the "-n" option, see |startup|.  When editing in readonly
         * 	mode this option will be initialized to 10000.
         * 	The swapfile can be disabled per buffer with |`'swapfile'` |.
         * 	When `'updatecount'`  is set from zero to non-zero, swap files are
         * 	created for all buffers that have `'swapfile'`  set.  When `'updatecount'` 
         * 	is set to zero, existing swap files are not deleted.
         * 	This option has no meaning in buffers where |`'buftype'` | is "nofile"
         * 	or "nowrite".
         */
        updatecount: Option<number>;

        /**
         * `'updatetime'`  `'ut'` 	number	(default 4000)
         * 			global
         * 	If this many milliseconds nothing is typed the swap file will be
         * 	written to disk (see |crash-recovery|).  Also used for the
         * 	|CursorHold| autocommand event.
         */
        updatetime: Option<number>;

        /**
         * `'varsofttabstop'`  `'vsts'` 	string	(default "")
         * 			local to buffer
         * 	A list of the number of spaces that a <Tab> counts for while editing,
         * 	such as inserting a <Tab> or using <BS>.  It "feels" like variable-
         * 	width <Tab>s are being inserted, while in fact a mixture of spaces
         * 	and <Tab>s is used.  Tab widths are separated with commas, with the
         * 	final value applying to all subsequent tabs.
         * 
         * 	For example, when editing assembly language files where statements
         * 	start in the 9th column and comments in the 41st, it may be useful
         * 	to use the following: >
         * 		:set varsofttabstop=8,32,8
         * <	This will set soft tabstops with 8 and 8 + 32 spaces, and 8 more
         * 	for every column thereafter.
         * 
         * 	Note that the value of |`'softtabstop'` | will be ignored while
         * 	`'varsofttabstop'`  is set.
         */
        varsofttabstop: ListOption;

        /**
         * `'vartabstop'`  `'vts'` 	string	(default "")
         * 			local to buffer
         * 	A list of the number of spaces that a <Tab> in the file counts for,
         * 	separated by commas.  Each value corresponds to one tab, with the
         * 	final value applying to all subsequent tabs. For example: >
         * 		:set vartabstop=4,20,10,8
         * <	This will make the first tab 4 spaces wide, the second 20 spaces,
         * 	the third 10 spaces, and all following tabs 8 spaces.
         * 
         * 	Note that the value of |`'tabstop'` | will be ignored while `'vartabstop'` 
         * 	is set.
         */
        vartabstop: ListOption;

        /**
         * `'verbose'`  `'vbs'` 		number	(default 0)
         * 			global
         * 	Sets the verbosity level.  Also set by |-V| and |:verbose|.
         * 
         * 	Tracing of options in Lua scripts is activated at level 1; Lua scripts
         * 	are not traced with verbose=0, for performance.
         * 
         * 	If greater than or equal to a given level, Nvim produces the following
         * 	messages:
         * 
         * 	Level   Messages ~
         * 	----------------------------------------------------------------------
         * 	1	Lua assignments to options, mappings, etc.
         * 	2	When a file is ":source"'ed, or |shada| file is read or written.
         * 	3	UI info, terminal capabilities.
         * 	4	Shell commands.
         * 	5	Every searched tags file and include file.
         * 	8	Files for which a group of autocommands is executed.
         * 	9	Executed autocommands.
         * 	11	Finding items in a path.
         * 	12	Vimscript function calls.
         * 	13	When an exception is thrown, caught, finished, or discarded.
         * 	14	Anything pending in a ":finally" clause.
         * 	15	Ex commands from a script (truncated at 200 characters).
         * 	16	Ex commands.
         * 
         * 	If `'verbosefile'`  is set then the verbose messages are not displayed.
         */
        verbose: Option<number>;

        /**
         * `'verbosefile'`  `'vfile'` 	string	(default empty)
         * 			global
         * 	When not empty all messages are written in a file with this name.
         * 	When the file exists messages are appended.
         * 	Writing to the file ends when Vim exits or when `'verbosefile'`  is made
         * 	empty.  Writes are buffered, thus may not show up for some time.
         * 	Setting `'verbosefile'`  to a new value is like making it empty first.
         * 	The difference with |:redir| is that verbose messages are not
         * 	displayed when `'verbosefile'`  is set.
         */
        verbosefile: Option<string>;

        /**
         * `'viewdir'`  `'vdir'` 	string	(default: "$XDG_STATE_HOME/nvim/view//")
         * 			global
         * 	Name of the directory where to store files for |:mkview|.
         * 	This option cannot be set from a |modeline| or in the |sandbox|, for
         * 	security reasons.
         */
        viewdir: Option<string>;

        /**
         * `'viewoptions'`  `'vop'` 	string	(default: "folds,cursor,curdir")
         * 			global
         * 	Changes the effect of the |:mkview| command.  It is a comma-separated
         * 	list of words.  Each word enables saving and restoring something:
         * 	   word		save and restore ~
         * 	   cursor	cursor position in file and in window
         * 	   curdir	local current directory, if set with |:lcd|
         * 	   folds	manually created folds, opened/closed folds and local
         * 			fold options
         * 	   options	options and mappings local to a window or buffer (not
         * 			global values for local options)
         * 	   localoptions same as "options"
         * 	   slash	|deprecated| Always enabled. Uses "/" in filenames.
         * 	   unix		|deprecated| Always enabled. Uses "\n" line endings.
         */
        viewoptions: ListOption;

        viminfo: ListOption;

        viminfofile: ListOption;

        /**
         * `'virtualedit'`  `'ve'` 	string	(default "")
         * 			global or local to window |global-local|
         * 	A comma-separated list of these words:
         * 	    block	Allow virtual editing in Visual block mode.
         * 	    insert	Allow virtual editing in Insert mode.
         * 	    all		Allow virtual editing in all modes.
         * 	    onemore	Allow the cursor to move just past the end of the line
         * 	    none	When used as the local value, do not allow virtual
         * 			editing even when the global value is set.  When used
         * 			as the global value, "none" is the same as "".
         * 	    NONE	Alternative spelling of "none".
         * 
         * 	Virtual editing means that the cursor can be positioned where there is
         * 	no actual character.  This can be halfway into a tab or beyond the end
         * 	of the line.  Useful for selecting a rectangle in Visual mode and
         * 	editing a table.
         * 	"onemore" is not the same, it will only allow moving the cursor just
         * 	after the last character of the line.  This makes some commands more
         * 	consistent.  Previously the cursor was always past the end of the line
         * 	if the line was empty.  But it is far from Vi compatible.  It may also
         * 	break some plugins or Vim scripts.  For example because |l| can move
         * 	the cursor after the last character.  Use with care!
         * 	Using the `$` command will move to the last character in the line, not
         * 	past it.  This may actually move the cursor to the left!
         * 	The `g$` command will move to the end of the screen line.
         * 	It doesn't make sense to combine "all" with "onemore", but you will
         * 	not get a warning for it.
         * 	When combined with other words, "none" is ignored.
         */
        virtualedit: ListOption;

        /**
         * `'visualbell'`  `'vb'` 	boolean	(default off)
         * 			global
         * 	Use visual bell instead of beeping.  Also see `'errorbells'` .
         */
        visualbell: Option<boolean>;

        /**
         * `'warn'` 			boolean	(default on)
         * 			global
         * 	Give a warning message when a shell command is used while the buffer
         * 	has been changed.
         */
        warn: Option<boolean>;

        /**
         * `'whichwrap'`  `'ww'` 	string	(default: "b,s")
         * 			global
         * 	Allow specified keys that move the cursor left/right to move to the
         * 	previous/next line when the cursor is on the first/last character in
         * 	the line.  Concatenate characters to allow this for these keys:
         * 		char   key	  mode	~
         * 		 b    <BS>	 Normal and Visual
         * 		 s    <Space>	 Normal and Visual
         * 		 h    "h"	 Normal and Visual (not recommended)
         * 		 l    "l"	 Normal and Visual (not recommended)
         * 		 <    <Left>	 Normal and Visual
         * 		 >    <Right>	 Normal and Visual
         * 		 ~    "~"	 Normal
         * 		 [    <Left>	 Insert and Replace
         * 		 ]    <Right>	 Insert and Replace
         * 	For example: >
         * 		:set ww=<,>,[,]
         * <	allows wrap only when cursor keys are used.
         * 	When the movement keys are used in combination with a delete or change
         * 	operator, the <EOL> also counts for a character.  This makes "3h"
         * 	different from "3dh" when the cursor crosses the end of a line.  This
         * 	is also true for "x" and "X", because they do the same as "dl" and
         * 	"dh".  If you use this, you may also want to use the mapping
         * 	":map <BS> X" to make backspace delete the character in front of the
         * 	cursor.
         * 	When `'l'`  is included and it is used after an operator at the end of a
         * 	line (not an empty line) then it will not move to the next line.  This
         * 	makes "dl", "cl", "yl" etc. work normally.
         */
        whichwrap: ListOption;

        /**
         * `'wildchar'`  `'wc'` 		number	(default: <Tab>)
         * 			global
         * 	Character you have to type to start wildcard expansion in the
         * 	command-line, as specified with `'wildmode'` .
         * 	More info here: |cmdline-completion|.
         * 	The character is not recognized when used inside a macro.  See
         * 	`'wildcharm'`  for that.
         * 	Some keys will not work, such as CTRL-C, <CR> and Enter.
         * 	Although `'wc'`  is a number option, you can set it to a special key: >
         * 		:set wc=<Tab>
         * <
         */
        wildchar: Option<number>;

        /**
         * `'wildcharm'`  `'wcm'` 	number	(default: none (0))
         * 			global
         * 	`'wildcharm'`  works exactly like `'wildchar'` , except that it is
         * 	recognized when used inside a macro.  You can find "spare" command-line
         * 	keys suitable for this option by looking at |ex-edit-index|.  Normally
         * 	you'll never actually type `'wildcharm'` , just use it in mappings that
         * 	automatically invoke completion mode, e.g.: >
         * 		:set wcm=<C-Z>
         * 		:cnoremap ss so $vim/sessions/*.vim<C-Z>
         * <	Then after typing :ss you can use CTRL-P & CTRL-N.
         */
        wildcharm: Option<number>;

        /**
         * `'wildignore'`  `'wig'` 	string	(default "")
         * 			global
         * 	A list of file patterns.  A file that matches with one of these
         * 	patterns is ignored when expanding |wildcards|, completing file or
         * 	directory names, and influences the result of |expand()|, |glob()| and
         * 	|globpath()| unless a flag is passed to disable this.
         * 	The pattern is used like with |:autocmd|, see |autocmd-pattern|.
         * 	Also see `'suffixes'` .
         * 	Example: >
         * 		:set wildignore=.obj
         * <	The use of |:set+=| and |:set-=| is preferred when adding or removing
         * 	a pattern from the list.  This avoids problems when a future version
         * 	uses another default.
         */
        wildignore: ListOption;

        /**
         * `'wildignorecase'`  `'wic'` 	boolean	(default off)
         * 			global
         * 	When set case is ignored when completing file names and directories.
         * 	Has no effect when `'fileignorecase'`  is set.
         * 	Does not apply when the shell is used to expand wildcards, which
         * 	happens when there are special characters.
         */
        wildignorecase: Option<boolean>;

        /**
         * `'wildmenu'`  `'wmnu'` 	boolean	(default on)
         * 			global
         * 	When `'wildmenu'`  is on, command-line completion operates in an enhanced
         * 	mode.  On pressing `'wildchar'`  (usually <Tab>) to invoke completion,
         * 	the possible matches are shown.
         * 	When `'wildoptions'`  contains "pum", then the completion matches are
         * 	shown in a popup menu.  Otherwise they are displayed just above the
         * 	command line, with the first match highlighted (overwriting the status
         * 	line, if there is one).
         * 	Keys that show the previous/next match, such as <Tab> or
         * 	CTRL-P/CTRL-N, cause the highlight to move to the appropriate match.
         * 	`'wildmode'`  must specify "full": "longest" and "list" do not start
         * 	`'wildmenu'`  mode. You can check the current mode with |wildmenumode()|.
         * 	The menu is cancelled when a key is hit that is not used for selecting
         * 	a completion.
         * 
         * 	While the menu is active these keys have special meanings:
         * 
         * 	CTRL-Y		- accept the currently selected match and stop
         * 			  completion.
         * 	CTRL-E		- end completion, go back to what was there before
         * 			  selecting a match.
         * 	<Left> <Right>	- select previous/next match (like CTRL-P/CTRL-N)
         * 	<Down>		- in filename/menu name completion: move into a
         * 			  subdirectory or submenu.
         * 	<CR>		- in menu completion, when the cursor is just after a
         * 			  dot: move into a submenu.
         * 	<Up>		- in filename/menu name completion: move up into
         * 			  parent directory or parent menu.
         * 
         * 	If you want <Left> and <Right> to move the cursor instead of selecting
         * 	a different match, use this: >
         * 		:cnoremap <Left> <Space><BS><Left>
         * 		:cnoremap <Right> <Space><BS><Right>
         * <
         * 	|hl-WildMenu| highlights the current match.
         */
        wildmenu: Option<boolean>;

        /**
         * `'wildmode'`  `'wim'` 	string	(default: "full")
         * 			global
         * 	Completion mode that is used for the character specified with
         * 	`'wildchar'` .  It is a comma-separated list of up to four parts.  Each
         * 	part specifies what to do for each consecutive use of `'wildchar'` .  The
         * 	first part specifies the behavior for the first use of `'wildchar'` ,
         * 	The second part for the second use, etc.
         * 
         * 	Each part consists of a colon separated list consisting of the
         * 	following possible values:
         * 	""		Complete only the first match.
         * 	"full"		Complete the next full match.  After the last match,
         * 			the original string is used and then the first match
         * 			again.  Will also start `'wildmenu'`  if it is enabled.
         * 	"longest"	Complete till longest common string.  If this doesn't
         * 			result in a longer string, use the next part.
         * 	"list"		When more than one match, list all matches.
         * 	"lastused"	When completing buffer names and more than one buffer
         * 			matches, sort buffers by time last used (other than
         * 			the current buffer).
         * 	When there is only a single match, it is fully completed in all cases.
         * 
         * 	Examples of useful colon-separated values:
         * 	"longest:full"	Like "longest", but also start `'wildmenu'`  if it is
         * 			enabled.  Will not complete to the next full match.
         * 	"list:full"	When more than one match, list all matches and
         * 			complete first match.
         * 	"list:longest"	When more than one match, list all matches and
         * 			complete till longest common string.
         * 	"list:lastused" When more than one buffer matches, list all matches
         * 			and sort buffers by time last used (other than the
         * 			current buffer).
         * 
         * 	Examples: >
         * 		:set wildmode=full
         * <	Complete first full match, next match, etc.  (the default) >
         * 		:set wildmode=longest,full
         * <	Complete longest common string, then each full match >
         * 		:set wildmode=list:full
         * <	List all matches and complete each full match >
         * 		:set wildmode=list,full
         * <	List all matches without completing, then each full match >
         * 		:set wildmode=longest,list
         * <	Complete longest common string, then list alternatives.
         * 	More info here: |cmdline-completion|.
         */
        wildmode: ListOption;

        /**
         * `'wildoptions'`  `'wop'` 	string	(default "pum,tagfile")
         * 			global
         * 	A list of words that change how |cmdline-completion| is done.
         * 	The following values are supported:
         * 	  fuzzy		Use |fuzzy-matching| to find completion matches. When
         * 			this value is specified, wildcard expansion will not
         * 			be used for completion.  The matches will be sorted by
         * 			the "best match" rather than alphabetically sorted.
         * 			This will find more matches than the wildcard
         * 			expansion. Currently fuzzy matching based completion
         * 			is not supported for file and directory names and
         * 			instead wildcard expansion is used.
         * 	  pum		Display the completion matches using the popup menu
         * 			in the same style as the |ins-completion-menu|.
         * 	  tagfile	When using CTRL-D to list matching tags, the kind of
         * 			tag and the file of the tag is listed.	Only one match
         * 			is displayed per line.  Often used tag kinds are:
         * 				d	#define
         * 				f	function
         */
        wildoptions: ListOption;

        /**
         * `'winaltkeys'`  `'wak'` 	string	(default "menu")
         * 			global
         * 			{only used in Win32}
         * 	Some GUI versions allow the access to menu entries by using the ALT
         * 	key in combination with a character that appears underlined in the
         * 	menu.  This conflicts with the use of the ALT key for mappings and
         * 	entering special characters.  This option tells what to do:
         * 	  no	Don't use ALT keys for menus.  ALT key combinations can be
         * 		mapped, but there is no automatic handling.
         * 	  yes	ALT key handling is done by the windowing system.  ALT key
         * 		combinations cannot be mapped.
         * 	  menu	Using ALT in combination with a character that is a menu
         * 		shortcut key, will be handled by the windowing system.  Other
         * 		keys can be mapped.
         * 	If the menu is disabled by excluding `'m'`  from `'guioptions'` , the ALT
         * 	key is never used for the menu.
         * 	This option is not used for <F10>; on Win32.
         */
        winaltkeys: Option<string>;

        /**
         * `'winbar'`  `'wbr'` 		string (default empty)
         * 			global or local to window |global-local|
         * 	When non-empty, this option enables the window bar and determines its
         * 	contents. The window bar is a bar that's shown at the top of every
         * 	window with it enabled. The value of `'winbar'`  is evaluated like with
         * 	`'statusline'` .
         * 
         * 	When changing something that is used in `'winbar'`  that does not trigger
         * 	it to be updated, use |:redrawstatus|.
         * 
         * 	Floating windows do not use the global value of `'winbar'` . The
         * 	window-local value of `'winbar'`  must be set for a floating window to
         * 	have a window bar.
         * 
         * 	This option cannot be set in a modeline when `'modelineexpr'`  is off.
         */
        winbar: Option<string>;

        /**
         * `'winblend'`  `'winbl'` 		number	(default 0)
         * 			local to window
         * 	Enables pseudo-transparency for a floating window. Valid values are in
         * 	the range of 0 for fully opaque window (disabled) to 100 for fully
         * 	transparent background. Values between 0-30 are typically most useful.
         * 
         * 	UI-dependent. Works best with RGB colors. `'termguicolors'` 
         */
        winblend: Option<number>;

        /**
         * `'window'`  `'wi'` 		number  (default screen height - 1)
         * 			global
         * 	Window height used for |CTRL-F| and |CTRL-B| when there is only one
         * 	window and the value is smaller than `'lines'`  minus one.  The screen
         * 	will scroll `'window'`  minus two lines, with a minimum of one.
         * 	When `'window'`  is equal to `'lines'`  minus one CTRL-F and CTRL-B scroll
         * 	in a much smarter way, taking care of wrapping lines.
         * 	When resizing the Vim window, the value is smaller than 1 or more than
         * 	or equal to `'lines'`  it will be set to `'lines'`  minus 1.
         * 	Note: Do not confuse this with the height of the Vim window, use
         * 	`'lines'`  for that.
         */
        window: Option<number>;

        /**
         * `'winfixheight'`  `'wfh'` 	boolean	(default off)
         * 			local to window
         * 	Keep the window height when windows are opened or closed and
         * 	`'equalalways'`  is set.  Also for |CTRL-W_=|.  Set by default for the
         * 	|preview-window| and |quickfix-window|.
         * 	The height may be changed anyway when running out of room.
         */
        winfixheight: Option<boolean>;

        /**
         * `'winfixwidth'`  `'wfw'` 	boolean	(default off)
         * 			local to window
         * 	Keep the window width when windows are opened or closed and
         * 	`'equalalways'`  is set.  Also for |CTRL-W_=|.
         * 	The width may be changed anyway when running out of room.
         */
        winfixwidth: Option<boolean>;

        /**
         * `'winheight'`  `'wh'` 	number	(default 1)
         * 			global
         * 	Minimal number of lines for the current window.  This is not a hard
         * 	minimum, Vim will use fewer lines if there is not enough room.  If the
         * 	focus goes to a window that is smaller, its size is increased, at the
         * 	cost of the height of other windows.
         * 	Set `'winheight'`  to a small number for normal editing.
         * 	Set it to 999 to make the current window fill most of the screen.
         * 	Other windows will be only `'winminheight'`  high.  This has the drawback
         * 	that ":all" will create only two windows.  To avoid "vim -o 1 2 3 4"
         * 	to create only two windows, set the option after startup is done,
         * 	using the |VimEnter| event: >
         * 		au VimEnter * set winheight=999
         * <	Minimum value is 1.
         * 	The height is not adjusted after one of the commands that change the
         * 	height of the current window.
         * 	`'winheight'`  applies to the current window.  Use `'winminheight'`  to set
         * 	the minimal height for other windows.
         */
        winheight: Option<number>;

        /**
         * `'winhighlight'`  `'winhl'` 	string (default empty)
         * 			local to window
         * 	Window-local highlights.  Comma-delimited list of highlight
         * 	|group-name| pairs "{hl-from}:{hl-to},..." where each {hl-from} is
         * 	a |highlight-groups| item to be overridden by {hl-to} group in
         * 	the window.
         * 
         * 	Note: highlight namespaces take precedence over `'winhighlight'` .
         * 	See |nvim_win_set_hl_ns()| and |nvim_set_hl()|.
         * 
         * 	Highlights of vertical separators are determined by the window to the
         * 	left of the separator.  The `'tabline'`  highlight of a tabpage is
         * 	decided by the last-focused window of the tabpage.  Highlights of
         * 	the popupmenu are determined by the current window.  Highlights in the
         * 	message area cannot be overridden.
         * 
         * 	Example: show a different color for non-current windows: >
         * 		set winhighlight=Normal:MyNormal,NormalNC:MyNormalNC
         * <
         */
        winhighlight: MapOption;

        /**
         * `'winminheight'`  `'wmh'` 	number	(default 1)
         * 			global
         * 	The minimal height of a window, when it's not the current window.
         * 	This is a hard minimum, windows will never become smaller.
         * 	When set to zero, windows may be "squashed" to zero lines (i.e. just a
         * 	status bar) if necessary.  They will return to at least one line when
         * 	they become active (since the cursor has to have somewhere to go.)
         * 	Use `'winheight'`  to set the minimal height of the current window.
         * 	This option is only checked when making a window smaller.  Don't use a
         * 	large number, it will cause errors when opening more than a few
         * 	windows.  A value of 0 to 3 is reasonable.
         */
        winminheight: Option<number>;

        /**
         * `'winminwidth'`  `'wmw'` 	number	(default 1)
         * 			global
         * 	The minimal width of a window, when it's not the current window.
         * 	This is a hard minimum, windows will never become smaller.
         * 	When set to zero, windows may be "squashed" to zero columns (i.e. just
         * 	a vertical separator) if necessary.  They will return to at least one
         * 	line when they become active (since the cursor has to have somewhere
         * 	to go.)
         * 	Use `'winwidth'`  to set the minimal width of the current window.
         * 	This option is only checked when making a window smaller.  Don't use a
         * 	large number, it will cause errors when opening more than a few
         * 	windows.  A value of 0 to 12 is reasonable.
         */
        winminwidth: Option<number>;

        /**
         * `'winwidth'`  `'wiw'` 	number	(default 20)
         * 			global
         * 	Minimal number of columns for the current window.  This is not a hard
         * 	minimum, Vim will use fewer columns if there is not enough room.  If
         * 	the current window is smaller, its size is increased, at the cost of
         * 	the width of other windows.  Set it to 999 to make the current window
         * 	always fill the screen.  Set it to a small number for normal editing.
         * 	The width is not adjusted after one of the commands to change the
         * 	width of the current window.
         * 	`'winwidth'`  applies to the current window.  Use `'winminwidth'`  to set
         * 	the minimal width for other windows.
         */
        winwidth: Option<number>;

        /**
         * `'wrap'` 			boolean	(default on)
         * 			local to window
         * 	This option changes how text is displayed.  It doesn't change the text
         * 	in the buffer, see `'textwidth'`  for that.
         * 	When on, lines longer than the width of the window will wrap and
         * 	displaying continues on the next line.  When off lines will not wrap
         * 	and only part of long lines will be displayed.  When the cursor is
         * 	moved to a part that is not shown, the screen will scroll
         * 	horizontally.
         * 	The line will be broken in the middle of a word if necessary.  See
         * 	`'linebreak'`  to get the break at a word boundary.
         * 	To make scrolling horizontally a bit more useful, try this: >
         * 		:set sidescroll=5
         * 		:set listchars+=precedes:<,extends:>
         * <	See `'sidescroll'` , `'listchars'`  and |wrap-off|.
         * 	This option can't be set from a |modeline| when the `'diff'`  option is
         * 	on.
         */
        wrap: Option<boolean>;

        /**
         * `'wrapmargin'`  `'wm'` 	number	(default 0)
         * 			local to buffer
         * 	Number of characters from the right window border where wrapping
         * 	starts.  When typing text beyond this limit, an <EOL> will be inserted
         * 	and inserting continues on the next line.
         * 	Options that add a margin, such as `'number'`  and `'foldcolumn'` , cause
         * 	the text width to be further reduced.
         * 	When `'textwidth'`  is non-zero, this option is not used.
         * 	See also `'formatoptions'`  and |ins-textwidth|.
         */
        wrapmargin: Option<number>;

        /**
         * `'wrapscan'`  `'ws'` 		boolean	(default on)
         * 			global
         * 	Searches wrap around the end of the file.  Also applies to |]s| and
         * 	|[s|, searching for spelling mistakes.
         */
        wrapscan: Option<boolean>;

        /**
         * `'write'` 			boolean	(default on)
         * 			global
         * 	Allows writing files.  When not set, writing a file is not allowed.
         * 	Can be used for a view-only mode, where modifications to the text are
         * 	still allowed.  Can be reset with the |-m| or |-M| command line
         * 	argument.  Filtering text is still possible, even though this requires
         * 	writing a temporary file.
         */
        write: Option<boolean>;

        /**
         * `'writeany'`  `'wa'` 		boolean	(default off)
         * 			global
         * 	Allows writing to any file with no need for "!" override.
         */
        writeany: Option<boolean>;

        /**
         * `'writebackup'`  `'wb'` 	boolean	(default on)
         * 			global
         * 	Make a backup before overwriting a file.  The backup is removed after
         * 	the file was successfully written, unless the `'backup'`  option is
         * 	also on.
         * 	WARNING: Switching this option off means that when Vim fails to write
         * 	your buffer correctly and then, for whatever reason, Vim exits, you
         * 	lose both the original file and what you were writing.  Only reset
         * 	this option if your file system is almost full and it makes the write
         * 	fail (and make sure not to exit Vim until the write was successful).
         * 	See |backup-table| for another explanation.
         * 	When the `'backupskip'`  pattern matches, a backup is not made anyway.
         * 	Depending on `'backupcopy'`  the backup is a new file or the original
         * 	file renamed (and a new file is written).
         */
        writebackup: Option<boolean>;

        writedelay: Option<number>;
    }

    export const opt: opt;
}

declare module vim.keymap {

    type ShortMode = "n" | "i" | "c" | "o" | "v" | "x" | "" | "!";

    /*
     * set({mode}, {lhs}, {rhs}, {opts})
     *     Adds a new |mapping|. Examples: >lua
     *
     *        -- Map to a Lua function:
     *        vim.keymap.set('n', 'lhs', function() print("real lua function") end)
     *        -- Map to multiple modes:
     *        vim.keymap.set({'n', 'v'}, '<leader>lr', vim.lsp.buf.references, { buffer=true })
     *        -- Buffer-local mapping:
     *        vim.keymap.set('n', '<leader>w', "<cmd>w<cr>", { silent = true, buffer = 5 })
     *        -- Expr mapping:
     *        vim.keymap.set('i', '<Tab>', function()
     *          return vim.fn.pumvisible() == 1 and "<C-n>" or "<Tab>"
     *        end, { expr = true })
     *        -- <Plug> mapping:
     *        vim.keymap.set('n', '[%', '<Plug>(MatchitNormalMultiBackward)')
     * <
     *
     *     Parameters: ~
     *       • {mode}  string|table Mode short-name, see |nvim_set_keymap()|. Can
     *                 also be list of modes to create mapping on multiple modes.
     *       • {lhs}   (string) Left-hand side |{lhs}| of the mapping.
     *       • {rhs}   string|function Right-hand side |{rhs}| of the mapping, can be
     *                 a Lua function.
     *       • {opts}  (table|nil) Table of |:map-arguments|.
     *                 • Same as |nvim_set_keymap()| {opts}, except:
     *                   • "replace_keycodes" defaults to `true` if "expr" is `true`.
     *                   • "noremap": inverse of "remap" (see below).
     *
     *                 • Also accepts:
     *                   • "buffer" number|boolean Creates buffer-local mapping, `0`
     *                     or `true` for current buffer.
     *                   • remap: (boolean) Make the mapping recursive. Inverses
     *                     "noremap". Defaults to `false`.
     */
    function set(
        mode: ShortMode | ShortMode[],
        lhs: string,
        rhs: string | Function,
        opts?: {
            /**
             * non-recursive mapping |:noremap|
             */
            noremap?: boolean;

            /**
             * Make the mapping recursive. Inverses "noremap". Defaults to `false`.
             */
            remap?: boolean;

            /**
             * Creates buffer-local mapping, `0` or `true` for current buffer
             */
            buffer?: boolean | number;

            /**
             * "desc" human-readable description.
             */
            desc?: string;

            /**
             * "callback" Lua function called when the mapping is executed.
             */
            callback?: () => void;

            /**
             * "replace_keycodes" (boolean) When "expr" is true, replace
             * keycodes in the resulting string (see
             * |nvim_replace_termcodes()|). Returning nil from the Lua
             * "callback" is equivalent to returning an empty string.
             */
            replace_keycodes?: boolean;

            expr?: boolean;
            silent?: boolean;
        }
    ): void;

    /**
     * del({modes}, {lhs}, {opts})
     *
     *     Remove an existing mapping. Examples: >lua
     *
     *        vim.keymap.del('n', 'lhs')
     *
     *        vim.keymap.del({'n', 'i', 'v'}, '<leader>w', { buffer = 5 })
     * <
     *
     *     Parameters: ~
     *       • {opts}  (table|nil) A table of optional arguments:
     *                 • buffer: (number or boolean) Remove a mapping from the given
     *                   buffer. When "true" or 0, use the current buffer.
     *
     *     See also: ~
     *       • |vim.keymap.set()|
     */
    function del(
        modes: ShortMode | ShortMode[],
        lhs: string,
        opts?: {
            /**
             * Remove a mapping from the given buffer.
             * When "true" or 0, use the current buffer.
             */
            buffer?: number | boolean;
        }
    ): void;
}

declare module vim.diagnostic {
    /**
     * bufnr       buffer number; must be the number of a valid
     *             buffer
     * filename    name of a file; only used when "bufnr" is not
     *             present or it is invalid.
     * module      name of a module; if given it will be used in
     *             quickfix error window instead of the filename.
     * lnum	line   number in the file
     * end_lnum    end of lines, if the item spans multiple lines
     * pattern     search pattern used to locate the error
     * col         column number
     * vcol        when non-zero: "col" is visual column
     *             when zero: "col" is byte index
     * end_col     end column, if the item spans multiple columns
     * nr          error number
     * text        description of the error
     * type        single-character error type, 'E', 'W', etc.
     * valid       recognized error message
     * 
     * The "col", "vcol", "nr", "type" and "text" entries are
     * optional.  Either "lnum" or "pattern" entry can be used to
     * locate a matching error line.
     * If the "filename" and "bufnr" entries are not present or
     * neither the "lnum" or "pattern" entries are present, then the
     * item will not be handled as an error line.
     * If both "pattern" and "lnum" are present then "pattern" will
     * be used.
     * If the "valid" entry is not supplied, then the valid flag is
     * set when "bufnr" is a valid buffer or "filename" exists.
     * If you supply an empty {list}, the quickfix list will be
     * cleared.
     */
    interface QfListItem {
        bufnr?: number;
        filename?: string;
        module?: string;
        lnum?: number
        end_lnum?: number;
        pattern?: string;
        col?: number;
        vcol?: number;
        end_col?: number;
        nr?: number;
        text?: string;
        type?: "E" | "W";
        valid?: string;
    }

    interface OpenFloatOpts {
        bufnr?: number;
        focusable?: boolean;
        namespace?: number;
        scope?: "cursor" | "line" | "buffer" | "c" | "l" | "b";
        pos?: number | [number, number];
        severity_sort?: boolean | {
            reverse?: boolean;
        };
        severity?: DiagnosticSeverity;
        header?: string | [string, string];
        source?: boolean | string;
        format?: (diagnostic: Diagnostic) => string;
        prefix?: string;
        suffix?: string;
    }

    interface GotoDiagnosticOpts {
        namespace?: number;
        cursor_position?: [number, number];
        wrap?: boolean;
        severity?: DiagnosticSeverity;
        float?: boolean | OpenFloatOpts;
        win_id?: number;
    }

    interface DiagnosticConfigOptions {
        virtual_text?: boolean | {
            severity?: number;
            source?: boolean | string;
            spacing?: number;
            prefix?: string;
            suffix?: string;
            format?: (diagnostic: Diagnostic) => string;
        };
        signs?: boolean | {
            severity?: number;
            priority?: number;
        };
        underline?: boolean | {
            severity?: number;
        };
        float?: OpenFloatOpts;
        severity_sort?: boolean | {
            reverse?: boolean;
        };
    }

    interface Diagnostic {
        // Buffer number
        bufnr?: number;
        // The starting line of the diagnostic
        lnum: number;
        // The final line of the diagnostic
        end_lnum?: number;
        // The starting column of the diagnostic
        col: number;
        // The final column of the diagnostic
        end_col?: number;
        // The severity of the diagnostic |vim.diagnostic.severity|
        severity?: DiagnosticSeverity;
        // The diagnostic text
        message: string;
        // The source of the diagnostic
        source?: string;
        // The diagnostic code
        code?: string;
        // Arbitrary data plugins or users can add
        user_data?: any;
    }

    type DiagnosticSeverity = number;

    export const severity: {
        ERROR: 1;
        E: 1;
        WARN: 2;
        W: 2;
        INFO: 3;
        I: 3;
        HINT: 4;
        N: 4;
    }

    export const handlers: {
        [name: string]: {
            show: (namespace: number, bufnr: number, diagnostics: Diagnostic[], opts: DiagnosticConfigOptions) => any,
            hide: (namespace: number, bufnr: number) => any
        }
    };

    /**
     *  Configure diagnostic options globally or for a specific diagnostic
     *  namespace.
     * 
     *  Configuration can be specified globally, per-namespace, or ephemerally
     *  (i.e. only for a single call to |vim.diagnostic.set()| or
     *  |vim.diagnostic.show()|). Ephemeral configuration has highest priority,
     *  followed by namespace configuration, and finally global configuration.
     * 
     *  For example, if a user enables virtual text globally with
     *  <pre>lua
     *    vim.diagnostic.config({ virtual_text = true })
     *  </pre>
     * 
     *  and a diagnostic producer sets diagnostics with
     *  <pre>lua
     *    vim.diagnostic.set(ns, 0, diagnostics, { virtual_text = false })
     *  </pre>
     * 
     *  then virtual text will not be enabled for those diagnostics.
     * 
     * @note Each of the configuration options below accepts one of the following:
     *          - `false`: Disable this feature
     *          - `true`: Enable this feature, use default settings.
     *          - `table`: Enable this feature with overrides. Use an empty table to use default values.
     *          - `function`: Function with signature (namespace, bufnr) that returns any of the above.
     * 
     * @param opts table|nil When omitted or "nil", retrieve the current configuration. Otherwise, a
     *                       configuration table with the following keys:
     *        - underline: (default true) Use underline for diagnostics. Options:
     *                     * severity: Only underline diagnostics matching the given severity
     *                     |diagnostic-severity|
     *        - virtual_text: (default true) Use virtual text for diagnostics. If multiple diagnostics
     *                        are set for a namespace, one prefix per diagnostic + the last diagnostic
     *                        message are shown.
     *                        Options:
     *                        * severity: Only show virtual text for diagnostics matching the given
     *                        severity |diagnostic-severity|
     *                        * source: (boolean or string) Include the diagnostic source in virtual
     *                                  text. Use "if_many" to only show sources if there is more than
     *                                  one diagnostic source in the buffer. Otherwise, any truthy value
     *                                  means to always show the diagnostic source.
     *                        * spacing: (number) Amount of empty spaces inserted at the beginning
     *                                   of the virtual text.
     *                        * prefix: (string) Prepend diagnostic message with prefix.
     *                        * suffix: (string or function) Append diagnostic message with suffix.
     *                                  If a function, it must have the signature (diagnostic) ->
     *                                  string, where {diagnostic} is of type |diagnostic-structure|.
     *                                  This can be used to render an LSP diagnostic error code.
     *                        * format: (function) A function that takes a diagnostic as input and
     *                                  returns a string. The return value is the text used to display
     *                                  the diagnostic. Example:
     *                        <pre>lua
     *                          function(diagnostic)
     *                            if diagnostic.severity == vim.diagnostic.severity.ERROR then
     *                              return string.format("E: %s", diagnostic.message)
     *                            end
     *                            return diagnostic.message
     *                          end
     *                        </pre>
     *        - signs: (default true) Use signs for diagnostics. Options:
     *                 * severity: Only show signs for diagnostics matching the given severity
     *                 |diagnostic-severity|
     *                 * priority: (number, default 10) Base priority to use for signs. When
     *                 {severity_sort} is used, the priority of a sign is adjusted based on
     *                 its severity. Otherwise, all signs use the same priority.
     *        - float: Options for floating windows. See |vim.diagnostic.open_float()|.
     *        - update_in_insert: (default false) Update diagnostics in Insert mode (if false,
     *                            diagnostics are updated on InsertLeave)
     *        - severity_sort: (default false) Sort diagnostics by severity. This affects the order in
     *                          which signs and virtual text are displayed. When true, higher severities
     *                          are displayed before lower severities (e.g. ERROR is displayed before WARN).
     *                          Options:
     *                          * reverse: (boolean) Reverse sort order
     * 
     * @param namespace integer|nil Update the options for the given namespace. When omitted, update the
     *                             global diagnostic options.
     */
    function config(opts?: undefined, namespace?: number): DiagnosticConfigOptions;
    function config(opts: DiagnosticConfigOptions, namespace?: number): void;

    /*
     *  Set diagnostics for the given namespace and buffer.
     * 
     * @param namespace integer The diagnostic namespace
     * @param bufnr integer Buffer number
     * @param diagnostics table A list of diagnostic items |diagnostic-structure|
     * @param opts table|nil Display options to pass to |vim.diagnostic.show()|
     */
    function set(namespace: number, bufnr: number, diagnostics: Diagnostic[], opts?: DiagnosticConfigOptions): void;

    /**
     *  Get namespace metadata.
     * 
     * @param namespace integer Diagnostic namespace
     * @return table Namespace metadata
     */
    function get_namespace(namespace: number): any;

    /**
     *  Get current diagnostic namespaces.
     * 
     * @return table A list of active diagnostic namespaces |vim.diagnostic|.
     */
    function get_namespaces(): number[];


    /**
     *  Get current diagnostics.
     * 
     * @param bufnr integer|nil Buffer number to get diagnostics from. Use 0 for
     *                         current buffer or nil for all buffers.
     * @param opts table|nil A table with the following keys:
     *                         - namespace: (number) Limit diagnostics to the given namespace.
     *                         - lnum: (number) Limit diagnostics to the given line number.
     *                         - severity: See |diagnostic-severity|.
     * @return Diagnostic[] table A list of diagnostic items |diagnostic-structure|.
     */
    function get(bufnr?: number, opts?: { namespace: number, lnum: number, severity: DiagnosticSeverity }): Diagnostic[];

    /**
     *  Get the previous diagnostic closest to the cursor position.
     * 
     * @param opts nil|table See |vim.diagnostic.goto_next()|
     * @return Diagnostic|nil Previous diagnostic
     */
    function get_prev(opts?: GotoDiagnosticOpts): (Diagnostic | undefined);

    /**
     *  Return the position of the previous diagnostic in the current buffer.
     * 
     * @param opts table|nil See |vim.diagnostic.goto_next()|
     * @return table|false Previous diagnostic position as a (row, col) tuple or false if there is no
     *                     prior diagnostic
     */
    function get_prev_pos(opts?: GotoDiagnosticOpts): ([number, number] | false);

    /**
     *  Move to the previous diagnostic in the current buffer.
     * @param opts table|nil See |vim.diagnostic.goto_next()|
     */
    function goto_prev(opts?: GotoDiagnosticOpts): void;

    /**
     *  Get the next diagnostic closest to the cursor position.
     * 
     * @param opts table|nil See |vim.diagnostic.goto_next()|
     * @return Diagnostic|nil Next diagnostic
     */
    function get_next(opts?: GotoDiagnosticOpts): (Diagnostic | undefined);

    /**
     *  Return the position of the next diagnostic in the current buffer.
     * 
     * @param opts table|nil See |vim.diagnostic.goto_next()|
     * @return table|false Next diagnostic position as a (row, col) tuple or false if no next
     *                     diagnostic.
     */
    function get_next_pos(opts?: GotoDiagnosticOpts): ([number, number] | false);

    /**
     *  Move to the next diagnostic.
     * 
     * @param opts table|nil Configuration table with the following keys:
     *          - namespace: (number) Only consider diagnostics from the given namespace.
     *          - cursor_position: (cursor position) Cursor position as a (row, col) tuple. See
     *                           |nvim_win_get_cursor()|. Defaults to the current cursor position.
     *          - wrap: (boolean, default true) Whether to loop around file or not. Similar to 'wrapscan'.
     *          - severity: See |diagnostic-severity|.
     *          - float: (boolean or table, default true) If "true", call |vim.diagnostic.open_float()|
     *                     after moving. If a table, pass the table as the {opts} parameter to
     *                     |vim.diagnostic.open_float()|. Unless overridden, the float will show
     *                     diagnostics at the new cursor position (as if "cursor" were passed to
     *                     the "scope" option).
     *          - win_id: (number, default 0) Window ID
     */
    function goto_next(opts?: GotoDiagnosticOpts): void;

    /**
     *  Hide currently displayed diagnostics.
     * 
     *  This only clears the decorations displayed in the buffer. Diagnostics can
     *  be redisplayed with |vim.diagnostic.show()|. To completely remove
     *  diagnostics, use |vim.diagnostic.reset()|.
     * 
     *  To hide diagnostics and prevent them from re-displaying, use
     *  |vim.diagnostic.disable()|.
     * 
     * @param namespace integer|nil Diagnostic namespace. When omitted, hide
     *                             diagnostics from all namespaces.
     * @param bufnr integer|nil Buffer number, or 0 for current buffer. When
     *                         omitted, hide diagnostics in all buffers.
     */
    function hide(namespace?: number, bufnr?: number): void;

    /**
     *  Check whether diagnostics are disabled in a given buffer.
     * 
     * @param bufnr integer|nil Buffer number, or 0 for current buffer.
     * @param namespace integer|nil Diagnostic namespace. When omitted, checks if
     *                             all diagnostics are disabled in {bufnr}.
     *                             Otherwise, only checks if diagnostics from
     *                             {namespace} are disabled.
     * @return boolean
     */
    function is_disabled(bufnr?: number, namespace?: number): boolean;

    /**
     *  Display diagnostics for the given namespace and buffer.
     * 
     * @param namespace integer|nil Diagnostic namespace. When omitted, show
     *                             diagnostics from all namespaces.
     * @param bufnr integer|nil Buffer number, or 0 for current buffer. When omitted, show
     *                         diagnostics in all buffers.
     * @param diagnostics table|nil The diagnostics to display. When omitted, use the
     *                              saved diagnostics for the given namespace and
     *                              buffer. This can be used to display a list of diagnostics
     *                              without saving them or to display only a subset of
     *                              diagnostics. May not be used when {namespace}
     *                              or {bufnr} is nil.
     * @param opts table|nil Display options. See |vim.diagnostic.config()|.
     */
    function show(namespace?: number, bufnr?: number, diagnostics?: Diagnostic[], opts?: DiagnosticConfigOptions): void;

    /**
     *  Show diagnostics in a floating window.
     * 
     * @param opts table|nil Configuration table with the same keys as
     *             |vim.lsp.util.open_floating_preview()| in addition to the following:
     *             - bufnr: (number) Buffer number to show diagnostics from.
     *                      Defaults to the current buffer.
     *             - namespace: (number) Limit diagnostics to the given namespace
     *             - scope: (string, default "line") Show diagnostics from the whole buffer ("buffer"),
     *                      the current cursor line ("line"), or the current cursor position ("cursor").
     *                      Shorthand versions are also accepted ("c" for "cursor", "l" for "line", "b"
     *                      for "buffer").
     *             - pos: (number or table) If {scope} is "line" or "cursor", use this position rather
     *                    than the cursor position. If a number, interpreted as a line number;
     *                    otherwise, a (row, col) tuple.
     *             - severity_sort: (default false) Sort diagnostics by severity. Overrides the setting
     *                              from |vim.diagnostic.config()|.
     *             - severity: See |diagnostic-severity|. Overrides the setting from
     *                         |vim.diagnostic.config()|.
     *             - header: (string or table) String to use as the header for the floating window. If a
     *                       table, it is interpreted as a [text, hl_group] tuple. Overrides the setting
     *                       from |vim.diagnostic.config()|.
     *             - source: (boolean or string) Include the diagnostic source in the message.
     *                       Use "if_many" to only show sources if there is more than one source of
     *                       diagnostics in the buffer. Otherwise, any truthy value means to always show
     *                       the diagnostic source. Overrides the setting from
     *                       |vim.diagnostic.config()|.
     *             - format: (function) A function that takes a diagnostic as input and returns a
     *                       string. The return value is the text used to display the diagnostic.
     *                       Overrides the setting from |vim.diagnostic.config()|.
     *             - prefix: (function, string, or table) Prefix each diagnostic in the floating
     *                       window. If a function, it must have the signature (diagnostic, i,
     *                       total) -> (string, string), where {i} is the index of the diagnostic
     *                       being evaluated and {total} is the total number of diagnostics
     *                       displayed in the window. The function should return a string which
     *                       is prepended to each diagnostic in the window as well as an
     *                       (optional) highlight group which will be used to highlight the
     *                       prefix. If {prefix} is a table, it is interpreted as a [text,
     *                       hl_group] tuple as in |nvim_echo()|; otherwise, if {prefix} is a
     *                       string, it is prepended to each diagnostic in the window with no
     *                       highlight.
     *                       Overrides the setting from |vim.diagnostic.config()|.
     *             - suffix: Same as {prefix}, but appends the text to the diagnostic instead of
     *                       prepending it. Overrides the setting from |vim.diagnostic.config()|.
     * @return integer|nil, integer|nil: ({float_bufnr}, {win_id})
     */
    function open_float(opts: OpenFloatOpts, ...vargs: any[]): [number | undefined, number | undefined];

    /**
     *  Remove all diagnostics from the given namespace.
     * 
     *  Unlike |vim.diagnostic.hide()|, this function removes all saved
     *  diagnostics. They cannot be redisplayed using |vim.diagnostic.show()|. To
     *  simply remove diagnostic decorations in a way that they can be
     *  re-displayed, use |vim.diagnostic.hide()|.
     * 
     * @param namespace integer|nil Diagnostic namespace. When omitted, remove
     *                             diagnostics from all namespaces.
     * @param bufnr integer|nil Remove diagnostics for the given buffer. When omitted,
     *              diagnostics are removed for all buffers.
     */
    function reset(namespace?: number, bufnr?: number): void;

    /**
     *  Add all diagnostics to the quickfix list.
     * 
     * @param opts table|nil Configuration table with the following keys:
     *          - namespace: (number) Only add diagnostics from the given namespace.
     *          - open: (boolean, default true) Open quickfix list after setting.
     *          - title: (string) Title of quickfix list. Defaults to "Diagnostics".
     *          - severity: See |diagnostic-severity|.
     */
    function setqflist(opts?: {
        namespace?: number;
        open?: boolean;
        title?: string;
        severity?: DiagnosticSeverity;
    }): void;

    /**
     *  Add buffer diagnostics to the location list.
     * 
     * @param opts table|nil Configuration table with the following keys:
     *          - namespace: (number) Only add diagnostics from the given namespace.
     *          - winnr: (number, default 0) Window number to set location list for.
     *          - open: (boolean, default true) Open the location list after setting.
     *          - title: (string) Title of the location list. Defaults to "Diagnostics".
     *          - severity: See |diagnostic-severity|.
     */
    function setloclist(opts?: {
        namespace?: number;
        winnr?: number;
        open?: boolean;
        title?: string;
        severity?: DiagnosticSeverity;
    }): void;

    /**
     *  Disable diagnostics in the given buffer.
     * 
     * @param bufnr integer|nil Buffer number, or 0 for current buffer. When
     *                         omitted, disable diagnostics in all buffers.
     * @param namespace integer|nil Only disable diagnostics for the given namespace.
     */
    function disable(bufnr?: number, namespace?: number): void;

    /**
     *  Enable diagnostics in the given buffer.
     * 
     * @param bufnr integer|nil Buffer number, or 0 for current buffer. When
     *                         omitted, enable diagnostics in all buffers.
     * @param namespace integer|nil Only enable diagnostics for the given namespace.
     */
    function enable(bufnr?: number, namespace?: number): void;

    /**
     *  Parse a diagnostic from a string.
     * 
     *  For example, consider a line of output from a linter:
     *  <pre>
     *  WARNING filename:27:3: Variable 'foo' does not exist
     *  </pre>
     * 
     *  This can be parsed into a diagnostic |diagnostic-structure|
     *  with:
     *  <pre>lua
     *    local s = "WARNING filename:27:3: Variable 'foo' does not exist"
     *    local pattern = "^(%w+) %w+:(%d+):(%d+): (.+)$"
     *    local groups = { "severity", "lnum", "col", "message" }
     *    vim.diagnostic.match(s, pattern, groups, { WARNING = vim.diagnostic.WARN })
     *  </pre>
     * 
     * @param str string String to parse diagnostics from.
     * @param pat string Lua pattern with capture groups.
     * @param groups table List of fields in a |diagnostic-structure| to
     *                     associate with captures from {pat}.
     * @param severity_map table A table mapping the severity field from {groups}
     *                           with an item from |vim.diagnostic.severity|.
     * @param defaults table|nil Table of default values for any fields not listed in {groups}.
     *                           When omitted, numeric values default to 0 and "severity" defaults to
     *                           ERROR.
     * @return Diagnostic|nil: |diagnostic-structure| or `nil` if {pat} fails to match {str}.
     */
    function match(
        str: string,
        pat: string,
        groups: Partial<Diagnostic>[],
        severity_map: { [key in DiagnosticSeverity]?: DiagnosticSeverity },
        defaults?: Partial<Diagnostic>
    ): Diagnostic | undefined;

    /**
     *  Convert a list of diagnostics to a list of quickfix items that can be
     *  passed to |setqflist()| or |setloclist()|.
     * 
     * @param diagnostics table List of diagnostics |diagnostic-structure|.
     * @return table[] of quickfix list items |setqflist-what|
     */
    function toqflist(diagnostics: Diagnostic[]): QfListItem[];

    /**
     *  Convert a list of quickfix items to a list of diagnostics.
     * 
     * @param list table A list of quickfix items from |getqflist()| or
     *             |getloclist()|.
     *
     * @return Diagnostic[] array of |diagnostic-structure|
     */
    function fromqflist(list: QfListItem[]): Diagnostic[];
}

declare module vim.json {
    /**
     * Decodes (or "unpacks") the JSON-encoded {str} to a Lua object.
     * 
     * {opts} is a table with the key `luanil = { object: bool, array: bool }`
     * that controls whether `null` in JSON objects or arrays should be converted
     * to Lua `nil` instead of `vim.NIL`.
     */
    function decode<T>(str: string, opts?: {luanil?: {object?: boolean, array?: boolean}}): T;

    /**
     * Encodes (or "packs") Lua object {obj} as JSON in a Lua string.
     */
    function encode(obj: any): string;
}

declare module vim.mpack {
    /**
     * Decodes (or "unpacks") the msgpack-encoded {str} to a Lua object.
     */
    function decode<T>(str: string): T;

    /**
     * Encodes (or "packs") Lua object {obj} as msgpack in a Lua string.
     */
    function encode(obj: any): string;
}

declare module vim.fs {
    type Iterator = LuaIterable<LuaMultiReturn<[string | undefined, string | undefined]>>;

    /**
     *  Iterate over all the parents of the given file or directory.
     * 
     *  Example:
     *  <pre>lua
     *  local root_dir
     *  for dir in vim.fs.parents(vim.api.nvim_buf_get_name(0)) do
     *    if vim.fn.isdirectory(dir .. "/.git") == 1 then
     *      root_dir = dir
     *      break
     *    end
     *  end
     * 
     *  if root_dir then
     *    print("Found git repository at", root_dir)
     *  end
     *  </pre>
     * 
     * @param start (string) Initial file or directory.
     * @return (function) Iterator
     */
    function parents(start: string): Iterator;

    /**
     *  Return the parent directory of the given file or directory
     * 
     * @param file (string) File or directory
     * @return (string) Parent directory of {file}
     */
    function dirname(file: string): string;

    /**
     *  Return the basename of the given file or directory
     * 
     * @param file (string) File or directory
     * @return (string) Basename of {file}
     */
    function basename(file: string): string

    /**
     * Return an iterator over the files and directories located in {path}
     * 
     * @param path (string) An absolute or relative path to the directory to iterate
     *             over. The path is first normalized |vim.fs.normalize()|.
     * @param opts table|nil Optional keyword arguments:
     *              - depth: integer|nil How deep the traverse (default 1)
     *              - skip: (fun(dir_name: string): boolean)|nil Predicate
     *                to control traversal. Return false to stop searching the current directory.
     *                Only useful when depth > 1
     * 
     * @return Iterator over files and directories in {path}. Each iteration yields
     *         two values: name and type. Each "name" is the basename of the file or
     *         directory relative to {path}. Type is one of "file" or "directory".
     */
    function dir(path: string, opts?: { depth?: number, skip?: (dir_name: string) => boolean }): Iterator;

    /**
     *  Find files or directories in the given path.
     * 
     *  Finds any files or directories given in {names} starting from {path}. If
     *  {upward} is "true" then the search traverses upward through parent
     *  directories; otherwise, the search traverses downward. Note that downward
     *  searches are recursive and may search through many directories! If {stop}
     *  is non-nil, then the search stops when the directory given in {stop} is
     *  reached. The search terminates when {limit} (default 1) matches are found.
     *  The search can be narrowed to find only files or only directories by
     *  specifying {type} to be "file" or "directory", respectively.
     * 
     *  Examples:
     *  <pre>lua
     *  -- location of Cargo.toml from the current buffer's path
     *  local cargo = vim.fs.find('Cargo.toml', {
     *    upward = true,
     *    stop = vim.loop.os_homedir(),
     *    path = vim.fs.dirname(vim.api.nvim_buf_get_name(0)),
     *  })
     * 
     *  -- list all test directories under the runtime directory
     *  local test_dirs = vim.fs.find(
     *    {'test', 'tst', 'testdir'},
     *    {limit = math.huge, type = 'directory', path = './runtime/'}
     *  )
     * 
     *  -- get all files ending with .cpp or .hpp inside lib/
     *  local cpp_hpp = vim.fs.find(function(name, path)
     *    return name:match('.*%.[ch]pp$') and path:match('[/\\\\]lib$')
     *  end, {limit = math.huge, type = 'file'})
     *  </pre>
     * 
     * @param names (string|table|fun(name: string, path: string): boolean) Names of the files
     *              and directories to find.
     *              Must be base names, paths and globs are not supported when {names} is a string or a table.
     *              If {names} is a function, it is called for each traversed file and directory with args:
     *              - name: base name of the current item
     *              - path: full path of the current item
     *              The function should return `true` if the given file or directory is considered a match.
     * @return (table) Normalized paths |vim.fs.normalize()| of all matching files or directories
     */
    function find(names: string | string[] | ((name: string, path: string) => boolean), opts?: {
        /**
         * - path (string): Path to begin searching from. If
         *        omitted, the |current-directory| is used.
         */
        path?: string;

        /**
         * - upward (boolean, default false): If true, search
         *          upward through parent directories. Otherwise,
         *          search through child directories
         *          (recursively).
         */
        upward?: boolean;

        /**
         * - stop (string): Stop searching when this directory is
         *        reached. The directory itself is not searched.
         */
        stop?: string;

        /**
         * - type (string): Find only files ("file") or
         *        directories ("directory"). If omitted, both
         *        files and directories that match {names} are
         *        included.
         */
        type?: "file" | "directory";

        /**
         * - limit (number, default 1): Stop the search after
         *         finding this many matches. Use `math.huge` to
         *         place no limit on the number of matches.
         */
        limit?: number;
    }): string[];

    //  Normalize a path to a standard format. A tilde (~) character at the
    //  beginning of the path is expanded to the user's home directory and any
    //  backslash (\\) characters are converted to forward slashes (/). Environment
    //  variables are also expanded.
    // 
    //  Examples:
    //  <pre>lua
    //    vim.fs.normalize('C:\\\\Users\\\\jdoe')
    //    --> 'C:/Users/jdoe'
    // 
    //    vim.fs.normalize('~/src/neovim')
    //    --> '/home/jdoe/src/neovim'
    // 
    //    vim.fs.normalize('$XDG_CONFIG_HOME/nvim/init.vim')
    //    --> '/Users/jdoe/.config/nvim/init.vim'
    //  </pre>
    // 
    // @param path (string) Path to normalize
    // @param opts table|nil Options:
    //              - expand_env: boolean Expand environment variables (default: true)
    // @return (string) Normalized path
    function normalize(path: string, opts?: {
        /**
         * Expand environment variables (default: true)
         */
        expand_env?: boolean;
    }): string;
}

declare namespace vim.spell {
    /**
     * Check {str} for spelling errors. Similar to the Vimscript function
     * |spellbadword()|.
     * 
     * Note: The behaviour of this function is dependent on: 'spelllang',
     * 'spellfile', 'spellcapcheck' and 'spelloptions' which can all be local to
     * the buffer. Consider calling this with |nvim_buf_call()|.
     * 
     * Example: 
     * ```lua
     *     vim.spell.check("the quik brown fox")
     *     -- =>
     *     -- {
     *     --     {'quik', 'bad', 5}
     *     -- }
     * ```
     * Parameters: ~
     *   • {str}    String to spell check.
     * 
     * Return: ~
     *   List of tuples with three items:
     *     - The badly spelled word.
     *     - The type of the spelling error:
     *         "bad"   spelling mistake
     *         "rare"  rare word
     *         "local" word only valid in another region
     *         "caps"  word should start with Capital
     *     - The position in {str} where the word begins.
     */
    function check(str: string): [string, "bad" | "rare" | "local" | "caps", number][];
}

/**
 *  @brief The \`vim.version\` module provides functions for comparing versions and ranges
 *  conforming to the https://semver.org spec. Plugins, and plugin managers, can use this to check
 *  available tools and dependencies on the current system.
 * 
 *  Example:
 *    <pre>lua
 *    local v = vim.version.parse(vim.fn.system({'tmux', '-V'}), {strict=false})
 *    if vim.version.gt(v, {3, 2, 0}) then
 *      -- ...
 *    end
 *    </pre>
 * 
 *  \*vim.version()\* returns the version of the current Nvim process.
 * 
 *  VERSION RANGE SPEC \*version-range\*
 * 
 *  A version "range spec" defines a semantic version range which can be tested against a version,
 *  using |vim.version.range()|.
 * 
 *  Supported range specs are shown in the following table.
 *  Note: suffixed versions (1.2.3-rc1) are not matched.
 *    <pre>
 *    1.2.3             is 1.2.3
 *    =1.2.3            is 1.2.3
 *    >1.2.3            greater than 1.2.3
 *    <1.2.3            before 1.2.3
 *    >=1.2.3           at least 1.2.3
 *    ~1.2.3            is >=1.2.3 <1.3.0       "reasonably close to 1.2.3"
 *    ^1.2.3            is >=1.2.3 <2.0.0       "compatible with 1.2.3"
 *    ^0.2.3            is >=0.2.3 <0.3.0       (0.x.x is special)
 *    ^0.0.1            is =0.0.1               (0.0.x is special)
 *    ^1.2              is >=1.2.0 <2.0.0       (like ^1.2.0)
 *    ~1.2              is >=1.2.0 <1.3.0       (like ~1.2.0)
 *    ^1                is >=1.0.0 <2.0.0       "compatible with 1"
 *    ~1                same                    "reasonably close to 1"
 *    1.x               same
 *    1.*               same
 *    1                 same
 *    *                 any version
 *    x                 same
 * 
 *    1.2.3 - 2.3.4     is >=1.2.3 <=2.3.4
 * 
 *    Partial right: missing pieces treated as x (2.3 => 2.3.x).
 *    1.2.3 - 2.3       is >=1.2.3 <2.4.0
 *    1.2.3 - 2         is >=1.2.3 <3.0.0
 * 
 *    Partial left: missing pieces treated as 0 (1.2 => 1.2.0).
 *    1.2 - 2.3.0       is 1.2.0 - 2.3.0
 *    </pre>
 */
declare module vim.version {
    interface Version {
        1: number;
        2: number;
        3: number;
        major: number;
        minor: number;
        patch: number;
        prerelease?: string;
        build?: string;
    }

    /**
     * TODO: generalize this, move to func.lua
     * 
     * @generic T: Version
     * @param versions T[]
     * @return T?
     */
    function last<T extends Version>(versions: T[]): T | undefined;

    interface Range {
        from: Version;
        to?: Version;
    }

    /**
     *  Parses a semver |version-range| "spec" and returns a range object:
     *    <pre>
     *    {
     *      from: Version
     *      to: Version
     *      has(v: string|Version)
     *    }
     *    </pre>
     * 
     *  `:has()` checks if a version is in the range (inclusive `from`, exclusive `to`). Example:
     *    <pre>lua
     *    local r = vim.version.range('1.0.0 - 2.0.0')
     *    print(r:has('1.9.9'))  -- true
     *    print(r:has('2.0.0'))  -- false
     *    </pre>
     * 
     *  Or use cmp(), eq(), lt(), and gt() to compare `.to` and `.from` directly:
     *    <pre>lua
     *    local r = vim.version.range('1.0.0 - 2.0.0')
     *    print(vim.version.gt({1,0,3}, r.from) and vim.version.lt({1,0,3}, r.to))
     *    </pre>
     * 
     *  @see # https://github.com/npm/node-semver#ranges
     * 
     *  @param spec string Version range "spec"
     */
    function range(spec: string): Range //  Adapted from https://github.com/folke/lazy.nvim

    /**
     *  Parses and compares two version version objects (the result of |vim.version.parse()|, or
     *  specified literally as a `{major, minor, patch}` tuple, e.g. `{1, 0, 3}`).
     * 
     *  Example:
     *  <pre>lua
     *    if vim.version.cmp({1,0,3}, {0,2,1}) == 0 then
     *      -- ...
     *    end
     *    local v1 = vim.version.parse('1.0.3-pre')
     *    local v2 = vim.version.parse('0.2.1')
     *    if vim.version.cmp(v1, v2) == 0 then
     *      -- ...
     *    end
     *  </pre>
     * 
     *  @note Per semver, build metadata is ignored when comparing two otherwise-equivalent versions.
     * 
     * @param v1 Version|number[] Version object.
     * @param v2 Version|number[] Version to compare with `v1`.
     * @return integer -1 if `v1 < v2`, 0 if `v1 == v2`, 1 if `v1 > v2`.
     */
    function cmp(v1: Version | number[], v2: Version | number[]): -1 | 0 | 1;

    /**
     * Returns `true` if the given versions are equal. See |vim.version.cmp()| for usage.
     * @param v1 Version|number[]
     * @param v2 Version|number[]
     * @return boolean
     */
    function eq(v1: Version | number[], v2: Version | number[]): boolean;

    /**
     * Returns `true` if `v1 < v2`. See |vim.version.cmp()| for usage.
     * @param v1 Version|number[]
     * @param v2 Version|number[]
     * @return boolean
     */
    function lt(v1: Version | number[], v2: Version | number[]): boolean;

    /**
     * Returns `true` if `v1 > v2`. See |vim.version.cmp()| for usage.
     * @param v1 Version|number[]
     * @param v2 Version|number[]
     * @return boolean
     */
    function gt(v1: Version | number[], v2: Version | number[]): boolean;

    /**
     *  Parses a semantic version string and returns a version object which can be used with other
     *  `vim.version` functions. For example "1.0.1-rc1+build.2" returns:
     *  <pre>
     *    { major = 1, minor = 0, patch = 1, prerelease = "rc1", build = "build.2" }
     *  </pre>
     * 
     *  @see # https://semver.org/spec/v2.0.0.html
     * 
     * @param version string Version string to parse.
     * @param opts table|nil Optional keyword arguments:
     *                       - strict (boolean):  Default false. If `true`, no coercion is attempted on
     *                       input not conforming to semver v2.0.0. If `false`, `parse()` attempts to
     *                       coerce input such as "1.0", "0-x", "tmux 3.2a" into valid versions.
     * @return table|nil parsed_version Version object or `nil` if input is invalid.
     */
    function parse(version: string, opts?: { strict?: boolean }): Version | undefined;
}

declare module vim.ui {
    /**
     *  Prompts the user to pick from a list of items, allowing arbitrary (potentially asynchronous)
     *  work until `on_choice`.
     * 
     * @param items table Arbitrary items
     * @param opts table Additional options
     *      - prompt (string|nil)
     *                Text of the prompt. Defaults to `Select one of:`
     *      - format_item (function item -> text)
     *                Function to format an
     *                individual item from `items`. Defaults to `tostring`.
     *      - kind (string|nil)
     *                Arbitrary hint string indicating the item shape.
     *                Plugins reimplementing `vim.ui.select` may wish to
     *                use this to infer the structure or semantics of
     *                `items`, or the context in which select() was called.
     * @param on_choice function ((item|nil, idx|nil) -> ())
     *                Called once the user made a choice.
     *                `idx` is the 1-based index of `item` within `items`.
     *                `nil` if the user aborted the dialog.
     * 
     * 
     *  Example:
     *  <pre>lua
     *  vim.ui.select({ 'tabs', 'spaces' }, {
     *      prompt = 'Select tabs or spaces:',
     *      format_item = function(item)
     *          return "I'd like to choose " .. item
     *      end,
     *  }, function(choice)
     *      if choice == 'spaces' then
     *          vim.o.expandtab = true
     *      else
     *          vim.o.expandtab = false
     *      end
     *  end)
     *  </pre>
     */
    function select<T>(
        items: T[],
        opts: {
            prompt?: string;
            format_item?: (item: T) => string;
            kind?: string;
        },
        on_choice: (item?: T, idx?: number) => void
    )

    /**
     *  Prompts the user for input, allowing arbitrary (potentially asynchronous) work until
     *  `on_confirm`.
     * 
     * @param opts table Additional options. See |input()|
     *      - prompt (string|nil)
     *                Text of the prompt
     *      - default (string|nil)
     *                Default reply to the input
     *      - completion (string|nil)
     *                Specifies type of completion supported
     *                for input. Supported types are the same
     *                that can be supplied to a user-defined
     *                command using the "-complete=" argument.
     *                See |:command-completion|
     *      - highlight (function)
     *                Function that will be used for highlighting
     *                user inputs.
     * @param on_confirm function ((input|nil) -> ())
     *                Called once the user confirms or abort the input.
     *                `input` is what the user typed (it might be
     *                an empty string if nothing was entered), or
     *                `nil` if the user aborted the dialog.
     * 
     *  Example:
     *  <pre>lua
     *  vim.ui.input({ prompt = 'Enter value for shiftwidth: ' }, function(input)
     *      vim.o.shiftwidth = tonumber(input)
     *  end)
     *  </pre>
     */
    function input(
        opts: {
            prompt?: string;
            default?: string;
            completion?: string;
            highlight?: (...args: any[]) => any;
        },
        on_confirm: (input?: string) => void
    ): void;
}

declare module vim.highlight {
    export const priorities: {
        syntax: number;
        treesitter: number;
        semantic_tokens: number;
        diagnostics: number;
        user: number;
    }

    /**
     *  Highlight range between two positions
     * 
     * @param bufnr integer Buffer number to apply highlighting to
     * @param ns integer Namespace to add highlight to
     * @param higroup string Highlight group to use for highlighting
     * @param start { [1]: integer, [2]: integer } Start position {line, col}
     * @param finish { [1]: integer, [2]: integer } Finish position {line, col}
     * @param opts table|nil Optional parameters
     *              - regtype type of range (see |setreg()|, default charwise)
     *              - inclusive boolean indicating whether the range is end-inclusive (default false)
     *              - priority number indicating priority of highlight (default priorities.user)
     */
    function range(bufnr: number, ns: number, higroup: string, start: [number, number], finish: [number, number], opts?: {
        /**
         * type of range (see |setreg()|, default charwise)
         */
        regtype?: string;

        /**
         * indicating whether the range is end-inclusive (default false)
         */
        inclusive?: boolean;

        /**
         * indicating priority of highlight (default priorities.user)
         */
        priority?: number;
    }): void;

    /**
     *  Highlight the yanked region
     * 
     *  use from init.vim via
     *    au TextYankPost * lua vim.highlight.on_yank()
     *  customize highlight group and timeout via
     *    au TextYankPost * lua vim.highlight.on_yank {higroup="IncSearch", timeout=150}
     *  customize conditions (here: do not highlight a visual selection) via
     *    au TextYankPost * lua vim.highlight.on_yank {on_visual=false}
     * 
     *  @param opts table|nil Optional parameters
     *               - higroup   highlight group for yanked region (default "IncSearch")
     *               - timeout   time in ms before highlight is cleared (default 150)
     *               - on_macro  highlight when executing macro (default false)
     *               - on_visual highlight when yanking visual selection (default true)
     *               - event     event structure (default vim.v.event)
     */
    function on_yank(opts?: {
        /**
         * highlight group for yanked region (default "IncSearch")
         */
        higroup?: string;

        /**
         * time in ms before highlight is cleared (default 150)
         */
        timeout?: number;

        /**
         * highlight when executing macro (default false)
         */
        on_macro?: boolean;

        /**
         ** - on_visual highlight when yanking visual selection (default true)
         */
        on_visual?: boolean;

        /**
         ** - event     event structure (default vim.v.event)
         */
        event: any;
    }): void;
}

declare module vim.api {

    type AutocommandEvent = "BufAdd" | "BufDelete" | "BufEnter" | "BufFilePost" | "BufFilePre" | "BufHidden" | "BufLeave" | "BufModifiedSet" | "BufNew" | "BufNewFile" | "BufRead" | "BufReadPost" | "BufReadCmd" | "BufReadPre" | "BufUnload" | "BufWinEnter" | "BufWinLeave" | "BufWipeout" | "BufWrite" | "BufWriteCmd" | "BufWritePost" | "ChanInfo" | "ChanOpen" | "CmdUndefined" | "CmdlineChanged" | "CmdlineEnter" | "CmdlineLeave" | "CmdwinEnter" | "CmdwinLeave" | "ColorScheme" | "ColorSchemePre" | "CompleteChanged" | "CompleteDonePre" | "CompleteDone" | "CursorHold" | "CursorHoldI" | "CursorMoved" | "CursorMovedI" | "DiffUpdated" | "DirChanged" | "DirChangedPre" | "ExitPre" | "FileAppendCmd" | "FileAppendPost" | "FileAppendPre" | "FileChangedRO" | "FileChangedShell" | "FileChangedShellPost" | "FileReadCmd" | "FileReadPost" | "FileReadPre" | "FileType" | "FileWriteCmd" | "FileWritePost" | "FileWritePre" | "FilterReadPost" | "FilterReadPre" | "FilterWritePost" | "FilterWritePre" | "FocusGained" | "FocusLost" | "FuncUndefined" | "UIEnter" | "UILeave" | "InsertChange" | "InsertCharPre" | "InsertEnter" | "InsertLeavePre" | "InsertLeave" | "MenuPopup" | "ModeChanged" | "OptionSet" | "QuickFixCmdPre" | "QuickFixCmdPost" | "QuitPre" | "RemoteReply" | "SearchWrapped" | "RecordingEnter" | "RecordingLeave" | "SessionLoadPost" | "ShellCmdPost" | "Signal" | "ShellFilterPost" | "SourcePre" | "SourcePost" | "SourceCmd" | "SpellFileMissing" | "StdinReadPost" | "StdinReadPre" | "SwapExists" | "Syntax" | "TabEnter" | "TabLeave" | "TabNew" | "TabNewEntered" | "TabClosed" | "TermOpen" | "TermEnter" | "TermLeave" | "TermClose" | "TermResponse" | "TextChanged" | "TextChangedI" | "TextChangedP" | "TextChangedT" | "TextYankPost" | "User" | "UserGettingBored" | "VimEnter" | "VimLeave" | "VimLeavePre" | "VimResized" | "VimResume" | "VimSuspend" | "WinClosed" | "WinEnter" | "WinLeave" | "WinNew" | "WinScrolled" | "WinResized";

    interface AutocommandCallbackData {
        /**
         * autocommand id
         */
        id: number;

        /**
         * name of the triggered event |autocmd-events|.
         */
        event: string;

        /**
         * autocommand group id, if any
         */
        group?: number;

        /**
         * expanded value of |<amatch>|
         */
        match: string;

        /**
         * expanded value of |<abuf>|
         */
        buf: number;

        /**
         * expanded value of |<afile>|
         */
        file: string;

        /**
         * arbitrary data passed from |nvim_exec_autocmds()|.
         */
        data: any;
    }

    interface CreateAutocommandOpts {
        /**
         * autocommand group name or id to match against.
         */
        group?: string | number;

        /**
         * pattern(s) to match literally.
         */
        pattern?: string | string[];

        /**
         * buffer number for buffer-local autocommands |autocmd-buflocal|. Cannot be used with {pattern}.
         */
        buffer?: number;

        /**
         * description (for documentation and troubleshooting).
         */
        desc?: string;

        /**
         * Lua function (or Vimscript function name, if string) called when the
         * event(s) is triggered. Lua callback can return true to delete the
         * autocommand.
         */
        callback?: (data: AutocommandCallbackData) => (boolean | void) | string

        /**
         * Vim command to execute on event. Cannot be used with {callback}.
         */
        command?: string;

        /**
         * defaults to false. Run the autocommand only once |autocmd-once|.
         */
        once?: boolean;

        /**
         * defaults to false. Run nested autocommands |autocmd-nested|.
         */
        nested?: boolean;
    }



    function nvim__buf_redraw_range(buffer: number, first: number, last: number): any;

    function nvim__buf_stats(buffer: number): any;

    function nvim__get_lib_dir(): any;

    /**
     * Find files in runtime directories
     * 
     * Attributes: ~
     *     |api-fast|
     * 
     * Parameters: ~
     *   • {pat}   pattern of files to search for
     *   • {all}   whether to return all matches or only the first
     *   • {opts}  is_lua: only search lua subdirs
     * 
     * Return: ~
     *     list of absolute paths to the found files
     */
    function nvim__get_runtime(pat: any, all: any, opts?: { [key: string]: any }): any;

    /**
     * Returns object given as argument.
     * 
     * This API function is used for testing. One should not rely on its presence
     * in plugins.
     * 
     * Parameters: ~
     *   • {obj}  Object to return.
     * 
     * Return: ~
     *     its argument.
     */
    function nvim__id(obj: any): any;

    /**
     * Returns array given as argument.
     * 
     * This API function is used for testing. One should not rely on its presence
     * in plugins.
     * 
     * Parameters: ~
     *   • {arr}  Array to return.
     * 
     * Return: ~
     *     its argument.
     */
    function nvim__id_array(arr: any): any;

    /**
     * Returns dictionary given as argument.
     * 
     * This API function is used for testing. One should not rely on its presence
     * in plugins.
     * 
     * Parameters: ~
     *   • {dct}  Dictionary to return.
     * 
     * Return: ~
     *     its argument.
     */
    function nvim__id_dictionary(dct: any): any;

    /**
     * Returns floating-point value given as argument.
     * 
     * This API function is used for testing. One should not rely on its presence
     * in plugins.
     * 
     * Parameters: ~
     *   • {flt}  Value to return.
     * 
     * Return: ~
     *     its argument.
     */
    function nvim__id_float(flt: any): any;

    /**
     * NB: if your UI doesn't use hlstate, this will not return hlstate first
     * time.
     */
    function nvim__inspect_cell(grid: any, row: any, col: number): any;

    function nvim__runtime_inspect(): any;

    function nvim__screenshot(path: string): any;

    /**
     * Gets internal stats.
     * 
     * Return: ~
     *     Map of various internal stats.
     */
    function nvim__stats(): any;

    function nvim__unpack(str: string): any;

    /**
     * Adds a highlight to buffer.
     * 
     * Useful for plugins that dynamically generate highlights to a buffer (like
     * a semantic highlighter or linter). The function adds a single highlight to
     * a buffer. Unlike |matchaddpos()| highlights follow changes to line
     * numbering (as lines are inserted/removed above the highlighted line), like
     * signs and marks do.
     * 
     * Namespaces are used for batch deletion/updating of a set of highlights. To
     * create a namespace, use |nvim_create_namespace()| which returns a
     * namespace id. Pass it in to this function as `ns_id` to add highlights to
     * the namespace. All highlights in the same namespace can then be cleared
     * with single call to |nvim_buf_clear_namespace()|. If the highlight never
     * will be deleted by an API call, pass `ns_id = -1`.
     * 
     * As a shorthand, `ns_id = 0` can be used to create a new namespace for the
     * highlight, the allocated id is then returned. If `hl_group` is the empty
     * string no highlight is added, but a new `ns_id` is still returned. This is
     * supported for backwards compatibility, new code should use
     * |nvim_create_namespace()| to create a new empty namespace.
     * 
     * Parameters: ~
     *   • {buffer}     Buffer handle, or 0 for current buffer
     *   • {ns_id}      namespace to use or -1 for ungrouped highlight
     *   • {hl_group}   Name of the highlight group to use
     *   • {line}       Line to highlight (zero-indexed)
     *   • {col_start}  Start of (byte-indexed) column range to highlight
     *   • {col_end}    End of (byte-indexed) column range to highlight, or -1 to
     *                  highlight to end of line
     * 
     * Return: ~
     *     The ns_id that was used
     */
    function nvim_buf_add_highlight(buffer: number, ns_id: number, hl_group: string, line: number, col_start: number, col_end: number): number;

    /**
     * Activates buffer-update events on a channel, or as Lua callbacks.
     * 
     * Example (Lua): capture buffer updates in a global `events` variable (use "print(vim.inspect(events))" to see its contents): 
     * ```lua
     *   events = {}
     *   vim.api.nvim_buf_attach(0, false, {
     *     on_lines=function(...) table.insert(events, {...}) end})
     * ```
     * 
     * Parameters: ~
     *   • {buffer}       Buffer handle, or 0 for current buffer
     *   • {send_buffer}  True if the initial notification should contain the
     *                    whole buffer: first notification will be
     *                    `nvim_buf_lines_event`. Else the first notification
     *                    will be `nvim_buf_changedtick_event`. Not for Lua
     *                    callbacks.
     *   • {opts}         Optional parameters.
     *                    • on_lines: Lua callback invoked on change. Return `true` to detach. Args:
     *                      • the string "lines"
     *                      • buffer handle
     *                      • b:changedtick
     *                      • first line that changed (zero-indexed)
     *                      • last line that was changed
     *                      • last line in the updated range
     *                      • byte count of previous contents
     *                      • deleted_codepoints (if `utf_sizes` is true)
     *                      • deleted_codeunits (if `utf_sizes` is true)
     * 
     *                    • on_bytes: lua callback invoked on change. This
     *                      callback receives more granular information about the
     *                      change compared to on_lines. Return `true` to detach. Args:
     *                      • the string "bytes"
     *                      • buffer handle
     *                      • b:changedtick
     *                      • start row of the changed text (zero-indexed)
     *                      • start column of the changed text
     *                      • byte offset of the changed text (from the start of
     *                        the buffer)
     *                      • old end row of the changed text
     *                      • old end column of the changed text
     *                      • old end byte length of the changed text
     *                      • new end row of the changed text
     *                      • new end column of the changed text
     *                      • new end byte length of the changed text
     * 
     *                    • on_changedtick: Lua callback invoked on changedtick
     *                      increment without text change. Args:
     *                      • the string "changedtick"
     *                      • buffer handle
     *                      • b:changedtick
     * 
     *                    • on_detach: Lua callback invoked on detach. Args:
     *                      • the string "detach"
     *                      • buffer handle
     * 
     *                    • on_reload: Lua callback invoked on reload. The entire
     *                      buffer content should be considered changed. Args:
     *                      • the string "reload"
     *                      • buffer handle
     * 
     *                    • utf_sizes: include UTF-32 and UTF-16 size of the
     *                      replaced region, as args to `on_lines`.
     *                    • preview: also attach to command preview (i.e.
     *                      'inccommand') events.
     * 
     * Return: ~
     *     False if attach failed (invalid parameter, or buffer isn't loaded);
     *     otherwise True. TODO: LUA_API_NO_EVAL
     * 
     * See also: ~
     *   • |nvim_buf_detach()|
     *   • |api-buffer-updates-lua|
     */
    function nvim_buf_attach(buffer: number, send_buffer: boolean, opts: { [key: string]: any }): boolean;

    /**
     * call a function with buffer as temporary current buffer
     * 
     * This temporarily switches current buffer to "buffer". If the current
     * window already shows "buffer", the window is not switched If a window
     * inside the current tabpage (including a float) already shows the buffer
     * One of these windows will be set as current window temporarily. Otherwise
     * a temporary scratch window (called the "autocmd window" for historical
     * reasons) will be used.
     * 
     * This is useful e.g. to call vimL functions that only work with the current
     * buffer/window currently, like |termopen()|.
     * 
     * Attributes: ~
     *     Lua |vim.api| only
     * 
     * Parameters: ~
     *   • {buffer}  Buffer handle, or 0 for current buffer
     *   • {fun}     Function to call inside the buffer (currently lua callable
     *               only)
     * 
     * Return: ~
     *     Return value of function. NB: will deepcopy lua values currently, use
     *     upvalues to send lua references in and out.
     */
    function nvim_buf_call(buffer: number, fun: Function): object;

    /**
     * Clears |namespace|d objects (highlights, |extmarks|, virtual text) from a
     * region.
     * 
     * Lines are 0-indexed. |api-indexing| To clear the namespace in the entire
     * buffer, specify line_start=0 and line_end=-1.
     * 
     * Parameters: ~
     *   • {buffer}      Buffer handle, or 0 for current buffer
     *   • {ns_id}       Namespace to clear, or -1 to clear all namespaces.
     *   • {line_start}  Start of range of lines to clear
     *   • {line_end}    End of range of lines to clear (exclusive) or -1 to
     *                   clear to end of buffer.
     */
    function nvim_buf_clear_namespace(buffer: number, ns_id: number, line_start: number, line_end: number): void;

    /**
     * Creates a buffer-local command |user-commands|.
     * 
     * Parameters: ~
     *   • {buffer}  Buffer handle, or 0 for current buffer.
     * 
     * See also: ~
     *   • nvim_create_user_command
     */
    function nvim_buf_create_user_command(buffer: number, name: string, command: object, opts?: { [key: string]: any }): void;

    /**
     * Removes an |extmark|.
     * 
     * Parameters: ~
     *   • {buffer}  Buffer handle, or 0 for current buffer
     *   • {ns_id}   Namespace id from |nvim_create_namespace()|
     *   • {id}      Extmark id
     * 
     * Return: ~
     *     true if the extmark was found, else false
     */
    function nvim_buf_del_extmark(buffer: number, ns_id: number, id: number): boolean;

    /**
     * Unmaps a buffer-local |mapping| for the given mode.
     * 
     * Parameters: ~
     *   • {buffer}  Buffer handle, or 0 for current buffer
     * 
     * See also: ~
     *   • |nvim_del_keymap()|
     */
    function nvim_buf_del_keymap(buffer: number, mode: string, lhs: string): void;

    /**
     * Deletes a named mark in the buffer. See |mark-motions|.
     * 
     * Note:
     *     only deletes marks set in the buffer, if the mark is not set in the
     *     buffer it will return false.
     * 
     * Parameters: ~
     *   • {buffer}  Buffer to set the mark on
     *   • {name}    Mark name
     * 
     * Return: ~
     *     true if the mark was deleted, else false.
     * 
     * See also: ~
     *   • |nvim_buf_set_mark()|
     *   • |nvim_del_mark()|
     */
    function nvim_buf_del_mark(buffer: number, name: string): boolean;

    /**
     * Delete a buffer-local user-defined command.
     * 
     * Only commands created with |:command-buffer| or
     * |nvim_buf_create_user_command()| can be deleted with this function.
     * 
     * Parameters: ~
     *   • {buffer}  Buffer handle, or 0 for current buffer.
     *   • {name}    Name of the command to delete.
     */
    function nvim_buf_del_user_command(buffer: number, name: string): void;

    /**
     * Removes a buffer-scoped (b:) variable
     * 
     * Parameters: ~
     *   • {buffer}  Buffer handle, or 0 for current buffer
     *   • {name}    Variable name
     */
    function nvim_buf_del_var(buffer: number, name: string): void;

    /**
     * Deletes the buffer. See |:bwipeout|
     * 
     * Attributes: ~
     *     not allowed when |textlock| is active
     * 
     * Parameters: ~
     *   • {buffer}  Buffer handle, or 0 for current buffer
     *   • {opts}    Optional parameters. Keys:
     *               • force: Force deletion and ignore unsaved changes.
     *               • unload: Unloaded only, do not delete. See |:bunload|
     */
    function nvim_buf_delete(buffer: number, opts: { [key: string]: any }): void;

    /**
     * Gets a changed tick of a buffer
     * 
     * Parameters: ~
     *   • {buffer}  Buffer handle, or 0 for current buffer
     * 
     * Return: ~
     *     `b:changedtick` value.
     */
    function nvim_buf_get_changedtick(buffer: number): number;

    /**
     * Gets a map of buffer-local |user-commands|.
     * 
     * Parameters: ~
     *   • {buffer}  Buffer handle, or 0 for current buffer
     *   • {opts}    Optional parameters. Currently not used.
     * 
     * Return: ~
     *     Map of maps describing commands.
     */
    function nvim_buf_get_commands(buffer: number, opts?: { [key: string]: any }): { [key: string]: any };

    /**
     * Gets the position (0-indexed) of an |extmark|.
     * 
     * Parameters: ~
     *   • {buffer}  Buffer handle, or 0 for current buffer
     *   • {ns_id}   Namespace id from |nvim_create_namespace()|
     *   • {id}      Extmark id
     *   • {opts}    Optional parameters. Keys:
     *               • details: Whether to include the details dict
     *               • hl_name: Whether to include highlight group name instead
     *                 of id, true if omitted
     * 
     * Return: ~
     *     0-indexed (row, col) tuple or empty list () if extmark id was absent
     */
    function nvim_buf_get_extmark_by_id(buffer: number, ns_id: number, id: number, opts: { [key: string]: any }): any[];

    /**
     * Gets |extmarks| in "traversal order" from a |charwise| region defined by
     * buffer positions (inclusive, 0-indexed |api-indexing|).
     * 
     * Region can be given as (row,col) tuples, or valid extmark ids (whose
     * positions define the bounds). 0 and -1 are understood as (0,0) and (-1,-1)
     * respectively, thus the following are equivalent: 
     * ```lua
     *   vim.api.nvim_buf_get_extmarks(0, my_ns, 0, -1, {})
     *   vim.api.nvim_buf_get_extmarks(0, my_ns, {0,0}, {-1,-1}, {})
     * ```
     * 
     * If `end` is less than `start`, traversal works backwards. (Useful with
     * `limit`, to get the first marks prior to a given position.)
     * 
     * Example: 
     * ```lua
     *   local api = vim.api
     *   local pos = api.nvim_win_get_cursor(0)
     *   local ns  = api.nvim_create_namespace('my-plugin')
     *   -- Create new extmark at line 1, column 1.
     *   local m1  = api.nvim_buf_set_extmark(0, ns, 0, 0, {})
     *   -- Create new extmark at line 3, column 1.
     *   local m2  = api.nvim_buf_set_extmark(0, ns, 2, 0, {})
     *   -- Get extmarks only from line 3.
     *   local ms  = api.nvim_buf_get_extmarks(0, ns, {2,0}, {2,0}, {})
     *   -- Get all marks in this buffer + namespace.
     *   local all = api.nvim_buf_get_extmarks(0, ns, 0, -1, {})
     *   print(vim.inspect(ms))
     * ```
     * 
     * Parameters: ~
     *   • {buffer}  Buffer handle, or 0 for current buffer
     *   • {ns_id}   Namespace id from |nvim_create_namespace()| or -1 for all
     *               namespaces
     *   • {start}   Start of range: a 0-indexed (row, col) or valid extmark id
     *               (whose position defines the bound). |api-indexing|
     *   • {end}     End of range (inclusive): a 0-indexed (row, col) or valid
     *               extmark id (whose position defines the bound).
     *               |api-indexing|
     *   • {opts}    Optional parameters. Keys:
     *               • limit: Maximum number of marks to return
     *               • details: Whether to include the details dict
     *               • hl_name: Whether to include highlight group name instead
     *                 of id, true if omitted
     *               • type: Filter marks by type: "highlight", "sign",
     *                 "virt_text" and "virt_lines"
     * 
     * Return: ~
     *     List of [extmark_id, row, col] tuples in "traversal order".
     */
    function nvim_buf_get_extmarks(buffer: number, ns_id: number, start: object, end: object, opts: { [key: string]: any }): any[];

    /**
     * Gets a list of buffer-local |mapping| definitions.
     * 
     * Parameters: ~
     *   • {mode}    Mode short-name ("n", "i", "v", ...)
     *   • {buffer}  Buffer handle, or 0 for current buffer
     * 
     * Return: ~
     *     Array of |maparg()|-like dictionaries describing mappings. The
     *     "buffer" key holds the associated buffer handle.
     */
    function nvim_buf_get_keymap(buffer: number, mode: string): any[];

    /**
     * Gets a line-range from the buffer.
     * 
     * Indexing is zero-based, end-exclusive. Negative indices are interpreted as
     * length+1+index: -1 refers to the index past the end. So to get the last
     * element use start=-2 and end=-1.
     * 
     * Out-of-bounds indices are clamped to the nearest valid value, unless
     * `strict_indexing` is set.
     * 
     * Parameters: ~
     *   • {buffer}           Buffer handle, or 0 for current buffer
     *   • {start}            First line index
     *   • {end}              Last line index, exclusive
     *   • {strict_indexing}  Whether out-of-bounds should be an error.
     * 
     * Return: ~
     *     Array of lines, or empty array for unloaded buffer.
     */
    function nvim_buf_get_lines(buffer: number, start: number, end: number, strict_indexing: boolean): string[];

    /**
     * Returns a tuple (row,col) representing the position of the named mark. See
     * |mark-motions|.
     * 
     * Marks are (1,0)-indexed. |api-indexing|
     * 
     * Parameters: ~
     *   • {buffer}  Buffer handle, or 0 for current buffer
     *   • {name}    Mark name
     * 
     * Return: ~
     *     (row, col) tuple, (0, 0) if the mark is not set, or is an
     *     uppercase/file mark set in another buffer.
     * 
     * See also: ~
     *   • |nvim_buf_set_mark()|
     *   • |nvim_buf_del_mark()|
     */
    function nvim_buf_get_mark(buffer: number, name: string): number[];

    /**
     * Gets the full file name for the buffer
     * 
     * Parameters: ~
     *   • {buffer}  Buffer handle, or 0 for current buffer
     * 
     * Return: ~
     *     Buffer name
     */
    function nvim_buf_get_name(buffer: number): string;

    /**
     * Returns the byte offset of a line (0-indexed). |api-indexing|
     * 
     * Line 1 (index=0) has offset 0. UTF-8 bytes are counted. EOL is one byte.
     * 'fileformat' and 'fileencoding' are ignored. The line index just after the
     * last line gives the total byte-count of the buffer. A final EOL byte is
     * counted if it would be written, see 'eol'.
     * 
     * Unlike |line2byte()|, throws error for out-of-bounds indexing. Returns -1
     * for unloaded buffer.
     * 
     * Parameters: ~
     *   • {buffer}  Buffer handle, or 0 for current buffer
     *   • {index}   Line index
     * 
     * Return: ~
     *     Integer byte offset, or -1 for unloaded buffer.
     */
    function nvim_buf_get_offset(buffer: number, index: number): number;

    /**
     * Gets a buffer option value
     * 
     * Parameters: ~
     *   • {buffer}  Buffer handle, or 0 for current buffer
     *   • {name}    Option name
     * 
     * Return: ~
     *     Option value
     */
    function nvim_buf_get_option(buffer: number, name: string): object;

    /**
     * Gets a range from the buffer.
     * 
     * This differs from |nvim_buf_get_lines()| in that it allows retrieving only
     * portions of a line.
     * 
     * Indexing is zero-based. Row indices are end-inclusive, and column indices
     * are end-exclusive.
     * 
     * Prefer |nvim_buf_get_lines()| when retrieving entire lines.
     * 
     * Parameters: ~
     *   • {buffer}     Buffer handle, or 0 for current buffer
     *   • {start_row}  First line index
     *   • {start_col}  Starting column (byte offset) on first line
     *   • {end_row}    Last line index, inclusive
     *   • {end_col}    Ending column (byte offset) on last line, exclusive
     *   • {opts}       Optional parameters. Currently unused.
     * 
     * Return: ~
     *     Array of lines, or empty array for unloaded buffer.
     */
    function nvim_buf_get_text(buffer: number, start_row: number, start_col: number, end_row: number, end_col: number, opts: { [key: string]: any }): string[];

    /**
     * Gets a buffer-scoped (b:) variable.
     * 
     * Parameters: ~
     *   • {buffer}  Buffer handle, or 0 for current buffer
     *   • {name}    Variable name
     * 
     * Return: ~
     *     Variable value
     */
    function nvim_buf_get_var(buffer: number, name: string): object;

    /**
     * Checks if a buffer is valid and loaded. See |api-buffer| for more info
     * about unloaded buffers.
     * 
     * Parameters: ~
     *   • {buffer}  Buffer handle, or 0 for current buffer
     * 
     * Return: ~
     *     true if the buffer is valid and loaded, false otherwise.
     */
    function nvim_buf_is_loaded(buffer: number): boolean;

    /**
     * Checks if a buffer is valid.
     * 
     * Note:
     *     Even if a buffer is valid it may have been unloaded. See |api-buffer|
     *     for more info about unloaded buffers.
     * 
     * Parameters: ~
     *   • {buffer}  Buffer handle, or 0 for current buffer
     * 
     * Return: ~
     *     true if the buffer is valid, false otherwise.
     */
    function nvim_buf_is_valid(buffer: number): boolean;

    /**
     * Returns the number of lines in the given buffer.
     * 
     * Parameters: ~
     *   • {buffer}  Buffer handle, or 0 for current buffer
     * 
     * Return: ~
     *     Line count, or 0 for unloaded buffer. |api-buffer|
     */
    function nvim_buf_line_count(buffer: number): number;

    /**
     * Creates or updates an |extmark|.
     * 
     * By default a new extmark is created when no id is passed in, but it is
     * also possible to create a new mark by passing in a previously unused id or
     * move an existing mark by passing in its id. The caller must then keep
     * track of existing and unused ids itself. (Useful over RPC, to avoid
     * waiting for the return value.)
     * 
     * Using the optional arguments, it is possible to use this to highlight a
     * range of text, and also to associate virtual text to the mark.
     * 
     * Parameters: ~
     *   • {buffer}  Buffer handle, or 0 for current buffer
     *   • {ns_id}   Namespace id from |nvim_create_namespace()|
     *   • {line}    Line where to place the mark, 0-based. |api-indexing|
     *   • {col}     Column where to place the mark, 0-based. |api-indexing|
     *   • {opts}    Optional parameters.
     *               • id : id of the extmark to edit.
     *               • end_row : ending line of the mark, 0-based inclusive.
     *               • end_col : ending col of the mark, 0-based exclusive.
     *               • hl_group : name of the highlight group used to highlight
     *                 this mark.
     *               • hl_eol : when true, for a multiline highlight covering the
     *                 EOL of a line, continue the highlight for the rest of the
     *                 screen line (just like for diff and cursorline highlight).
     *               • virt_text : virtual text to link to this mark. A list of
     *                 [text, highlight] tuples, each representing a text chunk
     *                 with specified highlight. `highlight` element can either
     *                 be a single highlight group, or an array of multiple
     *                 highlight groups that will be stacked (highest priority
     *                 last). A highlight group can be supplied either as a
     *                 string or as an integer, the latter which can be obtained
     *                 using |nvim_get_hl_id_by_name()|.
     *               • virt_text_pos : position of virtual text. Possible values:
     *                 • "eol": right after eol character (default)
     *                 • "overlay": display over the specified column, without
     *                   shifting the underlying text.
     *                 • "right_align": display right aligned in the window.
     * 
     *               • virt_text_win_col : position the virtual text at a fixed
     *                 window column (starting from the first text column)
     *               • virt_text_hide : hide the virtual text when the background
     *                 text is selected or hidden due to horizontal scroll
     *                 'nowrap'
     *               • hl_mode : control how highlights are combined with the
     *                 highlights of the text. Currently only affects virt_text
     *                 highlights, but might affect `hl_group` in later versions.
     *                 • "replace": only show the virt_text color. This is the
     *                   default
     *                 • "combine": combine with background text color
     *                 • "blend": blend with background text color.
     * 
     *               • virt_lines : virtual lines to add next to this mark This
     *                 should be an array over lines, where each line in turn is
     *                 an array over [text, highlight] tuples. In general, buffer
     *                 and window options do not affect the display of the text.
     *                 In particular 'wrap' and 'linebreak' options do not take
     *                 effect, so the number of extra screen lines will always
     *                 match the size of the array. However the 'tabstop' buffer
     *                 option is still used for hard tabs. By default lines are
     *                 placed below the buffer line containing the mark.
     *               • virt_lines_above: place virtual lines above instead.
     *               • virt_lines_leftcol: Place extmarks in the leftmost column
     *                 of the window, bypassing sign and number columns.
     *               • ephemeral : for use with |nvim_set_decoration_provider()|
     *                 callbacks. The mark will only be used for the current
     *                 redraw cycle, and not be permantently stored in the
     *                 buffer.
     *               • right_gravity : boolean that indicates the direction the
     *                 extmark will be shifted in when new text is inserted (true
     *                 for right, false for left). Defaults to true.
     *               • end_right_gravity : boolean that indicates the direction
     *                 the extmark end position (if it exists) will be shifted in
     *                 when new text is inserted (true for right, false for
     *                 left). Defaults to false.
     *               • priority: a priority value for the highlight group or sign
     *                 attribute. For example treesitter highlighting uses a
     *                 value of 100.
     *               • strict: boolean that indicates extmark should not be
     *                 placed if the line or column value is past the end of the
     *                 buffer or end of the line respectively. Defaults to true.
     *               • sign_text: string of length 1-2 used to display in the
     *                 sign column. Note: ranges are unsupported and decorations
     *                 are only applied to start_row
     *               • sign_hl_group: name of the highlight group used to
     *                 highlight the sign column text. Note: ranges are
     *                 unsupported and decorations are only applied to start_row
     *               • number_hl_group: name of the highlight group used to
     *                 highlight the number column. Note: ranges are unsupported
     *                 and decorations are only applied to start_row
     *               • line_hl_group: name of the highlight group used to
     *                 highlight the whole line. Note: ranges are unsupported and
     *                 decorations are only applied to start_row
     *               • cursorline_hl_group: name of the highlight group used to
     *                 highlight the line when the cursor is on the same line as
     *                 the mark and 'cursorline' is enabled. Note: ranges are
     *                 unsupported and decorations are only applied to start_row
     *               • conceal: string which should be either empty or a single
     *                 character. Enable concealing similar to |:syn-conceal|.
     *                 When a character is supplied it is used as |:syn-cchar|.
     *                 "hl_group" is used as highlight for the cchar if provided,
     *                 otherwise it defaults to |hl-Conceal|.
     *               • spell: boolean indicating that spell checking should be
     *                 performed within this extmark
     *               • ui_watched: boolean that indicates the mark should be
     *                 drawn by a UI. When set, the UI will receive win_extmark
     *                 events. Note: the mark is positioned by virt_text
     *                 attributes. Can be used together with virt_text.
     * 
     * Return: ~
     *     Id of the created/updated extmark
     */
    function nvim_buf_set_extmark(buffer: number, ns_id: number, line: number, col: number, opts?: { [key: string]: any }): number;

    /**
     * Sets a buffer-local |mapping| for the given mode.
     * 
     * Parameters: ~
     *   • {buffer}  Buffer handle, or 0 for current buffer
     * 
     * See also: ~
     *   • |nvim_set_keymap()|
     */
    function nvim_buf_set_keymap(buffer: number, mode: string, lhs: string, rhs: string, opts?: { [key: string]: any }): void;

    /**
     * Sets (replaces) a line-range in the buffer.
     * 
     * Indexing is zero-based, end-exclusive. Negative indices are interpreted as
     * length+1+index: -1 refers to the index past the end. So to change or
     * delete the last element use start=-2 and end=-1.
     * 
     * To insert lines at a given index, set `start` and `end` to the same index.
     * To delete a range of lines, set `replacement` to an empty array.
     * 
     * Out-of-bounds indices are clamped to the nearest valid value, unless
     * `strict_indexing` is set.
     * 
     * Attributes: ~
     *     not allowed when |textlock| is active
     * 
     * Parameters: ~
     *   • {buffer}           Buffer handle, or 0 for current buffer
     *   • {start}            First line index
     *   • {end}              Last line index, exclusive
     *   • {strict_indexing}  Whether out-of-bounds should be an error.
     *   • {replacement}      Array of lines to use as replacement
     * 
     * See also: ~
     *   • |nvim_buf_set_text()|
     */
    function nvim_buf_set_lines(buffer: number, start: number, end: number, strict_indexing: boolean, replacement: string[]): void;

    /**
     * Sets a named mark in the given buffer, all marks are allowed
     * file/uppercase, visual, last change, etc. See |mark-motions|.
     * 
     * Marks are (1,0)-indexed. |api-indexing|
     * 
     * Note:
     *     Passing 0 as line deletes the mark
     * 
     * Parameters: ~
     *   • {buffer}  Buffer to set the mark on
     *   • {name}    Mark name
     *   • {line}    Line number
     *   • {col}     Column/row number
     *   • {opts}    Optional parameters. Reserved for future use.
     * 
     * Return: ~
     *     true if the mark was set, else false.
     * 
     * See also: ~
     *   • |nvim_buf_del_mark()|
     *   • |nvim_buf_get_mark()|
     */
    function nvim_buf_set_mark(buffer: number, name: string, line: number, col: number, opts: { [key: string]: any }): boolean;

    /**
     * Sets the full file name for a buffer
     * 
     * Parameters: ~
     *   • {buffer}  Buffer handle, or 0 for current buffer
     *   • {name}    Buffer name
     */
    function nvim_buf_set_name(buffer: number, name: string): void;

    /**
     * Sets a buffer option value. Passing `nil` as value deletes the option
     * (only works if there's a global fallback)
     * 
     * Parameters: ~
     *   • {buffer}  Buffer handle, or 0 for current buffer
     *   • {name}    Option name
     *   • {value}   Option value
     */
    function nvim_buf_set_option(buffer: number, name: string, value: object): void;

    /**
     * Sets (replaces) a range in the buffer
     * 
     * This is recommended over |nvim_buf_set_lines()| when only modifying parts
     * of a line, as extmarks will be preserved on non-modified parts of the
     * touched lines.
     * 
     * Indexing is zero-based. Row indices are end-inclusive, and column indices
     * are end-exclusive.
     * 
     * To insert text at a given `(row, column)` location, use `start_row =
     * end_row = row` and `start_col = end_col = col`. To delete the text in a
     * range, use `replacement = {}`.
     * 
     * Prefer |nvim_buf_set_lines()| if you are only adding or deleting entire
     * lines.
     * 
     * Parameters: ~
     *   • {buffer}       Buffer handle, or 0 for current buffer
     *   • {start_row}    First line index
     *   • {start_col}    Starting column (byte offset) on first line
     *   • {end_row}      Last line index, inclusive
     *   • {end_col}      Ending column (byte offset) on last line, exclusive
     *   • {replacement}  Array of lines to use as replacement
     * 
     * See also: ~
     *   • |nvim_buf_set_lines()|
     */
    function nvim_buf_set_text(buffer: number, start_row: number, start_col: number, end_row: number, end_col: number, replacement: string[]): void;

    /**
     * Sets a buffer-scoped (b:) variable
     * 
     * Parameters: ~
     *   • {buffer}  Buffer handle, or 0 for current buffer
     *   • {name}    Variable name
     *   • {value}   Variable value
     */
    function nvim_buf_set_var(buffer: number, name: string, value: object): void;

    /**
     * Calls a VimL |Dictionary-function| with the given arguments.
     * 
     * On execution error: fails with VimL error, updates v:errmsg.
     * 
     * Parameters: ~
     *   • {dict}  Dictionary, or String evaluating to a VimL |self| dict
     *   • {fn}    Name of the function defined on the VimL dict
     *   • {args}  Function arguments packed in an Array
     * 
     * Return: ~
     *     Result of the function call
     */
    function nvim_call_dict_function(dict: object, fn: string, args: any[]): object;

    /**
     * Calls a VimL function with the given arguments.
     * 
     * On execution error: fails with VimL error, updates v:errmsg.
     * 
     * Parameters: ~
     *   • {fn}    Function to call
     *   • {args}  Function arguments packed in an Array
     * 
     * Return: ~
     *     Result of the function call
     */
    function nvim_call_function(fn: string, args: any[]): object;

    /**
     * Send data to channel `id`. For a job, it writes it to the stdin of the
     * process. For the stdio channel |channel-stdio|, it writes to Nvim's
     * stdout. For an internal terminal instance (|nvim_open_term()|) it writes
     * directly to terminal output. See |channel-bytes| for more information.
     * 
     * This function writes raw data, not RPC messages. If the channel was
     * created with `rpc=true` then the channel expects RPC messages, use
     * |vim.rpcnotify()| and |vim.rpcrequest()| instead.
     * 
     * Attributes: ~
     *     |RPC| only
     *     Lua |vim.api| only
     * 
     * Parameters: ~
     *   • {chan}  id of the channel
     *   • {data}  data to write. 8-bit clean: can contain NUL bytes.
     */
    function nvim_chan_send(chan: number, data: string): void;

    /**
     * Clear all autocommands that match the corresponding {opts}. To delete a
     * particular autocmd, see |nvim_del_autocmd()|.
     * 
     * Parameters: ~
     *   • {opts}  Parameters
     *             • event: (string|table) Examples:
     *               • event: "pat1"
     *               • event: { "pat1" }
     *               • event: { "pat1", "pat2", "pat3" }
     * 
     *             • pattern: (string|table)
     *               • pattern or patterns to match exactly.
     *                 • For example, if you have `*.py` as that pattern for the
     *                   autocmd, you must pass `*.py` exactly to clear it.
     *                   `test.py` will not match the pattern.
     * 
     *               • defaults to clearing all patterns.
     *               • NOTE: Cannot be used with {buffer}
     * 
     *             • buffer: (bufnr)
     *               • clear only |autocmd-buflocal| autocommands.
     *               • NOTE: Cannot be used with {pattern}
     * 
     *             • group: (string|int) The augroup name or id.
     *               • NOTE: If not passed, will only delete autocmds not in any group.
     */
    function nvim_clear_autocmds(opts?: { [key: string]: any }): void;

    /**
     * Executes an Ex command.
     * 
     * Unlike |nvim_command()| this command takes a structured Dictionary instead
     * of a String. This allows for easier construction and manipulation of an Ex
     * command. This also allows for things such as having spaces inside a
     * command argument, expanding filenames in a command that otherwise doesn't
     * expand filenames, etc. Command arguments may also be Number, Boolean or
     * String.
     * 
     * The first argument may also be used instead of count for commands that
     * support it in order to make their usage simpler with |vim.cmd()|. For
     * example, instead of `vim.cmd.bdelete{ count = 2 }`, you may do
     * `vim.cmd.bdelete(2)`.
     * 
     * On execution error: fails with VimL error, updates v:errmsg.
     * 
     * Parameters: ~
     *   • {cmd}   Command to execute. Must be a Dictionary that can contain the
     *             same values as the return value of |nvim_parse_cmd()| except
     *             "addr", "nargs" and "nextcmd" which are ignored if provided.
     *             All values except for "cmd" are optional.
     *   • {opts}  Optional parameters.
     *             • output: (boolean, default false) Whether to return command
     *               output.
     * 
     * Return: ~
     *     Command output (non-error, non-shell |:!|) if `output` is true, else
     *     empty string.
     * 
     * See also: ~
     *   • |nvim_exec2()|
     *   • |nvim_command()|
     */
    function nvim_cmd(cmd?: { [key: string]: any }, opts?: { [key: string]: any }): string;

    /**
     * Executes an Ex command.
     * 
     * On execution error: fails with VimL error, updates v:errmsg.
     * 
     * Prefer using |nvim_cmd()| or |nvim_exec2()| over this. To evaluate
     * multiple lines of Vim script or an Ex command directly, use
     * |nvim_exec2()|. To construct an Ex command using a structured format and
     * then execute it, use |nvim_cmd()|. To modify an Ex command before
     * evaluating it, use |nvim_parse_cmd()| in conjunction with |nvim_cmd()|.
     * 
     * Parameters: ~
     *   • {command}  Ex command string
     */
    function nvim_command(command: string): void;

    /**
     * Create or get an autocommand group |autocmd-groups|.
     * 
     * To get an existing group id, do: 
     * ```lua
     *     local id = vim.api.nvim_create_augroup("MyGroup", {
     *         clear = false
     *     })
     * ```
     * 
     * Parameters: ~
     *   • {name}  String: The name of the group
     *   • {opts}  Dictionary Parameters
     *             • clear (bool) optional: defaults to true. Clear existing
     *               commands if the group already exists |autocmd-groups|.
     * 
     * Return: ~
     *     Integer id of the created group.
     * 
     * See also: ~
     *   • |autocmd-groups|
     */
    function nvim_create_augroup(name: string, opts?: { [key: string]: any }): number;

    /**
     * Creates an |autocommand| event handler, defined by `callback` (Lua function or Vimscript function name string) or `command` (Ex command string).
     * 
     * Example using Lua callback: 
     * ```lua
     *     vim.api.nvim_create_autocmd({"BufEnter", "BufWinEnter"}, {
     *       pattern = {"*.c", "*.h"},
     *       callback = function(ev)
     *         print(string.format('event fired: s', vim.inspect(ev)))
     *       end
     *     })
     * ```
     * 
     * Example using an Ex command as the handler: 
     * ```lua
     *     vim.api.nvim_create_autocmd({"BufEnter", "BufWinEnter"}, {
     *       pattern = {"*.c", "*.h"},
     *       command = "echo 'Entering a C or C++ file'",
     *     })
     * ```
     * 
     * Note: `pattern` is NOT automatically expanded (unlike with |:autocmd|), thus names like
     * "$HOME" and "~" must be expanded explicitly: 
     * ```lua
     *   pattern = vim.fn.expand("~") .. "/some/path/*.py"
     * ```
     * 
     * Parameters: ~
     *   • {event}  (string|array) Event(s) that will trigger the handler
     *              (`callback` or `command`).
     *   • {opts}   Options dict:
     *              • group (string|integer) optional: autocommand group name or
     *                id to match against.
     *              • pattern (string|array) optional: pattern(s) to match
     *                literally |autocmd-pattern|.
     *              • buffer (integer) optional: buffer number for buffer-local
     *                autocommands |autocmd-buflocal|. Cannot be used with
     *                {pattern}.
     *              • desc (string) optional: description (for documentation and
     *                troubleshooting).
     *              • callback (function|string) optional: Lua function (or
     *                Vimscript function name, if string) called when the
     *                event(s) is triggered. Lua callback can return true to
     *                delete the autocommand, and receives a table argument with
     *                these keys:
     *                • id: (number) autocommand id
     *                • event: (string) name of the triggered event
     *                  |autocmd-events|
     *                • group: (number|nil) autocommand group id, if any
     *                • match: (string) expanded value of |<amatch>|
     *                • buf: (number) expanded value of |<abuf>|
     *                • file: (string) expanded value of |<afile>|
     *                • data: (any) arbitrary data passed from
     *                  |nvim_exec_autocmds()|
     * 
     *              • command (string) optional: Vim command to execute on event.
     *                Cannot be used with {callback}
     *              • once (boolean) optional: defaults to false. Run the
     *                autocommand only once |autocmd-once|.
     *              • nested (boolean) optional: defaults to false. Run nested
     *                autocommands |autocmd-nested|.
     * 
     * Return: ~
     *     Autocommand id (number)
     * 
     * See also: ~
     *   • |autocommand|
     *   • |nvim_del_autocmd()|
     */
    function nvim_create_autocmd(event: string | string[], opts?: CreateAutocommandOpts): number;

    /**
     * Creates a new, empty, unnamed buffer.
     * 
     * Parameters: ~
     *   • {listed}   Sets 'buflisted'
     *   • {scratch}  Creates a "throwaway" |scratch-buffer| for temporary work
     *                (always 'nomodified'). Also sets 'nomodeline' on the
     *                buffer.
     * 
     * Return: ~
     *     Buffer handle, or 0 on error
     * 
     * See also: ~
     *   • buf_open_scratch
     */
    function nvim_create_buf(listed: boolean, scratch: boolean): number;

    /**
     * Creates a new namespace or gets an existing one.
     * 
     * Namespaces are used for buffer highlights and virtual text, see
     * |nvim_buf_add_highlight()| and |nvim_buf_set_extmark()|.
     * 
     * Namespaces can be named or anonymous. If `name` matches an existing
     * namespace, the associated id is returned. If `name` is an empty string a
     * new, anonymous namespace is created.
     * 
     * Parameters: ~
     *   • {name}  Namespace name or empty string
     * 
     * Return: ~
     *     Namespace id
     */
    function nvim_create_namespace(name: string): number;

    /**
     * Creates a global |user-commands| command.
     * 
     * For Lua usage see |lua-guide-commands-create|.
     * 
     * Example: 
     * ```vim
     *    :call nvim_create_user_command('SayHello', 'echo "Hello world!"', {'bang': v:true})
     *    :SayHello
     *    Hello world!
     * ```
     * 
     * Parameters: ~
     *   • {name}     Name of the new user command. Must begin with an uppercase
     *                letter.
     *   • {command}  Replacement command to execute when this user command is
     *                executed. When called from Lua, the command can also be a
     *                Lua function. The function is called with a single table
     *                argument that contains the following keys:
     *                • name: (string) Command name
     *                • args: (string) The args passed to the command, if any
     *                  |<args>|
     *                • fargs: (table) The args split by unescaped whitespace
     *                  (when more than one argument is allowed), if any
     *                  |<f-args>|
     *                • bang: (boolean) "true" if the command was executed with a
     *                  ! modifier |<bang>|
     *                • line1: (number) The starting line of the command range
     *                  |<line1>|
     *                • line2: (number) The final line of the command range
     *                  |<line2>|
     *                • range: (number) The number of items in the command range:
     *                  0, 1, or 2 |<range>|
     *                • count: (number) Any count supplied |<count>|
     *                • reg: (string) The optional register, if specified |<reg>|
     *                • mods: (string) Command modifiers, if any |<mods>|
     *                • smods: (table) Command modifiers in a structured format.
     *                  Has the same structure as the "mods" key of
     *                  |nvim_parse_cmd()|.
     *   • {opts}     Optional |command-attributes|.
     *                • Set boolean attributes such as |:command-bang| or
     *                  |:command-bar| to true (but not |:command-buffer|, use
     *                  |nvim_buf_create_user_command()| instead).
     *                • "complete" |:command-complete| also accepts a Lua
     *                  function which works like
     *                  |:command-completion-customlist|.
     *                • Other parameters:
     *                  • desc: (string) Used for listing the command when a Lua
     *                    function is used for {command}.
     *                  • force: (boolean, default true) Override any previous
     *                    definition.
     *                  • preview: (function) Preview callback for 'inccommand'
     *                    |:command-preview|
     */
    function nvim_create_user_command(name: string, command: object, opts?: { [key: string]: any }): void;

    /**
     * Delete an autocommand group by id.
     * 
     * To get a group id one can use |nvim_get_autocmds()|.
     * 
     * NOTE: behavior differs from |:augroup-delete|. When deleting a group,
     * autocommands contained in this group will also be deleted and cleared.
     * This group will no longer exist.
     * 
     * Parameters: ~
     *   • {id}  Integer The id of the group.
     * 
     * See also: ~
     *   • |nvim_del_augroup_by_name()|
     *   • |nvim_create_augroup()|
     */
    function nvim_del_augroup_by_id(id: number): void;

    /**
     * Delete an autocommand group by name.
     * 
     * NOTE: behavior differs from |:augroup-delete|. When deleting a group,
     * autocommands contained in this group will also be deleted and cleared.
     * This group will no longer exist.
     * 
     * Parameters: ~
     *   • {name}  String The name of the group.
     * 
     * See also: ~
     *   • |autocmd-groups|
     */
    function nvim_del_augroup_by_name(name: string): void;

    /**
     * Delete an autocommand by id.
     * 
     * NOTE: Only autocommands created via the API have an id.
     * 
     * Parameters: ~
     *   • {id}  Integer The id returned by nvim_create_autocmd
     * 
     * See also: ~
     *   • |nvim_create_autocmd()|
     */
    function nvim_del_autocmd(id: number): void;

    /**
     * Deletes the current line.
     * 
     * Attributes: ~
     *     not allowed when |textlock| is active
     */
    function nvim_del_current_line(): void;

    /**
     * Unmaps a global |mapping| for the given mode.
     * 
     * To unmap a buffer-local mapping, use |nvim_buf_del_keymap()|.
     * 
     * See also: ~
     *   • |nvim_set_keymap()|
     */
    function nvim_del_keymap(mode: string, lhs: string): void;

    /**
     * Deletes an uppercase/file named mark. See |mark-motions|.
     * 
     * Note:
     *     fails with error if a lowercase or buffer local named mark is used.
     * 
     * Parameters: ~
     *   • {name}  Mark name
     * 
     * Return: ~
     *     true if the mark was deleted, else false.
     * 
     * See also: ~
     *   • |nvim_buf_del_mark()|
     *   • |nvim_get_mark()|
     */
    function nvim_del_mark(name: string): boolean;

    /**
     * Delete a user-defined command.
     * 
     * Parameters: ~
     *   • {name}  Name of the command to delete.
     */
    function nvim_del_user_command(name: string): void;

    /**
     * Removes a global (g:) variable.
     * 
     * Parameters: ~
     *   • {name}  Variable name
     */
    function nvim_del_var(name: string): void;

    /**
     * Echo a message.
     * 
     * Parameters: ~
     *   • {chunks}   A list of [text, hl_group] arrays, each representing a text
     *                chunk with specified highlight. `hl_group` element can be
     *                omitted for no highlight.
     *   • {history}  if true, add to |message-history|.
     *   • {opts}     Optional parameters.
     *                • verbose: Message was printed as a result of 'verbose'
     *                  option if Nvim was invoked with -V3log_file, the message
     *                  will be redirected to the log_file and suppressed from
     *                  direct output.
     */
    function nvim_echo(chunks: any[], history: boolean, opts?: { [key: string]: any }): void;

    /**
     * Writes a message to the Vim error buffer. Does not append "\n", the
     * message is buffered (won't display) until a linefeed is written.
     * 
     * Parameters: ~
     *   • {str}  Message
     */
    function nvim_err_write(str: string): void;

    /**
     * Writes a message to the Vim error buffer. Appends "\n", so the buffer is
     * flushed (and displayed).
     * 
     * Parameters: ~
     *   • {str}  Message
     * 
     * See also: ~
     *   • nvim_err_write()
     */
    function nvim_err_writeln(str: string): void;

    /**
     * Evaluates a VimL |expression|. Dictionaries and Lists are recursively
     * expanded.
     * 
     * On execution error: fails with VimL error, updates v:errmsg.
     * 
     * Parameters: ~
     *   • {expr}  VimL expression string
     * 
     * Return: ~
     *     Evaluation result or expanded object
     */
    function nvim_eval(expr: string): object;

    /**
     * Evaluates statusline string.
     * 
     * Attributes: ~
     *     |api-fast|
     * 
     * Parameters: ~
     *   • {str}   Statusline string (see 'statusline').
     *   • {opts}  Optional parameters.
     *             • winid: (number) |window-ID| of the window to use as context
     *               for statusline.
     *             • maxwidth: (number) Maximum width of statusline.
     *             • fillchar: (string) Character to fill blank spaces in the
     *               statusline (see 'fillchars'). Treated as single-width even
     *               if it isn't.
     *             • highlights: (boolean) Return highlight information.
     *             • use_winbar: (boolean) Evaluate winbar instead of statusline.
     *             • use_tabline: (boolean) Evaluate tabline instead of
     *               statusline. When true, {winid} is ignored. Mutually
     *               exclusive with {use_winbar}.
     *             • use_statuscol_lnum: (number) Evaluate statuscolumn for this
     *               line number instead of statusline.
     * 
     * Return: ~
     *     Dictionary containing statusline information, with these keys:
     *     • str: (string) Characters that will be displayed on the statusline.
     *     • width: (number) Display width of the statusline.
     *     • highlights: Array containing highlight information of the
     *       statusline. Only included when the "highlights" key in {opts} is
     *       true. Each element of the array is a |Dictionary| with these keys:
     *       • start: (number) Byte index (0-based) of first character that uses
     *         the highlight.
     *       • group: (string) Name of highlight group.
     */
    function nvim_eval_statusline(str: string, opts?: { [key: string]: any }): { [key: string]: any };

    /**
     * Executes Vimscript (multiline block of Ex commands), like anonymous
     * |:source|.
     * 
     * Unlike |nvim_command()| this function supports heredocs, script-scope
     * (s:), etc.
     * 
     * On execution error: fails with VimL error, updates v:errmsg.
     * 
     * Parameters: ~
     *   • {src}   Vimscript code
     *   • {opts}  Optional parameters.
     *             • output: (boolean, default false) Whether to capture and
     *               return all (non-error, non-shell |:!|) output.
     * 
     * Return: ~
     *     Dictionary containing information about execution, with these keys:
     *     • output: (string|nil) Output if `opts.output` is true.
     * 
     * See also: ~
     *   • |execute()|
     *   • |nvim_command()|
     *   • |nvim_cmd()|
     */
    function nvim_exec2(src: string, opts?: { [key: string]: any }): { [key: string]: any };

    /**
     * Execute all autocommands for {event} that match the corresponding {opts}
     * |autocmd-execute|.
     * 
     * Parameters: ~
     *   • {event}  (String|Array) The event or events to execute
     *   • {opts}   Dictionary of autocommand options:
     *              • group (string|integer) optional: the autocommand group name
     *                or id to match against. |autocmd-groups|.
     *              • pattern (string|array) optional: defaults to "*"
     *                |autocmd-pattern|. Cannot be used with {buffer}.
     *              • buffer (integer) optional: buffer number
     *                |autocmd-buflocal|. Cannot be used with {pattern}.
     *              • modeline (bool) optional: defaults to true. Process the
     *                modeline after the autocommands |<nomodeline>|.
     *              • data (any): arbitrary data to send to the autocommand
     *                callback. See |nvim_create_autocmd()| for details.
     * 
     * See also: ~
     *   • |:doautocmd|
     */
    function nvim_exec_autocmds(event: object, opts?: { [key: string]: any }): void;

    /**
     * Sends input-keys to Nvim, subject to various quirks controlled by `mode`
     * flags. This is a blocking call, unlike |nvim_input()|.
     * 
     * On execution error: does not fail, but updates v:errmsg.
     * 
     * To input sequences like <C-o> use |nvim_replace_termcodes()| (typically
     * with escape_ks=false) to replace |keycodes|, then pass the result to
     * nvim_feedkeys().
     * 
     * Example: 
     * ```vim
     *     :let key = nvim_replace_termcodes("<C-o>", v:true, v:false, v:true)
     *     :call nvim_feedkeys(key, 'n', v:false)
     * ```
     * 
     * Parameters: ~
     *   • {keys}       to be typed
     *   • {mode}       behavior flags, see |feedkeys()|
     *   • {escape_ks}  If true, escape K_SPECIAL bytes in `keys`. This should be
     *                  false if you already used |nvim_replace_termcodes()|, and
     *                  true otherwise.
     * 
     * See also: ~
     *   • feedkeys()
     *   • vim_strsave_escape_ks
     */
    function nvim_feedkeys(keys: string, mode: string, escape_ks: boolean): void;

    /**
     * Gets the option information for all options.
     * 
     * The dictionary has the full option names as keys and option metadata
     * dictionaries as detailed at |nvim_get_option_info2()|.
     * 
     * Return: ~
     *     dictionary of all options
     */
    function nvim_get_all_options_info(): { [key: string]: any };

    /**
     * Get all autocommands that match the corresponding {opts}.
     * 
     * These examples will get autocommands matching ALL the given criteria: 
     * ```lua
     *   -- Matches all criteria
     *   autocommands = vim.api.nvim_get_autocmds({
     *     group = "MyGroup",
     *     event = {"BufEnter", "BufWinEnter"},
     *     pattern = {"*.c", "*.h"}
     *   })
     * 
     *   -- All commands from one group
     *   autocommands = vim.api.nvim_get_autocmds({
     *     group = "MyGroup",
     *   })
     * ```
     * 
     * NOTE: When multiple patterns or events are provided, it will find all the
     * autocommands that match any combination of them.
     * 
     * Parameters: ~
     *   • {opts}  Dictionary with at least one of the following:
     *             • group (string|integer): the autocommand group name or id to
     *               match against.
     *             • event (string|array): event or events to match against
     *               |autocmd-events|.
     *             • pattern (string|array): pattern or patterns to match against
     *               |autocmd-pattern|. Cannot be used with {buffer}
     *             • buffer: Buffer number or list of buffer numbers for buffer
     *               local autocommands |autocmd-buflocal|. Cannot be used with
     *               {pattern}
     * 
     * Return: ~
     *     Array of autocommands matching the criteria, with each item containing
     *     the following fields:
     *     • id (number): the autocommand id (only when defined with the API).
     *     • group (integer): the autocommand group id.
     *     • group_name (string): the autocommand group name.
     *     • desc (string): the autocommand description.
     *     • event (string): the autocommand event.
     *     • command (string): the autocommand command. Note: this will be empty
     *       if a callback is set.
     *     • callback (function|string|nil): Lua function or name of a Vim script
     *       function which is executed when this autocommand is triggered.
     *     • once (boolean): whether the autocommand is only run once.
     *     • pattern (string): the autocommand pattern. If the autocommand is
     *       buffer local |autocmd-buffer-local|:
     *     • buflocal (boolean): true if the autocommand is buffer local.
     *     • buffer (number): the buffer number.
     */
    function nvim_get_autocmds(opts?: { [key: string]: any }): any[];

    /**
     * Gets information about a channel.
     * 
     * Return: ~
     *     Dictionary describing a channel, with these keys:
     *     • "id" Channel id.
     *     • "argv" (optional) Job arguments list.
     *     • "stream" Stream underlying the channel.
     *       • "stdio" stdin and stdout of this Nvim instance
     *       • "stderr" stderr of this Nvim instance
     *       • "socket" TCP/IP socket or named pipe
     *       • "job" Job with communication over its stdio.
     * 
     *     • "mode" How data received on the channel is interpreted.
     *       • "bytes" Send and receive raw bytes.
     *       • "terminal" |terminal| instance interprets ASCII sequences.
     *       • "rpc" |RPC| communication on the channel is active.
     * 
     *     • "pty" (optional) Name of pseudoterminal. On a POSIX system this is a
     *       device path like "/dev/pts/1". If the name is unknown, the key will
     *       still be present if a pty is used (e.g. for conpty on Windows).
     *     • "buffer" (optional) Buffer with connected |terminal| instance.
     *     • "client" (optional) Info about the peer (client on the other end of
     *       the RPC channel), if provided by it via |nvim_set_client_info()|.
     */
    function nvim_get_chan_info(chan: number): { [key: string]: any };

    /**
     * Returns the 24-bit RGB value of a |nvim_get_color_map()| color name or
     * "#rrggbb" hexadecimal string.
     * 
     * Example: 
     * ```vim
     *     :echo nvim_get_color_by_name("Pink")
     *     :echo nvim_get_color_by_name("#cbcbcb")
     * ```
     * 
     * Parameters: ~
     *   • {name}  Color name or "#rrggbb" string
     * 
     * Return: ~
     *     24-bit RGB value, or -1 for invalid argument.
     */
    function nvim_get_color_by_name(name: string): number;

    /**
     * Returns a map of color names and RGB values.
     * 
     * Keys are color names (e.g. "Aqua") and values are 24-bit RGB color values
     * (e.g. 65535).
     * 
     * Return: ~
     *     Map of color names and RGB values.
     */
    function nvim_get_color_map(): { [key: string]: any };

    /**
     * Gets a map of global (non-buffer-local) Ex commands.
     * 
     * Currently only |user-commands| are supported, not builtin Ex commands.
     * 
     * Parameters: ~
     *   • {opts}  Optional parameters. Currently only supports {"builtin":false}
     * 
     * Return: ~
     *     Map of maps describing commands.
     */
    function nvim_get_commands(opts?: { [key: string]: any }): { [key: string]: any };

    /**
     * Gets a map of the current editor state.
     * 
     * Parameters: ~
     *   • {opts}  Optional parameters.
     *             • types: List of |context-types| ("regs", "jumps", "bufs",
     *               "gvars", …) to gather, or empty for "all".
     * 
     * Return: ~
     *     map of global |context|.
     */
    function nvim_get_context(opts?: { [key: string]: any }): { [key: string]: any };

    /**
     * Gets the current buffer.
     * 
     * Return: ~
     *     Buffer handle
     */
    function nvim_get_current_buf(): number;

    /**
     * Gets the current line.
     * 
     * Return: ~
     *     Current line string
     */
    function nvim_get_current_line(): string;

    /**
     * Gets the current tabpage.
     * 
     * Return: ~
     *     Tabpage handle
     */
    function nvim_get_current_tabpage(): number;

    /**
     * Gets the current window.
     * 
     * Return: ~
     *     Window handle
     */
    function nvim_get_current_win(): number;

    /**
     * Gets all or specific highlight groups in a namespace.
     * 
     * Parameters: ~
     *   • {ns_id}  Get highlight groups for namespace ns_id
     *              |nvim_get_namespaces()|. Use 0 to get global highlight groups
     *              |:highlight|.
     *   • {opts}   Options dict:
     *              • name: (string) Get a highlight definition by name.
     *              • id: (integer) Get a highlight definition by id.
     *              • link: (boolean, default true) Show linked group name
     *                instead of effective definition |:hi-link|.
     * 
     * Return: ~
     *     Highlight groups as a map from group name to a highlight definition
     *     map as in |nvim_set_hl()|, or only a single highlight definition map
     *     if requested by name or id.
     * 
     * Note:
     *     When the `link` attribute is defined in the highlight definition map,
     *     other attributes will not be taking effect (see |:hi-link|).
     */
    function nvim_get_hl(ns_id: number, opts?: { [key: string]: any }): { [key: string]: any };

    /**
     * Gets a highlight group by name
     * 
     * similar to |hlID()|, but allocates a new ID if not present.
     */
    function nvim_get_hl_id_by_name(name: string): number;

    /**
     * Gets a list of global (non-buffer-local) |mapping| definitions.
     * 
     * Parameters: ~
     *   • {mode}  Mode short-name ("n", "i", "v", ...)
     * 
     * Return: ~
     *     Array of |maparg()|-like dictionaries describing mappings. The
     *     "buffer" key is always zero.
     */
    function nvim_get_keymap(mode: string): any[];

    /**
     * Return a tuple (row, col, buffer, buffername) representing the position of
     * the uppercase/file named mark. See |mark-motions|.
     * 
     * Marks are (1,0)-indexed. |api-indexing|
     * 
     * Note:
     *     fails with error if a lowercase or buffer local named mark is used.
     * 
     * Parameters: ~
     *   • {name}  Mark name
     *   • {opts}  Optional parameters. Reserved for future use.
     * 
     * Return: ~
     *     4-tuple (row, col, buffer, buffername), (0, 0, 0, '') if the mark is
     *     not set.
     * 
     * See also: ~
     *   • |nvim_buf_set_mark()|
     *   • |nvim_del_mark()|
     */
    function nvim_get_mark(name: string, opts: { [key: string]: any }): any[];

    /**
     * Gets the current mode. |mode()| "blocking" is true if Nvim is waiting for
     * input.
     * 
     * Return: ~
     *     Dictionary { "mode": String, "blocking": Boolean }
     * 
     * Attributes: ~
     *     |api-fast|
     */
    function nvim_get_mode(): { [key: string]: any };

    /**
     * Gets existing, non-anonymous |namespace|s.
     * 
     * Return: ~
     *     dict that maps from names to namespace ids.
     */
    function nvim_get_namespaces(): { [key: string]: any };

    /**
     * Gets the global value of an option.
     * 
     * Parameters: ~
     *   • {name}  Option name
     * 
     * Return: ~
     *     Option value (global)
     */
    function nvim_get_option(name: string): object;

    function nvim_get_option_info(): { [key: string]: any };

    /**
     * Gets the option information for one option from arbitrary buffer or window
     * 
     * Resulting dictionary has keys:
     * • name: Name of the option (like 'filetype')
     * • shortname: Shortened name of the option (like 'ft')
     * • type: type of option ("string", "number" or "boolean")
     * • default: The default value for the option
     * • was_set: Whether the option was set.
     * • last_set_sid: Last set script id (if any)
     * • last_set_linenr: line number where option was set
     * • last_set_chan: Channel where option was set (0 for local)
     * • scope: one of "global", "win", or "buf"
     * • global_local: whether win or buf option has a global value
     * • commalist: List of comma separated values
     * • flaglist: List of single char flags
     * 
     * When {scope} is not provided, the last set information applies to the
     * local value in the current buffer or window if it is available, otherwise
     * the global value information is returned. This behavior can be disabled by
     * explicitly specifying {scope} in the {opts} table.
     * 
     * Parameters: ~
     *   • {name}  Option name
     *   • {opts}  Optional parameters
     *             • scope: One of "global" or "local". Analogous to |:setglobal|
     *               and |:setlocal|, respectively.
     *             • win: |window-ID|. Used for getting window local options.
     *             • buf: Buffer number. Used for getting buffer local options.
     *               Implies {scope} is "local".
     * 
     * Return: ~
     *     Option Information
     */
    function nvim_get_option_info2(name: string, opts?: { [key: string]: any }): { [key: string]: any };

    /**
     * Gets the value of an option. The behavior of this function matches that of
     * |:set|: the local value of an option is returned if it exists; otherwise,
     * the global value is returned. Local values always correspond to the
     * current buffer or window, unless "buf" or "win" is set in {opts}.
     * 
     * Parameters: ~
     *   • {name}  Option name
     *   • {opts}  Optional parameters
     *             • scope: One of "global" or "local". Analogous to |:setglobal|
     *               and |:setlocal|, respectively.
     *             • win: |window-ID|. Used for getting window local options.
     *             • buf: Buffer number. Used for getting buffer local options.
     *               Implies {scope} is "local".
     *             • filetype: |filetype|. Used to get the default option for a
     *               specific filetype. Cannot be used with any other option.
     *               Note: this will trigger |ftplugin| and all |FileType|
     *               autocommands for the corresponding filetype.
     * 
     * Return: ~
     *     Option value
     */
    function nvim_get_option_value(name: string, opts?: { [key: string]: any }): object;

    /**
     * Gets info describing process `pid`.
     * 
     * Return: ~
     *     Map of process properties, or NIL if process not found.
     */
    function nvim_get_proc(pid: number): object;

    /**
     * Gets the immediate children of process `pid`.
     * 
     * Return: ~
     *     Array of child process ids, empty if process not found.
     */
    function nvim_get_proc_children(pid: number): any[];

    /**
     * Find files in runtime directories
     * 
     * "name" can contain wildcards. For example
     * nvim_get_runtime_file("colors/*.vim", true) will return all color scheme
     * files. Always use forward slashes (/) in the search pattern for
     * subdirectories regardless of platform.
     * 
     * It is not an error to not find any files. An empty array is returned then.
     * 
     * Attributes: ~
     *     |api-fast|
     * 
     * Parameters: ~
     *   • {name}  pattern of files to search for
     *   • {all}   whether to return all matches or only the first
     * 
     * Return: ~
     *     list of absolute paths to the found files
     */
    function nvim_get_runtime_file(name: string, all: boolean): string[];

    /**
     * Gets a global (g:) variable.
     * 
     * Parameters: ~
     *   • {name}  Variable name
     * 
     * Return: ~
     *     Variable value
     */
    function nvim_get_var(name: string): object;

    /**
     * Gets a v: variable.
     * 
     * Parameters: ~
     *   • {name}  Variable name
     * 
     * Return: ~
     *     Variable value
     */
    function nvim_get_vvar(name: string): object;

    /**
     * Queues raw user-input. Unlike |nvim_feedkeys()|, this uses a low-level
     * input buffer and the call is non-blocking (input is processed
     * asynchronously by the eventloop).
     * 
     * On execution error: does not fail, but updates v:errmsg.
     * 
     * Note:
     *     |keycodes| like <CR> are translated, so "<" is special. To input a
     *     literal "<", send <LT>.
     * 
     * Note:
     *     For mouse events use |nvim_input_mouse()|. The pseudokey form
     *     "<LeftMouse><col,row>" is deprecated since |api-level| 6.
     * 
     * Attributes: ~
     *     |api-fast|
     * 
     * Parameters: ~
     *   • {keys}  to be typed
     * 
     * Return: ~
     *     Number of bytes actually written (can be fewer than requested if the
     *     buffer becomes full).
     */
    function nvim_input(keys: string): number;

    /**
     * Send mouse event from GUI.
     * 
     * Non-blocking: does not wait on any result, but queues the event to be
     * processed soon by the event loop.
     * 
     * Note:
     *     Currently this doesn't support "scripting" multiple mouse events by
     *     calling it multiple times in a loop: the intermediate mouse positions
     *     will be ignored. It should be used to implement real-time mouse input
     *     in a GUI. The deprecated pseudokey form ("<LeftMouse><col,row>") of
     *     |nvim_input()| has the same limitation.
     * 
     * Attributes: ~
     *     |api-fast|
     * 
     * Parameters: ~
     *   • {button}    Mouse button: one of "left", "right", "middle", "wheel",
     *                 "move".
     *   • {action}    For ordinary buttons, one of "press", "drag", "release".
     *                 For the wheel, one of "up", "down", "left", "right".
     *                 Ignored for "move".
     *   • {modifier}  String of modifiers each represented by a single char. The
     *                 same specifiers are used as for a key press, except that
     *                 the "-" separator is optional, so "C-A-", "c-a" and "CA"
     *                 can all be used to specify Ctrl+Alt+click.
     *   • {grid}      Grid number if the client uses |ui-multigrid|, else 0.
     *   • {row}       Mouse row-position (zero-based, like redraw events)
     *   • {col}       Mouse column-position (zero-based, like redraw events)
     */
    function nvim_input_mouse(button: string, action: string, modifier: string, grid: number, row: number, col: number): void;

    /**
     * Gets the current list of buffer handles
     * 
     * Includes unlisted (unloaded/deleted) buffers, like `:ls!`. Use
     * |nvim_buf_is_loaded()| to check if a buffer is loaded.
     * 
     * Return: ~
     *     List of buffer handles
     */
    function nvim_list_bufs(): any[];

    /**
     * Get information about all open channels.
     * 
     * Return: ~
     *     Array of Dictionaries, each describing a channel with the format
     *     specified at |nvim_get_chan_info()|.
     */
    function nvim_list_chans(): any[];

    /**
     * Gets the paths contained in 'runtimepath'.
     * 
     * Return: ~
     *     List of paths
     */
    function nvim_list_runtime_paths(): string[];

    /**
     * Gets the current list of tabpage handles.
     * 
     * Return: ~
     *     List of tabpage handles
     */
    function nvim_list_tabpages(): any[];

    /**
     * Gets a list of dictionaries representing attached UIs.
     * 
     * Return: ~
     *     Array of UI dictionaries, each with these keys:
     *     • "height" Requested height of the UI
     *     • "width" Requested width of the UI
     *     • "rgb" true if the UI uses RGB colors (false implies |cterm-colors|)
     *     • "ext_..." Requested UI extensions, see |ui-option|
     *     • "chan" |channel-id| of remote UI
     */
    function nvim_list_uis(): any[];

    /**
     * Gets the current list of window handles.
     * 
     * Return: ~
     *     List of window handles
     */
    function nvim_list_wins(): any[];

    /**
     * Sets the current editor state from the given |context| map.
     * 
     * Parameters: ~
     *   • {dict}  |Context| map.
     */
    function nvim_load_context(dict: { [key: string]: any }): object;

    /**
     * Notify the user with a message
     * 
     * Relays the call to vim.notify . By default forwards your message in the
     * echo area but can be overridden to trigger desktop notifications.
     * 
     * Parameters: ~
     *   • {msg}        Message to display to the user
     *   • {log_level}  The log level
     *   • {opts}       Reserved for future use.
     */
    function nvim_notify(msg: string, log_level: number, opts: { [key: string]: any }): object;

    /**
     * Open a terminal instance in a buffer
     * 
     * By default (and currently the only option) the terminal will not be
     * connected to an external process. Instead, input send on the channel will
     * be echoed directly by the terminal. This is useful to display ANSI
     * terminal sequences returned as part of a rpc message, or similar.
     * 
     * Note: to directly initiate the terminal using the right size, display the
     * buffer in a configured window before calling this. For instance, for a
     * floating display, first create an empty buffer using |nvim_create_buf()|,
     * then display it using |nvim_open_win()|, and then call this function. Then
     * |nvim_chan_send()| can be called immediately to process sequences in a
     * virtual terminal having the intended size.
     * 
     * Parameters: ~
     *   • {buffer}  the buffer to use (expected to be empty)
     *   • {opts}    Optional parameters.
     *               • on_input: lua callback for input sent, i e keypresses in
     *                 terminal mode. Note: keypresses are sent raw as they would
     *                 be to the pty master end. For instance, a carriage return
     *                 is sent as a "\r", not as a "\n". |textlock| applies. It
     *                 is possible to call |nvim_chan_send()| directly in the
     *                 callback however. ["input", term, bufnr, data]
     * 
     * Return: ~
     *     Channel id, or 0 on error
     */
    function nvim_open_term(buffer: number, opts: { [key: string]: any }): number;

    /**
     * Open a new window.
     * 
     * Currently this is used to open floating and external windows. Floats are
     * windows that are drawn above the split layout, at some anchor position in
     * some other window. Floats can be drawn internally or by external GUI with
     * the |ui-multigrid| extension. External windows are only supported with
     * multigrid GUIs, and are displayed as separate top-level windows.
     * 
     * For a general overview of floats, see |api-floatwin|.
     * 
     * Exactly one of `external` and `relative` must be specified. The `width`
     * and `height` of the new window must be specified.
     * 
     * With relative=editor (row=0,col=0) refers to the top-left corner of the
     * screen-grid and (row=Lines-1,col=Columns-1) refers to the bottom-right
     * corner. Fractional values are allowed, but the builtin implementation
     * (used by non-multigrid UIs) will always round down to nearest integer.
     * 
     * Out-of-bounds values, and configurations that make the float not fit
     * inside the main editor, are allowed. The builtin implementation truncates
     * values so floats are fully within the main screen grid. External GUIs
     * could let floats hover outside of the main window like a tooltip, but this
     * should not be used to specify arbitrary WM screen positions.
     * 
     * Example (Lua): window-relative float 
     * ```lua
     *     vim.api.nvim_open_win(0, false,
     *       {relative='win', row=3, col=3, width=12, height=3})
     * ```
     * 
     * Example (Lua): buffer-relative float (travels as buffer is scrolled) 
     * ```lua
     *     vim.api.nvim_open_win(0, false,
     *       {relative='win', width=12, height=3, bufpos={100,10}})
     * ```
     * 
     * Attributes: ~
     *     not allowed when |textlock| is active
     * 
     * Parameters: ~
     *   • {buffer}  Buffer to display, or 0 for current buffer
     *   • {enter}   Enter the window (make it the current window)
     *   • {config}  Map defining the window configuration. Keys:
     *               • relative: Sets the window layout to "floating", placed at
     *                 (row,col) coordinates relative to:
     *                 • "editor" The global editor grid
     *                 • "win" Window given by the `win` field, or current
     *                   window.
     *                 • "cursor" Cursor position in current window.
     *                 • "mouse" Mouse position
     * 
     *               • win: |window-ID| for relative="win".
     *               • anchor: Decides which corner of the float to place at
     *                 (row,col):
     *                 • "NW" northwest (default)
     *                 • "NE" northeast
     *                 • "SW" southwest
     *                 • "SE" southeast
     * 
     *               • width: Window width (in character cells). Minimum of 1.
     *               • height: Window height (in character cells). Minimum of 1.
     *               • bufpos: Places float relative to buffer text (only when
     *                 relative="win"). Takes a tuple of zero-indexed [line,
     *                 column]. `row` and `col` if given are applied relative to this position, else they
     *                 default to:
     *                 • `row=1` and `col=0` if `anchor` is "NW" or "NE"
     *                 • `row=0` and `col=0` if `anchor` is "SW" or "SE" (thus
     *                   like a tooltip near the buffer text).
     * 
     *               • row: Row position in units of "screen cell height", may be
     *                 fractional.
     *               • col: Column position in units of "screen cell width", may
     *                 be fractional.
     *               • focusable: Enable focus by user actions (wincmds, mouse
     *                 events). Defaults to true. Non-focusable windows can be
     *                 entered by |nvim_set_current_win()|.
     *               • external: GUI should display the window as an external
     *                 top-level window. Currently accepts no other positioning
     *                 configuration together with this.
     *               • zindex: Stacking order. floats with higher `zindex` go on top on floats with lower indices. Must be larger
     *                 than zero. The following screen elements have hard-coded
     *                 z-indices:
     *                 • 100: insert completion popupmenu
     *                 • 200: message scrollback
     *                 • 250: cmdline completion popupmenu (when
     *                   wildoptions+=pum) The default value for floats are 50.
     *                   In general, values below 100 are recommended, unless
     *                   there is a good reason to overshadow builtin elements.
     * 
     *               • style: Configure the appearance of the window. Currently
     *                 only takes one non-empty value:
     *                 • "minimal" Nvim will display the window with many UI
     *                   options disabled. This is useful when displaying a
     *                   temporary float where the text should not be edited.
     *                   Disables 'number', 'relativenumber', 'cursorline',
     *                   'cursorcolumn', 'foldcolumn', 'spell' and 'list'
     *                   options. 'signcolumn' is changed to `auto` and
     *                   'colorcolumn' is cleared. 'statuscolumn' is changed to
     *                   empty. The end-of-buffer region is hidden by setting
     *                   `eob` flag of 'fillchars' to a space char, and clearing
     *                   the |hl-EndOfBuffer| region in 'winhighlight'.
     * 
     *               • border: Style of (optional) window border. This can either
     *                 be a string or an array. The string values are
     *                 • "none": No border (default).
     *                 • "single": A single line box.
     *                 • "double": A double line box.
     *                 • "rounded": Like "single", but with rounded corners ("╭"
     *                   etc.).
     *                 • "solid": Adds padding by a single whitespace cell.
     *                 • "shadow": A drop shadow effect by blending with the
     *                   background.
     *                 • If it is an array, it should have a length of eight or
     *                   any divisor of eight. The array will specifify the eight
     *                   chars building up the border in a clockwise fashion
     *                   starting with the top-left corner. As an example, the
     *                   double box style could be specified as [ "╔", "═" ,"╗",
     *                   "║", "╝", "═", "╚", "║" ]. If the number of chars are
     *                   less than eight, they will be repeated. Thus an ASCII
     *                   border could be specified as [ "/", "-", "\\", "|" ], or
     *                   all chars the same as [ "x" ]. An empty string can be
     *                   used to turn off a specific border, for instance, [ "",
     *                   "", "", ">", "", "", "", "<" ] will only make vertical
     *                   borders but not horizontal ones. By default,
     *                   `FloatBorder` highlight is used, which links to
     *                   `WinSeparator` when not defined. It could also be
     *                   specified by character: [ ["+", "MyCorner"], ["x",
     *                   "MyBorder"] ].
     * 
     *               • title: Title (optional) in window border, String or list.
     *                 List is [text, highlight] tuples. if is string the default
     *                 highlight group is `FloatTitle`.
     *               • title_pos: Title position must set with title option.
     *                 value can be of `left` `center` `right` default is left.
     *               • noautocmd: If true then no buffer-related autocommand
     *                 events such as |BufEnter|, |BufLeave| or |BufWinEnter| may
     *                 fire from calling this function.
     * 
     * Return: ~
     *     Window handle, or 0 on error
     */
    function nvim_open_win(buffer: number, enter: boolean, config?: { [key: string]: any }): number;

    /**
     * Writes a message to the Vim output buffer. Does not append "\n", the
     * message is buffered (won't display) until a linefeed is written.
     * 
     * Parameters: ~
     *   • {str}  Message
     */
    function nvim_out_write(str: string): void;

    /**
     * Parse command line.
     * 
     * Doesn't check the validity of command arguments.
     * 
     * Attributes: ~
     *     |api-fast|
     * 
     * Parameters: ~
     *   • {str}   Command line string to parse. Cannot contain "\n".
     *   • {opts}  Optional parameters. Reserved for future use.
     * 
     * Return: ~
     *     Dictionary containing command information, with these keys:
     *     • cmd: (string) Command name.
     *     • range: (array) (optional) Command range (|<line1>| |<line2>|).
     *       Omitted if command doesn't accept a range. Otherwise, has no
     *       elements if no range was specified, one element if only a single
     *       range item was specified, or two elements if both range items were
     *       specified.
     *     • count: (number) (optional) Command |<count>|. Omitted if command
     *       cannot take a count.
     *     • reg: (string) (optional) Command |<register>|. Omitted if command
     *       cannot take a register.
     *     • bang: (boolean) Whether command contains a |<bang>| (!) modifier.
     *     • args: (array) Command arguments.
     *     • addr: (string) Value of |:command-addr|. Uses short name or "line"
     *       for -addr=lines.
     *     • nargs: (string) Value of |:command-nargs|.
     *     • nextcmd: (string) Next command if there are multiple commands
     *       separated by a |:bar|. Empty if there isn't a next command.
     *     • magic: (dictionary) Which characters have special meaning in the
     *       command arguments.
     *       • file: (boolean) The command expands filenames. Which means
     *         characters such as "%", "#" and wildcards are expanded.
     *       • bar: (boolean) The "|" character is treated as a command separator
     *         and the double quote character (") is treated as the start of a
     *         comment.
     * 
     *     • mods: (dictionary) |:command-modifiers|.
     *       • filter: (dictionary) |:filter|.
     *         • pattern: (string) Filter pattern. Empty string if there is no
     *           filter.
     *         • force: (boolean) Whether filter is inverted or not.
     * 
     *       • silent: (boolean) |:silent|.
     *       • emsg_silent: (boolean) |:silent!|.
     *       • unsilent: (boolean) |:unsilent|.
     *       • sandbox: (boolean) |:sandbox|.
     *       • noautocmd: (boolean) |:noautocmd|.
     *       • browse: (boolean) |:browse|.
     *       • confirm: (boolean) |:confirm|.
     *       • hide: (boolean) |:hide|.
     *       • horizontal: (boolean) |:horizontal|.
     *       • keepalt: (boolean) |:keepalt|.
     *       • keepjumps: (boolean) |:keepjumps|.
     *       • keepmarks: (boolean) |:keepmarks|.
     *       • keeppatterns: (boolean) |:keeppatterns|.
     *       • lockmarks: (boolean) |:lockmarks|.
     *       • noswapfile: (boolean) |:noswapfile|.
     *       • tab: (integer) |:tab|. -1 when omitted.
     *       • verbose: (integer) |:verbose|. -1 when omitted.
     *       • vertical: (boolean) |:vertical|.
     *       • split: (string) Split modifier string, is an empty string when
     *         there's no split modifier. If there is a split modifier it can be
     *         one of:
     *         • "aboveleft": |:aboveleft|.
     *         • "belowright": |:belowright|.
     *         • "topleft": |:topleft|.
     *         • "botright": |:botright|.
     */
    function nvim_parse_cmd(str: string, opts: { [key: string]: any }): { [key: string]: any };

    /**
     * Parse a VimL expression.
     * 
     * Attributes: ~
     *     |api-fast|
     * 
     * Parameters: ~
     *   • {expr}       Expression to parse. Always treated as a single line.
     *   • {flags}      Flags:
     *                  • "m" if multiple expressions in a row are allowed (only
     *                    the first one will be parsed),
     *                  • "E" if EOC tokens are not allowed (determines whether
     *                    they will stop parsing process or be recognized as an
     *                    operator/space, though also yielding an error).
     *                  • "l" when needing to start parsing with lvalues for
     *                    ":let" or ":for". Common flag sets:
     *                  • "m" to parse like for ":echo".
     *                  • "E" to parse like for "<C-r>=".
     *                  • empty string for ":call".
     *                  • "lm" to parse for ":let".
     *   • {highlight}  If true, return value will also include "highlight" key
     *                  containing array of 4-tuples (arrays) (Integer, Integer,
     *                  Integer, String), where first three numbers define the
     *                  highlighted region and represent line, starting column
     *                  and ending column (latter exclusive: one should highlight
     *                  region [start_col, end_col)).
     * 
     * Return: ~
     * 
     *     • AST: top-level dictionary with these keys:
     *       • "error": Dictionary with error, present only if parser saw some
     *         error. Contains the following keys:
     *         • "message": String, error message in printf format, translated.
     *           Must contain exactly one "%.*s".
     *         • "arg": String, error message argument.
     * 
     *       • "len": Amount of bytes successfully parsed. With flags equal to ""
     *         that should be equal to the length of expr string. (“Successfully
     *         parsed” here means “participated in AST creation”, not “till the
     *         first error”.)
     *       • "ast": AST, either nil or a dictionary with these keys:
     *         • "type": node type, one of the value names from ExprASTNodeType
     *           stringified without "kExprNode" prefix.
     *         • "start": a pair [line, column] describing where node is
     *           "started" where "line" is always 0 (will not be 0 if you will be
     *           using nvim_parse_viml() on e.g. ":let", but that is not present
     *           yet). Both elements are Integers.
     *         • "len": “length” of the node. This and "start" are there for
     *           debugging purposes primary (debugging parser and providing debug
     *           information).
     *         • "children": a list of nodes described in top/"ast". There always
     *           is zero, one or two children, key will not be present if node
     *           has no children. Maximum number of children may be found in
     *           node_maxchildren array.
     * 
     *     • Local values (present only for certain nodes):
     *       • "scope": a single Integer, specifies scope for "Option" and
     *         "PlainIdentifier" nodes. For "Option" it is one of ExprOptScope
     *         values, for "PlainIdentifier" it is one of ExprVarScope values.
     *       • "ident": identifier (without scope, if any), present for "Option",
     *         "PlainIdentifier", "PlainKey" and "Environment" nodes.
     *       • "name": Integer, register name (one character) or -1. Only present
     *         for "Register" nodes.
     *       • "cmp_type": String, comparison type, one of the value names from
     *         ExprComparisonType, stringified without "kExprCmp" prefix. Only
     *         present for "Comparison" nodes.
     *       • "ccs_strategy": String, case comparison strategy, one of the value
     *         names from ExprCaseCompareStrategy, stringified without
     *         "kCCStrategy" prefix. Only present for "Comparison" nodes.
     *       • "augmentation": String, augmentation type for "Assignment" nodes.
     *         Is either an empty string, "Add", "Subtract" or "Concat" for "=",
     *         "+=", "-=" or ".=" respectively.
     *       • "invert": Boolean, true if result of comparison needs to be
     *         inverted. Only present for "Comparison" nodes.
     *       • "ivalue": Integer, integer value for "Integer" nodes.
     *       • "fvalue": Float, floating-point value for "Float" nodes.
     *       • "svalue": String, value for "SingleQuotedString" and
     *         "DoubleQuotedString" nodes.
     */
    function nvim_parse_expression(expr: string, flags: string, highlight: boolean): { [key: string]: any };

    /**
     * Pastes at cursor, in any mode.
     * 
     * Invokes the `vim.paste` handler, which handles each mode appropriately.
     * Sets redo/undo. Faster than |nvim_input()|. Lines break at LF ("\n").
     * 
     * Errors ('nomodifiable', `vim.paste()` failure, …) are reflected in `err`
     * but do not affect the return value (which is strictly decided by
     * `vim.paste()`). On error, subsequent calls are ignored ("drained") until
     * the next paste is initiated (phase 1 or -1).
     * 
     * Attributes: ~
     *     not allowed when |textlock| is active
     * 
     * Parameters: ~
     *   • {data}   Multiline input. May be binary (containing NUL bytes).
     *   • {crlf}   Also break lines at CR and CRLF.
     *   • {phase}  -1: paste in a single call (i.e. without streaming). To
     *              "stream" a paste, call `nvim_paste` sequentially with these `phase` values:
     *              • 1: starts the paste (exactly once)
     *              • 2: continues the paste (zero or more times)
     *              • 3: ends the paste (exactly once)
     * 
     * Return: ~
     * 
     *     • true: Client may continue pasting.
     *     • false: Client must cancel the paste.
     */
    function nvim_paste(data: string, crlf: boolean, phase: number): boolean;

    /**
     * Puts text at cursor, in any mode.
     * 
     * Compare |:put| and |p| which are always linewise.
     * 
     * Attributes: ~
     *     not allowed when |textlock| is active
     * 
     * Parameters: ~
     *   • {lines}   |readfile()|-style list of lines. |channel-lines|
     *   • {type}    Edit behavior: any |getregtype()| result, or:
     *               • "b" |blockwise-visual| mode (may include width, e.g. "b3")
     *               • "c" |charwise| mode
     *               • "l" |linewise| mode
     *               • "" guess by contents, see |setreg()|
     *   • {after}   If true insert after cursor (like |p|), or before (like
     *               |P|).
     *   • {follow}  If true place cursor at end of inserted text.
     */
    function nvim_put(lines: string[], type: string, after: boolean, follow: boolean): void;

    /**
     * Replaces terminal codes and |keycodes| (<CR>, <Esc>, ...) in a string with
     * the internal representation.
     * 
     * Parameters: ~
     *   • {str}        String to be converted.
     *   • {from_part}  Legacy Vim parameter. Usually true.
     *   • {do_lt}      Also translate <lt>. Ignored if `special` is false.
     *   • {special}    Replace |keycodes|, e.g. <CR> becomes a "\r" char.
     * 
     * See also: ~
     *   • replace_termcodes
     *   • cpoptions
     */
    function nvim_replace_termcodes(str: string, from_part: boolean, do_lt: boolean, special: boolean): string;

    /**
     * Selects an item in the completion popup menu.
     * 
     * If neither |ins-completion| nor |cmdline-completion| popup menu is active
     * this API call is silently ignored. Useful for an external UI using
     * |ui-popupmenu| to control the popup menu with the mouse. Can also be used
     * in a mapping; use <Cmd> |:map-cmd| or a Lua mapping to ensure the mapping
     * doesn't end completion mode.
     * 
     * Parameters: ~
     *   • {item}    Index (zero-based) of the item to select. Value of -1
     *               selects nothing and restores the original text.
     *   • {insert}  For |ins-completion|, whether the selection should be
     *               inserted in the buffer. Ignored for |cmdline-completion|.
     *   • {finish}  Finish the completion and dismiss the popup menu. Implies
     *               {insert}.
     *   • {opts}    Optional parameters. Reserved for future use.
     */
    function nvim_select_popupmenu_item(item: number, insert: boolean, finish: boolean, opts: { [key: string]: any }): void;

    /**
     * Sets the current buffer.
     * 
     * Attributes: ~
     *     not allowed when |textlock| is active
     * 
     * Parameters: ~
     *   • {buffer}  Buffer handle
     */
    function nvim_set_current_buf(buffer: number): void;

    /**
     * Changes the global working directory.
     * 
     * Parameters: ~
     *   • {dir}  Directory path
     */
    function nvim_set_current_dir(dir: string): void;

    /**
     * Sets the current line.
     * 
     * Attributes: ~
     *     not allowed when |textlock| is active
     * 
     * Parameters: ~
     *   • {line}  Line contents
     */
    function nvim_set_current_line(line: string): void;

    /**
     * Sets the current tabpage.
     * 
     * Attributes: ~
     *     not allowed when |textlock| is active
     * 
     * Parameters: ~
     *   • {tabpage}  Tabpage handle
     */
    function nvim_set_current_tabpage(tabpage: number): void;

    /**
     * Sets the current window.
     * 
     * Attributes: ~
     *     not allowed when |textlock| is active
     * 
     * Parameters: ~
     *   • {window}  Window handle
     */
    function nvim_set_current_win(window: number): void;

    /**
     * Set or change decoration provider for a |namespace|
     * 
     * This is a very general purpose interface for having lua callbacks being
     * triggered during the redraw code.
     * 
     * The expected usage is to set |extmarks| for the currently redrawn buffer.
     * |nvim_buf_set_extmark()| can be called to add marks on a per-window or
     * per-lines basis. Use the `ephemeral` key to only use the mark for the
     * current screen redraw (the callback will be called again for the next
     * redraw ).
     * 
     * Note: this function should not be called often. Rather, the callbacks
     * themselves can be used to throttle unneeded callbacks. the `on_start`
     * callback can return `false` to disable the provider until the next redraw.
     * Similarly, return `false` in `on_win` will skip the `on_lines` calls for
     * that window (but any extmarks set in `on_win` will still be used). A
     * plugin managing multiple sources of decoration should ideally only set one
     * provider, and merge the sources internally. You can use multiple `ns_id`
     * for the extmarks set/modified inside the callback anyway.
     * 
     * Note: doing anything other than setting extmarks is considered
     * experimental. Doing things like changing options are not expliticly
     * forbidden, but is likely to have unexpected consequences (such as 100% CPU
     * consumption). doing `vim.rpcnotify` should be OK, but `vim.rpcrequest` is
     * quite dubious for the moment.
     * 
     * Attributes: ~
     *     Lua |vim.api| only
     * 
     * Parameters: ~
     *   • {ns_id}  Namespace id from |nvim_create_namespace()|
     *   • {opts}   Table of callbacks:
     *              • on_start: called first on each screen redraw ["start",
     *                tick]
     *              • on_buf: called for each buffer being redrawn (before window
     *                callbacks) ["buf", bufnr, tick]
     *              • on_win: called when starting to redraw a specific window.
     *                ["win", winid, bufnr, topline, botline_guess]
     *              • on_line: called for each buffer line being redrawn. (The
     *                interaction with fold lines is subject to change) ["win",
     *                winid, bufnr, row]
     *              • on_end: called at the end of a redraw cycle ["end", tick]
     */
    function nvim_set_decoration_provider(ns_id: number, opts?: { [key: string]: any }): void;

    /**
     * Sets a highlight group.
     * 
     * Note:
     *     Unlike the `:highlight` command which can update a highlight group,
     *     this function completely replaces the definition. For example:
     *     `nvim_set_hl(0, 'Visual', {})` will clear the highlight group
     *     'Visual'.
     * 
     * Note:
     *     The fg and bg keys also accept the string values `"fg"` or `"bg"`
     *     which act as aliases to the corresponding foreground and background
     *     values of the Normal group. If the Normal group has not been defined,
     *     using these values results in an error.
     * 
     * Note:
     *     If `link` is used in combination with other attributes; only the
     *     `link` will take effect (see |:hi-link|).
     * 
     * Parameters: ~
     *   • {ns_id}  Namespace id for this highlight |nvim_create_namespace()|.
     *              Use 0 to set a highlight group globally |:highlight|.
     *              Highlights from non-global namespaces are not active by
     *              default, use |nvim_set_hl_ns()| or |nvim_win_set_hl_ns()| to
     *              activate them.
     *   • {name}   Highlight group name, e.g. "ErrorMsg"
     *   • {val}    Highlight definition map, accepts the following keys:
     *              • fg (or foreground): color name or "#RRGGBB", see note.
     *              • bg (or background): color name or "#RRGGBB", see note.
     *              • sp (or special): color name or "#RRGGBB"
     *              • blend: integer between 0 and 100
     *              • bold: boolean
     *              • standout: boolean
     *              • underline: boolean
     *              • undercurl: boolean
     *              • underdouble: boolean
     *              • underdotted: boolean
     *              • underdashed: boolean
     *              • strikethrough: boolean
     *              • italic: boolean
     *              • reverse: boolean
     *              • nocombine: boolean
     *              • link: name of another highlight group to link to, see
     *                |:hi-link|.
     *              • default: Don't override existing definition |:hi-default|
     *              • ctermfg: Sets foreground of cterm color |ctermfg|
     *              • ctermbg: Sets background of cterm color |ctermbg|
     *              • cterm: cterm attribute map, like |highlight-args|. If not
     *                set, cterm attributes will match those from the attribute
     *                map documented above.
     */
    function nvim_set_hl(ns_id: number, name: string, val?: { [key: string]: any }): void;

    /**
     * Set active namespace for highlights defined with |nvim_set_hl()|. This can
     * be set for a single window, see |nvim_win_set_hl_ns()|.
     * 
     * Parameters: ~
     *   • {ns_id}  the namespace to use
     */
    function nvim_set_hl_ns(ns_id: number): void;

    /**
     * Set active namespace for highlights defined with |nvim_set_hl()| while
     * redrawing.
     * 
     * This function meant to be called while redrawing, primarily from
     * |nvim_set_decoration_provider()| on_win and on_line callbacks, which are
     * allowed to change the namespace during a redraw cycle.
     * 
     * Attributes: ~
     *     |api-fast|
     * 
     * Parameters: ~
     *   • {ns_id}  the namespace to activate
     */
    function nvim_set_hl_ns_fast(ns_id: number): void;

    /**
     * Sets a global |mapping| for the given mode.
     * 
     * To set a buffer-local mapping, use |nvim_buf_set_keymap()|.
     * 
     * Unlike |:map|, leading/trailing whitespace is accepted as part of the
     * {lhs} or {rhs}. Empty {rhs} is |<Nop>|. |keycodes| are replaced as usual.
     * 
     * Example: 
     * ```vim
     *     call nvim_set_keymap('n', ' <NL>', '', {'nowait': v:true})
     * ```
     * 
     * is equivalent to: 
     * ```vim
     *     nmap <nowait> <Space><NL> <Nop>
     * ```
     * 
     * Parameters: ~
     *   • {mode}  Mode short-name (map command prefix: "n", "i", "v", "x", …) or
     *             "!" for |:map!|, or empty string for |:map|.
     *   • {lhs}   Left-hand-side |{lhs}| of the mapping.
     *   • {rhs}   Right-hand-side |{rhs}| of the mapping.
     *   • {opts}  Optional parameters map: Accepts all |:map-arguments| as keys
     *             except |<buffer>|, values are booleans (default false). Also:
     *             • "noremap" non-recursive mapping |:noremap|
     *             • "desc" human-readable description.
     *             • "callback" Lua function called when the mapping is executed.
     *             • "replace_keycodes" (boolean) When "expr" is true, replace
     *               keycodes in the resulting string (see
     *               |nvim_replace_termcodes()|). Returning nil from the Lua
     *               "callback" is equivalent to returning an empty string.
     */
    function nvim_set_keymap(mode: string, lhs: string, rhs: string, opts?: { [key: string]: any }): void;

    /**
     * Sets the global value of an option.
     * 
     * Parameters: ~
     *   • {name}   Option name
     *   • {value}  New option value
     */
    function nvim_set_option(name: string, value: object): void;

    /**
     * Sets the value of an option. The behavior of this function matches that of
     * |:set|: for global-local options, both the global and local value are set
     * unless otherwise specified with {scope}.
     * 
     * Note the options {win} and {buf} cannot be used together.
     * 
     * Parameters: ~
     *   • {name}   Option name
     *   • {value}  New option value
     *   • {opts}   Optional parameters
     *              • scope: One of "global" or "local". Analogous to
     *                |:setglobal| and |:setlocal|, respectively.
     *              • win: |window-ID|. Used for setting window local option.
     *              • buf: Buffer number. Used for setting buffer local option.
     */
    function nvim_set_option_value(name: string, value: object, opts?: { [key: string]: any }): void;

    /**
     * Sets a global (g:) variable.
     * 
     * Parameters: ~
     *   • {name}   Variable name
     *   • {value}  Variable value
     */
    function nvim_set_var(name: string, value: object): void;

    /**
     * Sets a v: variable, if it is not readonly.
     * 
     * Parameters: ~
     *   • {name}   Variable name
     *   • {value}  Variable value
     */
    function nvim_set_vvar(name: string, value: object): void;

    /**
     * Calculates the number of display cells occupied by `text`. Control
     * characters including <Tab> count as one cell.
     * 
     * Parameters: ~
     *   • {text}  Some text
     * 
     * Return: ~
     *     Number of cells
     */
    function nvim_strwidth(text: string): number;

    /**
     * Removes a tab-scoped (t:) variable
     * 
     * Parameters: ~
     *   • {tabpage}  Tabpage handle, or 0 for current tabpage
     *   • {name}     Variable name
     */
    function nvim_tabpage_del_var(tabpage: number, name: string): void;

    /**
     * Gets the tabpage number
     * 
     * Parameters: ~
     *   • {tabpage}  Tabpage handle, or 0 for current tabpage
     * 
     * Return: ~
     *     Tabpage number
     */
    function nvim_tabpage_get_number(tabpage: number): number;

    /**
     * Gets a tab-scoped (t:) variable
     * 
     * Parameters: ~
     *   • {tabpage}  Tabpage handle, or 0 for current tabpage
     *   • {name}     Variable name
     * 
     * Return: ~
     *     Variable value
     */
    function nvim_tabpage_get_var(tabpage: number, name: string): object;

    /**
     * Gets the current window in a tabpage
     * 
     * Parameters: ~
     *   • {tabpage}  Tabpage handle, or 0 for current tabpage
     * 
     * Return: ~
     *     Window handle
     */
    function nvim_tabpage_get_win(tabpage: number): number;

    /**
     * Checks if a tabpage is valid
     * 
     * Parameters: ~
     *   • {tabpage}  Tabpage handle, or 0 for current tabpage
     * 
     * Return: ~
     *     true if the tabpage is valid, false otherwise
     */
    function nvim_tabpage_is_valid(tabpage: number): boolean;

    /**
     * Gets the windows in a tabpage
     * 
     * Parameters: ~
     *   • {tabpage}  Tabpage handle, or 0 for current tabpage
     * 
     * Return: ~
     *     List of windows in `tabpage`
     */
    function nvim_tabpage_list_wins(tabpage: number): any[];

    /**
     * Sets a tab-scoped (t:) variable
     * 
     * Parameters: ~
     *   • {tabpage}  Tabpage handle, or 0 for current tabpage
     *   • {name}     Variable name
     *   • {value}    Variable value
     */
    function nvim_tabpage_set_var(tabpage: number, name: string, value: object): void;

    /**
     * Calls a function with window as temporary current window.
     * 
     * Attributes: ~
     *     Lua |vim.api| only
     * 
     * Parameters: ~
     *   • {window}  Window handle, or 0 for current window
     *   • {fun}     Function to call inside the window (currently lua callable
     *               only)
     * 
     * Return: ~
     *     Return value of function. NB: will deepcopy lua values currently, use
     *     upvalues to send lua references in and out.
     * 
     * See also: ~
     *   • |win_execute()|
     *   • |nvim_buf_call()|
     */
    function nvim_win_call(window: number, fun: Function): object;

    /**
     * Closes the window (like |:close| with a |window-ID|).
     * 
     * Attributes: ~
     *     not allowed when |textlock| is active
     * 
     * Parameters: ~
     *   • {window}  Window handle, or 0 for current window
     *   • {force}   Behave like `:close!` The last window of a buffer with
     *               unwritten changes can be closed. The buffer will become
     *               hidden, even if 'hidden' is not set.
     */
    function nvim_win_close(window: number, force: boolean): void;

    /**
     * Removes a window-scoped (w:) variable
     * 
     * Parameters: ~
     *   • {window}  Window handle, or 0 for current window
     *   • {name}    Variable name
     */
    function nvim_win_del_var(window: number, name: string): void;

    /**
     * Gets the current buffer in a window
     * 
     * Parameters: ~
     *   • {window}  Window handle, or 0 for current window
     * 
     * Return: ~
     *     Buffer handle
     */
    function nvim_win_get_buf(window: number): number;

    /**
     * Gets window configuration.
     * 
     * The returned value may be given to |nvim_open_win()|.
     * 
     * `relative` is empty for normal windows.
     * 
     * Parameters: ~
     *   • {window}  Window handle, or 0 for current window
     * 
     * Return: ~
     *     Map defining the window configuration, see |nvim_open_win()|
     */
    function nvim_win_get_config(window: number): { [key: string]: any };

    /**
     * Gets the (1,0)-indexed, buffer-relative cursor position for a given window
     * (different windows showing the same buffer have independent cursor
     * positions). |api-indexing|
     * 
     * Parameters: ~
     *   • {window}  Window handle, or 0 for current window
     * 
     * Return: ~
     *     (row, col) tuple
     */
    function nvim_win_get_cursor(window: number): number[];

    /**
     * Gets the window height
     * 
     * Parameters: ~
     *   • {window}  Window handle, or 0 for current window
     * 
     * Return: ~
     *     Height as a count of rows
     */
    function nvim_win_get_height(window: number): number;

    /**
     * Gets the window number
     * 
     * Parameters: ~
     *   • {window}  Window handle, or 0 for current window
     * 
     * Return: ~
     *     Window number
     */
    function nvim_win_get_number(window: number): number;

    /**
     * Gets a window option value
     * 
     * Parameters: ~
     *   • {window}  Window handle, or 0 for current window
     *   • {name}    Option name
     * 
     * Return: ~
     *     Option value
     */
    function nvim_win_get_option(window: number, name: string): object;

    /**
     * Gets the window position in display cells. First position is zero.
     * 
     * Parameters: ~
     *   • {window}  Window handle, or 0 for current window
     * 
     * Return: ~
     *     (row, col) tuple with the window position
     */
    function nvim_win_get_position(window: number): number[];

    /**
     * Gets the window tabpage
     * 
     * Parameters: ~
     *   • {window}  Window handle, or 0 for current window
     * 
     * Return: ~
     *     Tabpage that contains the window
     */
    function nvim_win_get_tabpage(window: number): number;

    /**
     * Gets a window-scoped (w:) variable
     * 
     * Parameters: ~
     *   • {window}  Window handle, or 0 for current window
     *   • {name}    Variable name
     * 
     * Return: ~
     *     Variable value
     */
    function nvim_win_get_var(window: number, name: string): object;

    /**
     * Gets the window width
     * 
     * Parameters: ~
     *   • {window}  Window handle, or 0 for current window
     * 
     * Return: ~
     *     Width as a count of columns
     */
    function nvim_win_get_width(window: number): number;

    /**
     * Closes the window and hide the buffer it contains (like |:hide| with a
     * |window-ID|).
     * 
     * Like |:hide| the buffer becomes hidden unless another window is editing
     * it, or 'bufhidden' is `unload`, `delete` or `wipe` as opposed to |:close|
     * or |nvim_win_close()|, which will close the buffer.
     * 
     * Attributes: ~
     *     not allowed when |textlock| is active
     * 
     * Parameters: ~
     *   • {window}  Window handle, or 0 for current window
     */
    function nvim_win_hide(window: number): void;

    /**
     * Checks if a window is valid
     * 
     * Parameters: ~
     *   • {window}  Window handle, or 0 for current window
     * 
     * Return: ~
     *     true if the window is valid, false otherwise
     */
    function nvim_win_is_valid(window: number): boolean;

    /**
     * Sets the current buffer in a window, without side effects
     * 
     * Attributes: ~
     *     not allowed when |textlock| is active
     * 
     * Parameters: ~
     *   • {window}  Window handle, or 0 for current window
     *   • {buffer}  Buffer handle
     */
    function nvim_win_set_buf(window: number, buffer: number): void;

    /**
     * Configures window layout. Currently only for floating and external windows
     * (including changing a split window to those layouts).
     * 
     * When reconfiguring a floating window, absent option keys will not be
     * changed. `row`/`col` and `relative` must be reconfigured together.
     * 
     * Parameters: ~
     *   • {window}  Window handle, or 0 for current window
     *   • {config}  Map defining the window configuration, see |nvim_open_win()|
     * 
     * See also: ~
     *   • |nvim_open_win()|
     */
    function nvim_win_set_config(window: number, config?: { [key: string]: any }): void;

    /**
     * Sets the (1,0)-indexed cursor position in the window. |api-indexing| This
     * scrolls the window even if it is not the current one.
     * 
     * Parameters: ~
     *   • {window}  Window handle, or 0 for current window
     *   • {pos}     (row, col) tuple representing the new position
     */
    function nvim_win_set_cursor(window: number, pos: number[]): void;

    /**
     * Sets the window height.
     * 
     * Parameters: ~
     *   • {window}  Window handle, or 0 for current window
     *   • {height}  Height as a count of rows
     */
    function nvim_win_set_height(window: number, height: number): void;

    /**
     * Set highlight namespace for a window. This will use highlights defined
     * with |nvim_set_hl()| for this namespace, but fall back to global
     * highlights (ns=0) when missing.
     * 
     * This takes precedence over the 'winhighlight' option.
     * 
     * Parameters: ~
     *   • {ns_id}  the namespace to use
     */
    function nvim_win_set_hl_ns(window: number, ns_id: number): void;

    /**
     * Sets a window option value. Passing `nil` as value deletes the option
     * (only works if there's a global fallback)
     * 
     * Parameters: ~
     *   • {window}  Window handle, or 0 for current window
     *   • {name}    Option name
     *   • {value}   Option value
     */
    function nvim_win_set_option(window: number, name: string, value: object): void;

    /**
     * Sets a window-scoped (w:) variable
     * 
     * Parameters: ~
     *   • {window}  Window handle, or 0 for current window
     *   • {name}    Variable name
     *   • {value}   Variable value
     */
    function nvim_win_set_var(window: number, name: string, value: object): void;

    /**
     * Sets the window width. This will only succeed if the screen is split
     * vertically.
     * 
     * Parameters: ~
     *   • {window}  Window handle, or 0 for current window
     *   • {width}   Width as a count of columns
     */
    function nvim_win_set_width(window: number, width: number): void;
}

/**
 * The [luv](https://github.com/luvit/luv/) project provides access to the multi-platform support library
 * [libuv](http://libuv.org/) in Lua code. It was primarily developed for the [luvit](https://github.com/luvit/luvit/) project as
 * the built-in `uv` module, but can be used in other Lua environments.
 * 
 * More information about the core libuv library can be found at the original
 * [libuv documentation page](http://docs.libuv.org/en/v1.x/).
 * 
 * ### TCP Echo Server Example
 * 
 * Here is a small example showing a TCP echo server:
 * 
 * ```lua
 * local uv = require("luv") -- "luv" when stand-alone, "uv" in luvi apps
 * 
 * local server = uv.new_tcp()
 * server:bind("127.0.0.1", 1337)
 * server:listen(128, function (err)
 *   assert(not err, err)
 *   local client = uv.new_tcp()
 *   server:accept(client)
 *   client:read_start(function (err, chunk)
 *     assert(not err, err)
 *     if chunk then
 *       client:write(chunk)
 *     else
 *       client:shutdown()
 *       client:close()
 *     end
 *   end)
 * end)
 * print("TCP server listening at 127.0.0.1 port 1337")
 * uv.run() -- an explicit run call is necessary outside of luvit
 * ```
 * 
 * ### Module Layout
 * 
 * The luv library contains a single Lua module referred to hereafter as `uv` for
 * simplicity. This module consists mostly of functions with names corresponding to
 * their original libuv versions. For example, the libuv function `uv_tcp_bind` has
 * a luv version at `uv.tcp_bind`. Currently, only two non-function fields exists:
 * `uv.constants` and `errno`, which are tables.
 * 
 * ### Functions vs Methods
 * 
 * In addition to having simple functions, luv provides an optional method-style
 * API. For example, `uv.tcp_bind(server, host, port)` can alternatively be called
 * as `server:bind(host, port)`. Note that the first argument `server` becomes the
 * object and `tcp_` is removed from the function name. Method forms are
 * documented below where they exist.
 * 
 * ### Synchronous vs Asynchronous Functions
 * 
 * Functions that accept a callback are asynchronous. These functions may
 * immediately return results to the caller to indicate their initial status, but
 * their final execution is deferred until at least the next libuv loop iteration.
 * After completion, their callbacks are executed with any results passed to it.
 * 
 * Functions that do not accept a callback are synchronous. These functions
 * immediately return their results to the caller.
 * 
 * Some (generally FS and DNS) functions can behave either synchronously or
 * asynchronously. If a callback is provided to these functions, they behave
 * asynchronously; if no callback is provided, they behave synchronously.
 * 
 * ### Pseudo-Types
 * 
 * Some unique types are defined. These are not actual types in Lua, but they are
 * used here to facilitate documenting consistent behavior:
 * - `fail`: an assertable `nil, string, string` tuple (see [Error handling][])
 * - `callable`: a `function`; or a `table` or `userdata` with a `__call`
 *   metamethod
 * - `buffer`: a `string` or a sequential `table` of `string`s
 * - `threadargs`: variable arguments (`...`) of type `nil`, `boolean`, `number`,
 *   `string`, or `userdata`
 */
declare namespace vim.loop {

    type buffer = string | string[];
    type threadargs = object | string | number | boolean | undefined;

    /**
     * The event loop is the central part of libuv's functionality. It takes care of
     * polling for I/O and scheduling callbacks to be run based on different sources of events.
     * 
     * In luv, there is an implicit uv loop for every Lua state that loads the library.
     * You can use this library in an multi-threaded environment as long as each thread
     * has it's own Lua state with its corresponding own uv loop. This loop is not
     * directly exposed to users in the Lua module.
     */
    interface uv_loop_t { }

    /**
     * `uv_req_t` is the base type for all libuv request types.
     */
    interface uv_req_t {
        /**
         * Cancel a pending request. Fails if the request is executing or has finished
         * executing. Only cancellation of `uv_fs_t`, `uv_getaddrinfo_t`,
         * `uv_getnameinfo_t` and `uv_work_t` requests is currently supported.
         */
        cancel(): fail<[success: 0]>;

        /**
         * Returns the name of the struct for a given request (e.g. `"fs"` for `uv_fs_t`)
         * and the libuv enum integer for the request's type (`uv_req_type`).
         */
        get_type(): LuaMultiReturn<[req_struct_name, req_struct_type]>;
    }

    /**
     * Cancel a pending request. Fails if the request is executing or has finished
     * executing. Only cancellation of `uv_fs_t`, `uv_getaddrinfo_t`,
     * `uv_getnameinfo_t` and `uv_work_t` requests is currently supported.
     */
    function cancel(req: uv_fs_t | uv_getnameinfo_t | uv_getnameinfo_t): fail<[success: 0]>;

    /**
     * Returns the name of the struct for a given request (e.g. `"fs"` for `uv_fs_t`)
     * and the libuv enum integer for the request's type (`uv_req_type`).
     */
    function req_get_type(req: uv_req_t): LuaMultiReturn<[req_struct_name, req_struct_type]>;

    /**
     * `uv_handle_t` is the base type for all libuv handle types. All API functions
     * defined here work with any handle type.
     */
    interface uv_handle_t {
        /**
         * 
         * Returns `true` if the handle is active, `false` if it's inactive. What "active”
         * means depends on the type of handle:
         * 
         *  - A `uv_async_t` handle is always active and cannot be deactivated, except
         *  by closing it with `uv.close()`.
         * 
         *  - A `uv_pipe_t`, `uv_tcp_t`, `uv_udp_t`, etc. handle - basically
         *  any handle that deals with I/O - is active when it is doing something that
         *  involves I/O, like reading, writing, connecting, accepting new connections,
         *  etc.
         * 
         *  - A `uv_check_t`, `uv_idle_t`, `uv_timer_t`, etc. handle is active
         *  when it has been started with a call to `uv.check_start()`, `uv.idle_start()`,
         *  `uv.timer_start()` etc. until it has been stopped with a call to its
         *  respective stop function.
         */
        is_active(): fail<[success: boolean]>

        /**
         * 
         * Returns `true` if the handle is closing or closed, `false` otherwise.
         * 
         * **Note**: This function should only be used between the initialization of the
         * handle and the arrival of the close callback.
         */
        is_closing(): fail<[success: boolean]>

        /**
         * 
         * Request handle to be closed. `callback` will be called asynchronously after this
         * call. This MUST be called on each handle before memory is released.
         * 
         * Handles that wrap file descriptors are closed immediately but `callback` will
         * still be deferred to the next iteration of the event loop. It gives you a chance
         * to free up any resources associated with the handle.
         * 
         * In-progress requests, like `uv_connect_t` or `uv_write_t`, are cancelled and
         * have their callbacks called asynchronously with `ECANCELED`.
         */
        close(callback?: Function): void;

        /**
         * 
         * Reference the given handle. References are idempotent, that is, if a handle is
         * already referenced calling this function again will have no effect.
         */
        ref(): void

        /**
         * 
         * Un-reference the given handle. References are idempotent, that is, if a handle
         * is not referenced calling this function again will have no effect.
         */
        unref(): void

        /**
         * 
         * Returns `true` if the handle referenced, `false` if not.
         */
        has_ref(): fail<[success: boolean]>

        /**
         * 
         * Gets or sets the size of the send buffer that the operating system uses for the socket.
         * 
         * If `size` is omitted (or `0`), this will return the current send buffer size; otherwise, this will use `size` to set the new send buffer size.
         * 
         * This function works for TCP, pipe and UDP handles on Unix and for TCP and UDP
         * handles on Windows.
         * 
         * **Note**: Linux will set double the size and return double the size of the
         * original set value.
         */
        send_buffer_size(size?: number): fail<[success: 0]>

        /**
         * 
         * Gets or sets the size of the receive buffer that the operating system uses for the socket.
         * 
         * If `size` is omitted (or `0`), this will return the current send buffer size; otherwise, this will use `size` to set the new send buffer size.
         * 
         * This function works for TCP, pipe and UDP handles on Unix and for TCP and UDP
         * handles on Windows.
         * 
         * **Note**: Linux will set double the size and return double the size of the
         * original set value.
         */
        recv_buffer_size(size?: number): fail<[size: number]>

        /**
         * Gets the platform dependent file descriptor equivalent.
         * 
         * The following handles are supported: TCP, pipes, TTY, UDP and poll. Passing any
         * other handle type will fail with `EINVAL`.
         * 
         * If a handle doesn't have an attached file descriptor yet or the handle itself
         * has been closed, this function will return `EBADF`.
         * 
         * **Warning**: Be very careful when using this function. libuv assumes it's in
         * control of the file descriptor so any change to it may lead to malfunction.
         */
        fileno(): fail<[fileno: number]>;

        /**
         * 
         * Returns the name of the struct for a given handle (e.g. `"pipe"` for `uv_pipe_t`)
         * and the libuv enum integer for the handle's type (`uv_handle_type`).
         */
        get_type(): LuaMultiReturn<[handle_struct_name, handle_struct_type]>;
    }

    /**
     * 
     * Returns `true` if the handle is active, `false` if it's inactive. What "active”
     * means depends on the type of handle:
     * 
     *  - A `uv_async_t` handle is always active and cannot be deactivated, except
     *  by closing it with `uv.close()`.
     * 
     *  - A `uv_pipe_t`, `uv_tcp_t`, `uv_udp_t`, etc. handle - basically
     *  any handle that deals with I/O - is active when it is doing something that
     *  involves I/O, like reading, writing, connecting, accepting new connections,
     *  etc.
     * 
     *  - A `uv_check_t`, `uv_idle_t`, `uv_timer_t`, etc. handle is active
     *  when it has been started with a call to `uv.check_start()`, `uv.idle_start()`,
     *  `uv.timer_start()` etc. until it has been stopped with a call to its
     *  respective stop function.
     */
    function is_active(handle: uv_handle_t): fail<[success: boolean]>

    /**
     * 
     * Returns `true` if the handle is closing or closed, `false` otherwise.
     * 
     * **Note**: This function should only be used between the initialization of the
     * handle and the arrival of the close callback.
     */
    function is_closing(handle: uv_handle_t): fail<[success: boolean]>

    /**
     * 
     * Request handle to be closed. `callback` will be called asynchronously after this
     * call. This MUST be called on each handle before memory is released.
     * 
     * Handles that wrap file descriptors are closed immediately but `callback` will
     * still be deferred to the next iteration of the event loop. It gives you a chance
     * to free up any resources associated with the handle.
     * 
     * In-progress requests, like `uv_connect_t` or `uv_write_t`, are cancelled and
     * have their callbacks called asynchronously with `ECANCELED`.
     */
    function close(handle: uv_handle_t, callback?: Function): void;

    /**
     * 
     * Reference the given handle. References are idempotent, that is, if a handle is
     * already referenced calling this function again will have no effect.
     */
    function ref(handle: uv_handle_t): void

    /**
     * 
     * Un-reference the given handle. References are idempotent, that is, if a handle
     * is not referenced calling this function again will have no effect.
     */
    function unref(handle: uv_handle_t): void

    /**
     * 
     * Returns `true` if the handle referenced, `false` if not.
     */
    function has_ref(handle: uv_handle_t): fail<[success: boolean]>

    /**
     * 
     * Gets or sets the size of the send buffer that the operating system uses for the socket.
     * 
     * If `size` is omitted (or `0`), this will return the current send buffer size; otherwise, this will use `size` to set the new send buffer size.
     * 
     * This function works for TCP, pipe and UDP handles on Unix and for TCP and UDP
     * handles on Windows.
     * 
     * **Note**: Linux will set double the size and return double the size of the
     * original set value.
     */
    function send_buffer_size(handle: uv_handle_t, size?: number): fail<[success: 0]>

    /**
     * 
     * Gets or sets the size of the receive buffer that the operating system uses for the socket.
     * 
     * If `size` is omitted (or `0`), this will return the current send buffer size; otherwise, this will use `size` to set the new send buffer size.
     * 
     * This function works for TCP, pipe and UDP handles on Unix and for TCP and UDP
     * handles on Windows.
     * 
     * **Note**: Linux will set double the size and return double the size of the
     * original set value.
     */
    function recv_buffer_size(handle: uv_handle_t, size?: number): fail<[size: number]>

    /**
     * Gets the platform dependent file descriptor equivalent.
     * 
     * The following handles are supported: TCP, pipes, TTY, UDP and poll. Passing any
     * other handle type will fail with `EINVAL`.
     * 
     * If a handle doesn't have an attached file descriptor yet or the handle itself
     * has been closed, this function will return `EBADF`.
     * 
     * **Warning**: Be very careful when using this function. libuv assumes it's in
     * control of the file descriptor so any change to it may lead to malfunction.
     */
    function fileno(handle: uv_handle_t): fail<[fileno: number]>;

    /**
     * 
     * Returns the name of the struct for a given handle (e.g. `"pipe"` for `uv_pipe_t`)
     * and the libuv enum integer for the handle's type (`uv_handle_type`).
     */
    function handle_get_type(handle: uv_handle_t): LuaMultiReturn<[handle_struct_name, handle_struct_type]>;

    /**
     * Timer handles are used to schedule callbacks to be called in the future.
     */
    interface uv_timer_t extends uv_handle_t {
        /**
         * Start the timer. `timeout` and `repeat_n` are in milliseconds.
         * 
         * If `timeout` is zero, the callback fires on the next event loop iteration. If
         * `repeat_n` is non-zero, the callback fires first after `timeout` milliseconds and
         * then repeatedly after `repeat_n` milliseconds.
         */
        start(timeout: number, repeat_n: number, callback: Function): fail<[success: 0]>;

        /**
         * Stop the timer, the callback will not be called anymore.
         */
        stop(): fail<[success: 0]>

        /**
         * Stop the timer, and if it is repeating restart it using the repeat value as the
         * timeout. If the timer has never been started before it raises `EINVAL`.
         */
        again(): fail<[success: 0]>;

        /**
         * Set the repeat interval value in milliseconds. The timer will be scheduled to
         * run on the given interval, regardless of the callback execution duration, and
         * will follow normal timer semantics in the case of a time-slice overrun.
         * 
         * For example, if a 50 ms repeating timer first runs for 17 ms, it will be
         * scheduled to run again 33 ms later. If other tasks consume more than the 33 ms
         * following the first timer callback, then the callback will run as soon as
         * possible.
         */
        set_repeat(repeat_n: number): void;

        /**
         * Get the timer repeat value.
         */
        get_repeat(): number;

        /**
         * Get the timer due value or 0 if it has expired. The time is relative to `uv.now()`.
         * 
         * **Note**: New in libuv version 1.40.0.
         */
        get_due_in(): number;
    }

    /**
     * Start the timer. `timeout` and `repeat_n` are in milliseconds.
     * 
     * If `timeout` is zero, the callback fires on the next event loop iteration. If
     * `repeat_n` is non-zero, the callback fires first after `timeout` milliseconds and
     * then repeatedly after `repeat_n` milliseconds.
     */
    function timer_start(timer: uv_timer_t, timeout: number, repeat_n: number, callback: Function): fail<[success: 0]>;

    /**
     * Stop the timer, the callback will not be called anymore.
     */
    function timer_stop(timer: uv_timer_t): fail<[success: 0]>

    /**
     * Stop the timer, and if it is repeating restart it using the repeat value as the
     * timeout. If the timer has never been started before it raises `EINVAL`.
     */
    function timer_again(timer: uv_timer_t): fail<[success: 0]>;

    /**
     * Set the repeat interval value in milliseconds. The timer will be scheduled to
     * run on the given interval, regardless of the callback execution duration, and
     * will follow normal timer semantics in the case of a time-slice overrun.
     * 
     * For example, if a 50 ms repeating timer first runs for 17 ms, it will be
     * scheduled to run again 33 ms later. If other tasks consume more than the 33 ms
     * following the first timer callback, then the callback will run as soon as
     * possible.
     */
    function timer_set_repeat(timer: uv_timer_t, repeat_n: number): void;

    /**
     * Get the timer repeat value.
     */
    function timer_get_repeat(timer: uv_timer_t): number;

    /**
     * Get the timer due value or 0 if it has expired. The time is relative to `uv.now()`.
     * 
     * **Note**: New in libuv version 1.40.0.
     */
    function timer_get_due_in(timer: uv_timer_t): number;

    /**
     * 
     * Prepare handles will run the given callback once per loop iteration, right
     * before polling for I/O.
     * 
     * ```lua
     * local prepare = uv.new_prepare()
     * prepare:start(function()
     *   print("Before I/O polling")
     * end)
     * ```
     */
    interface uv_prepare_t extends uv_handle_t {
        /**
         * Start the handle with the given callback.
         */
        start(callback: Function): fail<[success: 0]>;

        /**
         * Stop the handle, the callback will no longer be called.
         */
        stop(): fail<[success: 0]>;
    }

    /**
     * Start the handle with the given callback.
     */
    function prepare_start(prepare: uv_prepare_t, callback: Function): fail<[success: 0]>;

    /**
     * Stop the handle, the callback will no longer be called.
     */
    function prepare_stop(prepare: uv_prepare_t): fail<[success: 0]>;

    /**
     * Check handles will run the given callback once per loop iteration, right after
     * polling for I/O.
     * 
     * ```lua
     * local check = uv.new_check()
     * check:start(function()
     *   print("After I/O polling")
     * end)
     * ```
     */
    interface uv_check_t extends uv_handle_t {
        /**
         * Start the handle with the given callback.
         */
        start(callback: Function): fail<[success: 0]>;

        /**
         * Stop the handle, the callback will no longer be called.
         */
        stop(): fail<[success: 0]>;
    }

    /**
     * Start the handle with the given callback.
     */
    function check_start(check: uv_check_t, callback: Function): fail<[success: 0]>;

    /**
     * Stop the handle, the callback will no longer be called.
     */
    function check_stop(check: uv_check_t): fail<[success: 0]>;

    /**
     * Idle handles will run the given callback once per loop iteration, right before
     * the `uv_prepare_t` handles.
     * 
     * **Note**: The notable difference with prepare handles is that when there are
     * active idle handles, the loop will perform a zero timeout poll instead of
     * blocking for I/O.
     * 
     * **Warning**: Despite the name, idle handles will get their callbacks called on
     * every loop iteration, not when the loop is actually "idle".
     * 
     * ```lua
     * local idle = uv.new_idle()
     * idle:start(function()
     *   print("Before I/O polling, no blocking")
     * end)
     * ```
     */
    interface uv_idle_t extends uv_handle_t {
        /**
         * Start the handle with the given callback.
         */
        start(callback: Function): fail<[success: 0]>;

        /**
         * Stop the handle, the callback will no longer be called.
         */
        stop(): fail<[success: 0]>;
    }

    /**
     * Start the handle with the given callback.
     */
    function idle_start(idle: uv_idle_t, callback: Function): fail<[success: 0]>;

    /**
     * Stop the handle, the callback will no longer be called.
     */
    function idle_stop(idle: uv_idle_t): fail<[success: 0]>;

    /**
     * Async handles allow the user to "wakeup" the event loop and get a callback
     * called from another thread.
     * 
     * ```lua
     * local async
     * async = uv.new_async(function()
     *   print("async operation ran")
     *   async:close()
     * end)
     * 
     * async:send()
     * ```
     */
    interface uv_async_t extends uv_handle_t {
        /**
         * Wakeup the event loop and call the async handle's callback.
         * 
         * **Note**: It's safe to call this function from any thread. The callback will be
         * called on the loop thread.
         * 
         * **Warning**: libuv will coalesce calls to `uv.async_send(async)`, that is, not
         * every call to it will yield an execution of the callback. For example: if
         * `uv.async_send()` is called 5 times in a row before the callback is called, the
         * callback will only be called once. If `uv.async_send()` is called again after
         * the callback was called, it will be called again.
         */
        send(...args: threadargs[]): fail<[success: 0]>
    }

    /**
     * Wakeup the event loop and call the async handle's callback.
     * 
     * **Note**: It's safe to call this function from any thread. The callback will be
     * called on the loop thread.
     * 
     * **Warning**: libuv will coalesce calls to `uv.async_send(async)`, that is, not
     * every call to it will yield an execution of the callback. For example: if
     * `uv.async_send()` is called 5 times in a row before the callback is called, the
     * callback will only be called once. If `uv.async_send()` is called again after
     * the callback was called, it will be called again.
     */
    function async_send(async: uv_async_t, ...args: threadargs[]): fail<[success: 0]>

    /**
     * Poll handles are used to watch file descriptors for readability and writability,
     * similar to the purpose of [poll(2)](http://linux.die.net/man/2/poll).
     * 
     * The purpose of poll handles is to enable integrating external libraries that
     * rely on the event loop to signal it about the socket status changes, like c-ares
     * or libssh2. Using `uv_poll_t` for any other purpose is not recommended;
     * `uv_tcp_t`, `uv_udp_t`, etc. provide an implementation that is faster and more
     * scalable than what can be achieved with `uv_poll_t`, especially on Windows.
     * 
     * It is possible that poll handles occasionally signal that a file descriptor is
     * readable or writable even when it isn't. The user should therefore always be
     * prepared to handle EAGAIN or equivalent when it attempts to read from or write
     * to the fd.
     * 
     * It is not okay to have multiple active poll handles for the same socket, this
     * can cause libuv to busyloop or otherwise malfunction.
     * 
     * The user should not close a file descriptor while it is being polled by an
     * active poll handle. This can cause the handle to report an error, but it might
     * also start polling another socket. However the fd can be safely closed
     * immediately after a call to `uv.poll_stop()` or `uv.close()`.
     * 
     * **Note**: On windows only sockets can be polled with poll handles. On Unix any
     * file descriptor that would be accepted by poll(2) can be used.
     */
    interface uv_poll_t extends uv_handle_t {
        /**
         * Starts polling the file descriptor.
         * See alias below for accepted `events`, where `r` is `READABLE`, `w` is `WRITABLE`, `d` is
         * `DISCONNECT`, and `p` is `PRIORITIZED`.
         * As soon as an event is detected
         * the callback will be called with status set to 0, and the detected events set on
         * the events field.
         * 
         * The user should not close the socket while the handle is active. If the user
         * does that anyway, the callback may be called reporting an error status, but this
         * is not guaranteed.
         * 
         * **Note** Calling `uv.poll_start()` on a handle that is already active is fine.
         * Doing so will update the events mask that is being watched for.
         */
        start(events: poll_events | undefined, callback: (err?: string, events?: poll_events) => void): fail<[success: 0]>;

        /**
         * Stop polling the file descriptor, the callback will no longer be called.
         */
        stop(): fail<[success: 0]>;
    }

    /**
     * Starts polling the file descriptor.
     * See alias below for accepted `events`, where `r` is `READABLE`, `w` is `WRITABLE`, `d` is
     * `DISCONNECT`, and `p` is `PRIORITIZED`.
     * As soon as an event is detected
     * the callback will be called with status set to 0, and the detected events set on
     * the events field.
     * 
     * The user should not close the socket while the handle is active. If the user
     * does that anyway, the callback may be called reporting an error status, but this
     * is not guaranteed.
     * 
     * **Note** Calling `uv.poll_start()` on a handle that is already active is fine.
     * Doing so will update the events mask that is being watched for.
     */
    function poll_start(poll: uv_poll_t, events: poll_events | undefined, callback: (err?: string, events?: poll_events) => void): fail<[success: 0]>;

    /**
     * Stop polling the file descriptor, the callback will no longer be called.
     */
    function poll_stop(poll: uv_poll_t): fail<[success: 0]>;

    /**
     * Signal handles implement Unix style signal handling on a per-event loop bases.
     * 
     * **Windows Notes:**
     * 
     * Reception of some signals is emulated on Windows:
     *   - SIGINT is normally delivered when the user presses CTRL+C. However, like on
     *   Unix, it is not generated when terminal raw mode is enabled.
     *   - SIGBREAK is delivered when the user pressed CTRL + BREAK.
     *   - SIGHUP is generated when the user closes the console window. On SIGHUP the
     *   program is given approximately 10 seconds to perform cleanup. After that
     *   Windows will unconditionally terminate it.
     *   - SIGWINCH is raised whenever libuv detects that the console has been resized.
     *   SIGWINCH is emulated by libuv when the program uses a uv_tty_t handle to write
     *   to the console. SIGWINCH may not always be delivered in a timely manner; libuv
     *   will only detect size changes when the cursor is being moved. When a readable
     *   [`uv_tty_t`][] handle is used in raw mode, resizing the console buffer will
     *   also trigger a SIGWINCH signal.
     *   - Watchers for other signals can be successfully created, but these signals
     *   are never received. These signals are: SIGILL, SIGABRT, SIGFPE, SIGSEGV,
     *   SIGTERM and SIGKILL.
     *   - Calls to raise() or abort() to programmatically raise a signal are not
     *   detected by libuv; these will not trigger a signal watcher.
     * 
     * **Unix Notes:**
     * 
     *   - SIGKILL and SIGSTOP are impossible to catch.
     *   - Handling SIGBUS, SIGFPE, SIGILL or SIGSEGV via libuv results into undefined
     *   behavior.
     *   - SIGABRT will not be caught by libuv if generated by abort(), e.g. through
     *   assert().
     *   - On Linux SIGRT0 and SIGRT1 (signals 32 and 33) are used by the NPTL pthreads
     *   library to manage threads. Installing watchers for those signals will lead to
     *   unpredictable behavior and is strongly discouraged. Future versions of libuv
     *   may simply reject them.
     * 
     * ```lua
     * -- Create a new signal handler
     * local signal = uv.new_signal()
     * -- Define a handler function
     * uv.signal_start(signal, "sigint", function(signal)
     *   print("got " .. signal .. ", shutting down")
     *   os.exit(1)
     * end)
     * ```
     */
    interface uv_signal_t extends uv_handle_t {
        /**
         * Start the handle with the given callback, watching for the given signal.
         */
        start(signum: number | signals, callback?: (signum: signals) => void): fail<[success: 0]>;

        /**
         * Same functionality as `uv.signal_start()` but the signal handler is reset the moment the signal is received.
         */
        start_oneshot(signum: number | signals, callback?: (signum: signals) => void): fail<[success: 0]>;

        /**
         * Stop the handle, the callback will no longer be called.
         */
        stop(): fail<[success: 0]>;
    }

    /**
     * Start the handle with the given callback, watching for the given signal.
     */
    function signal_start(signal: uv_signal_t, signum: number | signals, callback?: (signum: signals) => void): fail<[success: 0]>;

    /**
     * Same functionality as `uv.signal_start()` but the signal handler is reset the moment the signal is received.
     */
    function signal_start_oneshot(signal: uv_signal_t, signum: number | signals, callback?: (signum: signals) => void): fail<[success: 0]>;

    /**
     * Stop the handle, the callback will no longer be called.
     */
    function signal_stop(signal: uv_signal_t): fail<[success: 0]>;

    /**
     * Process handles will spawn a new process and allow the user to control it and
     * establish communication channels with it using streams.
     */
    interface uv_process_t extends uv_handle_t {
        /**
         * Sends the specified signal to the given process handle.
         */
        kill(signum: number | signals): fail<[success: 0]>;

        /**
         * Returns the handle's pid.
         */
        get_pid(): number;
    }

    /**
     * Sends the specified signal to the given process handle.
     */
    function process_kill(process: uv_process_t, signum: number | signals): fail<[success: 0]>;

    /**
     * Returns the handle's pid.
     */
    function process_get_pid(process: uv_process_t): number;

    /**
     * Stream handles provide an abstraction of a duplex communication channel.
     * `uv_stream_t` is an abstract type, libuv provides 3 stream implementations
     * in the form of `uv_tcp_t`, `uv_pipe_t` and `uv_tty_t`.
     */
    interface uv_stream_t extends uv_handle_t {
        /**
         * Shutdown the outgoing (write) side of a duplex stream. It waits for pending
         * write requests to complete. The callback is called after shutdown is complete.
         */
        shutdown(callback?: (err?: string) => void): fail<[uv_shutdown_t]>

        /**
         * Start listening for incoming connections. `backlog` indicates the number of
         * connections the kernel might queue, same as `listen(2)`. When a new incoming
         * connection is received the callback is called.
         */
        listen(backlog: number, callback: (err?: string) => void): fail<[success: 0]>;

        /**
         * This call is used in conjunction with `uv.listen()` to accept incoming
         * connections. Call this function after receiving a callback to accept the
         * connection.
         * 
         * When the connection callback is called it is guaranteed that this function
         * will complete successfully the first time. If you attempt to use it more than
         * once, it may fail. It is suggested to only call this function once per
         * connection call.
         * 
         * ```lua
         * server:listen(128, function (err)
         *   local client = uv.new_tcp()
         *   server:accept(client)
         * end)
         * ```
         */
        accept(client_stream: uv_stream_t): fail<[success: 0]>;

        /**
         * Read data from an incoming stream. The callback will be made several times until
         * there is no more data to read or `uv.read_stop()` is called. When we've reached
         * EOF, `data` will be `nil`.
         * 
         * ```lua
         * stream:read_start(function (err, chunk)
         *   if err then
         *     -- handle read error
         *   elseif chunk then
         *     -- handle data
         *   else
         *     -- handle disconnect
         *   end
         * end)
         * ```
         */
        read_start(callback: (err?: string, data?: string) => void): fail<[success: 0]>;

        /**
         * Stop reading data from the stream. The read callback will no longer be called.
         * This function is idempotent and may be safely called on a stopped stream.
         */
        read_stop(): fail<[success: 0]>

        /**
         * Write data to stream.
         * `data` can either be a Lua string or a table of strings. If a table is passed
         * in, the C backend will use writev to send all strings in a single system call.
         * The optional `callback` is for knowing when the write is complete.
         */
        write(data: buffer, callback: (err?: string) => void): fail<[uv_write_t]>;

        /**
         * Extended write function for sending handles over a pipe. The pipe must be
         * initialized with `ipc` option `true`.
         * 
         * **Note:** `send_handle` must be a TCP socket or pipe, which is a server or a
         * connection (listening or connected state). Bound sockets or pipes will be
         * assumed to be servers.
         */
        write2(data: buffer, send_handle: uv_tcp_t | uv_pipe_t, callback?: Function): fail<[uv_write_t]>;

        /**
         * Same as `uv.write()`, but won't queue a write request if it can't be completed
         * immediately.
         * Will return number of bytes written (can be less than the supplied buffer size).
         */
        try_write(data: buffer): fail<[bytes: number]>;

        /**
         * Like `uv.write2()`, but with the properties of `uv.try_write()`. Not supported on Windows, where it returns `UV_EAGAIN`.
         * Will return number of bytes written (can be less than the supplied buffer size).
         */
        try_write2(data: buffer, send_handle: uv_tcp_t | uv_pipe_t): fail<[bytes: number]>;

        /**
         * Returns `true` if the stream is readable, `false` otherwise.
         */
        is_readable(): boolean

        /**
         * Returns `true` if the stream is writable, `false` otherwise.
         */
        is_writable(): boolean;

        /**
         * Enable or disable blocking mode for a stream.
         * When blocking mode is enabled all writes complete synchronously. The interface
         * remains unchanged otherwise, e.g. completion or failure of the operation will
         * still be reported through a callback which is made asynchronously.
         * 
         * **Warning**: Relying too much on this API is not recommended. It is likely to
         * change significantly in the future. Currently this only works on Windows and
         * only for `uv_pipe_t` handles. Also libuv currently makes no ordering guarantee
         * when the blocking mode is changed after write requests have already been
         * submitted. Therefore it is recommended to set the blocking mode immediately
         * after opening or creating the stream.
         */
        set_blocking(blocking: boolean): fail<[success: 0]>;

        /**
         * Returns the stream's write queue size.
         */
        get_write_queue_size(): number;
    }

    /**
     * Shutdown the outgoing (write) side of a duplex stream. It waits for pending
     * write requests to complete. The callback is called after shutdown is complete.
     */
    function shutdown(stream: uv_stream_t, callback?: (err?: string) => void): fail<[uv_shutdown_t]>

    /**
     * Start listening for incoming connections. `backlog` indicates the number of
     * connections the kernel might queue, same as `listen(2)`. When a new incoming
     * connection is received the callback is called.
     */
    function listen(stream: uv_stream_t, backlog: number, callback: (err?: string) => void): fail<[success: 0]>;

    /**
     * This call is used in conjunction with `uv.listen()` to accept incoming
     * connections. Call this function after receiving a callback to accept the
     * connection.
     * 
     * When the connection callback is called it is guaranteed that this function
     * will complete successfully the first time. If you attempt to use it more than
     * once, it may fail. It is suggested to only call this function once per
     * connection call.
     * 
     * ```lua
     * server:listen(128, function (err)
     *   local client = uv.new_tcp()
     *   server:accept(client)
     * end)
     * ```
     */
    function accept(stream: uv_stream_t, client_stream: uv_stream_t): fail<[success: 0]>;

    /**
     * Read data from an incoming stream. The callback will be made several times until
     * there is no more data to read or `uv.read_stop()` is called. When we've reached
     * EOF, `data` will be `nil`.
     * 
     * ```lua
     * stream:read_start(function (err, chunk)
     *   if err then
     *     -- handle read error
     *   elseif chunk then
     *     -- handle data
     *   else
     *     -- handle disconnect
     *   end
     * end)
     * ```
     */
    function read_start(stream: uv_stream_t, callback: (err?: string, data?: string) => void): fail<[success: 0]>;

    /**
     * Stop reading data from the stream. The read callback will no longer be called.
     * This function is idempotent and may be safely called on a stopped stream.
     */
    function read_stop(stream: uv_stream_t): fail<[success: 0]>

    /**
     * Write data to stream.
     * `data` can either be a Lua string or a table of strings. If a table is passed
     * in, the C backend will use writev to send all strings in a single system call.
     * The optional `callback` is for knowing when the write is complete.
     */
    function write(stream: uv_stream_t, data: buffer, callback: (err?: string) => void): fail<[uv_write_t]>;

    /**
     * Extended write function for sending handles over a pipe. The pipe must be
     * initialized with `ipc` option `true`.
     * 
     * **Note:** `send_handle` must be a TCP socket or pipe, which is a server or a
     * connection (listening or connected state). Bound sockets or pipes will be
     * assumed to be servers.
     */
    function write2(stream: uv_stream_t, data: buffer, send_handle: uv_tcp_t | uv_pipe_t, callback?: Function): fail<[uv_write_t]>;

    /**
     * Same as `uv.write()`, but won't queue a write request if it can't be completed
     * immediately.
     * Will return number of bytes written (can be less than the supplied buffer size).
     */
    function try_write(stream: uv_stream_t, data: buffer): fail<[bytes: number]>;

    /**
     * Like `uv.write2()`, but with the properties of `uv.try_write()`. Not supported on Windows, where it returns `UV_EAGAIN`.
     * Will return number of bytes written (can be less than the supplied buffer size).
     */
    function try_write2(stream: uv_stream_t, data: buffer, send_handle: uv_tcp_t | uv_pipe_t): fail<[bytes: number]>;

    /**
     * Returns `true` if the stream is readable, `false` otherwise.
     */
    function is_readable(stream: uv_stream_t): boolean

    /**
     * Returns `true` if the stream is writable, `false` otherwise.
     */
    function is_writable(stream: uv_stream_t): boolean;

    /**
     * Enable or disable blocking mode for a stream.
     * When blocking mode is enabled all writes complete synchronously. The interface
     * remains unchanged otherwise, e.g. completion or failure of the operation will
     * still be reported through a callback which is made asynchronously.
     * 
     * **Warning**: Relying too much on this API is not recommended. It is likely to
     * change significantly in the future. Currently this only works on Windows and
     * only for `uv_pipe_t` handles. Also libuv currently makes no ordering guarantee
     * when the blocking mode is changed after write requests have already been
     * submitted. Therefore it is recommended to set the blocking mode immediately
     * after opening or creating the stream.
     */
    function stream_set_blocking(stream: uv_stream_t, blocking: boolean): fail<[success: 0]>;

    /**
     * Returns the stream's write queue size.
     */
    function stream_get_write_queue_size(): number;

    /**
     * TCP handles are used to represent both TCP streams and servers.
     */
    interface uv_tcp_t extends uv_stream_t {
        /**
         * Open an existing file descriptor or SOCKET as a TCP handle.
         * 
         * **Note:** The passed file descriptor or SOCKET is not checked for its type, but it's required that it represents a valid stream socket.
         */
        open(sock: number): fail<[success: 0]>;

        /**
         * Enable / disable Nagle's algorithm.
         */
        nodelay(enable: boolean): fail<[success: 0]>

        /**
         * Enable / disable TCP keep-alive. `delay` is the initial delay in seconds,
         * ignored when enable is `false`.
         */
        keepalive(enable: boolean, delay?: number): fail<[success: 0]>;

        /**
         * Enable / disable simultaneous asynchronous accept requests that are queued by
         * the operating system when listening for new TCP connections.
         * 
         * This setting is used to tune a TCP server for the desired performance. Having
         * simultaneous accepts can significantly improve the rate of accepting connections
         * (which is why it is enabled by default) but may lead to uneven load distribution
         * in multi-process setups.
         */
        simultaneous_accepts(enable: boolean): fail<[success: 0]>;

        /**
         * Bind the handle to an host and port. `host` should be an IP address and
         * not a domain name. Any `flags` are set with a table with field `ipv6only`
         * equal to `true` or `false`.
         * 
         * When the port is already taken, you can expect to see an `EADDRINUSE` error
         * from either `uv.tcp_bind()`, `uv.listen()` or `uv.tcp_connect()`. That is, a
         * successful call to this function does not guarantee that the call to `uv.listen()`
         * or `uv.tcp_connect()` will succeed as well.
         * 
         * Use a port of `0` to let the OS assign an ephemeral port.  You can look it up
         * later using `uv.tcp_getsockname()`.
         */
        bind(host: string, port: number, flags: tcp_bind_flags): fail<[success: 0]>

        /**
         * Get the address of the peer connected to the handle.
         */
        getpeername(): fail<[getpeername_rtn]>;

        /**
         * Get the current address to which the handle is bound.
         */
        getsockname(): fail<[getsockname_rtn]>;

        /**
         * Establish an IPv4 or IPv6 TCP connection.
         * 
         * ```lua
         * local client = uv.new_tcp()
         * client:connect("127.0.0.1", 8080, function (err)
         *   -- check error and carry on.
         * end)
         * ```
         */
        connect(host: string, port: number, callback: (err?: string) => void): fail<[uv_connect_t]>;

        /**
         * Please use `uv.stream_get_write_queue_size()` instead.
         * 
         * @deprecated
         */
        write_queue_size(): unknown;

        /**
         * Resets a TCP connection by sending a RST packet. This is accomplished by setting
         * the SO_LINGER socket option with a linger interval of zero and then calling
         * `uv.close()`. Due to some platform inconsistencies, mixing of `uv.shutdown()`
         * and `uv.tcp_close_reset()` calls is not allowed.
         */
        close_reset(callback?: Function): fail<[success: 0]>;
    }

    /**
     * Open an existing file descriptor or SOCKET as a TCP handle.
     * 
     * **Note:** The passed file descriptor or SOCKET is not checked for its type, but it's required that it represents a valid stream socket.
     */
    function tcp_open(tcp: uv_tcp_t, sock: number): fail<[success: 0]>;

    /**
     * Enable / disable Nagle's algorithm.
     */
    function tcp_nodelay(tcp: uv_tcp_t, enable: boolean): fail<[success: 0]>

    /**
     * Enable / disable TCP keep-alive. `delay` is the initial delay in seconds,
     * ignored when enable is `false`.
     */
    function tcp_keepalive(tcp: uv_tcp_t, enable: boolean, delay?: number): fail<[success: 0]>;

    /**
     * Enable / disable simultaneous asynchronous accept requests that are queued by
     * the operating system when listening for new TCP connections.
     * 
     * This setting is used to tune a TCP server for the desired performance. Having
     * simultaneous accepts can significantly improve the rate of accepting connections
     * (which is why it is enabled by default) but may lead to uneven load distribution
     * in multi-process setups.
     */
    function tcp_simultaneous_accepts(tcp: uv_tcp_t, enable: boolean): fail<[success: 0]>;

    /**
     * Bind the handle to an host and port. `host` should be an IP address and
     * not a domain name. Any `flags` are set with a table with field `ipv6only`
     * equal to `true` or `false`.
     * 
     * When the port is already taken, you can expect to see an `EADDRINUSE` error
     * from either `uv.tcp_bind()`, `uv.listen()` or `uv.tcp_connect()`. That is, a
     * successful call to this function does not guarantee that the call to `uv.listen()`
     * or `uv.tcp_connect()` will succeed as well.
     * 
     * Use a port of `0` to let the OS assign an ephemeral port.  You can look it up
     * later using `uv.tcp_getsockname()`.
     */
    function tcp_bind(tcp: uv_tcp_t, host: string, port: number, flags: tcp_bind_flags): fail<[success: 0]>

    /**
     * Get the address of the peer connected to the handle.
     */
    function tcp_getpeername(tcp: uv_tcp_t): fail<[getpeername_rtn]>;

    /**
     * Get the current address to which the handle is bound.
     */
    function tcp_getsockname(tcp: uv_tcp_t): fail<[getsockname_rtn]>;

    /**
     * Establish an IPv4 or IPv6 TCP connection.
     * 
     * ```lua
     * local client = uv.new_tcp()
     * client:connect("127.0.0.1", 8080, function (err)
     *   -- check error and carry on.
     * end)
     * ```
     */
    function tcp_connect(tcp: uv_tcp_t, host: string, port: number, callback: (err?: string) => void): fail<[uv_connect_t]>;

    /**
     * Please use `uv.stream_get_write_queue_size()` instead.
     * 
     * @deprecated
     */
    function tcp_write_queue_size(tcp: uv_tcp_t): unknown;

    /**
     * Resets a TCP connection by sending a RST packet. This is accomplished by setting
     * the SO_LINGER socket option with a linger interval of zero and then calling
     * `uv.close()`. Due to some platform inconsistencies, mixing of `uv.shutdown()`
     * and `uv.tcp_close_reset()` calls is not allowed.
     */
    function tcp_close_reset(tcp: uv_tcp_t, callback?: Function): fail<[success: 0]>;

    /**
     * Pipe handles provide an abstraction over local domain sockets on Unix and named pipes on Windows.
     * 
     * ```lua
     * local pipe = uv.new_pipe(false)
     * 
     * pipe:bind('/tmp/sock.test')
     * 
     * pipe:listen(128, function()
     *   local client = uv.new_pipe(false)
     *   pipe:accept(client)
     *   client:write("hello!\n")
     *   client:close()
     * end)
     * ```
     */
    interface uv_pipe_t extends uv_stream_t {
        /**
         * Open an existing file descriptor or `uv_handle_t` as a pipe.
         * 
         * **Note**: The file descriptor is set to non-blocking mode.
         */
        open(fd: number): fail<[success: 0]>

        /**
         * Bind the pipe to a file path (Unix) or a name (Windows).
         * 
         * **Note**: Paths on Unix get truncated to sizeof(sockaddr_un.sun_path) bytes,
         * typically between 92 and 108 bytes.
         */
        bind(name: string): fail<[success: 0]>

        /**
         * Connect to the Unix domain socket or the named pipe.
         * 
         * **Note**: Paths on Unix get truncated to sizeof(sockaddr_un.sun_path) bytes,
         * typically between 92 and 108 bytes.
         */
        connect(name: string, callback?: (err?: string) => void): fail<[uv_connect_t]>;

        /**
         * Get the name of the Unix domain socket or the named pipe.
         */
        getsockname(): fail<[string]>;

        /**
         * Get the name of the Unix domain socket or the named pipe to which the handle is
         * connected.
         */
        getpeername(): fail<[string]>;

        /**
         * Set the number of pending pipe instance handles when the pipe server is waiting
         * for connections.
         * 
         * **Note**: This setting applies to Windows only.
         */
        pending_instances(count: number): void;

        /**
         * Returns the pending pipe count for the named pipe.
         */
        pending_count(): number;

        /**
         * Used to receive handles over IPC pipes.
         * 
         * First - call `uv.pipe_pending_count()`, if it's > 0 then initialize a handle of
         * the given type, returned by `uv.pipe_pending_type()` and call
         * `uv.accept(pipe, handle)`.
         */
        pending_type(): string;

        /**
         * Alters pipe permissions, allowing it to be accessed from processes run by different users.
         * Makes the pipe writable or readable by all users.
         * See below for accepted flags, where `r` is `READABLE` and `w` is `WRITABLE`.
         * This function is blocking.
         */
        chmod(flags: pipe_chmod_flags): fail<[success: 0]>;
    }

    /**
     * Open an existing file descriptor or `uv_handle_t` as a pipe.
     * 
     * **Note**: The file descriptor is set to non-blocking mode.
     */
    function pipe_open(pipe: uv_pipe_t, fd: number): fail<[success: 0]>

    /**
     * Bind the pipe to a file path (Unix) or a name (Windows).
     * 
     * **Note**: Paths on Unix get truncated to sizeof(sockaddr_un.sun_path) bytes,
     * typically between 92 and 108 bytes.
     */
    function pipe_bind(pipe: uv_pipe_t, name: string): fail<[success: 0]>

    /**
     * Connect to the Unix domain socket or the named pipe.
     * 
     * **Note**: Paths on Unix get truncated to sizeof(sockaddr_un.sun_path) bytes,
     * typically between 92 and 108 bytes.
     */
    function pipe_connect(pipe: uv_pipe_t, name: string, callback?: (err?: string) => void): fail<[uv_connect_t]>;

    /**
     * Get the name of the Unix domain socket or the named pipe.
     */
    function pipe_getsockname(pipe: uv_pipe_t): fail<[string]>;

    /**
     * Get the name of the Unix domain socket or the named pipe to which the handle is
     * connected.
     */
    function pipe_getpeername(pipe: uv_pipe_t): fail<[string]>;

    /**
     * Set the number of pending pipe instance handles when the pipe server is waiting
     * for connections.
     * 
     * **Note**: This setting applies to Windows only.
     */
    function pipe_pending_instances(pipe: uv_pipe_t, count: number): void;

    /**
     * Returns the pending pipe count for the named pipe.
     */
    function pipe_pending_count(pipe: uv_pipe_t): number;

    /**
     * Used to receive handles over IPC pipes.
     * 
     * First - call `uv.pipe_pending_count()`, if it's > 0 then initialize a handle of
     * the given type, returned by `uv.pipe_pending_type()` and call
     * `uv.accept(pipe, handle)`.
     */
    function pipe_pending_type(pipe: uv_pipe_t): string;

    /**
     * Alters pipe permissions, allowing it to be accessed from processes run by different users.
     * Makes the pipe writable or readable by all users.
     * See below for accepted flags, where `r` is `READABLE` and `w` is `WRITABLE`.
     * This function is blocking.
     */
    function pipe_chmod(pipe: uv_pipe_t, flags: pipe_chmod_flags): fail<[success: 0]>;

    /**
     * TTY handles represent a stream for the console.
     * 
     * ```lua
     * -- Simple echo program
     * local stdin = uv.new_tty(0, true)
     * local stdout = uv.new_tty(1, false)
     * 
     * stdin:read_start(function (err, data)
     *   assert(not err, err)
     *   if data then
     *     stdout:write(data)
     *   else
     *     stdin:close()
     *     stdout:close()
     *   end
     * end)
     * ```
     */
    interface uv_tty_t extends uv_stream_t {
        /**
         * Set the TTY using the specified terminal mode.
         * 
         * Parameter `mode` is a C enum with the values below.
         */
        set_mode(mode: tty_mode): fail<[success: 0]>;

        /**
         * Gets the current Window width and height.
         */
        get_winsize(): fail<[width: number, height: number]>;
    }

    /**
     * Set the TTY using the specified terminal mode.
     * 
     * Parameter `mode` is a C enum with the values below.
     */
    function tty_set_mode(tty: uv_tty_t, mode: tty_mode): fail<[success: 0]>;

    /**
     * Gets the current Window width and height.
     */
    function tty_get_winsize(tty: uv_tty_t): fail<[width: number, height: number]>;

    /**
     * UDP handles encapsulate UDP communication for both clients and servers.
     */
    interface uv_udp_t extends uv_handle_t {
        /**
         * Returns the handle's send queue size.
         */
        get_send_queue_size(): number;

        /**
         * Returns the handle's send queue count.
         */
        get_send_queue_count(): number;

        /**
         * Opens an existing file descriptor or Windows SOCKET as a UDP handle.
         * 
         * Unix only: The only requirement of the sock argument is that it follows the
         * datagram contract (works in unconnected mode, supports sendmsg()/recvmsg(),
         * etc). In other words, other datagram-type sockets like raw sockets or netlink
         * sockets can also be passed to this function.
         * 
         * The file descriptor is set to non-blocking mode.
         * 
         * **Note:** The passed file descriptor or SOCKET is not checked for its type, but
         * it's required that it represents a valid datagram socket.
         */
        open(fd: number): fail<[success: 0]>;

        /**
         * Bind the UDP handle to an IP address and port. Any `flags` are set with a table
         * with fields `reuseaddr` or `ipv6only` equal to `true` or `false`.
         */
        bind(host: string, port: number, flags: udp_bind_flags): fail<[success: 0]>;

        /**
         * Get the local IP and port of the UDP handle.
         */
        getsockname(): fail<[udp_getsockname_rtn]>;

        /**
         * Get the remote IP and port of the UDP handle on connected UDP handles.
         */
        getpeername(): fail<[udp_getpeername_rtn]>;

        /**
         * Set membership for a multicast address. `multicast_addr` is multicast address to
         * set membership for. `interface_addr` is interface address. `membership` can be
         * the string `"leave"` or `"join"`.
         */
        set_membership(multicast_addr: string, interface_addr: string | undefined, membership: udp_membership): fail<[success: 0]>;

        /**
         * Set membership for a source-specific multicast group. `multicast_addr` is multicast
         * address to set membership for. `interface_addr` is interface address. `source_addr`
         * is source address. `membership` can be the string `"leave"` or `"join"`.
         */
        set_source_membership(multicast_addr: string, interface_addr: string | undefined, source_addr: string, membership: udp_membership): fail<[success: 0]>;

        /**
         * Set IP multicast loop flag. Makes multicast packets loop back to local
         * sockets.
         */
        set_multicast_loop(on: boolean): fail<[success: 0]>;

        /**
         * Set the multicast ttl.
         * `ttl` is an integer 1 through 255.
         */
        set_multicast_ttl(ttl: number): fail<[success: 0]>;

        /**
         * Set the multicast interface to send or receive data on.
         */
        set_multicast_interface(interface_addr: string): fail<[success: 0]>;

        /**
         * Set broadcast on or off.
         */
        set_broadcast(on: boolean): fail<[success: 0]>;

        /**
         * Set the time to live.
         * `ttl` is an integer 1 through 255.
         */
        set_ttl(ttl: number): fail<[success: 0]>;

        /**
         * Send data over the UDP socket. If the socket has not previously been bound
         * with `uv.udp_bind()` it will be bound to `0.0.0.0` (the "all interfaces" IPv4
         * address) and a random port number.
         */
        send(data: buffer, host: string, port: number, callback: (err?: string) => void): fail<[uv_udp_send_t]>;

        /**
         * Same as `uv.udp_send()`, but won't queue a send request if it can't be
         * completed immediately.
         */
        try_send(data: buffer, host: string, port: number): fail<[bytes: number]>;

        /**
         * Prepare for receiving data. If the socket has not previously been bound with
         * `uv.udp_bind()` it is bound to `0.0.0.0` (the "all interfaces" IPv4 address)
         * and a random port number.
         */
        recv_start(callback: (err: string | undefined, data: string | undefined, add: udp_getpeername_rtn | undefined, flags: udp_recv_start_callback_flags) => void): fail<[success: 0]>;

        /**
         * Stop listening for incoming datagrams.
         */
        recv_stop(): fail<[success: 0]>;

        /**
         * Associate the UDP handle to a remote address and port, so every message sent by
         * this handle is automatically sent to that destination. Calling this function
         * with a NULL addr disconnects the handle. Trying to call `uv.udp_connect()` on an
         * already connected handle will result in an `EISCONN` error. Trying to disconnect
         * a handle that is not connected will return an `ENOTCONN` error.
         */
        connect(host: string, port: number): fail<[success: 0]>;
    }

    /**
     * Returns the handle's send queue size.
     */
    function udp_get_send_queue_size(): number;

    /**
     * Returns the handle's send queue count.
     */
    function udp_get_send_queue_count(): number;

    /**
     * Opens an existing file descriptor or Windows SOCKET as a UDP handle.
     * 
     * Unix only: The only requirement of the sock argument is that it follows the
     * datagram contract (works in unconnected mode, supports sendmsg()/recvmsg(),
     * etc). In other words, other datagram-type sockets like raw sockets or netlink
     * sockets can also be passed to this function.
     * 
     * The file descriptor is set to non-blocking mode.
     * 
     * **Note:** The passed file descriptor or SOCKET is not checked for its type, but
     * it's required that it represents a valid datagram socket.
     */
    function udp_open(udp: uv_udp_t, fd: number): fail<[success: 0]>;

    /**
     * Bind the UDP handle to an IP address and port. Any `flags` are set with a table
     * with fields `reuseaddr` or `ipv6only` equal to `true` or `false`.
     */
    function udp_bind(udp: uv_udp_t, host: string, port: number, flags: udp_bind_flags): fail<[success: 0]>;

    /**
     * Get the local IP and port of the UDP handle.
     */
    function udp_getsockname(udp: uv_udp_t): fail<[udp_getsockname_rtn]>;

    /**
     * Get the remote IP and port of the UDP handle on connected UDP handles.
     */
    function udp_getpeername(udp: uv_udp_t): fail<[udp_getpeername_rtn]>;

    /**
     * Set membership for a multicast address. `multicast_addr` is multicast address to
     * set membership for. `interface_addr` is interface address. `membership` can be
     * the string `"leave"` or `"join"`.
     */
    function udp_set_membership(udp: uv_udp_t, multicast_addr: string, interface_addr: string | undefined, membership: udp_membership): fail<[success: 0]>;

    /**
     * Set membership for a source-specific multicast group. `multicast_addr` is multicast
     * address to set membership for. `interface_addr` is interface address. `source_addr`
     * is source address. `membership` can be the string `"leave"` or `"join"`.
     */
    function udp_set_source_membership(udp: uv_udp_t, multicast_addr: string, interface_addr: string | undefined, source_addr: string, membership: udp_membership): fail<[success: 0]>;

    /**
     * Set IP multicast loop flag. Makes multicast packets loop back to local
     * sockets.
     */
    function udp_set_multicast_loop(udp: uv_udp_t, on: boolean): fail<[success: 0]>;

    /**
     * Set the multicast ttl.
     * `ttl` is an integer 1 through 255.
     */
    function udp_set_multicast_ttl(udp: uv_udp_t, ttl: number): fail<[success: 0]>;

    /**
     * Set the multicast interface to send or receive data on.
     */
    function udp_set_multicast_interface(udp: uv_udp_t, interface_addr: string): fail<[success: 0]>;

    /**
     * Set broadcast on or off.
     */
    function udp_set_broadcast(udp: uv_udp_t, on: boolean): fail<[success: 0]>;

    /**
     * Set the time to live.
     * `ttl` is an integer 1 through 255.
     */
    function udp_set_ttl(udp: uv_udp_t, ttl: number): fail<[success: 0]>;

    /**
     * Send data over the UDP socket. If the socket has not previously been bound
     * with `uv.udp_bind()` it will be bound to `0.0.0.0` (the "all interfaces" IPv4
     * address) and a random port number.
     */
    function udp_send(udp: uv_udp_t, data: buffer, host: string, port: number, callback: (err?: string) => void): fail<[uv_udp_send_t]>;

    /**
     * Same as `uv.udp_send()`, but won't queue a send request if it can't be
     * completed immediately.
     */
    function udp_try_send(udp: uv_udp_t, data: buffer, host: string, port: number): fail<[bytes: number]>;

    /**
     * Prepare for receiving data. If the socket has not previously been bound with
     * `uv.udp_bind()` it is bound to `0.0.0.0` (the "all interfaces" IPv4 address)
     * and a random port number.
     */
    function udp_recv_start(udp: uv_udp_t, callback: (err: string | undefined, data: string | undefined, add: udp_getpeername_rtn | undefined, flags: udp_recv_start_callback_flags) => void): fail<[success: 0]>;

    /**
     * Stop listening for incoming datagrams.
     */
    function udp_recv_stop(udp: uv_udp_t): fail<[success: 0]>;

    /**
     * Associate the UDP handle to a remote address and port, so every message sent by
     * this handle is automatically sent to that destination. Calling this function
     * with a NULL addr disconnects the handle. Trying to call `uv.udp_connect()` on an
     * already connected handle will result in an `EISCONN` error. Trying to disconnect
     * a handle that is not connected will return an `ENOTCONN` error.
     */
    function udp_connect(udp: uv_udp_t, host: string, port: number): fail<[success: 0]>;

    /**
     * FS Event handles allow the user to monitor a given path for changes, for
     * example, if the file was renamed or there was a generic change in it. This
     * handle uses the best backend for the job on each platform.
     */
    interface uv_fs_event_t extends uv_handle_t {
        /**
         * Start the handle with the given callback, which will watch the specified path
         * for changes.
         */
        start(path: string, flags: fs_event_start_flags, callback: (err: string | undefined, filename: string, events: fs_event_start_callback_events) => void): fail<[success: 0]>;

        /**
         * Stop the handle, the callback will no longer be called.
         */
        stop(): fail<[success: 0]>;

        /**
         * Get the path being monitored by the handle.
         */
        getpath(): fail<[string]>;
    }

    /**
     * Start the handle with the given callback, which will watch the specified path
     * for changes.
     */
    function fs_event_start(fs_event: uv_fs_event_t, path: string, flags: fs_event_start_flags, callback: (err: string | undefined, filename: string, events: fs_event_start_callback_events) => void): fail<[success: 0]>;

    /**
     * Stop the handle, the callback will no longer be called.
     */
    function fs_event_stop(): fail<[success: 0]>;

    /**
     * Get the path being monitored by the handle.
     */
    function fs_event_getpath(): fail<[string]>;

    /**
     * FS Poll handles allow the user to monitor a given path for changes. Unlike
     * `uv_fs_event_t`, fs poll handles use `stat` to detect when a file has changed so
     * they can work on file systems where fs event handles can't.
     */
    interface uv_fs_poll_t extends uv_handle_t {
        /**
         * Check the file at `path` for changes every `interval` milliseconds.
         * 
         * **Note:** For maximum portability, use multi-second intervals. Sub-second
         * intervals will not detect all changes on many file systems.
         */
        start(path: string, interval: number, callback: (err: string | undefined, prev: fs_stat_table, curr: fs_stat_table) => void): fail<[success: 0]>;

        /**
         * Stop the handle, the callback will no longer be called.
         */
        stop(): fail<[success: 0]>;

        /**
         * Get the path being monitored by the handle.
         */
        getpath(): fail<[string]>;
    }

    /**
     * Check the file at `path` for changes every `interval` milliseconds.
     * 
     * **Note:** For maximum portability, use multi-second intervals. Sub-second
     * intervals will not detect all changes on many file systems.
     */
    function fs_poll_start(fs_poll: uv_fs_poll_t, path: string, interval: number, callback: (err: string | undefined, prev: fs_stat_table, curr: fs_stat_table) => void): fail<[success: 0]>;

    /**
     * Stop the handle, the callback will no longer be called.
     */
    function fs_poll_stop(): fail<[success: 0]>;

    /**
     * Get the path being monitored by the handle.
     */
    function fs_poll_getpath(): fail<[string]>;

    interface luv_dir_t {
        /**
         * Iterates over the directory stream `uv_dir_t` returned by a successful
         * `uv.fs_opendir()` call. A table of data tables is returned where the number
         * of entries `n` is equal to or less than the `entries` parameter used in
         * the associated `uv.fs_opendir()` call.
         */
        readdir(callback: (err?: string, entries?: fs_readdir_entries) => void): uv_fs_t;
        readdir(): fail<[fs_readdir_entries]>;

        /**
         * Closes a directory stream returned by a successful `uv.fs_opendir()` call.
         */
        closedir(callback: (err?: string, success?: boolean) => void): uv_fs_t;
        closedir(): fail<[success: boolean]>;
    }

    /**
     * Iterates over the directory stream `uv_dir_t` returned by a successful
     * `uv.fs_opendir()` call. A table of data tables is returned where the number
     * of entries `n` is equal to or less than the `entries` parameter used in
     * the associated `uv.fs_opendir()` call.
     */
    function fs_readdir(dir: luv_dir_t, callback: (err?: string, entries?: fs_readdir_entries) => void): uv_fs_t;
    function fs_readdir(dir: luv_dir_t): fail<[fs_readdir_entries]>;

    /**
     * Closes a directory stream returned by a successful `uv.fs_opendir()` call.
     */
    function fs_closedir(dir: luv_dir_t, callback: (err?: string, success?: boolean) => void): uv_fs_t;
    function fs_closedir(dir: luv_dir_t): fail<[success: boolean]>;


    /**
     * Libuv provides a threadpool which can be used to run user code and get notified
     * in the loop thread. This threadpool is internally used to run all file system
     * operations, as well as `getaddrinfo` and `getnameinfo` requests.
     * 
     * ```lua
     * local function work_callback(a, b)
     *   return a + b
     * end
     * 
     * local function after_work_callback(c)
     *   print("The result is: " .. c)
     * end
     * 
     * local work = uv.new_work(work_callback, after_work_callback)
     * 
     * work:queue(1, 2)
     * 
     * -- output: "The result is: 3"
     * ```
     */
    interface luv_work_ctx_t {
        /**
         * Queues a work request which will run `work_callback` in a new Lua state in a
         * thread from the threadpool with any additional arguments from `...`. Values
         * returned from `work_callback` are passed to `after_work_callback`, which is
         * called in the main loop thread.
         */
        queue(work_ctx: luv_work_ctx_t, ...args: threadargs[]): fail<[success: boolean]>;
    }

    /**
     * Queues a work request which will run `work_callback` in a new Lua state in a
     * thread from the threadpool with any additional arguments from `...`. Values
     * returned from `work_callback` are passed to `after_work_callback`, which is
     * called in the main loop thread.
     */
    function queue_work(work_ctx: luv_work_ctx_t, ...args: threadargs[]): fail<[success: boolean]>;

    /**
     * Libuv provides cross-platform implementations for multiple threading an
     *  synchronization primitives. The API largely follows the pthreads API.
     */
    interface luv_thread_t {
        /**
         * Returns a boolean indicating whether two threads are the same. This function is
         * equivalent to the `__eq` metamethod.
         */
        equal(other_thread: luv_thread_t): boolean;

        /**
         * Waits for the `thread` to finish executing its entry function.
         */
        join(): fail<[success: boolean]>;
    }

    /**
     * Returns a boolean indicating whether two threads are the same. This function is
     * equivalent to the `__eq` metamethod.
     */
    function thread_equal(thread: luv_thread_t, other_thread: luv_thread_t): boolean;

    /**
     * Waits for the `thread` to finish executing its entry function.
     */
    function thread_join(thread: luv_thread_t): fail<[success: boolean]>;

    /**
     * In libuv, errors are negative numbered constants; however, while those errors are exposed through `errno`,
     * the functions used to handle them are not exposed to luv users. Instead, if an
     * internal error is encountered, the luv function will return to the caller an
     * assertable `nil, err, name` tuple.
     * 
     * - `nil` idiomatically indicates failure
     * - `err` is a string with the format `{name}: {message}`
     *   - `{name}` is the error name provided internally by `uv_err_name`
     *   - `{message}` is a human-readable message provided internally by `uv_strerror`
     * - `name` is the same string used to construct `err`
     * 
     * This tuple is referred to below as the `fail` pseudo-type.
     * 
     * When a function is called successfully, it will return either a value that is
     * relevant to the operation of the function, or the integer `0` to indicate
     * success, or sometimes nothing at all. These cases are documented below.
     * 
     * @section Error Handling
     */
    type fail<T extends any[]> = LuaMultiReturn<[success: undefined, err_name: string, err_msg: string] | T>;

    /**
     * A table value which exposes error constants as a map, where the key is the
     * error name (without the `UV_` prefix) and its value is a negative number.
     * See Libuv's "Error constants" page for further details.
     * (https://docs.libuv.org/en/v1.x/errors.html#error-constants)
     */
    const errno: {
        E2BIG: number;
        EACCES: number;
        EADDRINUSE: number;
        EADDRNOTAVAIL: number;
        EAFNOSUPPORT: number;
        EAGAIN: number;
        EAI_ADDRFAMILY: number;
        EAI_AGAIN: number;
        EAI_BADFLAGS: number;
        EAI_BADHINTS: number;
        EAI_CANCELED: number;
        EAI_FAIL: number;
        EAI_FAMILY: number;
        EAI_MEMORY: number;
        EAI_NODATA: number;
        EAI_NONAME: number;
        EAI_OVERFLOW: number;
        EAI_PROTOCOL: number;
        EAI_SERVICE: number;
        EAI_SOCKTYPE: number;
        EALREADY: number;
        EBADF: number;
        EBUSY: number;
        ECANCELED: number;
        ECHARSET: number;
        ECONNABORTED: number;
        ECONNREFUSED: number;
        ECONNRESET: number;
        EDESTADDRREQ: number;
        EEXIST: number;
        EFAULT: number;
        EFBIG: number;
        EFTYPE: number;
        EHOSTDOWN: number;
        EHOSTUNREACH: number;
        EILSEQ: number;
        EINTR: number;
        EINVAL: number;
        EIO: number;
        EISCONN: number;
        EISDIR: number;
        ELOOP: number;
        EMFILE: number;
        EMLINK: number;
        EMSGSIZE: number;
        ENAMETOOLONG: number;
        ENETDOWN: number;
        ENETUNREACH: number;
        ENFILE: number;
        ENOBUFS: number;
        ENODATA: number;
        ENODEV: number;
        ENOENT: number;
        ENOMEM: number;
        ENONET: number;
        ENOPROTOOPT: number;
        ENOSPC: number;
        ENOSYS: number;
        ENOTCONN: number;
        ENOTDIR: number;
        ENOTEMPTY: number;
        ENOTSOCK: number;
        ENOTSUP: number;
        ENOTTY: number;
        ENXIO: number;
        EOF: number;
        EOVERFLOW: number;
        EPERM: number;
        EPIPE: number;
        EPROTO: number;
        EPROTONOSUPPORT: number;
        EPROTOTYPE: number;
        ERANGE: number;
        EREMOTEIO: number;
        EROFS: number;
        ESHUTDOWN: number;
        ESOCKTNOSUPPORT: number;
        ESPIPE: number;
        ESRCH: number;
        ETIMEDOUT: number;
        ETXTBSY: number;
        EXDEV: number;
        UNKNOWN: number;
    }

    /**
     * Returns the libuv version packed into a single integer. 8 bits are used for each
     * component, with the patch number stored in the 8 least significant bits. For
     * example, this would be 0x010203 in libuv 1.2.3.
     */
    function version(): number;

    /**
     * Returns the libuv version number as a string. For example, this would be "1.2.3"
     * in libuv 1.2.3. For non-release versions, the version suffix is included.
     */
    function version_string(): string;

    /**
     * 'default'
     * Runs the event loop until there are no more active and referenced handles or requests.
     * Returns `true` if `uv.stop()` was called and there are still active handles or requests.
     * Returns `false` in all other cases.
     *
     * 'once'
     * Poll for I/O once. Note that this function blocks if there are no
     * pending callbacks. Returns `false` when done (no active handles or requests
     * left), or `true` if more callbacks are expected (meaning you should run the
     * event loop again sometime in the future).
     *
     * 'nowait'
     * Poll for I/O once but don't block if there are no pending callbacks.
     * Returns `false` if done (no active handles or requests left),
     * or `true` if more callbacks are expected (meaning you should run the event loop again sometime in the future).
     */
    type run_mode = "default" | "once" | "nowait";

    /**
     * 'block_signal'
     * Block a signal when polling for new events.
     * The second argument to loop_configure() is the signal name (as a lowercase string) or the signal number.
     * This operation is currently only implemented for `"sigprof"` signals, to suppress unnecessary wakeups when using a sampling profiler.
     * Requesting other signals will fail with `EINVAL`.
     *
     * 'metrics_idle_time'
     * Accumulate the amount of idle time the event loop spends in the event provider.
     * This option is necessary to use `metrics_idle_time()`.
     */
    type loop_configure_option = "block_signal" | "metrics_idle_time"

    /**
     * Closes all internal loop resources. In normal execution, the loop will
     * automatically be closed when it is garbage collected by Lua, so it is not
     * necessary to explicitly call `loop_close()`. Call this function only after the
     * loop has finished executing and all open handles and requests have been closed,
     * or it will return `EBUSY`.
     */
    function loop_close(): fail<[success: 0]>;

    /**
     * This function runs the event loop. It will act differently depending on the
     * specified mode:
     * - `"default"`: Runs the event loop until there are no more active and
     * referenced handles or requests. Returns `true` if `uv.stop()` was called and
     * there are still active handles or requests. Returns `false` in all other
     * cases.
     * - `"once"`: Poll for I/O once. Note that this function blocks if there are no
     * pending callbacks. Returns `false` when done (no active handles or requests
     * left), or `true` if more callbacks are expected (meaning you should run the
     * event loop again sometime in the future).
     * - `"nowait"`: Poll for I/O once but don't block if there are no pending
     * callbacks. Returns `false` if done (no active handles or requests left),
     * or `true` if more callbacks are expected (meaning you should run the event
     * loop again sometime in the future).
     * 
     * **Note**: Luvit will implicitly call `uv.run()` after loading user code, but if
     * you use the luv bindings directly, you need to call this after registering
     * your initial set of event callbacks to start the event loop.
     */
    function run(mode?: run_mode): fail<[success: boolean]>;

    /**
     * Set additional loop options. You should normally call this before the first call
     * to uv_run() unless mentioned otherwise.
     * Supported options:
     * - `"block_signal"`: Block a signal when polling for new events. The second argument
     * to loop_configure() is the signal name (as a lowercase string) or the signal number.
     * This operation is currently only implemented for `"sigprof"` signals, to suppress
     * unnecessary wakeups when using a sampling profiler. Requesting other signals will
     * fail with `EINVAL`.
     * - `"metrics_idle_time"`: Accumulate the amount of idle time the event loop spends
     * in the event provider. This option is necessary to use `metrics_idle_time()`.
     * An example of a valid call to this function is:
     * ```lua
     * uv.loop_configure("block_signal", "sigprof")
     * ```
     * 
     * **Note**: Be prepared to handle the `ENOSYS` error; it means the loop option is
     * not supported by the platform.
     */
    function loop_configure(option: loop_configure_option, ...args: any): fail<[success: 0]>;

    /**
     * If the loop is running, returns a string indicating the mode in use. If the loop
     * is not running, `nil` is returned instead.
     */
    function loop_mode(): run_mode | undefined;

    /**
     * Returns `true` if there are referenced active handles, active requests, or
     * closing handles in the loop; otherwise, `false`.
     */
    function loop_alive(): fail<[success: boolean]>;

    /**
     * Stop the event loop, causing `uv.run()` to end as soon as possible. This
     * will happen not sooner than the next loop iteration. If this function was called
     * before blocking for I/O, the loop won't block for I/O on this iteration.
     */
    function stop(): void;

    /**
     * Get backend file descriptor. Only kqueue, epoll, and event ports are supported.
     * This can be used in conjunction with `uv.run("nowait")` to poll in one thread
     * and run the event loop's callbacks in another
     * 
     * **Note**: Embedding a kqueue fd in another kqueue pollset doesn't work on all
     * platforms. It's not an error to add the fd but it never generates events.
     */
    function backend_fd(): number | undefined;

    /**
     * Get the poll timeout. The return value is in milliseconds, or -1 for no timeout.
     */
    function backend_timeout(): number;

    /**
     * Returns the current timestamp in milliseconds. The timestamp is cached at the
     * start of the event loop tick, see `uv.update_time()` for details and rationale.
     * The timestamp increases monotonically from some arbitrary point in time. Don't
     * make assumptions about the starting point, you will only get disappointed.
     * 
     * **Note**: Use `uv.hrtime()` if you need sub-millisecond granularity.
     */
    function now(): number;

    /**
     * Update the event loop's concept of "now". Libuv caches the current time at the
     * start of the event loop tick in order to reduce the number of time-related
     * system calls.
     * You won't normally need to call this function unless you have callbacks that
     * block the event loop for longer periods of time, where "longer" is somewhat
     * subjective but probably on the order of a millisecond or more.
     */
    function update_time(): void;

    /**
     * Walk the list of handles: `callback` will be executed with each handle.
     * 
     * Example usage of uv.walk to close all handles that aren't already closing.
     * ```lua
     * uv.walk(function (handle)
     *   if not handle:is_closing() then
     *     handle:close()
     *   end
     * end)
     * ```
     */
    function walk(callback: (handle: handle_instances) => void): void;

    type req_struct_name =
        | 'unknown'     // 0
        | 'req'         // 1
        | 'connect'     // 2
        | 'write'       // 3
        | 'shutdown'    // 4
        | 'udp_send'    // 5
        | 'fs'          // 6
        | 'work'        // 7
        | 'getaddrinfo' // 8
        | 'getnameinfo' // 9
        | 'random'      // 10

    type req_struct_type =
        | 0   // unknown
        | 1   // req
        | 2   // connect
        | 3   // write
        | 4   // shutdown
        | 5   // udp_send
        | 6   // fs
        | 7   // work
        | 8   // getaddrinfo
        | 9   // getnameinfo
        | 10  // random

    type handle_instances =
        | uv_handle_t
        | uv_stream_t
        | uv_tcp_t
        | uv_pipe_t
        | uv_tty_t
        | uv_udp_t
        | uv_fs_event_t
        | uv_fs_poll_t

    type handle_struct_name =
        | 'unknown'   // 0
        | 'async'     // 1
        | 'check'     // 2
        | 'fs_event'  // 3
        | 'fs_poll'   // 4
        | 'handle'    // 5
        | 'idle'      // 6
        | 'pipe'      // 7
        | 'poll'      // 8
        | 'prepare'   // 9
        | 'process'   // 10
        | 'stream'    // 11
        | 'tcp'       // 12
        | 'timer'     // 13
        | 'tty'       // 14
        | 'udp'       // 15
        | 'signal'    // 16
        | 'file'      // 17

    type handle_struct_type =
        | 0   // unknown
        | 1   // async
        | 2   // check
        | 3   // fs_event
        | 4   // fs_poll
        | 5   // handle
        | 6   // idle
        | 7   // pipe
        | 8   // poll
        | 9   // prepare
        | 10  // process
        | 11  // stream
        | 12  // tcp
        | 13  // timer
        | 14  // tty
        | 15  // udp
        | 16  // signal
        | 17  // file


    /**
     * @section Reference counting
     * 
     * The libuv event loop (if run in the default mode) will run until there are no
     * active and referenced handles left. The user can force the loop to exit early by
     * unreferencing handles which are active, for example by calling `uv.unref()`
     * after calling `uv.timer_start()`.
     * 
     * A handle can be referenced or unreferenced, the refcounting scheme doesn't use a
     * counter, so both operations are idempotent.
     * 
     * All handles are referenced when active by default, see `uv.is_active()` for a
     * more detailed explanation on what being active involves.
     * 
    
    /**
     * Creates and initializes a new `uv_timer_t`. Returns the Lua userdata wrapping it.
     * 
     * Some examples:
     * ```lua
     * -- Creating a simple setTimeout wrapper
     * local function setTimeout(timeout, callback)
     *   local timer = uv.new_timer()
     *   timer:start(timeout, 0, function ()
     *     timer:stop()
     *     timer:close()
     *     callback()
     *   end)
     *   return timer
     * end
     * 
     * -- Creating a simple setInterval wrapper
     * local function setInterval(interval, callback)
     *   local timer = uv.new_timer()
     *   timer:start(interval, interval, function ()
     *     callback()
     *   end)
     *   return timer
     * end
     * 
     * -- And clearInterval
     * local function clearInterval(timer)
     *   timer:stop()
     *   timer:close()
     * end
     * ```
     */
    function new_timer(): uv_timer_t;



    /**
     * Creates and initializes a new `uv_prepare_t`.
     * Returns the Lua userdata wrapping it.
     */
    function new_prepare(): fail<[uv_prepare_t]>;


    /**
     * Creates and initializes a new `uv_check_t`. Returns the Lua userdata wrapping it.
     */
    function new_check(): fail<[uv_check_t]>;

    /**
     * Creates and initializes a new `uv_idle_t`. Returns the Lua userdata wrapping it.
     */
    function new_idle(): fail<[uv_idle_t]>;

    /**
     * Creates and initializes a new `uv_async_t`. Returns the Lua userdata wrapping
     * it. A `nil` callback is allowed.
     * 
     * **Note**: Unlike other handle initialization functions, this immediately starts
     * the handle.
     */
    function new_async(callback?: (...args: threadargs[]) => void): fail<[uv_async_t]>;

    type poll_events =
        | "r"
        | "w"
        | "rw"
        | "d"
        | "rd"
        | "wd"
        | "rwd"
        | "p"
        | "rp"
        | "wp"
        | "rwp"
        | "dp"
        | "rdp"
        | "wdp"
        | "rwdp"

    /**
     * Initialize the handle using a file descriptor.
     * The file descriptor is set to non-blocking mode.
     */
    function new_poll(fd: number): fail<[uv_poll_t]>;

    /**
     * Initialize the handle using a socket descriptor. On Unix this is identical to
     * `uv.new_poll()`. On windows it takes a SOCKET handle.
     * The socket is set to non-blocking mode.
     */
    function new_socket_poll(fd: number): fail<[uv_poll_t]>;

    type signals =
        | "sigabrt"    // Abort signal from abort(3)
        | "sigalrm"    // Timer signal from alarm(2)
        | "sigbus"     // Bus error (bad memory access)
        | "sigchld"    // Child stopped or terminated
        | "sigcont"    // Continue if stopped
        | "sigfpe"     // Floating-point exception
        | "sighup"     // Hangup detected on controlling terminal or death of controlling process
        | "sigill"     // Illegal Instruction
        | "sigint"     // Interrupt from keyboard
        | "sigio"      // I/O now possible (4.2BSD)
        | "sigiot"     // IOT trap. A synonym for sigabrt
        | "sigkill"    // Kill signal
        | "sigpipe"    // Broken pipe: write to pipe with no readers; see pipe(7)
        | "sigpoll"    // Pollable event (Sys V); synonym for sigIO
        | "sigprof"    // Profiling timer expired
        | "sigpwr"     // Power failure (System V)
        | "sigquit"    // Quit from keyboard
        | "sigsegv"    // Invalid memory reference
        | "sigstkflt"  // Stack fault on coprocessor
        | "sigstop"    // Stop process
        | "sigtstp"    // Stop typed at terminal
        | "sigsys"     // Bad system call (SVr4); see also seccomp(2)
        | "sigterm"    // Termination signal
        | "sigtrap"    // Trace/breakpoint trap
        | "sigttin"    // Terminal input for background process
        | "sigttou"    // Terminal output for background process
        | "sigurg"     // Urgent condition on socket (4.2BSD)
        | "sigusr1"    // User-defined signal 1
        | "sigusr2"    // User-defined signal 2
        | "sigvtalrm"  // Virtual alarm clock (4.2BSD)
        | "sigxcpu"    // CPU time limit exceeded (4.2BSD); see setrlimit(2)
        | "sigxfsz"    // File size limit exceeded (4.2BSD);see setrlimit(2)
        | "sigwinch"   // Window resize signal (4.3BSD, Sun)
        | "sigbreak"   // CTRL + BREAK has been pressed
        | "siglost"    // File lock lost

    /**
     * Creates and initializes a new `uv_signal_t`.
     * Returns the Lua userdata wrapping it.
     */
    function new_signal(): fail<[uv_signal_t]>;

    interface spawn_options { args?: string[], stdio?: { [key: number]: (number | uv_stream_t | undefined) }, env?: { [key: string]: any }, cwd?: string, uid?: number, gid?: number, verbatim?: boolean, detached?: boolean, hide?: boolean }

    /**
     * Disables inheritance for file descriptors / handles that this process inherited
     * from its parent. The effect is that child processes spawned by this process
     * don't accidentally inherit these handles.
     * It is recommended to call this function as early in your program as possible,
     * before the inherited file descriptors can be closed or duplicated.
     * 
     * **Note:** This function works on a best-effort basis: there is no guarantee that
     * libuv can discover all file descriptors that were inherited. In general it does
     * a better job on Windows than it does on Unix.
     */
    function disable_stdio_inheritance(): void;

    /**
     * Initializes the process handle and starts the process. If the process is
     * successfully spawned, this function will return the handle and pid of the child
     * process.
     * Possible reasons for failing to spawn would include (but not be limited to) the
     * file to execute not existing, not having permissions to use the setuid or setgid
     * specified, or not having enough memory to allocate for the new process.
     * 
     * ```lua
     * local stdin = uv.new_pipe()
     * local stdout = uv.new_pipe()
     * local stderr = uv.new_pipe()
     * 
     * print("stdin", stdin)
     * print("stdout", stdout)
     * print("stderr", stderr)
     * 
     * local handle, pid = uv.spawn("cat", {
     *    stdio = {stdin, stdout, stderr}
     * }, function(code, signal) -- on exit
     *    print("exit code", code)
     *    print("exit signal", signal)
     * end)
     * 
     * print("process opened", handle, pid)
     * 
     * uv.read_start(stdout, function(err, data)
     *    assert(not err, err)
     *    if data then
     *      print("stdout chunk", stdout, data)
     *    else
     *      print("stdout end", stdout)
     *    end
     * end)
     * 
     * uv.read_start(stderr, function(err, data)
     *    assert(not err, err)
     *    if data then
     *      print("stderr chunk", stderr, data)
     *    else
     *      print("stderr end", stderr)
     *    end
     * end)
     * 
     * uv.write(stdin, "Hello World")
     * 
     * uv.shutdown(stdin, function()
     *    print("stdin shutdown", stdin)
     *    uv.close(handle, function()
     *      print("process closed", handle, pid)
     *    end)
     * end)
     * ```
     * 
     * The `options` table accepts the following fields:
     * 
     *  - `options.args` - Command line arguments as a list of string. The first
     * string should be the path to the program. On Windows, this uses CreateProcess
     * which concatenates the arguments into a string. This can cause some strange
     * errors. (See `options.verbatim` below for Windows.)
     * 
     *  - `options.stdio` - Set the file descriptors that will be made available to
     *   the child process. The convention is that the first entries are stdin, stdout,
     *   and stderr. (**Note**: On Windows, file descriptors after the third are
     *   available to the child process only if the child processes uses the MSVCRT
     *   runtime.)
     * 
     *  - `options.env` - Set environment variables for the new process.
     * 
     *  - `options.cwd` - Set the current working directory for the sub-process.
     * 
     *  - `options.uid` - Set the child process' user id.
     * 
     *  - `options.gid` - Set the child process' group id.
     * 
     *  - `options.verbatim` - If true, do not wrap any arguments in quotes, or
     *   perform any other escaping, when converting the argument list into a command
     *   line string. This option is only meaningful on Windows systems. On Unix it is
     *   silently ignored.
     * 
     *  - `options.detached` - If true, spawn the child process in a detached state -
     *   this will make it a process group leader, and will effectively enable the
     *   child to keep running after the parent exits. Note that the child process
     *   will still keep the parent's event loop alive unless the parent process calls
     *   `uv.unref()` on the child's process handle.
     * 
     *  - `options.hide` - If true, hide the subprocess console window that would
     *   normally be created. This option is only meaningful on Windows systems. On
     *   Unix it is silently ignored.
     * The `options.stdio` entries can take many shapes.
     * 
     *   - If they are numbers, then the child process inherits that same zero-indexed
     *   fd from the parent process.
     * 
     *  - If `uv_stream_t` handles are passed in, those are used as a read-write pipe
     *   or inherited stream depending if the stream has a valid fd.
     * 
     *  - Including `nil` placeholders means to ignore that fd in the child process.
     * 
     * When the child process exits, `on_exit` is called with an exit code and signal.
     */
    function spawn(path: string, options: spawn_options, on_exit?: (code: number, signal: number) => void): fail<[uv_process_t]>;


    /**
     * Sends the specified signal to the given PID.
     */
    function kill(pid: number, signum?: number | signals): fail<[success: 0]>;


    type uv_shutdown_t = uv_req_t
    type uv_write_t = uv_req_t
    type uv_connect_t = uv_req_t

    type network_family =
        | "unix"
        | "inet"
        | "inet6"
        | "ipx"
        | "netlink"
        | "x25"
        | "ax25"
        | "atmpvc"
        | "appletalk"
        | "packet"

    type network_protocols =
        | "ip"              // internet protocol, pseudo protocol number
        | "hopopt"          // hop-by-hop options for ipv6
        | "icmp"            // internet control message protocol
        | "igmp"            // internet group management protocol
        | "ggp"             // gateway-gateway protocol
        | "ipv4"            // IPv4 encapsulation
        | "st"              // ST datagram mode
        | "tcp"             // transmission control protocol
        | "cbt"             // CBT, Tony Ballardie <A.Ballardie@cs.ucl.ac.uk>
        | "egp"             // exterior gateway protocol
        | "igp"             // any private interior gateway (Cisco: for IGRP)
        | "bbn-rcc"         // BBN RCC Monitoring
        | "nvp"             // Network Voice Protocol
        | "pup"             // PARC universal packet protocol
        | "argus"           // ARGUS (deprecated)
        | "emcon"           // EMCON
        | "xnet"            // Cross Net Debugger
        | "chaos"           // Chaos
        | "udp"             // user datagram protocol
        | "mux"             // Multiplexing protocol
        | "dcn"             // DCN Measurement Subsystems
        | "hmp"             // host monitoring protocol
        | "prm"             // packet radio measurement protocol
        | "xns-idp"         // Xerox NS IDP
        | "trunk-1"         // Trunk-1
        | "trunk-2"         // Trunk-2
        | "leaf-1"          // Leaf-1
        | "leaf-2"          // Leaf-2
        | "rdp"             // "reliable datagram" protocol
        | "irtp"            // Internet Reliable Transaction Protocol
        | "iso-tp4"         // ISO Transport Protocol Class 4
        | "netblt"          // Bulk Data Transfer Protocol
        | "mfe-nsp"         // MFE Network Services Protocol
        | "merit-inp"       // MERIT Internodal Protocol
        | "dccp"            // Datagram Congestion Control Protocol
        | "3pc"             // Third Party Connect Protocol
        | "idpr"            // Inter-Domain Policy Routing Protocol
        | "xtp"             // Xpress Tranfer Protocol
        | "ddp"             // Datagram Delivery Protocol
        | "idpr-cmtp"       // IDPR Control Message Transport Proto
        | "tp++"            // TP++ Transport Protocol
        | "il"              // IL Transport Protocol
        | "ipv6"            // IPv6 encapsulation
        | "sdrp"            // Source Demand Routing Protocol
        | "ipv6-route"      // Routing Header for IPv6
        | "ipv6-frag"       // Fragment Header for IPv6
        | "idrp"            // Inter-Domain Routing Protocol
        | "rsvp"            // Resource ReSerVation Protocol
        | "gre"             // Generic Routing Encapsulation
        | "dsr"             // Dynamic Source Routing Protocol
        | "bna"             // BNA
        | "esp"             // Encap Security Payload
        | "ipv6-crypt"      // Encryption Header for IPv6 (not in official list)
        | "ah"              // Authentication Header
        | "ipv6-auth"       // Authentication Header for IPv6 (not in official list)
        | "i-nlsp"          // Integrated Net Layer Security TUBA
        | "swipe"           // IP with Encryption
        | "narp"            // NBMA Address Resolution Protocol
        | "mobile"          // IP Mobility
        | "tlsp"            // Transport Layer Security Protocol
        | "skip"            // SKIP
        | "ipv6-icmp"       // ICMP for IPv6
        | "ipv6-nonxt"      // No Next Header for IPv6
        | "ipv6-opts"       // Destination Options for IPv6
        | "#"               // any host internal protocol
        | "cftp"            // CFTP
        | "#"               // any local network
        | "sat-expak"       // SATNET and Backroom EXPAK
        | "kryptolan"       // Kryptolan
        | "rvd"             // MIT Remote Virtual Disk Protocol
        | "ippc"            // Internet Pluribus Packet Core
        | "#"               // any distributed file system
        | "sat-mon"         // SATNET Monitoring
        | "visa"            // VISA Protocol
        | "ipcv"            // Internet Packet Core Utility
        | "cpnx"            // Computer Protocol Network Executive
        | "cphb"            // Computer Protocol Heart Beat
        | "wsn"             // Wang Span Network
        | "pvp"             // Packet Video Protocol
        | "br-sat-mon"      // Backroom SATNET Monitoring
        | "sun-nd"          // SUN ND PROTOCOL-Temporary
        | "wb-mon"          // WIDEBAND Monitoring
        | "wb-expak"        // WIDEBAND EXPAK
        | "iso-ip"          // ISO Internet Protocol
        | "vmtp"            // Versatile Message Transport
        | "secure-vmtp"     // SECURE-VMTP
        | "vines"           // VINES
        | "ttp"             // TTP
        | "nsfnet-igp"      // NSFNET-IGP
        | "dgp"             // Dissimilar Gateway Protocol
        | "tcf"             // TCF
        | "eigrp"           // Enhanced Interior Routing Protocol (Cisco)
        | "ospf"            // Open Shortest Path First IGP
        | "sprite-rpc"      // Sprite RPC Protocol
        | "larp"            // Locus Address Resolution Protocol
        | "mtp"             // Multicast Transport Protocol
        | "ax.25"           // AX.25 Frames
        | "ipip"            // Yet Another IP encapsulation
        | "micp"            // Mobile Internetworking Control Pro.
        | "scc-sp"          // Semaphore Communications Sec. Pro.
        | "etherip"         // Ethernet-within-IP Encapsulation
        | "encap"           // Yet Another IP encapsulation
        | "#"               // any private encryption scheme
        | "gmtp"            // GMTP
        | "ifmp"            // Ipsilon Flow Management Protocol
        | "pnni"            // PNNI over IP
        | "pim"             // Protocol Independent Multicast
        | "aris"            // ARIS
        | "scps"            // SCPS
        | "qnx"             // QNX
        | "a/n"             // Active Networks
        | "ipcomp"          // IP Payload Compression Protocol
        | "snp"             // Sitara Networks Protocol
        | "compaq-peer"     // Compaq Peer Protocol
        | "ipx-in-ip"       // IPX in IP
        | "vrrp"            // Virtual Router Redundancy Protocol
        | "pgm"             // PGM Reliable Transport Protocol
        | "#"               // any 0-hop protocol
        | "l2tp"            // Layer Two Tunneling Protocol
        | "ddx"             // D-II Data Exchange
        | "iatp"            // Interactive Agent Transfer Protocol
        | "stp"             // Schedule Transfer
        | "srp"             // SpectraLink Radio Protocol
        | "uti"             // UTI
        | "smp"             // Simple Message Protocol
        | "sm"              // SM (deprecated)
        | "ptp"             // Performance Transparency Protocol
        | "isis"            // ISIS over IPv4
        | "crtp"            // Combat Radio Transport Protocol
        | "crudp"           // Combat Radio User Datagram
        | "sps"             // Secure Packet Shield
        | "pipe"            // Private IP Encapsulation within IP
        | "sctp"            // Stream Control Transmission Protocol
        | "fc"              // Fibre Channel
        | "mobility-header" // Mobility Header
        | "manet"           // MANET Protocols
        | "hip"             // Host Identity Protocol
        | "shim6"           // Shim6 Protocol
        | "wesp"            // Wrapped Encapsulating Security Payload
        | "rohc"            // Robust Header Compression

    type tcp_socket_type =
        | "stream"
        | "dgram"
        | "raw"
        | "rdm"
        | "seqpacket"

    interface tcp_bind_flags { ipv6only?: boolean }

    interface getpeername_rtn { ip: string, family: network_family, port: number }

    type getsockname_rtn = getpeername_rtn

    interface socketpair_flags { nonblock: boolean }

    /**
     * Creates and initializes a new `uv_tcp_t`.
     * Returns the Lua userdata wrapping it.
     */
    function new_tcp(flags?: network_family | number): fail<[uv_tcp_t]>;

    /**
     * Create a pair of connected sockets with the specified properties. The resulting handles can be passed to `uv.tcp_open`, used with `uv.spawn`, or for any other purpose.
     * When specified as a string, `socktype` must be one of `"stream"`, `"dgram"`, `"raw"`,
     * `"rdm"`, or `"seqpacket"`.
     * 
     * When `protocol` is set to 0 or nil, it will be automatically chosen based on the socket's domain and type. When `protocol` is specified as a string, it will be looked up using the `getprotobyname(3)` function (examples: `"ip"`, `"icmp"`, `"tcp"`, `"udp"`, etc).
     * 
     * Flags:
     * - `nonblock`: Opens the specified socket handle for `OVERLAPPED` or `FIONBIO`/`O_NONBLOCK` I/O usage. This is recommended for handles that will be used by libuv, and not usually recommended otherwise.
     * 
     * Equivalent to `socketpair(2)` with a domain of `AF_UNIX`.
     * 
     * ```lua
     * -- Simple read/write with tcp
     * local fds = uv.socketpair(nil, nil, {nonblock=true}, {nonblock=true})
     * 
     * local sock1 = uv.new_tcp()
     * sock1:open(fds[1])
     * 
     * local sock2 = uv.new_tcp()
     * sock2:open(fds[2])
     * 
     * sock1:write("hello")
     * sock2:read_start(function(err, chunk)
     *   assert(not err, err)
     *   print(chunk)
     * end)
     * ```
     */
    function socketpair(socktype?: tcp_socket_type | number, protocol?: network_protocols | number, flags1?: socketpair_flags, flags2?: socketpair_flags): fail<[[number, number]]>;

    type pipe_chmod_flags =
        | "r"
        | "w"
        | "rw"
        | "wr"

    interface pipe_flags { nonblock?: boolean }
    interface pipe_rtn { read: number, write: number }

    /**
     * Creates and initializes a new `uv_pipe_t`. Returns the Lua userdata wrapping
     * it. The `ipc` argument is a boolean to indicate if this pipe will be used for
     * handle passing between processes.
     */
    function new_pipe(ipc?: boolean): fail<[uv_pipe_t]>;

    /**
     * Create a pair of connected pipe handles. Data may be written to the `write` fd and read from the `read` fd.
     * The resulting handles can be passed to `pipe_open`, used with `spawn`, or for any other purpose.
     * 
     * Flags:
     *  - `nonblock`: Opens the specified socket handle for `OVERLAPPED` or `FIONBIO`/`O_NONBLOCK` I/O usage.
     *  This is recommended for handles that will be used by libuv, and not usually recommended otherwise.
     * 
     * Equivalent to `pipe(2)` with the `O_CLOEXEC` flag set.
     * 
     * ```lua
     * -- Simple read/write with pipe_open
     * local fds = uv.pipe({nonblock=true}, {nonblock=true})
     * 
     * local read_pipe = uv.new_pipe()
     * read_pipe:open(fds.read)
     * 
     * local write_pipe = uv.new_pipe()
     * write_pipe:open(fds.write)
     * 
     * write_pipe:write("hello")
     * read_pipe:read_start(function(err, chunk)
     *   assert(not err, err)
     *   print(chunk)
     * end)
     * ```
     */
    function pipe(read_flags?: pipe_flags, write_flags?: pipe_flags): fail<[pipe_rtn]>;

    /**
     * tty_fd
     * 0 = stdin
     * 1 = stdout
     * 2 = stderr
     */
    type tty_fd = 0 | 1 | 2

    /**
     * tty_mode
     * 0 = UV_TTY_MODE_NORMAL: Initial/normal terminal mode
     * 1 = UV_TTY_MODE_RAW: Raw input mode (On Windows, ENABLE_WINDOW_INPUT is also enabled)
     * 2 = UV_TTY_MODE_IO: Binary-safe I/O mode for IPC (Unix-only)
     */
    type tty_mode = 0 | 1 | 2

    type tty_vsterm_state = "supported" | "unsupported"

    /**
     * Initialize a new TTY stream with the given file descriptor.
     * See below for possible file descriptors.
     * 
     * On Unix this function will determine the path of the fd of the terminal using
     * ttyname_r(3), open it, and use it if the passed file descriptor refers to a TTY.
     * 
     * This lets libuv put the tty in non-blocking mode without affecting other
     * processes that share the tty.
     * 
     * This function is not thread safe on systems that don’t support ioctl TIOCGPTN or TIOCPTYGNAME, for instance OpenBSD and Solaris.
     * 
     * **Note:** If reopening the TTY fails, libuv falls back to blocking writes.
     */
    function new_tty(fd: tty_fd | number, readable: boolean): fail<[uv_tty_t]>;

    /**
     * To be called when the program exits. Resets TTY settings to default values for
     * the next process to take over.
     * This function is async signal-safe on Unix platforms but can fail with error
     * code `EBUSY` if you call it when execution is inside `uv.tty_set_mode()`.
     */
    function tty_reset_mode(): fail<[success: 0]>;

    /**
     * Controls whether console virtual terminal sequences are processed by libuv or
     * console. Useful in particular for enabling ConEmu support of ANSI X3.64 and
     * Xterm 256 colors. Otherwise Windows10 consoles are usually detected
     * automatically. State should be one of: `"supported"` or `"unsupported"`.
     * 
     * This function is only meaningful on Windows systems. On Unix it is silently
     * ignored.
     */
    function tty_set_vterm_state(state: tty_vsterm_state): void;

    /**
     * Get the current state of whether console virtual terminal sequences are handled
     * by libuv or the console. The return value is `"supported"` or `"unsupported"`.
     * This function is not implemented on Unix, where it returns `ENOTSUP`.
     */
    function tty_get_vterm_state(): tty_vsterm_state;



    type uv_udp_send_t = object

    interface new_udp_flags { family: network_family, mmsgs: number }

    interface udp_bind_flags { ipv6only: boolean, reuseaddr: boolean }

    type udp_getsockname_rtn = getsockname_rtn

    type udp_getpeername_rtn = getpeername_rtn

    type udp_membership = "join" | "leave"

    interface udp_recv_start_callback_flags { partial?: boolean, mmsg_chunk?: boolean }

    /**
     * Creates and initializes a new `uv_udp_t`. Returns the Lua userdata wrapping
     * it. The actual socket is created lazily.
     * 
     * See below for accepted `family` values.
     * 
     * When specified, `mmsgs` determines the number of messages able to be received
     * at one time via `recvmmsg(2)` (the allocated buffer will be sized to be able
     * to fit the specified number of max size dgrams). Only has an effect on
     * platforms that support `recvmmsg(2)`.
     * 
     * **Note:** For backwards compatibility reasons, `flags` can also be a string or
     * integer. When it is a string, it will be treated like the `family` key above.
     * When it is an integer, it will be used directly as the `flags` parameter when
     * calling `uv_udp_init_ex`.
     */
    function new_udp(flags?: new_udp_flags | network_family | number): fail<[uv_udp_t]>;

    interface fs_event_start_flags { watch_entry?: boolean, stat?: boolean, recursive?: boolean }

    interface fs_event_start_callback_events { change?: boolean, rename?: boolean }

    /**
     * Creates and initializes a new `uv_fs_event_t`.
     * Returns the Lua userdata wrapping it.
     */
    function new_fs_event(): fail<[uv_fs_event_t]>;

    /**
     * Creates and initializes a new `uv_fs_poll_t`.
     * Returns the Lua userdata wrapping it.
     */
    function new_fs_poll(): fail<[uv_fs_poll_t]>;

    /**
     * @section File system operations
     * 
     * Most file system functions can operate synchronously or asynchronously. When a synchronous version is called (by omitting a callback), the function will
     * immediately return the results of the FS call. When an asynchronous version is
     * called (by providing a callback), the function will immediately return a
     * `uv_fs_t` and asynchronously execute its callback; if an error is encountered, the first and only argument passed to the callback will be the `err` error string; if the operation completes successfully, the first argument will be `nil` and the remaining arguments will be the results of the FS call.
     * 
     * Synchronous and asynchronous versions of `readFile` (with naive error handling)
     * are implemented below as an example:
     * 
     * ```lua
     * local function readFileSync(path)
     *   local fd = assert(uv.fs_open(path, "r", 438))
     *   local stat = assert(uv.fs_fstat(fd))
     *   local data = assert(uv.fs_read(fd, stat.size, 0))
     *   assert(uv.fs_close(fd))
     *   return data
     * end
     * 
     * local data = readFileSync("main.lua")
     * print("synchronous read", data)
     * ```
     * 
     * ```lua
     * local function readFile(path, callback)
     *   uv.fs_open(path, "r", 438, function(err, fd)
     *     assert(not err, err)
     *     uv.fs_fstat(fd, function(err, stat)
     *       assert(not err, err)
     *       uv.fs_read(fd, stat.size, 0, function(err, data)
     *         assert(not err, err)
     *         uv.fs_close(fd, function(err)
     *           assert(not err, err)
     *           return callback(data)
     *         end)
     *       end)
     *     end)
     *   end)
     * end
     * 
     * readFile("main.lua", function(data)
     *   print("asynchronous read", data)
     * end)
     * ```
     */

    type uv_fs_t = uv_req_t

    type fs_access_flags =
        | "r"
        | "rs"
        | "sr"
        | "r+"
        | "rs+"
        | "sr+"
        | "w"
        | "wx"
        | "xw"
        | "w+"
        | "wx+"
        | "xw+"
        | "a"
        | "ax"
        | "xa"
        | "a+"
        | "ax+"
        | "xa+"

    type fs_stat_types =
        | "file"
        | "directory"
        | "link"
        | "fifo"
        | "socket"
        | "char"
        | "block"

    interface fs_stat_table { gen: number, flags: number, atime: { nsec: number, sec: number }, ctime: { nsec: number, sec: number }, birthtime: { nsec: number, sec: number }, uid: number, gid: number, mtime: { nsec: number, sec: number }, size: number, type?: fs_stat_types, nlink: number, dev: number, mode: number, rdev: number, ino: number, blksize: number, blocks: number }

    type fs_types =
        | "file"
        | "directory"
        | "link"
        | "fifo"
        | "socket"
        | "char"
        | "block"
        | "unknown"

    type fs_access_mode =
        | 'R'    // Tests for readbility.
        | 'W'    // Tests for writiblity.
        | 'X'    // Tests for executibility.
        | 'RW'   // Tests for readbility and writiblity.
        | 'RX'   // Tests for readbility and executibility.
        | 'WX'   // Tests for writiblity and executibility.
        | 'WRX'  // Tests for writiblity and readbility and executibility.
        | number // A bitwise OR mask.

    interface fs_readdir_entries { type: fs_types, name: string }

    interface fs_symlink_flags { dir: boolean, junction: boolean }

    interface fs_copyfile_flags { excl: boolean, ficlone: boolean, ficlone_force: boolean }

    type fs_statfs_stats_type =
        | 0          // Always 0 on Windows, sun, MVS, OpenBSD, NetBSD, HAIKU, QNK.
        | 44533      // ADFS_SUPER_MAGIC = 0xadf5
        | 44543      // AFFS_SUPER_MAGIC = 0xadff
        | 1397113167 // AFS_SUPER_MAGIC = 0x5346414f
        | 151263540  // ANON_INODE_FS_MAGIC = 0x09041934 | Anonymous inode FS (for pseudofiles that have no name; e.g., epoll, signalfd, bpf)
        | 391        // AUTOFS_SUPER_MAGIC = 0x0187
        | 1650746742 // BDEVFS_MAGIC = 0x62646576
        | 1111905073 // BEFS_SUPER_MAGIC = 0x42465331
        | 464386766  // BFS_MAGIC = 0x1badface
        | 1112100429 // BINFMTFS_MAGIC = 0x42494e4d
        | 3405662737 // BPF_FS_MAGIC = 0xcafe4a11
        | 2435016766 // BTRFS_SUPER_MAGIC = 0x9123683e
        | 1936880249 // BTRFS_TEST_MAGIC = 0x73727279
        | 2613483    // CGROUP_SUPER_MAGIC = 0x27e0eb | Cgroup pseudo FS
        | 1667723888 // CGROUP2_SUPER_MAGIC = 0x63677270 | Cgroup v2 pseudo FS
        | 4283649346 // CIFS_MAGIC_NUMBER = 0xff534d42
        | 1937076805 // CODA_SUPER_MAGIC = 0x73757245
        | 19920823   // COH_SUPER_MAGIC = 0x012ff7b7
        | 684539205  // CRAMFS_MAGIC = 0x28cd3d45
        | 1684170528 // DEBUGFS_MAGIC = 0x64626720
        | 4979       // DEVFS_SUPER_MAGIC = 0x1373 | Linux 2.6.17 and earlier
        | 7377       // DEVPTS_SUPER_MAGIC =	0x1cd1
        | 61791      // ECRYPTFS_SUPER_MAGIC	=	0xf15f
        | 3730735588 // EFIVARFS_MAGIC	=	0xde5e81e4
        | 4278867    // EFS_SUPER_MAGIC =	0x00414a53
        | 4989       // EXT_SUPER_MAGIC = 0x137d | Linux 2.0 and earlier
        | 61265      // EXT2_OLD_SUPER_MAGIC = 0xef51
        | 61267      // EXT2_SUPER_MAGIC = 0xef53
        | 61267      // EXT3_SUPER_MAGIC = 0xef53
        | 61267      // EXT4_SUPER_MAGIC = 0xef53
        | 4076150800 // F2FS_SUPER_MAGIC = 0xf2f52010
        | 1702057286 // FUSE_SUPER_MAGIC = 0x65735546
        | 195894762  // FUTEXFS_SUPER_MAGIC = 0xbad1dea | Unused
        | 16964      // HFS_SUPER_MAGIC = 0x4244
        | 12648430   // HOSTFS_SUPER_MAGIC = 0x00c0ffee
        | 4187351113 // HPFS_SUPER_MAGIC = 0xf995e849
        | 2508478710 // HUGETLBFS_MAGIC = 0x958458f6
        | 38496      // ISOFS_SUPER_MAGIC = 0x9660
        | 29366      // JFFS2_SUPER_MAGIC = 0x72b6
        | 827541066  // JFS_SUPER_MAGIC = 0x3153464a
        | 4991       // MINIX_SUPER_MAGIC = 0x137f | original minix FS
        | 5007       // MINIX_SUPER_MAGIC2 = 0x138f | 30 char minix FS
        | 9320       // MINIX2_SUPER_MAGIC = 0x2468 | minix V2 FS
        | 9336       // MINIX2_SUPER_MAGIC2 = 0x2478 | minix V2 FS, 30 char names
        | 19802      // MINIX3_SUPER_MAGIC = 0x4d5a | minix V3 FS, 60 char names
        | 427819522  // MQUEUE_MAGIC = 0x19800202 | POSIX message queue FS
        | 19780      // MSDOS_SUPER_MAGIC = 0x4d44
        | 288389204  // MTD_INODE_FS_MAGIC = 0x11307854
        | 22092      // NCP_SUPER_MAGIC = 0x564c
        | 26985      // NFS_SUPER_MAGIC = 0x6969
        | 13364      // NILFS_SUPER_MAGIC = 0x3434
        | 1853056627 // NSFS_MAGIC = 0x6e736673
        | 1397118030 // NTFS_SB_MAGIC = 0x5346544e
        | 1952539503 // OCFS2_SUPER_MAGIC = 0x7461636f
        | 40865      // OPENPROM_SUPER_MAGIC = 0x9fa1
        | 2035054128 // OVERLAYFS_SUPER_MAGIC = 0x794c7630
        | 1346981957 // PIPEFS_MAGIC = 0x50495045
        | 40864      // PROC_SUPER_MAGIC = 0x9fa0 | /proc FS
        | 1634035564 // PSTOREFS_MAGIC = 0x6165676c
        | 47         // QNX4_SUPER_MAGIC = 0x002f
        | 1746473250 // QNX6_SUPER_MAGIC = 0x68191122
        | 2240043254 // RAMFS_MAGIC = 0x858458f6
        | 1382369651 // REISERFS_SUPER_MAGIC = 0x52654973
        | 29301      // ROMFS_MAGIC = 0x7275
        | 1935894131 // SECURITYFS_MAGIC = 0x73636673
        | 4185718668 // SELINUX_MAGIC = 0xf97cff8c
        | 1128357203 // SMACK_MAGIC = 0x43415d53
        | 20859      // SMB_SUPER_MAGIC = 0x517b
        | 4266872130 // SMB2_MAGIC_NUMBER = 0xfe534d42
        | 1397703499 // SOCKFS_MAGIC = 0x534f434b
        | 1936814952 // SQUASHFS_MAGIC = 0x73717368
        | 1650812274 // SYSFS_MAGIC = 0x62656572
        | 19920822   // SYSV2_SUPER_MAGIC = 0x012ff7b6
        | 19920821   // SYSV4_SUPER_MAGIC = 0x012ff7b5
        | 16914836   // TMPFS_MAGIC = 0x01021994
        | 1953653091 // TRACEFS_MAGIC = 0x74726163
        | 352400198  // UDF_SUPER_MAGIC = 0x15013346
        | 72020      // UFS_MAGIC = 0x00011954
        | 40866      // USBDEVICE_SUPER_MAGIC = 0x9fa2
        | 16914839   // V9FS_MAGIC = 0x01021997
        | 2768370933 // VXFS_SUPER_MAGIC = 0xa501fcf5
        | 2881100148 // XENFS_SUPER_MAGIC = 0xabba1974
        | 19920820   // XENIX_SUPER_MAGIC = 0x012ff7b4
        | 1481003842 // XFS_SUPER_MAGIC = 0x58465342
        | 19911021   // _XIAFS_SUPER_MAGIC = 0x012fd16d | Linux 2.0 and earlier

    interface fs_statfs_stats { type: fs_statfs_stats_type, bzise: number, blocks: number, bfree: number, bavail: number, files: number, ffree: number }

    /**
     * Equivalent to `close(2)`.
     */
    function fs_close(fd: number, callback: (err?: string, success?: boolean) => void): uv_fs_t;
    function fs_close(fd: number): fail<[success: boolean]>;

    /**
     * Equivalent to `open(2)`.
     * See below for available access `flags`.
     * 
     * **Note:** On Windows, libuv uses `CreateFileW` and thus the file is always
     * opened in binary mode. Because of this, the `O_BINARY` and `O_TEXT` flags are
     * not supported.
     */
    function fs_open(path: string, flags: fs_access_flags | number, mode: number, callback: (err?: string, fd?: number) => void): uv_fs_t;
    function fs_open(path: string, flags: fs_access_flags | number, mode: number): fail<[fd: number]>;

    /**
     * Equivalent to `preadv(2)`. Returns any data. An empty string indicates EOF.
     * 
     * If `offset` is nil or omitted, it will default to `-1`, which indicates 'use and update the current file offset.'
     * 
     * **Note:** When `offset` is >= 0, the current file offset will not be updated by the read.
     */
    function fs_read(fd: number, size: number, offset: number | undefined, callback: (err?: string, data?: string) => void): uv_fs_t;
    function fs_read(fd: number, size: number, callback: (err?: string, data?: string) => void): uv_fs_t;
    function fs_read(fd: number, size: number, offset?: number): fail<[uv_fs_t]>;

    /**
     * Equivalent to `unlink(2)`.
     */
    function fs_unlink(path: string, callback: (err?: string, success?: boolean) => void): uv_fs_t;
    function fs_unlink(path: string): fail<[success: boolean]>;

    /**
     * Equivalent to `pwritev(2)`. Returns the number of bytes written.
     * 
     * If `offset` is nil or omitted, it will default to `-1`, which indicates 'use and update the current file offset.'
     * 
     * **Note:** When `offset` is >= 0, the current file offset will not be updated by the write.
     */
    function fs_write(fd: number, data: buffer, offset: number | undefined, callback: (err?: string, bytes?: number) => void): uv_fs_t;
    function fs_write(fd: number, data: buffer, callback: (err?: string, bytes?: number) => void): uv_fs_t;
    function fs_write(fd: number, data: buffer, offset: number | undefined): fail<[bytes: number]>;

    /**
     * Equivalent to `mkdir(2)`.
     */
    function fs_mkdir(path: string, mode: number, callback: (err?: string, success?: boolean) => void): uv_fs_t;
    function fs_mkdir(path: string, mode: number): fail<[success: boolean]>;

    /**
     * Equivalent to `mkdtemp(3)`.
     */
    function fs_mkdtemp(template: string, callback: (err?: string, path?: string) => void): uv_fs_t;
    function fs_mkdtemp(template: string): fail<[string]>;

    /**
     * Equivalent to `mkstemp(3)`. Returns a temporary file handle and filename.
     */
    function fs_mkstemp(template: string, callback: (err?: string, fd?: number, path?: string) => void): uv_fs_t;
    function fs_mkstemp(template: string): fail<[foo: number, bar: string]>;

    /**
     * Equivalent to `rmdir(2)`.
     */
    function fs_rmdir(path: string, callback: (err?: string, success?: boolean) => void): uv_fs_t;
    function fs_rmdir(path: string): fail<[success: boolean]>;

    /**
     * Equivalent to `scandir(3)`, with a slightly different API. Returns a handle that
     * the user can pass to `uv.fs_scandir_next()`.
     * 
     * **Note:** This function can be used synchronously or asynchronously. The request
     * userdata is always synchronously returned regardless of whether a callback is
     * provided and the same userdata is passed to the callback if it is provided.
     */
    function fs_scandir(path: string, callback: (err?: string, success?: uv_fs_t) => void): fail<[uv_fs_t]>;
    function fs_scandir(path: string): fail<[uv_fs_t]>;

    /**
     * Called on a `uv_fs_t` returned by `uv.fs_scandir()` to get the next directory
     * entry data as a `name, type` pair. When there are no more entries, `nil` is
     * returned.
     * 
     * **Note:** This function only has a synchronous version. See `uv.fs_opendir` and
     * its related functions for an asynchronous version.
     */
    function fs_scandir_next(fs: uv_fs_t): fail<[string]>;

    /**
     * Equivalent to `stat(2)`.
     */
    function fs_stat(path: string, callback: (err?: string, stat?: fs_stat_table) => void): uv_fs_t;
    function fs_stat(path: string): fail<[fs_stat_table]>;

    /**
     * Equivalent to `fstat(2)`.
     */
    function fs_fstat(fd: number, callback: (err?: string, stat?: fs_stat_table) => void): uv_fs_t;
    function fs_fstat(fd: number): fail<[uv_fs_t]>;

    /**
     * Equivalent to `lstat(2)`.
     */
    function fs_lstat(path: string, callback: (err?: string, stat?: fs_stat_table) => void): uv_fs_t;
    function fs_lstat(path: string): fail<[fs_stat_table]>;

    /**
     * Equivalent to `rename(2)`.
     */
    function fs_rename(path: string, new_path: string, callback: (err?: string, success?: boolean) => void): uv_fs_t;
    function fs_rename(path: string, new_path: string): fail<[success: boolean]>;

    /**
     * Equivalent to `fsync(2)`.
     */
    function fs_fsync(fd: number, callback: (err?: string, success?: boolean) => void): uv_fs_t;
    function fs_fsync(fd: number): fail<[success: boolean]>;

    /**
     * Equivalent to `fdatasync(2)`.
     */
    function fs_fdatasync(fd: number, callback: (err?: string, success?: boolean) => void): uv_fs_t;
    function fs_fdatasync(fd: number): fail<[success: boolean]>;

    /**
     * Equivalent to `ftruncate(2)`.
     */
    function fs_ftruncate(fd: number, offset: number, callback: (err?: string, success?: boolean) => void): uv_fs_t;
    function fs_ftruncate(fd: number, offset: number): fail<[success: boolean]>;

    /**
     * Limited equivalent to `sendfile(2)`. Returns the number of bytes written.
     */
    function fs_sendfile(out_fd: number, in_fd: number, in_offset: number, size: number, callback: (err?: string, bytes?: number) => void): uv_fs_t;
    function fs_sendfile(out_fd: number, in_fd: number, in_offset: number, size: number): fail<[bytes: number]>;

    /**
     * Equivalent to `access(2)` on Unix. Windows uses `GetFileAttributesW()`. Access
     * `mode` can be an integer or a string containing `"R"` or `"W"` or `"X"`.
     * 
     * Returns `true` or `false` indicating access permission.
     */
    function fs_access(path: string, mode: fs_access_mode | number, callback: (err?: string, permission?: boolean) => void): uv_fs_t;
    function fs_access(path: string, mode: fs_access_mode | number): fail<[permission: boolean]>;

    /**
     * Equivalent to `chmod(2)`.
     */
    function fs_chmod(path: string, mode: number, callback: (err?: string, success?: boolean) => void): uv_fs_t;
    function fs_chmod(path: string, mode: number): fail<[success: boolean]>;

    /**
     * Equivalent to `fchmod(2)`.
     */
    function fs_fchmod(fd: number, mode: number, callback: (err?: string, success?: boolean) => void): uv_fs_t;
    function fs_fchmod(fd: number, mode: number): fail<[success: boolean]>;

    /**
     * Equivalent to `utime(2)`.
     */
    function fs_utime(path: string, atime: number, mtime: number, callback: (err?: string, success?: boolean) => void): uv_fs_t;
    function fs_utime(path: string, atime: number, mtime: number): fail<[success: boolean]>;

    /**
     * Equivalent to `futime(2)`.
     */
    function fs_futime(fd: number, atime: number, mtime: number, callback: (err?: string, success?: boolean) => void): uv_fs_t;
    function fs_futime(fd: number, atime: number, mtime: number): fail<[success: boolean]>;

    /**
     * Equivalent to `lutime(2)`.
     */
    function fs_lutime(path: string, atime: number, mtime: number, callback: (err?: string, success?: boolean) => void): uv_fs_t;
    function fs_lutime(path: string, atime: number, mtime: number): fail<[success: boolean]>;

    /**
     * Equivalent to `link(2)`.
     */
    function fs_link(path: string, new_path: string, callback: (err?: string, success?: boolean) => void): uv_fs_t;
    function fs_link(path: string, new_path: string): fail<[success: boolean]>;

    /**
     * Equivalent to `symlink(2)`.
     * If the `flags` parameter is omitted, then the 3rd parameter will be treated as the `callback`.
     */
    function fs_symlink(path: string, new_path: string, flags: fs_symlink_flags | number, callback: (err?: string, success?: boolean) => void): uv_fs_t;
    function fs_symlink(path: string, new_path: string, callback: (err?: string, success?: boolean) => void): uv_fs_t;
    function fs_symlink(path: string, new_path: string, flags?: fs_symlink_flags | number): fail<[success: boolean]>;

    /**
     * Equivalent to `readlink(2)`.
     */
    function fs_readlink(path: string, callback: (err?: string, path?: string) => void): uv_fs_t;
    function fs_readlink(path: string): fail<[string]>;

    /**
     * Equivalent to `realpath(3)`.
     */
    function fs_realpath(path: string, callback: (err?: string, path?: string) => void): uv_fs_t;
    function fs_realpath(path: string): fail<[string]>;

    /**
     * Equivalent to `chown(2)`.
     */
    function fs_chown(path: string, uid: number, gid: number, callback: (err?: string, success?: boolean) => void): uv_fs_t;
    function fs_chown(path: string, uid: number, gid: number): fail<[success: boolean]>;

    /**
     * Equivalent to `fchown(2)`.
     */
    function fs_fchown(fd: number, uid: number, gid: number, callback: (err?: string, success?: boolean) => void): uv_fs_t;
    function fs_fchown(fd: number, uid: number, gid: number): fail<[success: boolean]>;

    /**
     * Equivalent to `lchown(2)`.
     */
    function fs_lchown(fd: number, uid: number, gid: number, callback: (err?: string, success?: boolean) => void): uv_fs_t;
    function fs_lchown(fd: number, uid: number, gid: number): fail<[success: boolean]>;

    /**
     * Copies a file from `path` to `new_path`.
     * If the `flags` parameter is omitted, then the 3rd parameter will be treated as the `callback`.
     */
    function fs_copyfile(path: string, new_path: string, flags: fs_copyfile_flags, callback: (err?: string, success?: boolean) => void): uv_fs_t;
    function fs_copyfile(path: string, new_path: string, callback: (err?: string, success?: boolean) => void): uv_fs_t;
    function fs_copyfile(path: string, new_path: string, flags?: fs_copyfile_flags): fail<[success: boolean]>;

    /**
     * Opens path as a directory stream. Returns a handle that the user can pass to
     * `uv.fs_readdir()`. The `entries` parameter defines the maximum number of entries
     * that should be returned by each call to `uv.fs_readdir()`.
     */
    function fs_opendir(path: string, entries: number | undefined, callback: (err?: string, dir?: luv_dir_t) => void): uv_fs_t;
    function fs_opendir(path: string, entries: number | undefined): fail<[luv_dir_t]>;

    /**
     * Equivalent to `statfs(2)`.
     */
    function fs_statfs(path: string, callback: (err?: string, stats?: fs_statfs_stats) => void): uv_fs_t;
    function fs_statfs(path: string): fail<[fs_statfs_stats]>;

    /**
     * Creates and initializes a new `luv_work_ctx_t` (not `uv_work_t`).
     * `work_callback` is a Lua function or a string containing Lua code or bytecode dumped from a function.
     * Returns the Lua userdata wrapping it.
     * 
     * @generic T: threadargs
     */
    function new_work<T extends threadargs>(work_callback: (...args: T[]) => void | string, after_work_callback: (...args: threadargs[]) => void): luv_work_ctx_t;

    // 
    // @section DNS utility functions
    // 

    type uv_getaddrinfo_t = uv_req_t;

    interface getaddrinfo_hint { family?: network_family | number, socktype?: tcp_socket_type, protocol?: network_protocols, addrconfig?: boolean, v4mapped?: boolean, all?: boolean, numberichost?: boolean, passive?: boolean, numericserv?: boolean, canonname?: boolean }

    type getaddrinfo_rtn = { addr: string, family: network_family, port?: number, socktype: tcp_socket_type, protocol: network_protocols, canonname?: string }[]

    type uv_getnameinfo_t = uv_req_t

    interface uv_getnameinfo_address { ip?: string, port?: number, family?: network_family | number }

    /**
     * Equivalent to `getaddrinfo(3)`.
     * Either `host` or `service` may be `nil` but not both.
     */
    function getaddrinfo(host: string | undefined, service: string | undefined, hints: getaddrinfo_hint | undefined, callback: (err?: string, addresses?: getaddrinfo_rtn) => void): uv_getaddrinfo_t;
    function getaddrinfo(host: string | undefined, service: string | undefined, hints: getaddrinfo_hint | undefined): fail<[getaddrinfo_rtn]>;

    /**
     * Equivalent to `getnameinfo(3)`.
     */
    function getnameinfo(address: uv_getnameinfo_address, callback: (err?: string, host?: string, service?: string) => void): uv_getnameinfo_t;
    function getnameinfo(address: uv_getnameinfo_address): fail<[string, string]>;

    /**
     * Creates and initializes a `luv_thread_t` (not `uv_thread_t`). Returns the Lua
     * userdata wrapping it and asynchronously executes `entry`, which can be
     * either a Lua function or a string containing Lua code or bytecode dumped from a function. Additional arguments `...`
     * are passed to the `entry` function and an optional `options` table may be
     * provided. Currently accepted `option` fields are `stack_size`.
     * 
     * @generic T: threadargs
     * @vararg T # varargs passed to `entry`
     */
    function new_thread<T extends threadargs>(options: { stack_size?: number } | undefined, entry: ((...args: T[]) => void) | string): fail<[luv_thread_t]>;
    function new_thread<T extends threadargs>(entry: ((...args: T[]) => void) | string): fail<[luv_thread_t]>;

    /**
     * Returns the handle for the thread in which this is called.
     */
    function thread_self(): luv_thread_t;

    /**
     * Pauses the thread in which this is called for a number of milliseconds.
     */
    function sleep(msec: number): void;

    interface os_passwd { username: string, uid: number, gid: number, shell: string, homedir: string }

    interface os_uname { sysname: string, release: string, version: string, machine: string }

    interface rusage { utime: { sec: number, usec: number }, stime: { sec: number, usec: number }, maxrss: number, ixrss: number, idrss: number, isrss: number, minflt: number, majflt: number, nswap: number, inblock: number, oublock: number, msgsnd: number, msgrcv: number, nsignals: number, nvcsw: number, nivcsw: number }

    interface cpu_info { [key: number]: { modal: string, speed: number, times: { user: number, nice: number, sys: number, idle: number, irq: number } } }

    interface interface_addresses { [key: string]: { ip: string, family: network_family, netmask: string, internal: boolean, mac: string } }

    /**
     * Returns the executable path.
     */
    function exepath(): fail<[string]>;

    /**
     * Returns the current working directory.
     */
    function cwd(): fail<[string]>;

    /**
     * Sets the current working directory with the string `cwd`.
     */
    function chdir(cwd: string): fail<[success: 0]>;

    /**
     * Returns the title of the current process.
     */
    function get_process_title(): fail<[string]>;

    /**
     * Sets the title of the current process with the string `title`.
     */
    function set_process_title(title: string): fail<[success: 0]>;

    /**
     * Returns the current total system memory in bytes.
     */
    function get_total_memory(): number;

    /**
     * Returns the current free system memory in bytes.
     */
    function get_free_memory(): number;

    /**
     * Gets the amount of memory available to the process in bytes based on limits
     * imposed by the OS. If there is no such constraint, or the constraint is unknown,
     * 0 is returned. Note that it is not unusual for this value to be less than or
     * greater than the total system memory.
     */
    function get_constrained_memory(): number;

    /**
     * Returns the resident set size (RSS) for the current process.
     */
    function resident_set_memory(): fail<[rss: number]>;

    /**
     * Returns the resource usage.
     */
    function getrusage(): fail<[rusage]>;

    /**
     * Returns an estimate of the default amount of parallelism a program should use. Always returns a non-zero value.
     * 
     * On Linux, inspects the calling thread’s CPU affinity mask to determine if it has been pinned to specific CPUs.
     * 
     * On Windows, the available parallelism may be underreported on systems with more than 64 logical CPUs.
     * 
     * On other platforms, reports the number of CPUs that the operating system considers to be online.
     */
    function available_parallelism(): number;

    /**
     * Returns information about the CPU(s) on the system as a table of tables for each
     * CPU found.
     */
    function cpu_info(): fail<[cpu_info]>;

    /**
     * **Deprecated:** Please use `uv.os_getpid()` instead.
     * 
     * @deprecated
     */
    function getpid(): number;

    /**
     * Returns the user ID of the process.
     * 
     * **Note:** This is not a libuv function and is not supported on Windows.
     */
    function getuid(): number;

    /**
     * Returns the group ID of the process.
     * 
     * **Note:** This is not a libuv function and is not supported on Windows.
     */
    function getgid(): number;

    /**
     * Sets the user ID of the process with the integer `id`.
     * 
     * **Note:** This is not a libuv function and is not supported on Windows.
     */
    function setuid(id: number): void;

    /**
     * Sets the group ID of the process with the integer `id`.
     * 
     * **Note:** This is not a libuv function and is not supported on Windows.
     */
    function setgid(id: number): void;

    /**
     * Returns a current high-resolution time in nanoseconds as a number. This is
     * relative to an arbitrary time in the past. It is not related to the time of day
     * and therefore not subject to clock drift. The primary use is for measuring
     * time between intervals.
     */
    function hrtime(): number;

    /**
     * Returns the current system uptime in seconds.
     */
    function uptime(): fail<[seconds: number]>;

    /**
     * Prints all handles associated with the main loop to stderr. The format is
     * `[flags] handle-type handle-address`. Flags are `R` for referenced, `A` for
     * active and `I` for internal.
     * 
     * **Note:** This is not available on Windows.
     * 
     * **Warning:** This function is meant for ad hoc debugging, there are no API/ABI
     * stability guarantees.
     */
    function print_all_handles(): void;

    /**
     * The same as `uv.print_all_handles()` except only active handles are printed.
     * 
     * **Note:** This is not available on Windows.
     * 
     * **Warning:** This function is meant for ad hoc debugging, there are no API/ABI
     * stability guarantees.
     */
    function print_active_handles(): void;

    /**
     * Used to detect what type of stream should be used with a given file
     * descriptor `fd`. Usually this will be used during initialization to guess the
     * type of the stdio streams.
     */
    function guess_handle(fd: number): handle_struct_name | undefined;

    /**
     * Cross-platform implementation of `gettimeofday(2)`. Returns the seconds and
     * microseconds of a unix time as a pair.
     */
    function gettimeofday(): fail<[seconds: number, microseconds: number]>;

    /**
     * Returns address information about the network interfaces on the system in a
     * table. Each table key is the name of the interface while each associated value
     * is an array of address information where fields are `ip`, `family`, `netmask`,
     * `internal`, and `mac`.
     */
    function interface_addresses(): interface_addresses;

    /**
     * IPv6-capable implementation of `if_indextoname(3)`.
     */
    function if_indextoname(ifindex: number): fail<[string]>;

    /**
     * Retrieves a network interface identifier suitable for use in an IPv6 scoped
     * address. On Windows, returns the numeric `ifindex` as a string. On all other
     * platforms, `uv.if_indextoname()` is used.
     */
    function if_indextoiid(ifindex: number): fail<[string]>;

    /**
     * Returns the load average as a triad. Not supported on Windows.
     */
    function loadavg(): [number, number, number];

    /**
     * Returns system information.
     */
    function os_uname(): os_uname;

    /**
     * Returns the hostname.
     */
    function os_gethostname(): string;

    /**
     * Returns the environment variable specified by `name` as string. The internal
     * buffer size can be set by defining `size`. If omitted, `LUAL_BUFFERSIZE` is
     * used. If the environment variable exceeds the storage available in the internal
     * buffer, `ENOBUFS` is returned. If no matching environment variable exists,
     * `ENOENT` is returned.
     * **Warning:** This function is not thread safe.
     */
    function os_getenv(name: string, size: number): fail<[string]>;

    /**
     * Sets the environmental variable specified by `name` with the string `value`.
     * 
     * **Warning:** This function is not thread safe.
     */
    function os_setenv(name: string, value: string): fail<[success: boolean]>;

    /**
     * Unsets the environmental variable specified by `name`.
     * 
     * **Warning:** This function is not thread safe.
     */
    function os_unsetenv(name: string): fail<[success: boolean]>;

    /**
     * Returns all environmental variables as a dynamic table of names associated with
     * their corresponding values.
     * 
     * **Warning:** This function is not thread safe.
     */
    function os_environ(): { [key: string]: string };

    /**
     * **Warning:** This function is not thread safe.
     */
    function os_homedir(): fail<[string]>;

    /**
     * **Warning:** This function is not thread safe.
     */
    function os_tmpdir(): fail<[string]>;

    /**
     * Returns password file information.
     */
    function os_get_passwd(): os_passwd;

    /**
     * Returns the current process ID.
     */
    function os_getpid(): number;

    /**
     * Returns the parent process ID.
     */
    function os_getppid(): number;

    /**
     * Returns the scheduling priority of the process specified by `pid`.
     */
    function os_getpriority(pid: number): fail<[priority: number]>;

    /**
     * Sets the scheduling priority of the process specified by `pid`. The `priority`
     * range is between -20 (high priority) and 19 (low priority).
     */
    function os_setpriority(pid: number, priority: number): fail<[success: boolean]>;

    /**
     * Fills a string of length `len` with cryptographically strong random bytes
     * acquired from the system CSPRNG. `flags` is reserved for future extension
     * and must currently be `nil` or `0` or `{}`.
     * 
     * Short reads are not possible. When less than `len` random bytes are available,
     * a non-zero error value is returned or passed to the callback. If the callback
     * is omitted, this function is completed synchronously.
     * The synchronous version may block indefinitely when not enough entropy is
     * available. The asynchronous version may not ever finish when the system is
     * low on entropy.
     */
    function random(len: number, flags: undefined | 0 | {}, callback: (err?: string, bytes?: string) => void): fail<[success: 0]>;
    function random(len: number, flags: undefined | 0 | {}): fail<[success: 0]>;

    /**
     * Returns the libuv error message and error name (both in string form, see `err`
     * and `name` in Error Handling) equivalent to the given platform dependent
     * error code: POSIX error codes on Unix (the ones stored in errno), and Win32
     * error codes on Windows (those returned by GetLastError() or WSAGetLastError()).
     */
    function translate_sys_error(errcode: number): LuaMultiReturn<[string | undefined, string | undefined]>;


    /**
     * Retrieve the amount of time the event loop has been idle in the kernel’s event
     * provider (e.g. `epoll_wait`). The call is thread safe.
     * 
     * The return value is the accumulated time spent idle in the kernel’s event
     * provider starting from when the `uv_loop_t` was configured to collect the idle time.
     * 
     * **Note:** The event loop will not begin accumulating the event provider’s idle
     * time until calling `loop_configure` with `"metrics_idle_time"`.
     */
    function metrics_idle_time(): number;

    interface constants {
        O_RDONLY: number;
        O_WRONLY: number;
        O_RDWR: number;
        O_APPEND: number;
        O_CREAT: number;
        O_DSYNC: number;
        O_EXCL: number;
        O_NOCTTY: number;
        O_NONBLOCK: number;
        O_RSYNC: number;
        O_SYNC: number;
        O_TRUNC: number;
        SOCK_STREAM: number;
        SOCK_DGRAM: number;
        SOCK_SEQPACKET: number;
        SOCK_RAW: number;
        SOCK_RDM: number;
        AF_UNIX: number;
        AF_INET: number;
        AF_INET6: number;
        AF_IPX: number;
        AF_NETLINK: number;
        AF_X25: number;
        AF_AX25: number;
        AF_ATMPVC: number;
        AF_APPLETALK: number;
        AF_PACKET: number;
        AI_ADDRCONFIG: number;
        AI_V4MAPPED: number;
        AI_ALL: number;
        AI_NUMERICHOST: number;
        AI_PASSIVE: number;
        AI_NUMERICSERV: number;
        SIGHUP: number;
        SIGINT: number;
        SIGQUIT: number;
        SIGILL: number;
        SIGTRAP: number;
        SIGABRT: number;
        SIGIOT: number;
        SIGBUS: number;
        SIGFPE: number;
        SIGKILL: number;
        SIGUSR1: number;
        SIGSEGV: number;
        SIGUSR2: number;
        SIGPIPE: number;
        SIGALRM: number;
        SIGTERM: number;
        SIGCHLD: number;
        SIGSTKFLT: number;
        SIGCONT: number;
        SIGSTOP: number;
        SIGTSTP: number;
        SIGTTIN: number;
        SIGWINCH: number;
        SIGIO: number;
        SIGPOLL: number;
        SIGXFSZ: number;
        SIGVTALRM: number;
        SIGPROF: number;
        UDP_RECVMMSG: number;
        UDP_MMSG_CHUNK: number;
        UDP_REUSEADDR: number;
        UDP_PARTIAL: number;
        UDP_IPV6ONLY: number;
        TCP_IPV6ONLY: number;
        UDP_MMSG_FREE: number;
        SIGSYS: number;
        SIGPWR: number;
        SIGTTOU: number;
        SIGURG: number;
        SIGXCPU: number;
    }
}
